// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "module_xml.h"

namespace XMLModule
{
  // module
  // 

  const module::field_optional& module::
  field () const
  {
    return this->field_;
  }

  module::field_optional& module::
  field ()
  {
    return this->field_;
  }

  void module::
  field (const field_type& x)
  {
    this->field_.set (x);
  }

  void module::
  field (const field_optional& x)
  {
    this->field_ = x;
  }

  void module::
  field (::std::unique_ptr< field_type > x)
  {
    this->field_.set (std::move (x));
  }

  const module::coupling_optional& module::
  coupling () const
  {
    return this->coupling_;
  }

  module::coupling_optional& module::
  coupling ()
  {
    return this->coupling_;
  }

  void module::
  coupling (const coupling_type& x)
  {
    this->coupling_.set (x);
  }

  void module::
  coupling (const coupling_optional& x)
  {
    this->coupling_ = x;
  }

  void module::
  coupling (::std::unique_ptr< coupling_type > x)
  {
    this->coupling_.set (std::move (x));
  }


  // field
  // 

  const field::general_field_type& field::
  general_field () const
  {
    return this->general_field_.get ();
  }

  field::general_field_type& field::
  general_field ()
  {
    return this->general_field_.get ();
  }

  void field::
  general_field (const general_field_type& x)
  {
    this->general_field_.set (x);
  }

  void field::
  general_field (::std::unique_ptr< general_field_type > x)
  {
    this->general_field_.set (std::move (x));
  }

  const field::constants_type& field::
  constants () const
  {
    return this->constants_.get ();
  }

  field::constants_type& field::
  constants ()
  {
    return this->constants_.get ();
  }

  void field::
  constants (const constants_type& x)
  {
    this->constants_.set (x);
  }

  void field::
  constants (::std::unique_ptr< constants_type > x)
  {
    this->constants_.set (std::move (x));
  }

  const field::macros_optional& field::
  macros () const
  {
    return this->macros_;
  }

  field::macros_optional& field::
  macros ()
  {
    return this->macros_;
  }

  void field::
  macros (const macros_type& x)
  {
    this->macros_.set (x);
  }

  void field::
  macros (const macros_optional& x)
  {
    this->macros_ = x;
  }

  void field::
  macros (::std::unique_ptr< macros_type > x)
  {
    this->macros_.set (std::move (x));
  }

  const field::spaces_type& field::
  spaces () const
  {
    return this->spaces_.get ();
  }

  field::spaces_type& field::
  spaces ()
  {
    return this->spaces_.get ();
  }

  void field::
  spaces (const spaces_type& x)
  {
    this->spaces_.set (x);
  }

  void field::
  spaces (::std::unique_ptr< spaces_type > x)
  {
    this->spaces_.set (std::move (x));
  }

  const field::volume_type& field::
  volume () const
  {
    return this->volume_.get ();
  }

  field::volume_type& field::
  volume ()
  {
    return this->volume_.get ();
  }

  void field::
  volume (const volume_type& x)
  {
    this->volume_.set (x);
  }

  void field::
  volume (::std::unique_ptr< volume_type > x)
  {
    this->volume_.set (std::move (x));
  }

  const field::surface_type& field::
  surface () const
  {
    return this->surface_.get ();
  }

  field::surface_type& field::
  surface ()
  {
    return this->surface_.get ();
  }

  void field::
  surface (const surface_type& x)
  {
    this->surface_.set (x);
  }

  void field::
  surface (::std::unique_ptr< surface_type > x)
  {
    this->surface_.set (std::move (x));
  }

  const field::error_calculator_type& field::
  error_calculator () const
  {
    return this->error_calculator_.get ();
  }

  field::error_calculator_type& field::
  error_calculator ()
  {
    return this->error_calculator_.get ();
  }

  void field::
  error_calculator (const error_calculator_type& x)
  {
    this->error_calculator_.set (x);
  }

  void field::
  error_calculator (::std::unique_ptr< error_calculator_type > x)
  {
    this->error_calculator_.set (std::move (x));
  }

  const field::preprocessor_type& field::
  preprocessor () const
  {
    return this->preprocessor_.get ();
  }

  field::preprocessor_type& field::
  preprocessor ()
  {
    return this->preprocessor_.get ();
  }

  void field::
  preprocessor (const preprocessor_type& x)
  {
    this->preprocessor_.set (x);
  }

  void field::
  preprocessor (::std::unique_ptr< preprocessor_type > x)
  {
    this->preprocessor_.set (std::move (x));
  }

  const field::postprocessor_type& field::
  postprocessor () const
  {
    return this->postprocessor_.get ();
  }

  field::postprocessor_type& field::
  postprocessor ()
  {
    return this->postprocessor_.get ();
  }

  void field::
  postprocessor (const postprocessor_type& x)
  {
    this->postprocessor_.set (x);
  }

  void field::
  postprocessor (::std::unique_ptr< postprocessor_type > x)
  {
    this->postprocessor_.set (std::move (x));
  }


  // general_field
  // 

  const general_field::description_type& general_field::
  description () const
  {
    return this->description_.get ();
  }

  general_field::description_type& general_field::
  description ()
  {
    return this->description_.get ();
  }

  void general_field::
  description (const description_type& x)
  {
    this->description_.set (x);
  }

  void general_field::
  description (::std::unique_ptr< description_type > x)
  {
    this->description_.set (std::move (x));
  }

  const general_field::analyses_type& general_field::
  analyses () const
  {
    return this->analyses_.get ();
  }

  general_field::analyses_type& general_field::
  analyses ()
  {
    return this->analyses_.get ();
  }

  void general_field::
  analyses (const analyses_type& x)
  {
    this->analyses_.set (x);
  }

  void general_field::
  analyses (::std::unique_ptr< analyses_type > x)
  {
    this->analyses_.set (std::move (x));
  }

  const general_field::deformed_shape_optional& general_field::
  deformed_shape () const
  {
    return this->deformed_shape_;
  }

  general_field::deformed_shape_optional& general_field::
  deformed_shape ()
  {
    return this->deformed_shape_;
  }

  void general_field::
  deformed_shape (const deformed_shape_type& x)
  {
    this->deformed_shape_.set (x);
  }

  void general_field::
  deformed_shape (const deformed_shape_optional& x)
  {
    this->deformed_shape_ = x;
  }

  const general_field::id_type& general_field::
  id () const
  {
    return this->id_.get ();
  }

  general_field::id_type& general_field::
  id ()
  {
    return this->id_.get ();
  }

  void general_field::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void general_field::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }

  const general_field::name_type& general_field::
  name () const
  {
    return this->name_.get ();
  }

  general_field::name_type& general_field::
  name ()
  {
    return this->name_.get ();
  }

  void general_field::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void general_field::
  name (::std::unique_ptr< name_type > x)
  {
    this->name_.set (std::move (x));
  }


  // analyses
  // 

  const analyses::analysis_sequence& analyses::
  analysis () const
  {
    return this->analysis_;
  }

  analyses::analysis_sequence& analyses::
  analysis ()
  {
    return this->analysis_;
  }

  void analyses::
  analysis (const analysis_sequence& s)
  {
    this->analysis_ = s;
  }


  // analysis
  // 

  const analysis::field_config_optional& analysis::
  field_config () const
  {
    return this->field_config_;
  }

  analysis::field_config_optional& analysis::
  field_config ()
  {
    return this->field_config_;
  }

  void analysis::
  field_config (const field_config_type& x)
  {
    this->field_config_.set (x);
  }

  void analysis::
  field_config (const field_config_optional& x)
  {
    this->field_config_ = x;
  }

  void analysis::
  field_config (::std::unique_ptr< field_config_type > x)
  {
    this->field_config_.set (std::move (x));
  }

  const analysis::id_type& analysis::
  id () const
  {
    return this->id_.get ();
  }

  analysis::id_type& analysis::
  id ()
  {
    return this->id_.get ();
  }

  void analysis::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void analysis::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }

  const analysis::name_type& analysis::
  name () const
  {
    return this->name_.get ();
  }

  analysis::name_type& analysis::
  name ()
  {
    return this->name_.get ();
  }

  void analysis::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void analysis::
  name (::std::unique_ptr< name_type > x)
  {
    this->name_.set (std::move (x));
  }

  const analysis::solutions_type& analysis::
  solutions () const
  {
    return this->solutions_.get ();
  }

  analysis::solutions_type& analysis::
  solutions ()
  {
    return this->solutions_.get ();
  }

  void analysis::
  solutions (const solutions_type& x)
  {
    this->solutions_.set (x);
  }

  const analysis::type_type& analysis::
  type () const
  {
    return this->type_.get ();
  }

  analysis::type_type& analysis::
  type ()
  {
    return this->type_.get ();
  }

  void analysis::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void analysis::
  type (::std::unique_ptr< type_type > x)
  {
    this->type_.set (std::move (x));
  }


  // field_config
  // 

  const field_config::field_item_sequence& field_config::
  field_item () const
  {
    return this->field_item_;
  }

  field_config::field_item_sequence& field_config::
  field_item ()
  {
    return this->field_item_;
  }

  void field_config::
  field_item (const field_item_sequence& s)
  {
    this->field_item_ = s;
  }


  // coupling
  // 

  const coupling::general_coupling_type& coupling::
  general_coupling () const
  {
    return this->general_coupling_.get ();
  }

  coupling::general_coupling_type& coupling::
  general_coupling ()
  {
    return this->general_coupling_.get ();
  }

  void coupling::
  general_coupling (const general_coupling_type& x)
  {
    this->general_coupling_.set (x);
  }

  void coupling::
  general_coupling (::std::unique_ptr< general_coupling_type > x)
  {
    this->general_coupling_.set (std::move (x));
  }

  const coupling::constants_type& coupling::
  constants () const
  {
    return this->constants_.get ();
  }

  coupling::constants_type& coupling::
  constants ()
  {
    return this->constants_.get ();
  }

  void coupling::
  constants (const constants_type& x)
  {
    this->constants_.set (x);
  }

  void coupling::
  constants (::std::unique_ptr< constants_type > x)
  {
    this->constants_.set (std::move (x));
  }

  const coupling::volume_type& coupling::
  volume () const
  {
    return this->volume_.get ();
  }

  coupling::volume_type& coupling::
  volume ()
  {
    return this->volume_.get ();
  }

  void coupling::
  volume (const volume_type& x)
  {
    this->volume_.set (x);
  }

  void coupling::
  volume (::std::unique_ptr< volume_type > x)
  {
    this->volume_.set (std::move (x));
  }


  // general_coupling
  // 

  const general_coupling::description_type& general_coupling::
  description () const
  {
    return this->description_.get ();
  }

  general_coupling::description_type& general_coupling::
  description ()
  {
    return this->description_.get ();
  }

  void general_coupling::
  description (const description_type& x)
  {
    this->description_.set (x);
  }

  void general_coupling::
  description (::std::unique_ptr< description_type > x)
  {
    this->description_.set (std::move (x));
  }

  const general_coupling::modules_type& general_coupling::
  modules () const
  {
    return this->modules_.get ();
  }

  general_coupling::modules_type& general_coupling::
  modules ()
  {
    return this->modules_.get ();
  }

  void general_coupling::
  modules (const modules_type& x)
  {
    this->modules_.set (x);
  }

  void general_coupling::
  modules (::std::unique_ptr< modules_type > x)
  {
    this->modules_.set (std::move (x));
  }

  const general_coupling::id_type& general_coupling::
  id () const
  {
    return this->id_.get ();
  }

  general_coupling::id_type& general_coupling::
  id ()
  {
    return this->id_.get ();
  }

  void general_coupling::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void general_coupling::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }

  const general_coupling::name_type& general_coupling::
  name () const
  {
    return this->name_.get ();
  }

  general_coupling::name_type& general_coupling::
  name ()
  {
    return this->name_.get ();
  }

  void general_coupling::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void general_coupling::
  name (::std::unique_ptr< name_type > x)
  {
    this->name_.set (std::move (x));
  }


  // modules
  // 

  const modules::source_type& modules::
  source () const
  {
    return this->source_.get ();
  }

  modules::source_type& modules::
  source ()
  {
    return this->source_.get ();
  }

  void modules::
  source (const source_type& x)
  {
    this->source_.set (x);
  }

  void modules::
  source (::std::unique_ptr< source_type > x)
  {
    this->source_.set (std::move (x));
  }

  const modules::target_type& modules::
  target () const
  {
    return this->target_.get ();
  }

  modules::target_type& modules::
  target ()
  {
    return this->target_.get ();
  }

  void modules::
  target (const target_type& x)
  {
    this->target_.set (x);
  }

  void modules::
  target (::std::unique_ptr< target_type > x)
  {
    this->target_.set (std::move (x));
  }


  // source
  // 

  const source::id_type& source::
  id () const
  {
    return this->id_.get ();
  }

  source::id_type& source::
  id ()
  {
    return this->id_.get ();
  }

  void source::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void source::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }


  // target
  // 

  const target::id_type& target::
  id () const
  {
    return this->id_.get ();
  }

  target::id_type& target::
  id ()
  {
    return this->id_.get ();
  }

  void target::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void target::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }


  // constants
  // 

  const constants::constant_sequence& constants::
  constant () const
  {
    return this->constant_;
  }

  constants::constant_sequence& constants::
  constant ()
  {
    return this->constant_;
  }

  void constants::
  constant (const constant_sequence& s)
  {
    this->constant_ = s;
  }


  // constant
  // 

  const constant::id_type& constant::
  id () const
  {
    return this->id_.get ();
  }

  constant::id_type& constant::
  id ()
  {
    return this->id_.get ();
  }

  void constant::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void constant::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }

  const constant::value_type& constant::
  value () const
  {
    return this->value_.get ();
  }

  constant::value_type& constant::
  value ()
  {
    return this->value_.get ();
  }

  void constant::
  value (const value_type& x)
  {
    this->value_.set (x);
  }


  // macros
  // 

  const macros::macro_sequence& macros::
  macro () const
  {
    return this->macro_;
  }

  macros::macro_sequence& macros::
  macro ()
  {
    return this->macro_;
  }

  void macros::
  macro (const macro_sequence& s)
  {
    this->macro_ = s;
  }


  // macro
  // 

  const macro::expression_type& macro::
  expression () const
  {
    return this->expression_.get ();
  }

  macro::expression_type& macro::
  expression ()
  {
    return this->expression_.get ();
  }

  void macro::
  expression (const expression_type& x)
  {
    this->expression_.set (x);
  }

  void macro::
  expression (::std::unique_ptr< expression_type > x)
  {
    this->expression_.set (std::move (x));
  }

  const macro::id_type& macro::
  id () const
  {
    return this->id_.get ();
  }

  macro::id_type& macro::
  id ()
  {
    return this->id_.get ();
  }

  void macro::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void macro::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }


  // spaces
  // 

  const spaces::space_sequence& spaces::
  space () const
  {
    return this->space_;
  }

  spaces::space_sequence& spaces::
  space ()
  {
    return this->space_;
  }

  void spaces::
  space (const space_sequence& s)
  {
    this->space_ = s;
  }


  // space
  // 

  const space::space_config_sequence& space::
  space_config () const
  {
    return this->space_config_;
  }

  space::space_config_sequence& space::
  space_config ()
  {
    return this->space_config_;
  }

  void space::
  space_config (const space_config_sequence& s)
  {
    this->space_config_ = s;
  }

  const space::analysistype_type& space::
  analysistype () const
  {
    return this->analysistype_.get ();
  }

  space::analysistype_type& space::
  analysistype ()
  {
    return this->analysistype_.get ();
  }

  void space::
  analysistype (const analysistype_type& x)
  {
    this->analysistype_.set (x);
  }

  void space::
  analysistype (::std::unique_ptr< analysistype_type > x)
  {
    this->analysistype_.set (std::move (x));
  }


  // space_config
  // 

  const space_config::i_type& space_config::
  i () const
  {
    return this->i_.get ();
  }

  space_config::i_type& space_config::
  i ()
  {
    return this->i_.get ();
  }

  void space_config::
  i (const i_type& x)
  {
    this->i_.set (x);
  }

  const space_config::type_type& space_config::
  type () const
  {
    return this->type_.get ();
  }

  space_config::type_type& space_config::
  type ()
  {
    return this->type_.get ();
  }

  void space_config::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void space_config::
  type (::std::unique_ptr< type_type > x)
  {
    this->type_.set (std::move (x));
  }

  const space_config::orderadjust_type& space_config::
  orderadjust () const
  {
    return this->orderadjust_.get ();
  }

  space_config::orderadjust_type& space_config::
  orderadjust ()
  {
    return this->orderadjust_.get ();
  }

  void space_config::
  orderadjust (const orderadjust_type& x)
  {
    this->orderadjust_.set (x);
  }


  // preprocessor
  // 

  const preprocessor::gui_sequence& preprocessor::
  gui () const
  {
    return this->gui_;
  }

  preprocessor::gui_sequence& preprocessor::
  gui ()
  {
    return this->gui_;
  }

  void preprocessor::
  gui (const gui_sequence& s)
  {
    this->gui_ = s;
  }


  // gui
  // 

  const gui::group_sequence& gui::
  group () const
  {
    return this->group_;
  }

  gui::group_sequence& gui::
  group ()
  {
    return this->group_;
  }

  void gui::
  group (const group_sequence& s)
  {
    this->group_ = s;
  }

  const gui::type_type& gui::
  type () const
  {
    return this->type_.get ();
  }

  gui::type_type& gui::
  type ()
  {
    return this->type_.get ();
  }

  void gui::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void gui::
  type (::std::unique_ptr< type_type > x)
  {
    this->type_.set (std::move (x));
  }


  // group
  // 

  const group::quantity_sequence& group::
  quantity () const
  {
    return this->quantity_;
  }

  group::quantity_sequence& group::
  quantity ()
  {
    return this->quantity_;
  }

  void group::
  quantity (const quantity_sequence& s)
  {
    this->quantity_ = s;
  }

  const group::switch_combo_sequence& group::
  switch_combo () const
  {
    return this->switch_combo_;
  }

  group::switch_combo_sequence& group::
  switch_combo ()
  {
    return this->switch_combo_;
  }

  void group::
  switch_combo (const switch_combo_sequence& s)
  {
    this->switch_combo_ = s;
  }

  const group::name_optional& group::
  name () const
  {
    return this->name_;
  }

  group::name_optional& group::
  name ()
  {
    return this->name_;
  }

  void group::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void group::
  name (const name_optional& x)
  {
    this->name_ = x;
  }

  void group::
  name (::std::unique_ptr< name_type > x)
  {
    this->name_.set (std::move (x));
  }


  // switch_combo
  // 

  const switch_combo::switch_option_type& switch_combo::
  switch_option () const
  {
    return this->switch_option_.get ();
  }

  switch_combo::switch_option_type& switch_combo::
  switch_option ()
  {
    return this->switch_option_.get ();
  }

  void switch_combo::
  switch_option (const switch_option_type& x)
  {
    this->switch_option_.set (x);
  }

  void switch_combo::
  switch_option (::std::unique_ptr< switch_option_type > x)
  {
    this->switch_option_.set (std::move (x));
  }

  const switch_combo::id_type& switch_combo::
  id () const
  {
    return this->id_.get ();
  }

  switch_combo::id_type& switch_combo::
  id ()
  {
    return this->id_.get ();
  }

  void switch_combo::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void switch_combo::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }

  const switch_combo::name_type& switch_combo::
  name () const
  {
    return this->name_.get ();
  }

  switch_combo::name_type& switch_combo::
  name ()
  {
    return this->name_.get ();
  }

  void switch_combo::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void switch_combo::
  name (::std::unique_ptr< name_type > x)
  {
    this->name_.set (std::move (x));
  }

  const switch_combo::implicit_option_type& switch_combo::
  implicit_option () const
  {
    return this->implicit_option_.get ();
  }

  switch_combo::implicit_option_type& switch_combo::
  implicit_option ()
  {
    return this->implicit_option_.get ();
  }

  void switch_combo::
  implicit_option (const implicit_option_type& x)
  {
    this->implicit_option_.set (x);
  }

  void switch_combo::
  implicit_option (::std::unique_ptr< implicit_option_type > x)
  {
    this->implicit_option_.set (std::move (x));
  }


  // switch_option
  // 

  const switch_option::id_type& switch_option::
  id () const
  {
    return this->id_.get ();
  }

  switch_option::id_type& switch_option::
  id ()
  {
    return this->id_.get ();
  }

  void switch_option::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void switch_option::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }

  const switch_option::name_type& switch_option::
  name () const
  {
    return this->name_.get ();
  }

  switch_option::name_type& switch_option::
  name ()
  {
    return this->name_.get ();
  }

  void switch_option::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void switch_option::
  name (::std::unique_ptr< name_type > x)
  {
    this->name_.set (std::move (x));
  }


  // postprocessor
  // 

  const postprocessor::localvariables_type& postprocessor::
  localvariables () const
  {
    return this->localvariables_.get ();
  }

  postprocessor::localvariables_type& postprocessor::
  localvariables ()
  {
    return this->localvariables_.get ();
  }

  void postprocessor::
  localvariables (const localvariables_type& x)
  {
    this->localvariables_.set (x);
  }

  void postprocessor::
  localvariables (::std::unique_ptr< localvariables_type > x)
  {
    this->localvariables_.set (std::move (x));
  }

  const postprocessor::view_type& postprocessor::
  view () const
  {
    return this->view_.get ();
  }

  postprocessor::view_type& postprocessor::
  view ()
  {
    return this->view_.get ();
  }

  void postprocessor::
  view (const view_type& x)
  {
    this->view_.set (x);
  }

  void postprocessor::
  view (::std::unique_ptr< view_type > x)
  {
    this->view_.set (std::move (x));
  }

  const postprocessor::volumeintegrals_type& postprocessor::
  volumeintegrals () const
  {
    return this->volumeintegrals_.get ();
  }

  postprocessor::volumeintegrals_type& postprocessor::
  volumeintegrals ()
  {
    return this->volumeintegrals_.get ();
  }

  void postprocessor::
  volumeintegrals (const volumeintegrals_type& x)
  {
    this->volumeintegrals_.set (x);
  }

  void postprocessor::
  volumeintegrals (::std::unique_ptr< volumeintegrals_type > x)
  {
    this->volumeintegrals_.set (std::move (x));
  }

  const postprocessor::surfaceintegrals_type& postprocessor::
  surfaceintegrals () const
  {
    return this->surfaceintegrals_.get ();
  }

  postprocessor::surfaceintegrals_type& postprocessor::
  surfaceintegrals ()
  {
    return this->surfaceintegrals_.get ();
  }

  void postprocessor::
  surfaceintegrals (const surfaceintegrals_type& x)
  {
    this->surfaceintegrals_.set (x);
  }

  void postprocessor::
  surfaceintegrals (::std::unique_ptr< surfaceintegrals_type > x)
  {
    this->surfaceintegrals_.set (std::move (x));
  }

  const postprocessor::force_type& postprocessor::
  force () const
  {
    return this->force_.get ();
  }

  postprocessor::force_type& postprocessor::
  force ()
  {
    return this->force_.get ();
  }

  void postprocessor::
  force (const force_type& x)
  {
    this->force_.set (x);
  }

  void postprocessor::
  force (::std::unique_ptr< force_type > x)
  {
    this->force_.set (std::move (x));
  }


  // localvariables
  // 

  const localvariables::localvariable_sequence& localvariables::
  localvariable () const
  {
    return this->localvariable_;
  }

  localvariables::localvariable_sequence& localvariables::
  localvariable ()
  {
    return this->localvariable_;
  }

  void localvariables::
  localvariable (const localvariable_sequence& s)
  {
    this->localvariable_ = s;
  }


  // localvariable
  // 

  const localvariable::expression_sequence& localvariable::
  expression () const
  {
    return this->expression_;
  }

  localvariable::expression_sequence& localvariable::
  expression ()
  {
    return this->expression_;
  }

  void localvariable::
  expression (const expression_sequence& s)
  {
    this->expression_ = s;
  }

  const localvariable::format_optional& localvariable::
  format () const
  {
    return this->format_;
  }

  localvariable::format_optional& localvariable::
  format ()
  {
    return this->format_;
  }

  void localvariable::
  format (const format_type& x)
  {
    this->format_.set (x);
  }

  void localvariable::
  format (const format_optional& x)
  {
    this->format_ = x;
  }

  void localvariable::
  format (::std::unique_ptr< format_type > x)
  {
    this->format_.set (std::move (x));
  }

  const localvariable::id_type& localvariable::
  id () const
  {
    return this->id_.get ();
  }

  localvariable::id_type& localvariable::
  id ()
  {
    return this->id_.get ();
  }

  void localvariable::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void localvariable::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }

  const localvariable::name_type& localvariable::
  name () const
  {
    return this->name_.get ();
  }

  localvariable::name_type& localvariable::
  name ()
  {
    return this->name_.get ();
  }

  void localvariable::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void localvariable::
  name (::std::unique_ptr< name_type > x)
  {
    this->name_.set (std::move (x));
  }

  const localvariable::shortname_type& localvariable::
  shortname () const
  {
    return this->shortname_.get ();
  }

  localvariable::shortname_type& localvariable::
  shortname ()
  {
    return this->shortname_.get ();
  }

  void localvariable::
  shortname (const shortname_type& x)
  {
    this->shortname_.set (x);
  }

  void localvariable::
  shortname (::std::unique_ptr< shortname_type > x)
  {
    this->shortname_.set (std::move (x));
  }

  const localvariable::shortname_html_optional& localvariable::
  shortname_html () const
  {
    return this->shortname_html_;
  }

  localvariable::shortname_html_optional& localvariable::
  shortname_html ()
  {
    return this->shortname_html_;
  }

  void localvariable::
  shortname_html (const shortname_html_type& x)
  {
    this->shortname_html_.set (x);
  }

  void localvariable::
  shortname_html (const shortname_html_optional& x)
  {
    this->shortname_html_ = x;
  }

  void localvariable::
  shortname_html (::std::unique_ptr< shortname_html_type > x)
  {
    this->shortname_html_.set (std::move (x));
  }

  const localvariable::shortname_latex_optional& localvariable::
  shortname_latex () const
  {
    return this->shortname_latex_;
  }

  localvariable::shortname_latex_optional& localvariable::
  shortname_latex ()
  {
    return this->shortname_latex_;
  }

  void localvariable::
  shortname_latex (const shortname_latex_type& x)
  {
    this->shortname_latex_.set (x);
  }

  void localvariable::
  shortname_latex (const shortname_latex_optional& x)
  {
    this->shortname_latex_ = x;
  }

  void localvariable::
  shortname_latex (::std::unique_ptr< shortname_latex_type > x)
  {
    this->shortname_latex_.set (std::move (x));
  }

  const localvariable::type_type& localvariable::
  type () const
  {
    return this->type_.get ();
  }

  localvariable::type_type& localvariable::
  type ()
  {
    return this->type_.get ();
  }

  void localvariable::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void localvariable::
  type (::std::unique_ptr< type_type > x)
  {
    this->type_.set (std::move (x));
  }

  const localvariable::unit_type& localvariable::
  unit () const
  {
    return this->unit_.get ();
  }

  localvariable::unit_type& localvariable::
  unit ()
  {
    return this->unit_.get ();
  }

  void localvariable::
  unit (const unit_type& x)
  {
    this->unit_.set (x);
  }

  void localvariable::
  unit (::std::unique_ptr< unit_type > x)
  {
    this->unit_.set (std::move (x));
  }

  const localvariable::unit_html_optional& localvariable::
  unit_html () const
  {
    return this->unit_html_;
  }

  localvariable::unit_html_optional& localvariable::
  unit_html ()
  {
    return this->unit_html_;
  }

  void localvariable::
  unit_html (const unit_html_type& x)
  {
    this->unit_html_.set (x);
  }

  void localvariable::
  unit_html (const unit_html_optional& x)
  {
    this->unit_html_ = x;
  }

  void localvariable::
  unit_html (::std::unique_ptr< unit_html_type > x)
  {
    this->unit_html_.set (std::move (x));
  }

  const localvariable::unit_latex_optional& localvariable::
  unit_latex () const
  {
    return this->unit_latex_;
  }

  localvariable::unit_latex_optional& localvariable::
  unit_latex ()
  {
    return this->unit_latex_;
  }

  void localvariable::
  unit_latex (const unit_latex_type& x)
  {
    this->unit_latex_.set (x);
  }

  void localvariable::
  unit_latex (const unit_latex_optional& x)
  {
    this->unit_latex_ = x;
  }

  void localvariable::
  unit_latex (::std::unique_ptr< unit_latex_type > x)
  {
    this->unit_latex_.set (std::move (x));
  }


  // view
  // 

  const view::scalar_view_type& view::
  scalar_view () const
  {
    return this->scalar_view_.get ();
  }

  view::scalar_view_type& view::
  scalar_view ()
  {
    return this->scalar_view_.get ();
  }

  void view::
  scalar_view (const scalar_view_type& x)
  {
    this->scalar_view_.set (x);
  }

  void view::
  scalar_view (::std::unique_ptr< scalar_view_type > x)
  {
    this->scalar_view_.set (std::move (x));
  }

  const view::vector_view_type& view::
  vector_view () const
  {
    return this->vector_view_.get ();
  }

  view::vector_view_type& view::
  vector_view ()
  {
    return this->vector_view_.get ();
  }

  void view::
  vector_view (const vector_view_type& x)
  {
    this->vector_view_.set (x);
  }

  void view::
  vector_view (::std::unique_ptr< vector_view_type > x)
  {
    this->vector_view_.set (std::move (x));
  }


  // scalar_view
  // 

  const scalar_view::default_sequence& scalar_view::
  default_ () const
  {
    return this->default__;
  }

  scalar_view::default_sequence& scalar_view::
  default_ ()
  {
    return this->default__;
  }

  void scalar_view::
  default_ (const default_sequence& s)
  {
    this->default__ = s;
  }


  // vector_view
  // 

  const vector_view::default_sequence& vector_view::
  default_ () const
  {
    return this->default__;
  }

  vector_view::default_sequence& vector_view::
  default_ ()
  {
    return this->default__;
  }

  void vector_view::
  default_ (const default_sequence& s)
  {
    this->default__ = s;
  }


  // default_
  // 

  const default_::analysistype_type& default_::
  analysistype () const
  {
    return this->analysistype_.get ();
  }

  default_::analysistype_type& default_::
  analysistype ()
  {
    return this->analysistype_.get ();
  }

  void default_::
  analysistype (const analysistype_type& x)
  {
    this->analysistype_.set (x);
  }

  void default_::
  analysistype (::std::unique_ptr< analysistype_type > x)
  {
    this->analysistype_.set (std::move (x));
  }

  const default_::id_type& default_::
  id () const
  {
    return this->id_.get ();
  }

  default_::id_type& default_::
  id ()
  {
    return this->id_.get ();
  }

  void default_::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void default_::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }


  // volumeintegrals
  // 

  const volumeintegrals::volumeintegral_sequence& volumeintegrals::
  volumeintegral () const
  {
    return this->volumeintegral_;
  }

  volumeintegrals::volumeintegral_sequence& volumeintegrals::
  volumeintegral ()
  {
    return this->volumeintegral_;
  }

  void volumeintegrals::
  volumeintegral (const volumeintegral_sequence& s)
  {
    this->volumeintegral_ = s;
  }


  // volumeintegral
  // 

  const volumeintegral::expression_sequence& volumeintegral::
  expression () const
  {
    return this->expression_;
  }

  volumeintegral::expression_sequence& volumeintegral::
  expression ()
  {
    return this->expression_;
  }

  void volumeintegral::
  expression (const expression_sequence& s)
  {
    this->expression_ = s;
  }

  const volumeintegral::id_type& volumeintegral::
  id () const
  {
    return this->id_.get ();
  }

  volumeintegral::id_type& volumeintegral::
  id ()
  {
    return this->id_.get ();
  }

  void volumeintegral::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void volumeintegral::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }

  const volumeintegral::name_type& volumeintegral::
  name () const
  {
    return this->name_.get ();
  }

  volumeintegral::name_type& volumeintegral::
  name ()
  {
    return this->name_.get ();
  }

  void volumeintegral::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void volumeintegral::
  name (::std::unique_ptr< name_type > x)
  {
    this->name_.set (std::move (x));
  }

  const volumeintegral::shortname_type& volumeintegral::
  shortname () const
  {
    return this->shortname_.get ();
  }

  volumeintegral::shortname_type& volumeintegral::
  shortname ()
  {
    return this->shortname_.get ();
  }

  void volumeintegral::
  shortname (const shortname_type& x)
  {
    this->shortname_.set (x);
  }

  void volumeintegral::
  shortname (::std::unique_ptr< shortname_type > x)
  {
    this->shortname_.set (std::move (x));
  }

  const volumeintegral::shortname_html_optional& volumeintegral::
  shortname_html () const
  {
    return this->shortname_html_;
  }

  volumeintegral::shortname_html_optional& volumeintegral::
  shortname_html ()
  {
    return this->shortname_html_;
  }

  void volumeintegral::
  shortname_html (const shortname_html_type& x)
  {
    this->shortname_html_.set (x);
  }

  void volumeintegral::
  shortname_html (const shortname_html_optional& x)
  {
    this->shortname_html_ = x;
  }

  void volumeintegral::
  shortname_html (::std::unique_ptr< shortname_html_type > x)
  {
    this->shortname_html_.set (std::move (x));
  }

  const volumeintegral::shortname_latex_optional& volumeintegral::
  shortname_latex () const
  {
    return this->shortname_latex_;
  }

  volumeintegral::shortname_latex_optional& volumeintegral::
  shortname_latex ()
  {
    return this->shortname_latex_;
  }

  void volumeintegral::
  shortname_latex (const shortname_latex_type& x)
  {
    this->shortname_latex_.set (x);
  }

  void volumeintegral::
  shortname_latex (const shortname_latex_optional& x)
  {
    this->shortname_latex_ = x;
  }

  void volumeintegral::
  shortname_latex (::std::unique_ptr< shortname_latex_type > x)
  {
    this->shortname_latex_.set (std::move (x));
  }

  const volumeintegral::unit_type& volumeintegral::
  unit () const
  {
    return this->unit_.get ();
  }

  volumeintegral::unit_type& volumeintegral::
  unit ()
  {
    return this->unit_.get ();
  }

  void volumeintegral::
  unit (const unit_type& x)
  {
    this->unit_.set (x);
  }

  void volumeintegral::
  unit (::std::unique_ptr< unit_type > x)
  {
    this->unit_.set (std::move (x));
  }

  const volumeintegral::unit_html_optional& volumeintegral::
  unit_html () const
  {
    return this->unit_html_;
  }

  volumeintegral::unit_html_optional& volumeintegral::
  unit_html ()
  {
    return this->unit_html_;
  }

  void volumeintegral::
  unit_html (const unit_html_type& x)
  {
    this->unit_html_.set (x);
  }

  void volumeintegral::
  unit_html (const unit_html_optional& x)
  {
    this->unit_html_ = x;
  }

  void volumeintegral::
  unit_html (::std::unique_ptr< unit_html_type > x)
  {
    this->unit_html_.set (std::move (x));
  }

  const volumeintegral::unit_latex_optional& volumeintegral::
  unit_latex () const
  {
    return this->unit_latex_;
  }

  volumeintegral::unit_latex_optional& volumeintegral::
  unit_latex ()
  {
    return this->unit_latex_;
  }

  void volumeintegral::
  unit_latex (const unit_latex_type& x)
  {
    this->unit_latex_.set (x);
  }

  void volumeintegral::
  unit_latex (const unit_latex_optional& x)
  {
    this->unit_latex_ = x;
  }

  void volumeintegral::
  unit_latex (::std::unique_ptr< unit_latex_type > x)
  {
    this->unit_latex_.set (std::move (x));
  }

  const volumeintegral::eggshell_optional& volumeintegral::
  eggshell () const
  {
    return this->eggshell_;
  }

  volumeintegral::eggshell_optional& volumeintegral::
  eggshell ()
  {
    return this->eggshell_;
  }

  void volumeintegral::
  eggshell (const eggshell_type& x)
  {
    this->eggshell_.set (x);
  }

  void volumeintegral::
  eggshell (const eggshell_optional& x)
  {
    this->eggshell_ = x;
  }


  // surfaceintegrals
  // 

  const surfaceintegrals::surfaceintegral_sequence& surfaceintegrals::
  surfaceintegral () const
  {
    return this->surfaceintegral_;
  }

  surfaceintegrals::surfaceintegral_sequence& surfaceintegrals::
  surfaceintegral ()
  {
    return this->surfaceintegral_;
  }

  void surfaceintegrals::
  surfaceintegral (const surfaceintegral_sequence& s)
  {
    this->surfaceintegral_ = s;
  }


  // surfaceintegral
  // 

  const surfaceintegral::expression_sequence& surfaceintegral::
  expression () const
  {
    return this->expression_;
  }

  surfaceintegral::expression_sequence& surfaceintegral::
  expression ()
  {
    return this->expression_;
  }

  void surfaceintegral::
  expression (const expression_sequence& s)
  {
    this->expression_ = s;
  }

  const surfaceintegral::id_type& surfaceintegral::
  id () const
  {
    return this->id_.get ();
  }

  surfaceintegral::id_type& surfaceintegral::
  id ()
  {
    return this->id_.get ();
  }

  void surfaceintegral::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void surfaceintegral::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }

  const surfaceintegral::name_type& surfaceintegral::
  name () const
  {
    return this->name_.get ();
  }

  surfaceintegral::name_type& surfaceintegral::
  name ()
  {
    return this->name_.get ();
  }

  void surfaceintegral::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void surfaceintegral::
  name (::std::unique_ptr< name_type > x)
  {
    this->name_.set (std::move (x));
  }

  const surfaceintegral::shortname_type& surfaceintegral::
  shortname () const
  {
    return this->shortname_.get ();
  }

  surfaceintegral::shortname_type& surfaceintegral::
  shortname ()
  {
    return this->shortname_.get ();
  }

  void surfaceintegral::
  shortname (const shortname_type& x)
  {
    this->shortname_.set (x);
  }

  void surfaceintegral::
  shortname (::std::unique_ptr< shortname_type > x)
  {
    this->shortname_.set (std::move (x));
  }

  const surfaceintegral::shortname_html_optional& surfaceintegral::
  shortname_html () const
  {
    return this->shortname_html_;
  }

  surfaceintegral::shortname_html_optional& surfaceintegral::
  shortname_html ()
  {
    return this->shortname_html_;
  }

  void surfaceintegral::
  shortname_html (const shortname_html_type& x)
  {
    this->shortname_html_.set (x);
  }

  void surfaceintegral::
  shortname_html (const shortname_html_optional& x)
  {
    this->shortname_html_ = x;
  }

  void surfaceintegral::
  shortname_html (::std::unique_ptr< shortname_html_type > x)
  {
    this->shortname_html_.set (std::move (x));
  }

  const surfaceintegral::shortname_latex_optional& surfaceintegral::
  shortname_latex () const
  {
    return this->shortname_latex_;
  }

  surfaceintegral::shortname_latex_optional& surfaceintegral::
  shortname_latex ()
  {
    return this->shortname_latex_;
  }

  void surfaceintegral::
  shortname_latex (const shortname_latex_type& x)
  {
    this->shortname_latex_.set (x);
  }

  void surfaceintegral::
  shortname_latex (const shortname_latex_optional& x)
  {
    this->shortname_latex_ = x;
  }

  void surfaceintegral::
  shortname_latex (::std::unique_ptr< shortname_latex_type > x)
  {
    this->shortname_latex_.set (std::move (x));
  }

  const surfaceintegral::unit_type& surfaceintegral::
  unit () const
  {
    return this->unit_.get ();
  }

  surfaceintegral::unit_type& surfaceintegral::
  unit ()
  {
    return this->unit_.get ();
  }

  void surfaceintegral::
  unit (const unit_type& x)
  {
    this->unit_.set (x);
  }

  void surfaceintegral::
  unit (::std::unique_ptr< unit_type > x)
  {
    this->unit_.set (std::move (x));
  }

  const surfaceintegral::unit_html_optional& surfaceintegral::
  unit_html () const
  {
    return this->unit_html_;
  }

  surfaceintegral::unit_html_optional& surfaceintegral::
  unit_html ()
  {
    return this->unit_html_;
  }

  void surfaceintegral::
  unit_html (const unit_html_type& x)
  {
    this->unit_html_.set (x);
  }

  void surfaceintegral::
  unit_html (const unit_html_optional& x)
  {
    this->unit_html_ = x;
  }

  void surfaceintegral::
  unit_html (::std::unique_ptr< unit_html_type > x)
  {
    this->unit_html_.set (std::move (x));
  }

  const surfaceintegral::unit_latex_optional& surfaceintegral::
  unit_latex () const
  {
    return this->unit_latex_;
  }

  surfaceintegral::unit_latex_optional& surfaceintegral::
  unit_latex ()
  {
    return this->unit_latex_;
  }

  void surfaceintegral::
  unit_latex (const unit_latex_type& x)
  {
    this->unit_latex_.set (x);
  }

  void surfaceintegral::
  unit_latex (const unit_latex_optional& x)
  {
    this->unit_latex_ = x;
  }

  void surfaceintegral::
  unit_latex (::std::unique_ptr< unit_latex_type > x)
  {
    this->unit_latex_.set (std::move (x));
  }


  // force
  // 

  const force::expression_sequence& force::
  expression () const
  {
    return this->expression_;
  }

  force::expression_sequence& force::
  expression ()
  {
    return this->expression_;
  }

  void force::
  expression (const expression_sequence& s)
  {
    this->expression_ = s;
  }


  // volume
  // 

  const volume::quantity_sequence& volume::
  quantity () const
  {
    return this->quantity_;
  }

  volume::quantity_sequence& volume::
  quantity ()
  {
    return this->quantity_;
  }

  void volume::
  quantity (const quantity_sequence& s)
  {
    this->quantity_ = s;
  }

  const volume::function_sequence& volume::
  function () const
  {
    return this->function_;
  }

  volume::function_sequence& volume::
  function ()
  {
    return this->function_;
  }

  void volume::
  function (const function_sequence& s)
  {
    this->function_ = s;
  }

  const volume::matrix_form_sequence& volume::
  matrix_form () const
  {
    return this->matrix_form_;
  }

  volume::matrix_form_sequence& volume::
  matrix_form ()
  {
    return this->matrix_form_;
  }

  void volume::
  matrix_form (const matrix_form_sequence& s)
  {
    this->matrix_form_ = s;
  }

  const volume::vector_form_sequence& volume::
  vector_form () const
  {
    return this->vector_form_;
  }

  volume::vector_form_sequence& volume::
  vector_form ()
  {
    return this->vector_form_;
  }

  void volume::
  vector_form (const vector_form_sequence& s)
  {
    this->vector_form_ = s;
  }

  const volume::weakforms_volume_type& volume::
  weakforms_volume () const
  {
    return this->weakforms_volume_.get ();
  }

  volume::weakforms_volume_type& volume::
  weakforms_volume ()
  {
    return this->weakforms_volume_.get ();
  }

  void volume::
  weakforms_volume (const weakforms_volume_type& x)
  {
    this->weakforms_volume_.set (x);
  }

  void volume::
  weakforms_volume (::std::unique_ptr< weakforms_volume_type > x)
  {
    this->weakforms_volume_.set (std::move (x));
  }


  // surface
  // 

  const surface::quantity_sequence& surface::
  quantity () const
  {
    return this->quantity_;
  }

  surface::quantity_sequence& surface::
  quantity ()
  {
    return this->quantity_;
  }

  void surface::
  quantity (const quantity_sequence& s)
  {
    this->quantity_ = s;
  }

  const surface::matrix_form_sequence& surface::
  matrix_form () const
  {
    return this->matrix_form_;
  }

  surface::matrix_form_sequence& surface::
  matrix_form ()
  {
    return this->matrix_form_;
  }

  void surface::
  matrix_form (const matrix_form_sequence& s)
  {
    this->matrix_form_ = s;
  }

  const surface::vector_form_sequence& surface::
  vector_form () const
  {
    return this->vector_form_;
  }

  surface::vector_form_sequence& surface::
  vector_form ()
  {
    return this->vector_form_;
  }

  void surface::
  vector_form (const vector_form_sequence& s)
  {
    this->vector_form_ = s;
  }

  const surface::essential_form_sequence& surface::
  essential_form () const
  {
    return this->essential_form_;
  }

  surface::essential_form_sequence& surface::
  essential_form ()
  {
    return this->essential_form_;
  }

  void surface::
  essential_form (const essential_form_sequence& s)
  {
    this->essential_form_ = s;
  }

  const surface::weakforms_surface_type& surface::
  weakforms_surface () const
  {
    return this->weakforms_surface_.get ();
  }

  surface::weakforms_surface_type& surface::
  weakforms_surface ()
  {
    return this->weakforms_surface_.get ();
  }

  void surface::
  weakforms_surface (const weakforms_surface_type& x)
  {
    this->weakforms_surface_.set (x);
  }

  void surface::
  weakforms_surface (::std::unique_ptr< weakforms_surface_type > x)
  {
    this->weakforms_surface_.set (std::move (x));
  }


  // boundary
  // 

  const boundary::quantity_sequence& boundary::
  quantity () const
  {
    return this->quantity_;
  }

  boundary::quantity_sequence& boundary::
  quantity ()
  {
    return this->quantity_;
  }

  void boundary::
  quantity (const quantity_sequence& s)
  {
    this->quantity_ = s;
  }

  const boundary::linearity_option_sequence& boundary::
  linearity_option () const
  {
    return this->linearity_option_;
  }

  boundary::linearity_option_sequence& boundary::
  linearity_option ()
  {
    return this->linearity_option_;
  }

  void boundary::
  linearity_option (const linearity_option_sequence& s)
  {
    this->linearity_option_ = s;
  }

  const boundary::id_type& boundary::
  id () const
  {
    return this->id_.get ();
  }

  boundary::id_type& boundary::
  id ()
  {
    return this->id_.get ();
  }

  void boundary::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void boundary::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }

  const boundary::name_type& boundary::
  name () const
  {
    return this->name_.get ();
  }

  boundary::name_type& boundary::
  name ()
  {
    return this->name_.get ();
  }

  void boundary::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void boundary::
  name (::std::unique_ptr< name_type > x)
  {
    this->name_.set (std::move (x));
  }

  const boundary::equation_type& boundary::
  equation () const
  {
    return this->equation_.get ();
  }

  boundary::equation_type& boundary::
  equation ()
  {
    return this->equation_.get ();
  }

  void boundary::
  equation (const equation_type& x)
  {
    this->equation_.set (x);
  }

  void boundary::
  equation (::std::unique_ptr< equation_type > x)
  {
    this->equation_.set (std::move (x));
  }


  // weakforms_surface
  // 

  const weakforms_surface::group_optional& weakforms_surface::
  group () const
  {
    return this->group_;
  }

  weakforms_surface::group_optional& weakforms_surface::
  group ()
  {
    return this->group_;
  }

  void weakforms_surface::
  group (const group_type& x)
  {
    this->group_.set (x);
  }

  void weakforms_surface::
  group (const group_optional& x)
  {
    this->group_ = x;
  }

  void weakforms_surface::
  group (::std::unique_ptr< group_type > x)
  {
    this->group_.set (std::move (x));
  }

  const weakforms_surface::weakform_surface_sequence& weakforms_surface::
  weakform_surface () const
  {
    return this->weakform_surface_;
  }

  weakforms_surface::weakform_surface_sequence& weakforms_surface::
  weakform_surface ()
  {
    return this->weakform_surface_;
  }

  void weakforms_surface::
  weakform_surface (const weakform_surface_sequence& s)
  {
    this->weakform_surface_ = s;
  }


  // weakform_surface
  // 

  const weakform_surface::boundary_sequence& weakform_surface::
  boundary () const
  {
    return this->boundary_;
  }

  weakform_surface::boundary_sequence& weakform_surface::
  boundary ()
  {
    return this->boundary_;
  }

  void weakform_surface::
  boundary (const boundary_sequence& s)
  {
    this->boundary_ = s;
  }

  const weakform_surface::quantity_sequence& weakform_surface::
  quantity () const
  {
    return this->quantity_;
  }

  weakform_surface::quantity_sequence& weakform_surface::
  quantity ()
  {
    return this->quantity_;
  }

  void weakform_surface::
  quantity (const quantity_sequence& s)
  {
    this->quantity_ = s;
  }

  const weakform_surface::function_use_sequence& weakform_surface::
  function_use () const
  {
    return this->function_use_;
  }

  weakform_surface::function_use_sequence& weakform_surface::
  function_use ()
  {
    return this->function_use_;
  }

  void weakform_surface::
  function_use (const function_use_sequence& s)
  {
    this->function_use_ = s;
  }

  const weakform_surface::matrix_form_sequence& weakform_surface::
  matrix_form () const
  {
    return this->matrix_form_;
  }

  weakform_surface::matrix_form_sequence& weakform_surface::
  matrix_form ()
  {
    return this->matrix_form_;
  }

  void weakform_surface::
  matrix_form (const matrix_form_sequence& s)
  {
    this->matrix_form_ = s;
  }

  const weakform_surface::vector_form_sequence& weakform_surface::
  vector_form () const
  {
    return this->vector_form_;
  }

  weakform_surface::vector_form_sequence& weakform_surface::
  vector_form ()
  {
    return this->vector_form_;
  }

  void weakform_surface::
  vector_form (const vector_form_sequence& s)
  {
    this->vector_form_ = s;
  }

  const weakform_surface::analysistype_type& weakform_surface::
  analysistype () const
  {
    return this->analysistype_.get ();
  }

  weakform_surface::analysistype_type& weakform_surface::
  analysistype ()
  {
    return this->analysistype_.get ();
  }

  void weakform_surface::
  analysistype (const analysistype_type& x)
  {
    this->analysistype_.set (x);
  }

  void weakform_surface::
  analysistype (::std::unique_ptr< analysistype_type > x)
  {
    this->analysistype_.set (std::move (x));
  }

  const weakform_surface::default_optional& weakform_surface::
  default_ () const
  {
    return this->default__;
  }

  weakform_surface::default_optional& weakform_surface::
  default_ ()
  {
    return this->default__;
  }

  void weakform_surface::
  default_ (const default_type& x)
  {
    this->default__.set (x);
  }

  void weakform_surface::
  default_ (const default_optional& x)
  {
    this->default__ = x;
  }

  void weakform_surface::
  default_ (::std::unique_ptr< default_type > x)
  {
    this->default__.set (std::move (x));
  }


  // weakforms_volume
  // 

  const weakforms_volume::weakform_volume_sequence& weakforms_volume::
  weakform_volume () const
  {
    return this->weakform_volume_;
  }

  weakforms_volume::weakform_volume_sequence& weakforms_volume::
  weakform_volume ()
  {
    return this->weakform_volume_;
  }

  void weakforms_volume::
  weakform_volume (const weakform_volume_sequence& s)
  {
    this->weakform_volume_ = s;
  }


  // weakform_volume
  // 

  const weakform_volume::quantity_sequence& weakform_volume::
  quantity () const
  {
    return this->quantity_;
  }

  weakform_volume::quantity_sequence& weakform_volume::
  quantity ()
  {
    return this->quantity_;
  }

  void weakform_volume::
  quantity (const quantity_sequence& s)
  {
    this->quantity_ = s;
  }

  const weakform_volume::function_use_sequence& weakform_volume::
  function_use () const
  {
    return this->function_use_;
  }

  weakform_volume::function_use_sequence& weakform_volume::
  function_use ()
  {
    return this->function_use_;
  }

  void weakform_volume::
  function_use (const function_use_sequence& s)
  {
    this->function_use_ = s;
  }

  const weakform_volume::linearity_option_sequence& weakform_volume::
  linearity_option () const
  {
    return this->linearity_option_;
  }

  weakform_volume::linearity_option_sequence& weakform_volume::
  linearity_option ()
  {
    return this->linearity_option_;
  }

  void weakform_volume::
  linearity_option (const linearity_option_sequence& s)
  {
    this->linearity_option_ = s;
  }

  const weakform_volume::analysistype_type& weakform_volume::
  analysistype () const
  {
    return this->analysistype_.get ();
  }

  weakform_volume::analysistype_type& weakform_volume::
  analysistype ()
  {
    return this->analysistype_.get ();
  }

  void weakform_volume::
  analysistype (const analysistype_type& x)
  {
    this->analysistype_.set (x);
  }

  void weakform_volume::
  analysistype (::std::unique_ptr< analysistype_type > x)
  {
    this->analysistype_.set (std::move (x));
  }

  const weakform_volume::couplingtype_optional& weakform_volume::
  couplingtype () const
  {
    return this->couplingtype_;
  }

  weakform_volume::couplingtype_optional& weakform_volume::
  couplingtype ()
  {
    return this->couplingtype_;
  }

  void weakform_volume::
  couplingtype (const couplingtype_type& x)
  {
    this->couplingtype_.set (x);
  }

  void weakform_volume::
  couplingtype (const couplingtype_optional& x)
  {
    this->couplingtype_ = x;
  }

  void weakform_volume::
  couplingtype (::std::unique_ptr< couplingtype_type > x)
  {
    this->couplingtype_.set (std::move (x));
  }

  const weakform_volume::sourceanalysis_optional& weakform_volume::
  sourceanalysis () const
  {
    return this->sourceanalysis_;
  }

  weakform_volume::sourceanalysis_optional& weakform_volume::
  sourceanalysis ()
  {
    return this->sourceanalysis_;
  }

  void weakform_volume::
  sourceanalysis (const sourceanalysis_type& x)
  {
    this->sourceanalysis_.set (x);
  }

  void weakform_volume::
  sourceanalysis (const sourceanalysis_optional& x)
  {
    this->sourceanalysis_ = x;
  }

  void weakform_volume::
  sourceanalysis (::std::unique_ptr< sourceanalysis_type > x)
  {
    this->sourceanalysis_.set (std::move (x));
  }

  const weakform_volume::equation_type& weakform_volume::
  equation () const
  {
    return this->equation_.get ();
  }

  weakform_volume::equation_type& weakform_volume::
  equation ()
  {
    return this->equation_.get ();
  }

  void weakform_volume::
  equation (const equation_type& x)
  {
    this->equation_.set (x);
  }

  void weakform_volume::
  equation (::std::unique_ptr< equation_type > x)
  {
    this->equation_.set (std::move (x));
  }


  // linearity_option
  // 

  const linearity_option::matrix_form_sequence& linearity_option::
  matrix_form () const
  {
    return this->matrix_form_;
  }

  linearity_option::matrix_form_sequence& linearity_option::
  matrix_form ()
  {
    return this->matrix_form_;
  }

  void linearity_option::
  matrix_form (const matrix_form_sequence& s)
  {
    this->matrix_form_ = s;
  }

  const linearity_option::vector_form_sequence& linearity_option::
  vector_form () const
  {
    return this->vector_form_;
  }

  linearity_option::vector_form_sequence& linearity_option::
  vector_form ()
  {
    return this->vector_form_;
  }

  void linearity_option::
  vector_form (const vector_form_sequence& s)
  {
    this->vector_form_ = s;
  }

  const linearity_option::matrix_transient_form_sequence& linearity_option::
  matrix_transient_form () const
  {
    return this->matrix_transient_form_;
  }

  linearity_option::matrix_transient_form_sequence& linearity_option::
  matrix_transient_form ()
  {
    return this->matrix_transient_form_;
  }

  void linearity_option::
  matrix_transient_form (const matrix_transient_form_sequence& s)
  {
    this->matrix_transient_form_ = s;
  }

  const linearity_option::essential_form_sequence& linearity_option::
  essential_form () const
  {
    return this->essential_form_;
  }

  linearity_option::essential_form_sequence& linearity_option::
  essential_form ()
  {
    return this->essential_form_;
  }

  void linearity_option::
  essential_form (const essential_form_sequence& s)
  {
    this->essential_form_ = s;
  }

  const linearity_option::type_type& linearity_option::
  type () const
  {
    return this->type_.get ();
  }

  linearity_option::type_type& linearity_option::
  type ()
  {
    return this->type_.get ();
  }

  void linearity_option::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void linearity_option::
  type (::std::unique_ptr< type_type > x)
  {
    this->type_.set (std::move (x));
  }


  // matrix_form
  // 

  const matrix_form::id_type& matrix_form::
  id () const
  {
    return this->id_.get ();
  }

  matrix_form::id_type& matrix_form::
  id ()
  {
    return this->id_.get ();
  }

  void matrix_form::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void matrix_form::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }

  const matrix_form::i_optional& matrix_form::
  i () const
  {
    return this->i_;
  }

  matrix_form::i_optional& matrix_form::
  i ()
  {
    return this->i_;
  }

  void matrix_form::
  i (const i_type& x)
  {
    this->i_.set (x);
  }

  void matrix_form::
  i (const i_optional& x)
  {
    this->i_ = x;
  }

  const matrix_form::j_optional& matrix_form::
  j () const
  {
    return this->j_;
  }

  matrix_form::j_optional& matrix_form::
  j ()
  {
    return this->j_;
  }

  void matrix_form::
  j (const j_type& x)
  {
    this->j_.set (x);
  }

  void matrix_form::
  j (const j_optional& x)
  {
    this->j_ = x;
  }

  const matrix_form::planar_optional& matrix_form::
  planar () const
  {
    return this->planar_;
  }

  matrix_form::planar_optional& matrix_form::
  planar ()
  {
    return this->planar_;
  }

  void matrix_form::
  planar (const planar_type& x)
  {
    this->planar_.set (x);
  }

  void matrix_form::
  planar (const planar_optional& x)
  {
    this->planar_ = x;
  }

  void matrix_form::
  planar (::std::unique_ptr< planar_type > x)
  {
    this->planar_.set (std::move (x));
  }

  const matrix_form::axi_optional& matrix_form::
  axi () const
  {
    return this->axi_;
  }

  matrix_form::axi_optional& matrix_form::
  axi ()
  {
    return this->axi_;
  }

  void matrix_form::
  axi (const axi_type& x)
  {
    this->axi_.set (x);
  }

  void matrix_form::
  axi (const axi_optional& x)
  {
    this->axi_ = x;
  }

  void matrix_form::
  axi (::std::unique_ptr< axi_type > x)
  {
    this->axi_.set (std::move (x));
  }

  const matrix_form::symmetric_optional& matrix_form::
  symmetric () const
  {
    return this->symmetric_;
  }

  matrix_form::symmetric_optional& matrix_form::
  symmetric ()
  {
    return this->symmetric_;
  }

  void matrix_form::
  symmetric (const symmetric_type& x)
  {
    this->symmetric_.set (x);
  }

  void matrix_form::
  symmetric (const symmetric_optional& x)
  {
    this->symmetric_ = x;
  }

  const matrix_form::symmetric_planar_optional& matrix_form::
  symmetric_planar () const
  {
    return this->symmetric_planar_;
  }

  matrix_form::symmetric_planar_optional& matrix_form::
  symmetric_planar ()
  {
    return this->symmetric_planar_;
  }

  void matrix_form::
  symmetric_planar (const symmetric_planar_type& x)
  {
    this->symmetric_planar_.set (x);
  }

  void matrix_form::
  symmetric_planar (const symmetric_planar_optional& x)
  {
    this->symmetric_planar_ = x;
  }

  const matrix_form::symmetric_axi_optional& matrix_form::
  symmetric_axi () const
  {
    return this->symmetric_axi_;
  }

  matrix_form::symmetric_axi_optional& matrix_form::
  symmetric_axi ()
  {
    return this->symmetric_axi_;
  }

  void matrix_form::
  symmetric_axi (const symmetric_axi_type& x)
  {
    this->symmetric_axi_.set (x);
  }

  void matrix_form::
  symmetric_axi (const symmetric_axi_optional& x)
  {
    this->symmetric_axi_ = x;
  }

  const matrix_form::condition_optional& matrix_form::
  condition () const
  {
    return this->condition_;
  }

  matrix_form::condition_optional& matrix_form::
  condition ()
  {
    return this->condition_;
  }

  void matrix_form::
  condition (const condition_type& x)
  {
    this->condition_.set (x);
  }

  void matrix_form::
  condition (const condition_optional& x)
  {
    this->condition_ = x;
  }

  void matrix_form::
  condition (::std::unique_ptr< condition_type > x)
  {
    this->condition_.set (std::move (x));
  }


  // vector_form
  // 

  const vector_form::id_type& vector_form::
  id () const
  {
    return this->id_.get ();
  }

  vector_form::id_type& vector_form::
  id ()
  {
    return this->id_.get ();
  }

  void vector_form::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void vector_form::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }

  const vector_form::i_optional& vector_form::
  i () const
  {
    return this->i_;
  }

  vector_form::i_optional& vector_form::
  i ()
  {
    return this->i_;
  }

  void vector_form::
  i (const i_type& x)
  {
    this->i_.set (x);
  }

  void vector_form::
  i (const i_optional& x)
  {
    this->i_ = x;
  }

  const vector_form::j_optional& vector_form::
  j () const
  {
    return this->j_;
  }

  vector_form::j_optional& vector_form::
  j ()
  {
    return this->j_;
  }

  void vector_form::
  j (const j_type& x)
  {
    this->j_.set (x);
  }

  void vector_form::
  j (const j_optional& x)
  {
    this->j_ = x;
  }

  const vector_form::planar_optional& vector_form::
  planar () const
  {
    return this->planar_;
  }

  vector_form::planar_optional& vector_form::
  planar ()
  {
    return this->planar_;
  }

  void vector_form::
  planar (const planar_type& x)
  {
    this->planar_.set (x);
  }

  void vector_form::
  planar (const planar_optional& x)
  {
    this->planar_ = x;
  }

  void vector_form::
  planar (::std::unique_ptr< planar_type > x)
  {
    this->planar_.set (std::move (x));
  }

  const vector_form::axi_optional& vector_form::
  axi () const
  {
    return this->axi_;
  }

  vector_form::axi_optional& vector_form::
  axi ()
  {
    return this->axi_;
  }

  void vector_form::
  axi (const axi_type& x)
  {
    this->axi_.set (x);
  }

  void vector_form::
  axi (const axi_optional& x)
  {
    this->axi_ = x;
  }

  void vector_form::
  axi (::std::unique_ptr< axi_type > x)
  {
    this->axi_.set (std::move (x));
  }

  const vector_form::variant_optional& vector_form::
  variant () const
  {
    return this->variant_;
  }

  vector_form::variant_optional& vector_form::
  variant ()
  {
    return this->variant_;
  }

  void vector_form::
  variant (const variant_type& x)
  {
    this->variant_.set (x);
  }

  void vector_form::
  variant (const variant_optional& x)
  {
    this->variant_ = x;
  }

  void vector_form::
  variant (::std::unique_ptr< variant_type > x)
  {
    this->variant_.set (std::move (x));
  }

  const vector_form::coefficient_optional& vector_form::
  coefficient () const
  {
    return this->coefficient_;
  }

  vector_form::coefficient_optional& vector_form::
  coefficient ()
  {
    return this->coefficient_;
  }

  void vector_form::
  coefficient (const coefficient_type& x)
  {
    this->coefficient_.set (x);
  }

  void vector_form::
  coefficient (const coefficient_optional& x)
  {
    this->coefficient_ = x;
  }

  void vector_form::
  coefficient (::std::unique_ptr< coefficient_type > x)
  {
    this->coefficient_.set (std::move (x));
  }

  const vector_form::condition_optional& vector_form::
  condition () const
  {
    return this->condition_;
  }

  vector_form::condition_optional& vector_form::
  condition ()
  {
    return this->condition_;
  }

  void vector_form::
  condition (const condition_type& x)
  {
    this->condition_.set (x);
  }

  void vector_form::
  condition (const condition_optional& x)
  {
    this->condition_ = x;
  }

  void vector_form::
  condition (::std::unique_ptr< condition_type > x)
  {
    this->condition_.set (std::move (x));
  }


  // matrix_transient_form
  // 

  const matrix_transient_form::id_type& matrix_transient_form::
  id () const
  {
    return this->id_.get ();
  }

  matrix_transient_form::id_type& matrix_transient_form::
  id ()
  {
    return this->id_.get ();
  }

  void matrix_transient_form::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void matrix_transient_form::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }

  const matrix_transient_form::i_optional& matrix_transient_form::
  i () const
  {
    return this->i_;
  }

  matrix_transient_form::i_optional& matrix_transient_form::
  i ()
  {
    return this->i_;
  }

  void matrix_transient_form::
  i (const i_type& x)
  {
    this->i_.set (x);
  }

  void matrix_transient_form::
  i (const i_optional& x)
  {
    this->i_ = x;
  }

  const matrix_transient_form::j_optional& matrix_transient_form::
  j () const
  {
    return this->j_;
  }

  matrix_transient_form::j_optional& matrix_transient_form::
  j ()
  {
    return this->j_;
  }

  void matrix_transient_form::
  j (const j_type& x)
  {
    this->j_.set (x);
  }

  void matrix_transient_form::
  j (const j_optional& x)
  {
    this->j_ = x;
  }

  const matrix_transient_form::planar_optional& matrix_transient_form::
  planar () const
  {
    return this->planar_;
  }

  matrix_transient_form::planar_optional& matrix_transient_form::
  planar ()
  {
    return this->planar_;
  }

  void matrix_transient_form::
  planar (const planar_type& x)
  {
    this->planar_.set (x);
  }

  void matrix_transient_form::
  planar (const planar_optional& x)
  {
    this->planar_ = x;
  }

  void matrix_transient_form::
  planar (::std::unique_ptr< planar_type > x)
  {
    this->planar_.set (std::move (x));
  }

  const matrix_transient_form::axi_optional& matrix_transient_form::
  axi () const
  {
    return this->axi_;
  }

  matrix_transient_form::axi_optional& matrix_transient_form::
  axi ()
  {
    return this->axi_;
  }

  void matrix_transient_form::
  axi (const axi_type& x)
  {
    this->axi_.set (x);
  }

  void matrix_transient_form::
  axi (const axi_optional& x)
  {
    this->axi_ = x;
  }

  void matrix_transient_form::
  axi (::std::unique_ptr< axi_type > x)
  {
    this->axi_.set (std::move (x));
  }

  const matrix_transient_form::symmetric_optional& matrix_transient_form::
  symmetric () const
  {
    return this->symmetric_;
  }

  matrix_transient_form::symmetric_optional& matrix_transient_form::
  symmetric ()
  {
    return this->symmetric_;
  }

  void matrix_transient_form::
  symmetric (const symmetric_type& x)
  {
    this->symmetric_.set (x);
  }

  void matrix_transient_form::
  symmetric (const symmetric_optional& x)
  {
    this->symmetric_ = x;
  }

  const matrix_transient_form::symmetric_planar_optional& matrix_transient_form::
  symmetric_planar () const
  {
    return this->symmetric_planar_;
  }

  matrix_transient_form::symmetric_planar_optional& matrix_transient_form::
  symmetric_planar ()
  {
    return this->symmetric_planar_;
  }

  void matrix_transient_form::
  symmetric_planar (const symmetric_planar_type& x)
  {
    this->symmetric_planar_.set (x);
  }

  void matrix_transient_form::
  symmetric_planar (const symmetric_planar_optional& x)
  {
    this->symmetric_planar_ = x;
  }

  const matrix_transient_form::symmetric_axi_optional& matrix_transient_form::
  symmetric_axi () const
  {
    return this->symmetric_axi_;
  }

  matrix_transient_form::symmetric_axi_optional& matrix_transient_form::
  symmetric_axi ()
  {
    return this->symmetric_axi_;
  }

  void matrix_transient_form::
  symmetric_axi (const symmetric_axi_type& x)
  {
    this->symmetric_axi_.set (x);
  }

  void matrix_transient_form::
  symmetric_axi (const symmetric_axi_optional& x)
  {
    this->symmetric_axi_ = x;
  }

  const matrix_transient_form::condition_optional& matrix_transient_form::
  condition () const
  {
    return this->condition_;
  }

  matrix_transient_form::condition_optional& matrix_transient_form::
  condition ()
  {
    return this->condition_;
  }

  void matrix_transient_form::
  condition (const condition_type& x)
  {
    this->condition_.set (x);
  }

  void matrix_transient_form::
  condition (const condition_optional& x)
  {
    this->condition_ = x;
  }

  void matrix_transient_form::
  condition (::std::unique_ptr< condition_type > x)
  {
    this->condition_.set (std::move (x));
  }


  // essential_form
  // 

  const essential_form::id_type& essential_form::
  id () const
  {
    return this->id_.get ();
  }

  essential_form::id_type& essential_form::
  id ()
  {
    return this->id_.get ();
  }

  void essential_form::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void essential_form::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }

  const essential_form::i_optional& essential_form::
  i () const
  {
    return this->i_;
  }

  essential_form::i_optional& essential_form::
  i ()
  {
    return this->i_;
  }

  void essential_form::
  i (const i_type& x)
  {
    this->i_.set (x);
  }

  void essential_form::
  i (const i_optional& x)
  {
    this->i_ = x;
  }

  const essential_form::planar_optional& essential_form::
  planar () const
  {
    return this->planar_;
  }

  essential_form::planar_optional& essential_form::
  planar ()
  {
    return this->planar_;
  }

  void essential_form::
  planar (const planar_type& x)
  {
    this->planar_.set (x);
  }

  void essential_form::
  planar (const planar_optional& x)
  {
    this->planar_ = x;
  }

  void essential_form::
  planar (::std::unique_ptr< planar_type > x)
  {
    this->planar_.set (std::move (x));
  }

  const essential_form::axi_optional& essential_form::
  axi () const
  {
    return this->axi_;
  }

  essential_form::axi_optional& essential_form::
  axi ()
  {
    return this->axi_;
  }

  void essential_form::
  axi (const axi_type& x)
  {
    this->axi_.set (x);
  }

  void essential_form::
  axi (const axi_optional& x)
  {
    this->axi_ = x;
  }

  void essential_form::
  axi (::std::unique_ptr< axi_type > x)
  {
    this->axi_.set (std::move (x));
  }

  const essential_form::condition_optional& essential_form::
  condition () const
  {
    return this->condition_;
  }

  essential_form::condition_optional& essential_form::
  condition ()
  {
    return this->condition_;
  }

  void essential_form::
  condition (const condition_type& x)
  {
    this->condition_.set (x);
  }

  void essential_form::
  condition (const condition_optional& x)
  {
    this->condition_ = x;
  }

  void essential_form::
  condition (::std::unique_ptr< condition_type > x)
  {
    this->condition_.set (std::move (x));
  }


  // quantity
  // 

  const quantity::id_type& quantity::
  id () const
  {
    return this->id_.get ();
  }

  quantity::id_type& quantity::
  id ()
  {
    return this->id_.get ();
  }

  void quantity::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void quantity::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }

  const quantity::condition_optional& quantity::
  condition () const
  {
    return this->condition_;
  }

  quantity::condition_optional& quantity::
  condition ()
  {
    return this->condition_;
  }

  void quantity::
  condition (const condition_type& x)
  {
    this->condition_.set (x);
  }

  void quantity::
  condition (const condition_optional& x)
  {
    this->condition_ = x;
  }

  void quantity::
  condition (::std::unique_ptr< condition_type > x)
  {
    this->condition_.set (std::move (x));
  }

  const quantity::default_optional& quantity::
  default_ () const
  {
    return this->default__;
  }

  quantity::default_optional& quantity::
  default_ ()
  {
    return this->default__;
  }

  void quantity::
  default_ (const default_type& x)
  {
    this->default__.set (x);
  }

  void quantity::
  default_ (const default_optional& x)
  {
    this->default__ = x;
  }

  const quantity::nonlinearity_planar_optional& quantity::
  nonlinearity_planar () const
  {
    return this->nonlinearity_planar_;
  }

  quantity::nonlinearity_planar_optional& quantity::
  nonlinearity_planar ()
  {
    return this->nonlinearity_planar_;
  }

  void quantity::
  nonlinearity_planar (const nonlinearity_planar_type& x)
  {
    this->nonlinearity_planar_.set (x);
  }

  void quantity::
  nonlinearity_planar (const nonlinearity_planar_optional& x)
  {
    this->nonlinearity_planar_ = x;
  }

  void quantity::
  nonlinearity_planar (::std::unique_ptr< nonlinearity_planar_type > x)
  {
    this->nonlinearity_planar_.set (std::move (x));
  }

  const quantity::nonlinearity_axi_optional& quantity::
  nonlinearity_axi () const
  {
    return this->nonlinearity_axi_;
  }

  quantity::nonlinearity_axi_optional& quantity::
  nonlinearity_axi ()
  {
    return this->nonlinearity_axi_;
  }

  void quantity::
  nonlinearity_axi (const nonlinearity_axi_type& x)
  {
    this->nonlinearity_axi_.set (x);
  }

  void quantity::
  nonlinearity_axi (const nonlinearity_axi_optional& x)
  {
    this->nonlinearity_axi_ = x;
  }

  void quantity::
  nonlinearity_axi (::std::unique_ptr< nonlinearity_axi_type > x)
  {
    this->nonlinearity_axi_.set (std::move (x));
  }

  const quantity::dependence_optional& quantity::
  dependence () const
  {
    return this->dependence_;
  }

  quantity::dependence_optional& quantity::
  dependence ()
  {
    return this->dependence_;
  }

  void quantity::
  dependence (const dependence_type& x)
  {
    this->dependence_.set (x);
  }

  void quantity::
  dependence (const dependence_optional& x)
  {
    this->dependence_ = x;
  }

  void quantity::
  dependence (::std::unique_ptr< dependence_type > x)
  {
    this->dependence_.set (std::move (x));
  }

  const quantity::name_optional& quantity::
  name () const
  {
    return this->name_;
  }

  quantity::name_optional& quantity::
  name ()
  {
    return this->name_;
  }

  void quantity::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void quantity::
  name (const name_optional& x)
  {
    this->name_ = x;
  }

  void quantity::
  name (::std::unique_ptr< name_type > x)
  {
    this->name_.set (std::move (x));
  }

  const quantity::shortname_optional& quantity::
  shortname () const
  {
    return this->shortname_;
  }

  quantity::shortname_optional& quantity::
  shortname ()
  {
    return this->shortname_;
  }

  void quantity::
  shortname (const shortname_type& x)
  {
    this->shortname_.set (x);
  }

  void quantity::
  shortname (const shortname_optional& x)
  {
    this->shortname_ = x;
  }

  void quantity::
  shortname (::std::unique_ptr< shortname_type > x)
  {
    this->shortname_.set (std::move (x));
  }

  const quantity::shortname_html_optional& quantity::
  shortname_html () const
  {
    return this->shortname_html_;
  }

  quantity::shortname_html_optional& quantity::
  shortname_html ()
  {
    return this->shortname_html_;
  }

  void quantity::
  shortname_html (const shortname_html_type& x)
  {
    this->shortname_html_.set (x);
  }

  void quantity::
  shortname_html (const shortname_html_optional& x)
  {
    this->shortname_html_ = x;
  }

  void quantity::
  shortname_html (::std::unique_ptr< shortname_html_type > x)
  {
    this->shortname_html_.set (std::move (x));
  }

  const quantity::shortname_latex_optional& quantity::
  shortname_latex () const
  {
    return this->shortname_latex_;
  }

  quantity::shortname_latex_optional& quantity::
  shortname_latex ()
  {
    return this->shortname_latex_;
  }

  void quantity::
  shortname_latex (const shortname_latex_type& x)
  {
    this->shortname_latex_.set (x);
  }

  void quantity::
  shortname_latex (const shortname_latex_optional& x)
  {
    this->shortname_latex_ = x;
  }

  void quantity::
  shortname_latex (::std::unique_ptr< shortname_latex_type > x)
  {
    this->shortname_latex_.set (std::move (x));
  }

  const quantity::shortname_dependence_optional& quantity::
  shortname_dependence () const
  {
    return this->shortname_dependence_;
  }

  quantity::shortname_dependence_optional& quantity::
  shortname_dependence ()
  {
    return this->shortname_dependence_;
  }

  void quantity::
  shortname_dependence (const shortname_dependence_type& x)
  {
    this->shortname_dependence_.set (x);
  }

  void quantity::
  shortname_dependence (const shortname_dependence_optional& x)
  {
    this->shortname_dependence_ = x;
  }

  void quantity::
  shortname_dependence (::std::unique_ptr< shortname_dependence_type > x)
  {
    this->shortname_dependence_.set (std::move (x));
  }

  const quantity::shortname_dependence_html_optional& quantity::
  shortname_dependence_html () const
  {
    return this->shortname_dependence_html_;
  }

  quantity::shortname_dependence_html_optional& quantity::
  shortname_dependence_html ()
  {
    return this->shortname_dependence_html_;
  }

  void quantity::
  shortname_dependence_html (const shortname_dependence_html_type& x)
  {
    this->shortname_dependence_html_.set (x);
  }

  void quantity::
  shortname_dependence_html (const shortname_dependence_html_optional& x)
  {
    this->shortname_dependence_html_ = x;
  }

  void quantity::
  shortname_dependence_html (::std::unique_ptr< shortname_dependence_html_type > x)
  {
    this->shortname_dependence_html_.set (std::move (x));
  }

  const quantity::unit_optional& quantity::
  unit () const
  {
    return this->unit_;
  }

  quantity::unit_optional& quantity::
  unit ()
  {
    return this->unit_;
  }

  void quantity::
  unit (const unit_type& x)
  {
    this->unit_.set (x);
  }

  void quantity::
  unit (const unit_optional& x)
  {
    this->unit_ = x;
  }

  void quantity::
  unit (::std::unique_ptr< unit_type > x)
  {
    this->unit_.set (std::move (x));
  }

  const quantity::unit_html_optional& quantity::
  unit_html () const
  {
    return this->unit_html_;
  }

  quantity::unit_html_optional& quantity::
  unit_html ()
  {
    return this->unit_html_;
  }

  void quantity::
  unit_html (const unit_html_type& x)
  {
    this->unit_html_.set (x);
  }

  void quantity::
  unit_html (const unit_html_optional& x)
  {
    this->unit_html_ = x;
  }

  void quantity::
  unit_html (::std::unique_ptr< unit_html_type > x)
  {
    this->unit_html_.set (std::move (x));
  }

  const quantity::unit_latex_optional& quantity::
  unit_latex () const
  {
    return this->unit_latex_;
  }

  quantity::unit_latex_optional& quantity::
  unit_latex ()
  {
    return this->unit_latex_;
  }

  void quantity::
  unit_latex (const unit_latex_type& x)
  {
    this->unit_latex_.set (x);
  }

  void quantity::
  unit_latex (const unit_latex_optional& x)
  {
    this->unit_latex_ = x;
  }

  void quantity::
  unit_latex (::std::unique_ptr< unit_latex_type > x)
  {
    this->unit_latex_.set (std::move (x));
  }

  const quantity::is_source_optional& quantity::
  is_source () const
  {
    return this->is_source_;
  }

  quantity::is_source_optional& quantity::
  is_source ()
  {
    return this->is_source_;
  }

  void quantity::
  is_source (const is_source_type& x)
  {
    this->is_source_.set (x);
  }

  void quantity::
  is_source (const is_source_optional& x)
  {
    this->is_source_ = x;
  }

  const quantity::is_bool_optional& quantity::
  is_bool () const
  {
    return this->is_bool_;
  }

  quantity::is_bool_optional& quantity::
  is_bool ()
  {
    return this->is_bool_;
  }

  void quantity::
  is_bool (const is_bool_type& x)
  {
    this->is_bool_.set (x);
  }

  void quantity::
  is_bool (const is_bool_optional& x)
  {
    this->is_bool_ = x;
  }

  const quantity::only_if_optional& quantity::
  only_if () const
  {
    return this->only_if_;
  }

  quantity::only_if_optional& quantity::
  only_if ()
  {
    return this->only_if_;
  }

  void quantity::
  only_if (const only_if_type& x)
  {
    this->only_if_.set (x);
  }

  void quantity::
  only_if (const only_if_optional& x)
  {
    this->only_if_ = x;
  }

  void quantity::
  only_if (::std::unique_ptr< only_if_type > x)
  {
    this->only_if_.set (std::move (x));
  }

  const quantity::only_if_not_optional& quantity::
  only_if_not () const
  {
    return this->only_if_not_;
  }

  quantity::only_if_not_optional& quantity::
  only_if_not ()
  {
    return this->only_if_not_;
  }

  void quantity::
  only_if_not (const only_if_not_type& x)
  {
    this->only_if_not_.set (x);
  }

  void quantity::
  only_if_not (const only_if_not_optional& x)
  {
    this->only_if_not_ = x;
  }

  void quantity::
  only_if_not (::std::unique_ptr< only_if_not_type > x)
  {
    this->only_if_not_.set (std::move (x));
  }


  // function
  // 

  const function::quantity_sequence& function::
  quantity () const
  {
    return this->quantity_;
  }

  function::quantity_sequence& function::
  quantity ()
  {
    return this->quantity_;
  }

  void function::
  quantity (const quantity_sequence& s)
  {
    this->quantity_ = s;
  }

  const function::function_variant_sequence& function::
  function_variant () const
  {
    return this->function_variant_;
  }

  function::function_variant_sequence& function::
  function_variant ()
  {
    return this->function_variant_;
  }

  void function::
  function_variant (const function_variant_sequence& s)
  {
    this->function_variant_ = s;
  }

  const function::id_type& function::
  id () const
  {
    return this->id_.get ();
  }

  function::id_type& function::
  id ()
  {
    return this->id_.get ();
  }

  void function::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void function::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }

  const function::shortname_type& function::
  shortname () const
  {
    return this->shortname_.get ();
  }

  function::shortname_type& function::
  shortname ()
  {
    return this->shortname_.get ();
  }

  void function::
  shortname (const shortname_type& x)
  {
    this->shortname_.set (x);
  }

  void function::
  shortname (::std::unique_ptr< shortname_type > x)
  {
    this->shortname_.set (std::move (x));
  }

  const function::type_type& function::
  type () const
  {
    return this->type_.get ();
  }

  function::type_type& function::
  type ()
  {
    return this->type_.get ();
  }

  void function::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void function::
  type (::std::unique_ptr< type_type > x)
  {
    this->type_.set (std::move (x));
  }

  const function::postprocessor_analysis_optional& function::
  postprocessor_analysis () const
  {
    return this->postprocessor_analysis_;
  }

  function::postprocessor_analysis_optional& function::
  postprocessor_analysis ()
  {
    return this->postprocessor_analysis_;
  }

  void function::
  postprocessor_analysis (const postprocessor_analysis_type& x)
  {
    this->postprocessor_analysis_.set (x);
  }

  void function::
  postprocessor_analysis (const postprocessor_analysis_optional& x)
  {
    this->postprocessor_analysis_ = x;
  }

  void function::
  postprocessor_analysis (::std::unique_ptr< postprocessor_analysis_type > x)
  {
    this->postprocessor_analysis_.set (std::move (x));
  }

  const function::postprocessor_linearity_optional& function::
  postprocessor_linearity () const
  {
    return this->postprocessor_linearity_;
  }

  function::postprocessor_linearity_optional& function::
  postprocessor_linearity ()
  {
    return this->postprocessor_linearity_;
  }

  void function::
  postprocessor_linearity (const postprocessor_linearity_type& x)
  {
    this->postprocessor_linearity_.set (x);
  }

  void function::
  postprocessor_linearity (const postprocessor_linearity_optional& x)
  {
    this->postprocessor_linearity_ = x;
  }

  void function::
  postprocessor_linearity (::std::unique_ptr< postprocessor_linearity_type > x)
  {
    this->postprocessor_linearity_.set (std::move (x));
  }


  // function_variant
  // 

  const function_variant::switch_value_optional& function_variant::
  switch_value () const
  {
    return this->switch_value_;
  }

  function_variant::switch_value_optional& function_variant::
  switch_value ()
  {
    return this->switch_value_;
  }

  void function_variant::
  switch_value (const switch_value_type& x)
  {
    this->switch_value_.set (x);
  }

  void function_variant::
  switch_value (const switch_value_optional& x)
  {
    this->switch_value_ = x;
  }

  void function_variant::
  switch_value (::std::unique_ptr< switch_value_type > x)
  {
    this->switch_value_.set (std::move (x));
  }

  const function_variant::expr_type& function_variant::
  expr () const
  {
    return this->expr_.get ();
  }

  function_variant::expr_type& function_variant::
  expr ()
  {
    return this->expr_.get ();
  }

  void function_variant::
  expr (const expr_type& x)
  {
    this->expr_.set (x);
  }

  void function_variant::
  expr (::std::unique_ptr< expr_type > x)
  {
    this->expr_.set (std::move (x));
  }

  const function_variant::expr_axi_optional& function_variant::
  expr_axi () const
  {
    return this->expr_axi_;
  }

  function_variant::expr_axi_optional& function_variant::
  expr_axi ()
  {
    return this->expr_axi_;
  }

  void function_variant::
  expr_axi (const expr_axi_type& x)
  {
    this->expr_axi_.set (x);
  }

  void function_variant::
  expr_axi (const expr_axi_optional& x)
  {
    this->expr_axi_ = x;
  }

  void function_variant::
  expr_axi (::std::unique_ptr< expr_axi_type > x)
  {
    this->expr_axi_.set (std::move (x));
  }


  // function_use
  // 

  const function_use::id_type& function_use::
  id () const
  {
    return this->id_.get ();
  }

  function_use::id_type& function_use::
  id ()
  {
    return this->id_.get ();
  }

  void function_use::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void function_use::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }


  // error_calculator
  // 

  const error_calculator::calculator_sequence& error_calculator::
  calculator () const
  {
    return this->calculator_;
  }

  error_calculator::calculator_sequence& error_calculator::
  calculator ()
  {
    return this->calculator_;
  }

  void error_calculator::
  calculator (const calculator_sequence& s)
  {
    this->calculator_ = s;
  }


  // calculator
  // 

  const calculator::expression_sequence& calculator::
  expression () const
  {
    return this->expression_;
  }

  calculator::expression_sequence& calculator::
  expression ()
  {
    return this->expression_;
  }

  void calculator::
  expression (const expression_sequence& s)
  {
    this->expression_ = s;
  }

  const calculator::id_type& calculator::
  id () const
  {
    return this->id_.get ();
  }

  calculator::id_type& calculator::
  id ()
  {
    return this->id_.get ();
  }

  void calculator::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void calculator::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }

  const calculator::name_type& calculator::
  name () const
  {
    return this->name_.get ();
  }

  calculator::name_type& calculator::
  name ()
  {
    return this->name_.get ();
  }

  void calculator::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void calculator::
  name (::std::unique_ptr< name_type > x)
  {
    this->name_.set (std::move (x));
  }


  // expression
  // 

  const expression::analysistype_type& expression::
  analysistype () const
  {
    return this->analysistype_.get ();
  }

  expression::analysistype_type& expression::
  analysistype ()
  {
    return this->analysistype_.get ();
  }

  void expression::
  analysistype (const analysistype_type& x)
  {
    this->analysistype_.set (x);
  }

  void expression::
  analysistype (::std::unique_ptr< analysistype_type > x)
  {
    this->analysistype_.set (std::move (x));
  }

  const expression::axi_optional& expression::
  axi () const
  {
    return this->axi_;
  }

  expression::axi_optional& expression::
  axi ()
  {
    return this->axi_;
  }

  void expression::
  axi (const axi_type& x)
  {
    this->axi_.set (x);
  }

  void expression::
  axi (const axi_optional& x)
  {
    this->axi_ = x;
  }

  void expression::
  axi (::std::unique_ptr< axi_type > x)
  {
    this->axi_.set (std::move (x));
  }

  const expression::axi_r_optional& expression::
  axi_r () const
  {
    return this->axi_r_;
  }

  expression::axi_r_optional& expression::
  axi_r ()
  {
    return this->axi_r_;
  }

  void expression::
  axi_r (const axi_r_type& x)
  {
    this->axi_r_.set (x);
  }

  void expression::
  axi_r (const axi_r_optional& x)
  {
    this->axi_r_ = x;
  }

  void expression::
  axi_r (::std::unique_ptr< axi_r_type > x)
  {
    this->axi_r_.set (std::move (x));
  }

  const expression::axi_z_optional& expression::
  axi_z () const
  {
    return this->axi_z_;
  }

  expression::axi_z_optional& expression::
  axi_z ()
  {
    return this->axi_z_;
  }

  void expression::
  axi_z (const axi_z_type& x)
  {
    this->axi_z_.set (x);
  }

  void expression::
  axi_z (const axi_z_optional& x)
  {
    this->axi_z_ = x;
  }

  void expression::
  axi_z (::std::unique_ptr< axi_z_type > x)
  {
    this->axi_z_.set (std::move (x));
  }

  const expression::axi_phi_optional& expression::
  axi_phi () const
  {
    return this->axi_phi_;
  }

  expression::axi_phi_optional& expression::
  axi_phi ()
  {
    return this->axi_phi_;
  }

  void expression::
  axi_phi (const axi_phi_type& x)
  {
    this->axi_phi_.set (x);
  }

  void expression::
  axi_phi (const axi_phi_optional& x)
  {
    this->axi_phi_ = x;
  }

  void expression::
  axi_phi (::std::unique_ptr< axi_phi_type > x)
  {
    this->axi_phi_.set (std::move (x));
  }

  const expression::planar_optional& expression::
  planar () const
  {
    return this->planar_;
  }

  expression::planar_optional& expression::
  planar ()
  {
    return this->planar_;
  }

  void expression::
  planar (const planar_type& x)
  {
    this->planar_.set (x);
  }

  void expression::
  planar (const planar_optional& x)
  {
    this->planar_ = x;
  }

  void expression::
  planar (::std::unique_ptr< planar_type > x)
  {
    this->planar_.set (std::move (x));
  }

  const expression::planar_x_optional& expression::
  planar_x () const
  {
    return this->planar_x_;
  }

  expression::planar_x_optional& expression::
  planar_x ()
  {
    return this->planar_x_;
  }

  void expression::
  planar_x (const planar_x_type& x)
  {
    this->planar_x_.set (x);
  }

  void expression::
  planar_x (const planar_x_optional& x)
  {
    this->planar_x_ = x;
  }

  void expression::
  planar_x (::std::unique_ptr< planar_x_type > x)
  {
    this->planar_x_.set (std::move (x));
  }

  const expression::planar_y_optional& expression::
  planar_y () const
  {
    return this->planar_y_;
  }

  expression::planar_y_optional& expression::
  planar_y ()
  {
    return this->planar_y_;
  }

  void expression::
  planar_y (const planar_y_type& x)
  {
    this->planar_y_.set (x);
  }

  void expression::
  planar_y (const planar_y_optional& x)
  {
    this->planar_y_ = x;
  }

  void expression::
  planar_y (::std::unique_ptr< planar_y_type > x)
  {
    this->planar_y_.set (std::move (x));
  }

  const expression::planar_z_optional& expression::
  planar_z () const
  {
    return this->planar_z_;
  }

  expression::planar_z_optional& expression::
  planar_z ()
  {
    return this->planar_z_;
  }

  void expression::
  planar_z (const planar_z_type& x)
  {
    this->planar_z_.set (x);
  }

  void expression::
  planar_z (const planar_z_optional& x)
  {
    this->planar_z_ = x;
  }

  void expression::
  planar_z (::std::unique_ptr< planar_z_type > x)
  {
    this->planar_z_.set (std::move (x));
  }


  // field_item
  // 

  const field_item::field_key_type& field_item::
  field_key () const
  {
    return this->field_key_.get ();
  }

  field_item::field_key_type& field_item::
  field_key ()
  {
    return this->field_key_.get ();
  }

  void field_item::
  field_key (const field_key_type& x)
  {
    this->field_key_.set (x);
  }

  void field_item::
  field_key (::std::unique_ptr< field_key_type > x)
  {
    this->field_key_.set (std::move (x));
  }

  const field_item::field_value_type& field_item::
  field_value () const
  {
    return this->field_value_.get ();
  }

  field_item::field_value_type& field_item::
  field_value ()
  {
    return this->field_value_.get ();
  }

  void field_item::
  field_value (const field_value_type& x)
  {
    this->field_value_.set (x);
  }

  void field_item::
  field_value (::std::unique_ptr< field_value_type > x)
  {
    this->field_value_.set (std::move (x));
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, char >
  type_factory_plate_init;
}

namespace XMLModule
{
  // module
  //

  module::
  module ()
  : ::xml_schema::type (),
    field_ (this),
    coupling_ (this)
  {
  }

  module::
  module (const module& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    field_ (x.field_, f, this),
    coupling_ (x.coupling_, f, this)
  {
  }

  module::
  module (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    field_ (this),
    coupling_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void module::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // field
      //
      if (n.name () == "field" && n.namespace_ () == "XMLModule")
      {
        ::std::unique_ptr< field_type > r (
          field_traits::create (i, f, this));

        if (!this->field_)
        {
          this->field_.set (::std::move (r));
          continue;
        }
      }

      // coupling
      //
      if (n.name () == "coupling" && n.namespace_ () == "XMLModule")
      {
        ::std::unique_ptr< coupling_type > r (
          coupling_traits::create (i, f, this));

        if (!this->coupling_)
        {
          this->coupling_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  module* module::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class module (*this, f, c);
  }

  module& module::
  operator= (const module& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->field_ = x.field_;
      this->coupling_ = x.coupling_;
    }

    return *this;
  }

  module::
  ~module ()
  {
  }

  // field
  //

  field::
  field (const general_field_type& general_field,
         const constants_type& constants,
         const spaces_type& spaces,
         const volume_type& volume,
         const surface_type& surface,
         const error_calculator_type& error_calculator,
         const preprocessor_type& preprocessor,
         const postprocessor_type& postprocessor)
  : ::xml_schema::type (),
    general_field_ (general_field, this),
    constants_ (constants, this),
    macros_ (this),
    spaces_ (spaces, this),
    volume_ (volume, this),
    surface_ (surface, this),
    error_calculator_ (error_calculator, this),
    preprocessor_ (preprocessor, this),
    postprocessor_ (postprocessor, this)
  {
  }

  field::
  field (::std::unique_ptr< general_field_type > general_field,
         ::std::unique_ptr< constants_type > constants,
         ::std::unique_ptr< spaces_type > spaces,
         ::std::unique_ptr< volume_type > volume,
         ::std::unique_ptr< surface_type > surface,
         ::std::unique_ptr< error_calculator_type > error_calculator,
         ::std::unique_ptr< preprocessor_type > preprocessor,
         ::std::unique_ptr< postprocessor_type > postprocessor)
  : ::xml_schema::type (),
    general_field_ (std::move (general_field), this),
    constants_ (std::move (constants), this),
    macros_ (this),
    spaces_ (std::move (spaces), this),
    volume_ (std::move (volume), this),
    surface_ (std::move (surface), this),
    error_calculator_ (std::move (error_calculator), this),
    preprocessor_ (std::move (preprocessor), this),
    postprocessor_ (std::move (postprocessor), this)
  {
  }

  field::
  field (const field& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    general_field_ (x.general_field_, f, this),
    constants_ (x.constants_, f, this),
    macros_ (x.macros_, f, this),
    spaces_ (x.spaces_, f, this),
    volume_ (x.volume_, f, this),
    surface_ (x.surface_, f, this),
    error_calculator_ (x.error_calculator_, f, this),
    preprocessor_ (x.preprocessor_, f, this),
    postprocessor_ (x.postprocessor_, f, this)
  {
  }

  field::
  field (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    general_field_ (this),
    constants_ (this),
    macros_ (this),
    spaces_ (this),
    volume_ (this),
    surface_ (this),
    error_calculator_ (this),
    preprocessor_ (this),
    postprocessor_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void field::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // general_field
      //
      if (n.name () == "general_field" && n.namespace_ () == "XMLModule")
      {
        ::std::unique_ptr< general_field_type > r (
          general_field_traits::create (i, f, this));

        if (!general_field_.present ())
        {
          this->general_field_.set (::std::move (r));
          continue;
        }
      }

      // constants
      //
      if (n.name () == "constants" && n.namespace_ () == "XMLModule")
      {
        ::std::unique_ptr< constants_type > r (
          constants_traits::create (i, f, this));

        if (!constants_.present ())
        {
          this->constants_.set (::std::move (r));
          continue;
        }
      }

      // macros
      //
      if (n.name () == "macros" && n.namespace_ () == "XMLModule")
      {
        ::std::unique_ptr< macros_type > r (
          macros_traits::create (i, f, this));

        if (!this->macros_)
        {
          this->macros_.set (::std::move (r));
          continue;
        }
      }

      // spaces
      //
      if (n.name () == "spaces" && n.namespace_ () == "XMLModule")
      {
        ::std::unique_ptr< spaces_type > r (
          spaces_traits::create (i, f, this));

        if (!spaces_.present ())
        {
          this->spaces_.set (::std::move (r));
          continue;
        }
      }

      // volume
      //
      if (n.name () == "volume" && n.namespace_ () == "XMLModule")
      {
        ::std::unique_ptr< volume_type > r (
          volume_traits::create (i, f, this));

        if (!volume_.present ())
        {
          this->volume_.set (::std::move (r));
          continue;
        }
      }

      // surface
      //
      if (n.name () == "surface" && n.namespace_ () == "XMLModule")
      {
        ::std::unique_ptr< surface_type > r (
          surface_traits::create (i, f, this));

        if (!surface_.present ())
        {
          this->surface_.set (::std::move (r));
          continue;
        }
      }

      // error_calculator
      //
      if (n.name () == "error_calculator" && n.namespace_ () == "XMLModule")
      {
        ::std::unique_ptr< error_calculator_type > r (
          error_calculator_traits::create (i, f, this));

        if (!error_calculator_.present ())
        {
          this->error_calculator_.set (::std::move (r));
          continue;
        }
      }

      // preprocessor
      //
      if (n.name () == "preprocessor" && n.namespace_ () == "XMLModule")
      {
        ::std::unique_ptr< preprocessor_type > r (
          preprocessor_traits::create (i, f, this));

        if (!preprocessor_.present ())
        {
          this->preprocessor_.set (::std::move (r));
          continue;
        }
      }

      // postprocessor
      //
      if (n.name () == "postprocessor" && n.namespace_ () == "XMLModule")
      {
        ::std::unique_ptr< postprocessor_type > r (
          postprocessor_traits::create (i, f, this));

        if (!postprocessor_.present ())
        {
          this->postprocessor_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!general_field_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "general_field",
        "XMLModule");
    }

    if (!constants_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "constants",
        "XMLModule");
    }

    if (!spaces_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "spaces",
        "XMLModule");
    }

    if (!volume_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "volume",
        "XMLModule");
    }

    if (!surface_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "surface",
        "XMLModule");
    }

    if (!error_calculator_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "error_calculator",
        "XMLModule");
    }

    if (!preprocessor_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "preprocessor",
        "XMLModule");
    }

    if (!postprocessor_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "postprocessor",
        "XMLModule");
    }
  }

  field* field::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class field (*this, f, c);
  }

  field& field::
  operator= (const field& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->general_field_ = x.general_field_;
      this->constants_ = x.constants_;
      this->macros_ = x.macros_;
      this->spaces_ = x.spaces_;
      this->volume_ = x.volume_;
      this->surface_ = x.surface_;
      this->error_calculator_ = x.error_calculator_;
      this->preprocessor_ = x.preprocessor_;
      this->postprocessor_ = x.postprocessor_;
    }

    return *this;
  }

  field::
  ~field ()
  {
  }

  // general_field
  //

  general_field::
  general_field (const description_type& description,
                 const analyses_type& analyses,
                 const id_type& id,
                 const name_type& name)
  : ::xml_schema::type (),
    description_ (description, this),
    analyses_ (analyses, this),
    deformed_shape_ (this),
    id_ (id, this),
    name_ (name, this)
  {
  }

  general_field::
  general_field (const description_type& description,
                 ::std::unique_ptr< analyses_type > analyses,
                 const id_type& id,
                 const name_type& name)
  : ::xml_schema::type (),
    description_ (description, this),
    analyses_ (std::move (analyses), this),
    deformed_shape_ (this),
    id_ (id, this),
    name_ (name, this)
  {
  }

  general_field::
  general_field (const general_field& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    description_ (x.description_, f, this),
    analyses_ (x.analyses_, f, this),
    deformed_shape_ (x.deformed_shape_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this)
  {
  }

  general_field::
  general_field (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    description_ (this),
    analyses_ (this),
    deformed_shape_ (this),
    id_ (this),
    name_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void general_field::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // description
      //
      if (n.name () == "description" && n.namespace_ () == "XMLModule")
      {
        ::std::unique_ptr< description_type > r (
          description_traits::create (i, f, this));

        if (!description_.present ())
        {
          this->description_.set (::std::move (r));
          continue;
        }
      }

      // analyses
      //
      if (n.name () == "analyses" && n.namespace_ () == "XMLModule")
      {
        ::std::unique_ptr< analyses_type > r (
          analyses_traits::create (i, f, this));

        if (!analyses_.present ())
        {
          this->analyses_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!description_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "description",
        "XMLModule");
    }

    if (!analyses_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "analyses",
        "XMLModule");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "deformed_shape" && n.namespace_ ().empty ())
      {
        this->deformed_shape_.set (deformed_shape_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }
  }

  general_field* general_field::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class general_field (*this, f, c);
  }

  general_field& general_field::
  operator= (const general_field& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->description_ = x.description_;
      this->analyses_ = x.analyses_;
      this->deformed_shape_ = x.deformed_shape_;
      this->id_ = x.id_;
      this->name_ = x.name_;
    }

    return *this;
  }

  general_field::
  ~general_field ()
  {
  }

  // analyses
  //

  analyses::
  analyses ()
  : ::xml_schema::type (),
    analysis_ (this)
  {
  }

  analyses::
  analyses (const analyses& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    analysis_ (x.analysis_, f, this)
  {
  }

  analyses::
  analyses (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    analysis_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void analyses::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // analysis
      //
      if (n.name () == "analysis" && n.namespace_ () == "XMLModule")
      {
        ::std::unique_ptr< analysis_type > r (
          analysis_traits::create (i, f, this));

        this->analysis_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  analyses* analyses::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class analyses (*this, f, c);
  }

  analyses& analyses::
  operator= (const analyses& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->analysis_ = x.analysis_;
    }

    return *this;
  }

  analyses::
  ~analyses ()
  {
  }

  // analysis
  //

  analysis::
  analysis (const id_type& id,
            const name_type& name,
            const solutions_type& solutions,
            const type_type& type)
  : ::xml_schema::type (),
    field_config_ (this),
    id_ (id, this),
    name_ (name, this),
    solutions_ (solutions, this),
    type_ (type, this)
  {
  }

  analysis::
  analysis (const analysis& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    field_config_ (x.field_config_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this),
    solutions_ (x.solutions_, f, this),
    type_ (x.type_, f, this)
  {
  }

  analysis::
  analysis (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    field_config_ (this),
    id_ (this),
    name_ (this),
    solutions_ (this),
    type_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void analysis::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // field_config
      //
      if (n.name () == "field_config" && n.namespace_ () == "XMLModule")
      {
        ::std::unique_ptr< field_config_type > r (
          field_config_traits::create (i, f, this));

        if (!this->field_config_)
        {
          this->field_config_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "solutions" && n.namespace_ ().empty ())
      {
        this->solutions_.set (solutions_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }

    if (!solutions_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "solutions",
        "");
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }
  }

  analysis* analysis::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class analysis (*this, f, c);
  }

  analysis& analysis::
  operator= (const analysis& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->field_config_ = x.field_config_;
      this->id_ = x.id_;
      this->name_ = x.name_;
      this->solutions_ = x.solutions_;
      this->type_ = x.type_;
    }

    return *this;
  }

  analysis::
  ~analysis ()
  {
  }

  // field_config
  //

  field_config::
  field_config ()
  : ::xml_schema::type (),
    field_item_ (this)
  {
  }

  field_config::
  field_config (const field_config& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    field_item_ (x.field_item_, f, this)
  {
  }

  field_config::
  field_config (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    field_item_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void field_config::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // field_item
      //
      if (n.name () == "field_item" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< field_item_type > r (
          field_item_traits::create (i, f, this));

        this->field_item_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  field_config* field_config::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class field_config (*this, f, c);
  }

  field_config& field_config::
  operator= (const field_config& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->field_item_ = x.field_item_;
    }

    return *this;
  }

  field_config::
  ~field_config ()
  {
  }

  // coupling
  //

  coupling::
  coupling (const general_coupling_type& general_coupling,
            const constants_type& constants,
            const volume_type& volume)
  : ::xml_schema::type (),
    general_coupling_ (general_coupling, this),
    constants_ (constants, this),
    volume_ (volume, this)
  {
  }

  coupling::
  coupling (::std::unique_ptr< general_coupling_type > general_coupling,
            ::std::unique_ptr< constants_type > constants,
            ::std::unique_ptr< volume_type > volume)
  : ::xml_schema::type (),
    general_coupling_ (std::move (general_coupling), this),
    constants_ (std::move (constants), this),
    volume_ (std::move (volume), this)
  {
  }

  coupling::
  coupling (const coupling& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    general_coupling_ (x.general_coupling_, f, this),
    constants_ (x.constants_, f, this),
    volume_ (x.volume_, f, this)
  {
  }

  coupling::
  coupling (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    general_coupling_ (this),
    constants_ (this),
    volume_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void coupling::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // general_coupling
      //
      if (n.name () == "general_coupling" && n.namespace_ () == "XMLModule")
      {
        ::std::unique_ptr< general_coupling_type > r (
          general_coupling_traits::create (i, f, this));

        if (!general_coupling_.present ())
        {
          this->general_coupling_.set (::std::move (r));
          continue;
        }
      }

      // constants
      //
      if (n.name () == "constants" && n.namespace_ () == "XMLModule")
      {
        ::std::unique_ptr< constants_type > r (
          constants_traits::create (i, f, this));

        if (!constants_.present ())
        {
          this->constants_.set (::std::move (r));
          continue;
        }
      }

      // volume
      //
      if (n.name () == "volume" && n.namespace_ () == "XMLModule")
      {
        ::std::unique_ptr< volume_type > r (
          volume_traits::create (i, f, this));

        if (!volume_.present ())
        {
          this->volume_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!general_coupling_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "general_coupling",
        "XMLModule");
    }

    if (!constants_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "constants",
        "XMLModule");
    }

    if (!volume_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "volume",
        "XMLModule");
    }
  }

  coupling* coupling::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class coupling (*this, f, c);
  }

  coupling& coupling::
  operator= (const coupling& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->general_coupling_ = x.general_coupling_;
      this->constants_ = x.constants_;
      this->volume_ = x.volume_;
    }

    return *this;
  }

  coupling::
  ~coupling ()
  {
  }

  // general_coupling
  //

  general_coupling::
  general_coupling (const description_type& description,
                    const modules_type& modules,
                    const id_type& id,
                    const name_type& name)
  : ::xml_schema::type (),
    description_ (description, this),
    modules_ (modules, this),
    id_ (id, this),
    name_ (name, this)
  {
  }

  general_coupling::
  general_coupling (const description_type& description,
                    ::std::unique_ptr< modules_type > modules,
                    const id_type& id,
                    const name_type& name)
  : ::xml_schema::type (),
    description_ (description, this),
    modules_ (std::move (modules), this),
    id_ (id, this),
    name_ (name, this)
  {
  }

  general_coupling::
  general_coupling (const general_coupling& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    description_ (x.description_, f, this),
    modules_ (x.modules_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this)
  {
  }

  general_coupling::
  general_coupling (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    description_ (this),
    modules_ (this),
    id_ (this),
    name_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void general_coupling::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // description
      //
      if (n.name () == "description" && n.namespace_ () == "XMLModule")
      {
        ::std::unique_ptr< description_type > r (
          description_traits::create (i, f, this));

        if (!description_.present ())
        {
          this->description_.set (::std::move (r));
          continue;
        }
      }

      // modules
      //
      if (n.name () == "modules" && n.namespace_ () == "XMLModule")
      {
        ::std::unique_ptr< modules_type > r (
          modules_traits::create (i, f, this));

        if (!modules_.present ())
        {
          this->modules_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!description_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "description",
        "XMLModule");
    }

    if (!modules_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "modules",
        "XMLModule");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }
  }

  general_coupling* general_coupling::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class general_coupling (*this, f, c);
  }

  general_coupling& general_coupling::
  operator= (const general_coupling& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->description_ = x.description_;
      this->modules_ = x.modules_;
      this->id_ = x.id_;
      this->name_ = x.name_;
    }

    return *this;
  }

  general_coupling::
  ~general_coupling ()
  {
  }

  // modules
  //

  modules::
  modules (const source_type& source,
           const target_type& target)
  : ::xml_schema::type (),
    source_ (source, this),
    target_ (target, this)
  {
  }

  modules::
  modules (::std::unique_ptr< source_type > source,
           ::std::unique_ptr< target_type > target)
  : ::xml_schema::type (),
    source_ (std::move (source), this),
    target_ (std::move (target), this)
  {
  }

  modules::
  modules (const modules& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    source_ (x.source_, f, this),
    target_ (x.target_, f, this)
  {
  }

  modules::
  modules (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    source_ (this),
    target_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void modules::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // source
      //
      if (n.name () == "source" && n.namespace_ () == "XMLModule")
      {
        ::std::unique_ptr< source_type > r (
          source_traits::create (i, f, this));

        if (!source_.present ())
        {
          this->source_.set (::std::move (r));
          continue;
        }
      }

      // target
      //
      if (n.name () == "target" && n.namespace_ () == "XMLModule")
      {
        ::std::unique_ptr< target_type > r (
          target_traits::create (i, f, this));

        if (!target_.present ())
        {
          this->target_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!source_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "source",
        "XMLModule");
    }

    if (!target_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "target",
        "XMLModule");
    }
  }

  modules* modules::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class modules (*this, f, c);
  }

  modules& modules::
  operator= (const modules& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->source_ = x.source_;
      this->target_ = x.target_;
    }

    return *this;
  }

  modules::
  ~modules ()
  {
  }

  // source
  //

  source::
  source (const id_type& id)
  : ::xml_schema::type (),
    id_ (id, this)
  {
  }

  source::
  source (const source& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    id_ (x.id_, f, this)
  {
  }

  source::
  source (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void source::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  source* source::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class source (*this, f, c);
  }

  source& source::
  operator= (const source& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->id_ = x.id_;
    }

    return *this;
  }

  source::
  ~source ()
  {
  }

  // target
  //

  target::
  target (const id_type& id)
  : ::xml_schema::type (),
    id_ (id, this)
  {
  }

  target::
  target (const target& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    id_ (x.id_, f, this)
  {
  }

  target::
  target (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void target::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  target* target::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class target (*this, f, c);
  }

  target& target::
  operator= (const target& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->id_ = x.id_;
    }

    return *this;
  }

  target::
  ~target ()
  {
  }

  // constants
  //

  constants::
  constants ()
  : ::xml_schema::type (),
    constant_ (this)
  {
  }

  constants::
  constants (const constants& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    constant_ (x.constant_, f, this)
  {
  }

  constants::
  constants (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    constant_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void constants::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // constant
      //
      if (n.name () == "constant" && n.namespace_ () == "XMLModule")
      {
        ::std::unique_ptr< constant_type > r (
          constant_traits::create (i, f, this));

        this->constant_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  constants* constants::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class constants (*this, f, c);
  }

  constants& constants::
  operator= (const constants& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->constant_ = x.constant_;
    }

    return *this;
  }

  constants::
  ~constants ()
  {
  }

  // constant
  //

  constant::
  constant (const id_type& id,
            const value_type& value)
  : ::xml_schema::type (),
    id_ (id, this),
    value_ (value, this)
  {
  }

  constant::
  constant (const constant& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    id_ (x.id_, f, this),
    value_ (x.value_, f, this)
  {
  }

  constant::
  constant (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    id_ (this),
    value_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void constant::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        this->value_.set (value_traits::create (i, f, this));
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "value",
        "");
    }
  }

  constant* constant::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class constant (*this, f, c);
  }

  constant& constant::
  operator= (const constant& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->id_ = x.id_;
      this->value_ = x.value_;
    }

    return *this;
  }

  constant::
  ~constant ()
  {
  }

  // macros
  //

  macros::
  macros ()
  : ::xml_schema::type (),
    macro_ (this)
  {
  }

  macros::
  macros (const macros& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    macro_ (x.macro_, f, this)
  {
  }

  macros::
  macros (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    macro_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void macros::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // macro
      //
      if (n.name () == "macro" && n.namespace_ () == "XMLModule")
      {
        ::std::unique_ptr< macro_type > r (
          macro_traits::create (i, f, this));

        this->macro_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  macros* macros::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class macros (*this, f, c);
  }

  macros& macros::
  operator= (const macros& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->macro_ = x.macro_;
    }

    return *this;
  }

  macros::
  ~macros ()
  {
  }

  // macro
  //

  macro::
  macro (const expression_type& expression,
         const id_type& id)
  : ::xml_schema::type (),
    expression_ (expression, this),
    id_ (id, this)
  {
  }

  macro::
  macro (const macro& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    expression_ (x.expression_, f, this),
    id_ (x.id_, f, this)
  {
  }

  macro::
  macro (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    expression_ (this),
    id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void macro::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "expression" && n.namespace_ ().empty ())
      {
        this->expression_.set (expression_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }

    if (!expression_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "expression",
        "");
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  macro* macro::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class macro (*this, f, c);
  }

  macro& macro::
  operator= (const macro& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->expression_ = x.expression_;
      this->id_ = x.id_;
    }

    return *this;
  }

  macro::
  ~macro ()
  {
  }

  // spaces
  //

  spaces::
  spaces ()
  : ::xml_schema::type (),
    space_ (this)
  {
  }

  spaces::
  spaces (const spaces& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    space_ (x.space_, f, this)
  {
  }

  spaces::
  spaces (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    space_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void spaces::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // space
      //
      if (n.name () == "space" && n.namespace_ () == "XMLModule")
      {
        ::std::unique_ptr< space_type > r (
          space_traits::create (i, f, this));

        this->space_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  spaces* spaces::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class spaces (*this, f, c);
  }

  spaces& spaces::
  operator= (const spaces& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->space_ = x.space_;
    }

    return *this;
  }

  spaces::
  ~spaces ()
  {
  }

  // space
  //

  space::
  space (const analysistype_type& analysistype)
  : ::xml_schema::type (),
    space_config_ (this),
    analysistype_ (analysistype, this)
  {
  }

  space::
  space (const space& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    space_config_ (x.space_config_, f, this),
    analysistype_ (x.analysistype_, f, this)
  {
  }

  space::
  space (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    space_config_ (this),
    analysistype_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void space::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // space_config
      //
      if (n.name () == "space_config" && n.namespace_ () == "XMLModule")
      {
        ::std::unique_ptr< space_config_type > r (
          space_config_traits::create (i, f, this));

        this->space_config_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "analysistype" && n.namespace_ ().empty ())
      {
        this->analysistype_.set (analysistype_traits::create (i, f, this));
        continue;
      }
    }

    if (!analysistype_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "analysistype",
        "");
    }
  }

  space* space::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class space (*this, f, c);
  }

  space& space::
  operator= (const space& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->space_config_ = x.space_config_;
      this->analysistype_ = x.analysistype_;
    }

    return *this;
  }

  space::
  ~space ()
  {
  }

  // space_config
  //

  space_config::
  space_config (const i_type& i,
                const type_type& type,
                const orderadjust_type& orderadjust)
  : ::xml_schema::type (),
    i_ (i, this),
    type_ (type, this),
    orderadjust_ (orderadjust, this)
  {
  }

  space_config::
  space_config (const space_config& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    i_ (x.i_, f, this),
    type_ (x.type_, f, this),
    orderadjust_ (x.orderadjust_, f, this)
  {
  }

  space_config::
  space_config (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    i_ (this),
    type_ (this),
    orderadjust_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void space_config::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "i" && n.namespace_ ().empty ())
      {
        this->i_.set (i_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "orderadjust" && n.namespace_ ().empty ())
      {
        this->orderadjust_.set (orderadjust_traits::create (i, f, this));
        continue;
      }
    }

    if (!i_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "i",
        "");
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }

    if (!orderadjust_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "orderadjust",
        "");
    }
  }

  space_config* space_config::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class space_config (*this, f, c);
  }

  space_config& space_config::
  operator= (const space_config& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->i_ = x.i_;
      this->type_ = x.type_;
      this->orderadjust_ = x.orderadjust_;
    }

    return *this;
  }

  space_config::
  ~space_config ()
  {
  }

  // preprocessor
  //

  preprocessor::
  preprocessor ()
  : ::xml_schema::type (),
    gui_ (this)
  {
  }

  preprocessor::
  preprocessor (const preprocessor& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    gui_ (x.gui_, f, this)
  {
  }

  preprocessor::
  preprocessor (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    gui_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void preprocessor::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // gui
      //
      if (n.name () == "gui" && n.namespace_ () == "XMLModule")
      {
        ::std::unique_ptr< gui_type > r (
          gui_traits::create (i, f, this));

        this->gui_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  preprocessor* preprocessor::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class preprocessor (*this, f, c);
  }

  preprocessor& preprocessor::
  operator= (const preprocessor& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->gui_ = x.gui_;
    }

    return *this;
  }

  preprocessor::
  ~preprocessor ()
  {
  }

  // gui
  //

  gui::
  gui (const type_type& type)
  : ::xml_schema::type (),
    group_ (this),
    type_ (type, this)
  {
  }

  gui::
  gui (const gui& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    group_ (x.group_, f, this),
    type_ (x.type_, f, this)
  {
  }

  gui::
  gui (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    group_ (this),
    type_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void gui::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // group
      //
      if (n.name () == "group" && n.namespace_ () == "XMLModule")
      {
        ::std::unique_ptr< group_type > r (
          group_traits::create (i, f, this));

        this->group_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }
  }

  gui* gui::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class gui (*this, f, c);
  }

  gui& gui::
  operator= (const gui& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->group_ = x.group_;
      this->type_ = x.type_;
    }

    return *this;
  }

  gui::
  ~gui ()
  {
  }

  // group
  //

  group::
  group ()
  : ::xml_schema::type (),
    quantity_ (this),
    switch_combo_ (this),
    name_ (this)
  {
  }

  group::
  group (const group& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    quantity_ (x.quantity_, f, this),
    switch_combo_ (x.switch_combo_, f, this),
    name_ (x.name_, f, this)
  {
  }

  group::
  group (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    quantity_ (this),
    switch_combo_ (this),
    name_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void group::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // quantity
      //
      if (n.name () == "quantity" && n.namespace_ () == "XMLModule")
      {
        ::std::unique_ptr< quantity_type > r (
          quantity_traits::create (i, f, this));

        this->quantity_.push_back (::std::move (r));
        continue;
      }

      // switch_combo
      //
      if (n.name () == "switch_combo" && n.namespace_ () == "XMLModule")
      {
        ::std::unique_ptr< switch_combo_type > r (
          switch_combo_traits::create (i, f, this));

        this->switch_combo_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }
    }
  }

  group* group::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class group (*this, f, c);
  }

  group& group::
  operator= (const group& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->quantity_ = x.quantity_;
      this->switch_combo_ = x.switch_combo_;
      this->name_ = x.name_;
    }

    return *this;
  }

  group::
  ~group ()
  {
  }

  // switch_combo
  //

  switch_combo::
  switch_combo (const switch_option_type& switch_option,
                const id_type& id,
                const name_type& name,
                const implicit_option_type& implicit_option)
  : ::xml_schema::type (),
    switch_option_ (switch_option, this),
    id_ (id, this),
    name_ (name, this),
    implicit_option_ (implicit_option, this)
  {
  }

  switch_combo::
  switch_combo (::std::unique_ptr< switch_option_type > switch_option,
                const id_type& id,
                const name_type& name,
                const implicit_option_type& implicit_option)
  : ::xml_schema::type (),
    switch_option_ (std::move (switch_option), this),
    id_ (id, this),
    name_ (name, this),
    implicit_option_ (implicit_option, this)
  {
  }

  switch_combo::
  switch_combo (const switch_combo& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    switch_option_ (x.switch_option_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this),
    implicit_option_ (x.implicit_option_, f, this)
  {
  }

  switch_combo::
  switch_combo (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    switch_option_ (this),
    id_ (this),
    name_ (this),
    implicit_option_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void switch_combo::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // switch_option
      //
      if (n.name () == "switch_option" && n.namespace_ () == "XMLModule")
      {
        ::std::unique_ptr< switch_option_type > r (
          switch_option_traits::create (i, f, this));

        if (!switch_option_.present ())
        {
          this->switch_option_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!switch_option_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "switch_option",
        "XMLModule");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "implicit_option" && n.namespace_ ().empty ())
      {
        this->implicit_option_.set (implicit_option_traits::create (i, f, this));
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }

    if (!implicit_option_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "implicit_option",
        "");
    }
  }

  switch_combo* switch_combo::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class switch_combo (*this, f, c);
  }

  switch_combo& switch_combo::
  operator= (const switch_combo& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->switch_option_ = x.switch_option_;
      this->id_ = x.id_;
      this->name_ = x.name_;
      this->implicit_option_ = x.implicit_option_;
    }

    return *this;
  }

  switch_combo::
  ~switch_combo ()
  {
  }

  // switch_option
  //

  switch_option::
  switch_option (const id_type& id,
                 const name_type& name)
  : ::xml_schema::type (),
    id_ (id, this),
    name_ (name, this)
  {
  }

  switch_option::
  switch_option (const switch_option& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this)
  {
  }

  switch_option::
  switch_option (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    id_ (this),
    name_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void switch_option::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }
  }

  switch_option* switch_option::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class switch_option (*this, f, c);
  }

  switch_option& switch_option::
  operator= (const switch_option& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->id_ = x.id_;
      this->name_ = x.name_;
    }

    return *this;
  }

  switch_option::
  ~switch_option ()
  {
  }

  // postprocessor
  //

  postprocessor::
  postprocessor (const localvariables_type& localvariables,
                 const view_type& view,
                 const volumeintegrals_type& volumeintegrals,
                 const surfaceintegrals_type& surfaceintegrals,
                 const force_type& force)
  : ::xml_schema::type (),
    localvariables_ (localvariables, this),
    view_ (view, this),
    volumeintegrals_ (volumeintegrals, this),
    surfaceintegrals_ (surfaceintegrals, this),
    force_ (force, this)
  {
  }

  postprocessor::
  postprocessor (::std::unique_ptr< localvariables_type > localvariables,
                 ::std::unique_ptr< view_type > view,
                 ::std::unique_ptr< volumeintegrals_type > volumeintegrals,
                 ::std::unique_ptr< surfaceintegrals_type > surfaceintegrals,
                 ::std::unique_ptr< force_type > force)
  : ::xml_schema::type (),
    localvariables_ (std::move (localvariables), this),
    view_ (std::move (view), this),
    volumeintegrals_ (std::move (volumeintegrals), this),
    surfaceintegrals_ (std::move (surfaceintegrals), this),
    force_ (std::move (force), this)
  {
  }

  postprocessor::
  postprocessor (const postprocessor& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    localvariables_ (x.localvariables_, f, this),
    view_ (x.view_, f, this),
    volumeintegrals_ (x.volumeintegrals_, f, this),
    surfaceintegrals_ (x.surfaceintegrals_, f, this),
    force_ (x.force_, f, this)
  {
  }

  postprocessor::
  postprocessor (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    localvariables_ (this),
    view_ (this),
    volumeintegrals_ (this),
    surfaceintegrals_ (this),
    force_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void postprocessor::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // localvariables
      //
      if (n.name () == "localvariables" && n.namespace_ () == "XMLModule")
      {
        ::std::unique_ptr< localvariables_type > r (
          localvariables_traits::create (i, f, this));

        if (!localvariables_.present ())
        {
          this->localvariables_.set (::std::move (r));
          continue;
        }
      }

      // view
      //
      if (n.name () == "view" && n.namespace_ () == "XMLModule")
      {
        ::std::unique_ptr< view_type > r (
          view_traits::create (i, f, this));

        if (!view_.present ())
        {
          this->view_.set (::std::move (r));
          continue;
        }
      }

      // volumeintegrals
      //
      if (n.name () == "volumeintegrals" && n.namespace_ () == "XMLModule")
      {
        ::std::unique_ptr< volumeintegrals_type > r (
          volumeintegrals_traits::create (i, f, this));

        if (!volumeintegrals_.present ())
        {
          this->volumeintegrals_.set (::std::move (r));
          continue;
        }
      }

      // surfaceintegrals
      //
      if (n.name () == "surfaceintegrals" && n.namespace_ () == "XMLModule")
      {
        ::std::unique_ptr< surfaceintegrals_type > r (
          surfaceintegrals_traits::create (i, f, this));

        if (!surfaceintegrals_.present ())
        {
          this->surfaceintegrals_.set (::std::move (r));
          continue;
        }
      }

      // force
      //
      if (n.name () == "force" && n.namespace_ () == "XMLModule")
      {
        ::std::unique_ptr< force_type > r (
          force_traits::create (i, f, this));

        if (!force_.present ())
        {
          this->force_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!localvariables_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "localvariables",
        "XMLModule");
    }

    if (!view_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "view",
        "XMLModule");
    }

    if (!volumeintegrals_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "volumeintegrals",
        "XMLModule");
    }

    if (!surfaceintegrals_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "surfaceintegrals",
        "XMLModule");
    }

    if (!force_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "force",
        "XMLModule");
    }
  }

  postprocessor* postprocessor::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class postprocessor (*this, f, c);
  }

  postprocessor& postprocessor::
  operator= (const postprocessor& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->localvariables_ = x.localvariables_;
      this->view_ = x.view_;
      this->volumeintegrals_ = x.volumeintegrals_;
      this->surfaceintegrals_ = x.surfaceintegrals_;
      this->force_ = x.force_;
    }

    return *this;
  }

  postprocessor::
  ~postprocessor ()
  {
  }

  // localvariables
  //

  localvariables::
  localvariables ()
  : ::xml_schema::type (),
    localvariable_ (this)
  {
  }

  localvariables::
  localvariables (const localvariables& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    localvariable_ (x.localvariable_, f, this)
  {
  }

  localvariables::
  localvariables (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    localvariable_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void localvariables::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // localvariable
      //
      if (n.name () == "localvariable" && n.namespace_ () == "XMLModule")
      {
        ::std::unique_ptr< localvariable_type > r (
          localvariable_traits::create (i, f, this));

        this->localvariable_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  localvariables* localvariables::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class localvariables (*this, f, c);
  }

  localvariables& localvariables::
  operator= (const localvariables& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->localvariable_ = x.localvariable_;
    }

    return *this;
  }

  localvariables::
  ~localvariables ()
  {
  }

  // localvariable
  //

  localvariable::
  localvariable (const id_type& id,
                 const name_type& name,
                 const shortname_type& shortname,
                 const type_type& type,
                 const unit_type& unit)
  : ::xml_schema::type (),
    expression_ (this),
    format_ (this),
    id_ (id, this),
    name_ (name, this),
    shortname_ (shortname, this),
    shortname_html_ (this),
    shortname_latex_ (this),
    type_ (type, this),
    unit_ (unit, this),
    unit_html_ (this),
    unit_latex_ (this)
  {
  }

  localvariable::
  localvariable (const localvariable& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    expression_ (x.expression_, f, this),
    format_ (x.format_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this),
    shortname_ (x.shortname_, f, this),
    shortname_html_ (x.shortname_html_, f, this),
    shortname_latex_ (x.shortname_latex_, f, this),
    type_ (x.type_, f, this),
    unit_ (x.unit_, f, this),
    unit_html_ (x.unit_html_, f, this),
    unit_latex_ (x.unit_latex_, f, this)
  {
  }

  localvariable::
  localvariable (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    expression_ (this),
    format_ (this),
    id_ (this),
    name_ (this),
    shortname_ (this),
    shortname_html_ (this),
    shortname_latex_ (this),
    type_ (this),
    unit_ (this),
    unit_html_ (this),
    unit_latex_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void localvariable::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // expression
      //
      if (n.name () == "expression" && n.namespace_ () == "XMLModule")
      {
        ::std::unique_ptr< expression_type > r (
          expression_traits::create (i, f, this));

        this->expression_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "format" && n.namespace_ ().empty ())
      {
        this->format_.set (format_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "shortname" && n.namespace_ ().empty ())
      {
        this->shortname_.set (shortname_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "shortname_html" && n.namespace_ ().empty ())
      {
        this->shortname_html_.set (shortname_html_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "shortname_latex" && n.namespace_ ().empty ())
      {
        this->shortname_latex_.set (shortname_latex_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "unit" && n.namespace_ ().empty ())
      {
        this->unit_.set (unit_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "unit_html" && n.namespace_ ().empty ())
      {
        this->unit_html_.set (unit_html_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "unit_latex" && n.namespace_ ().empty ())
      {
        this->unit_latex_.set (unit_latex_traits::create (i, f, this));
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }

    if (!shortname_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "shortname",
        "");
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }

    if (!unit_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "unit",
        "");
    }
  }

  localvariable* localvariable::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class localvariable (*this, f, c);
  }

  localvariable& localvariable::
  operator= (const localvariable& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->expression_ = x.expression_;
      this->format_ = x.format_;
      this->id_ = x.id_;
      this->name_ = x.name_;
      this->shortname_ = x.shortname_;
      this->shortname_html_ = x.shortname_html_;
      this->shortname_latex_ = x.shortname_latex_;
      this->type_ = x.type_;
      this->unit_ = x.unit_;
      this->unit_html_ = x.unit_html_;
      this->unit_latex_ = x.unit_latex_;
    }

    return *this;
  }

  localvariable::
  ~localvariable ()
  {
  }

  // view
  //

  view::
  view (const scalar_view_type& scalar_view,
        const vector_view_type& vector_view)
  : ::xml_schema::type (),
    scalar_view_ (scalar_view, this),
    vector_view_ (vector_view, this)
  {
  }

  view::
  view (::std::unique_ptr< scalar_view_type > scalar_view,
        ::std::unique_ptr< vector_view_type > vector_view)
  : ::xml_schema::type (),
    scalar_view_ (std::move (scalar_view), this),
    vector_view_ (std::move (vector_view), this)
  {
  }

  view::
  view (const view& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    scalar_view_ (x.scalar_view_, f, this),
    vector_view_ (x.vector_view_, f, this)
  {
  }

  view::
  view (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    scalar_view_ (this),
    vector_view_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void view::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // scalar_view
      //
      if (n.name () == "scalar_view" && n.namespace_ () == "XMLModule")
      {
        ::std::unique_ptr< scalar_view_type > r (
          scalar_view_traits::create (i, f, this));

        if (!scalar_view_.present ())
        {
          this->scalar_view_.set (::std::move (r));
          continue;
        }
      }

      // vector_view
      //
      if (n.name () == "vector_view" && n.namespace_ () == "XMLModule")
      {
        ::std::unique_ptr< vector_view_type > r (
          vector_view_traits::create (i, f, this));

        if (!vector_view_.present ())
        {
          this->vector_view_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!scalar_view_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "scalar_view",
        "XMLModule");
    }

    if (!vector_view_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "vector_view",
        "XMLModule");
    }
  }

  view* view::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class view (*this, f, c);
  }

  view& view::
  operator= (const view& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->scalar_view_ = x.scalar_view_;
      this->vector_view_ = x.vector_view_;
    }

    return *this;
  }

  view::
  ~view ()
  {
  }

  // scalar_view
  //

  scalar_view::
  scalar_view ()
  : ::xml_schema::type (),
    default__ (this)
  {
  }

  scalar_view::
  scalar_view (const scalar_view& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    default__ (x.default__, f, this)
  {
  }

  scalar_view::
  scalar_view (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    default__ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void scalar_view::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // default
      //
      if (n.name () == "default" && n.namespace_ () == "XMLModule")
      {
        ::std::unique_ptr< default_type > r (
          default_traits::create (i, f, this));

        this->default__.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  scalar_view* scalar_view::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class scalar_view (*this, f, c);
  }

  scalar_view& scalar_view::
  operator= (const scalar_view& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->default__ = x.default__;
    }

    return *this;
  }

  scalar_view::
  ~scalar_view ()
  {
  }

  // vector_view
  //

  vector_view::
  vector_view ()
  : ::xml_schema::type (),
    default__ (this)
  {
  }

  vector_view::
  vector_view (const vector_view& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    default__ (x.default__, f, this)
  {
  }

  vector_view::
  vector_view (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    default__ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void vector_view::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // default
      //
      if (n.name () == "default" && n.namespace_ () == "XMLModule")
      {
        ::std::unique_ptr< default_type > r (
          default_traits::create (i, f, this));

        this->default__.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  vector_view* vector_view::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class vector_view (*this, f, c);
  }

  vector_view& vector_view::
  operator= (const vector_view& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->default__ = x.default__;
    }

    return *this;
  }

  vector_view::
  ~vector_view ()
  {
  }

  // default_
  //

  default_::
  default_ (const analysistype_type& analysistype,
            const id_type& id)
  : ::xml_schema::type (),
    analysistype_ (analysistype, this),
    id_ (id, this)
  {
  }

  default_::
  default_ (const default_& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    analysistype_ (x.analysistype_, f, this),
    id_ (x.id_, f, this)
  {
  }

  default_::
  default_ (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    analysistype_ (this),
    id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void default_::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "analysistype" && n.namespace_ ().empty ())
      {
        this->analysistype_.set (analysistype_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }

    if (!analysistype_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "analysistype",
        "");
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  default_* default_::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class default_ (*this, f, c);
  }

  default_& default_::
  operator= (const default_& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->analysistype_ = x.analysistype_;
      this->id_ = x.id_;
    }

    return *this;
  }

  default_::
  ~default_ ()
  {
  }

  // volumeintegrals
  //

  volumeintegrals::
  volumeintegrals ()
  : ::xml_schema::type (),
    volumeintegral_ (this)
  {
  }

  volumeintegrals::
  volumeintegrals (const volumeintegrals& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    volumeintegral_ (x.volumeintegral_, f, this)
  {
  }

  volumeintegrals::
  volumeintegrals (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    volumeintegral_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void volumeintegrals::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // volumeintegral
      //
      if (n.name () == "volumeintegral" && n.namespace_ () == "XMLModule")
      {
        ::std::unique_ptr< volumeintegral_type > r (
          volumeintegral_traits::create (i, f, this));

        this->volumeintegral_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  volumeintegrals* volumeintegrals::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class volumeintegrals (*this, f, c);
  }

  volumeintegrals& volumeintegrals::
  operator= (const volumeintegrals& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->volumeintegral_ = x.volumeintegral_;
    }

    return *this;
  }

  volumeintegrals::
  ~volumeintegrals ()
  {
  }

  // volumeintegral
  //

  volumeintegral::
  volumeintegral (const id_type& id,
                  const name_type& name,
                  const shortname_type& shortname,
                  const unit_type& unit)
  : ::xml_schema::type (),
    expression_ (this),
    id_ (id, this),
    name_ (name, this),
    shortname_ (shortname, this),
    shortname_html_ (this),
    shortname_latex_ (this),
    unit_ (unit, this),
    unit_html_ (this),
    unit_latex_ (this),
    eggshell_ (this)
  {
  }

  volumeintegral::
  volumeintegral (const volumeintegral& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    expression_ (x.expression_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this),
    shortname_ (x.shortname_, f, this),
    shortname_html_ (x.shortname_html_, f, this),
    shortname_latex_ (x.shortname_latex_, f, this),
    unit_ (x.unit_, f, this),
    unit_html_ (x.unit_html_, f, this),
    unit_latex_ (x.unit_latex_, f, this),
    eggshell_ (x.eggshell_, f, this)
  {
  }

  volumeintegral::
  volumeintegral (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    expression_ (this),
    id_ (this),
    name_ (this),
    shortname_ (this),
    shortname_html_ (this),
    shortname_latex_ (this),
    unit_ (this),
    unit_html_ (this),
    unit_latex_ (this),
    eggshell_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void volumeintegral::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // expression
      //
      if (n.name () == "expression" && n.namespace_ () == "XMLModule")
      {
        ::std::unique_ptr< expression_type > r (
          expression_traits::create (i, f, this));

        this->expression_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "shortname" && n.namespace_ ().empty ())
      {
        this->shortname_.set (shortname_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "shortname_html" && n.namespace_ ().empty ())
      {
        this->shortname_html_.set (shortname_html_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "shortname_latex" && n.namespace_ ().empty ())
      {
        this->shortname_latex_.set (shortname_latex_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "unit" && n.namespace_ ().empty ())
      {
        this->unit_.set (unit_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "unit_html" && n.namespace_ ().empty ())
      {
        this->unit_html_.set (unit_html_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "unit_latex" && n.namespace_ ().empty ())
      {
        this->unit_latex_.set (unit_latex_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "eggshell" && n.namespace_ ().empty ())
      {
        this->eggshell_.set (eggshell_traits::create (i, f, this));
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }

    if (!shortname_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "shortname",
        "");
    }

    if (!unit_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "unit",
        "");
    }
  }

  volumeintegral* volumeintegral::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class volumeintegral (*this, f, c);
  }

  volumeintegral& volumeintegral::
  operator= (const volumeintegral& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->expression_ = x.expression_;
      this->id_ = x.id_;
      this->name_ = x.name_;
      this->shortname_ = x.shortname_;
      this->shortname_html_ = x.shortname_html_;
      this->shortname_latex_ = x.shortname_latex_;
      this->unit_ = x.unit_;
      this->unit_html_ = x.unit_html_;
      this->unit_latex_ = x.unit_latex_;
      this->eggshell_ = x.eggshell_;
    }

    return *this;
  }

  volumeintegral::
  ~volumeintegral ()
  {
  }

  // surfaceintegrals
  //

  surfaceintegrals::
  surfaceintegrals ()
  : ::xml_schema::type (),
    surfaceintegral_ (this)
  {
  }

  surfaceintegrals::
  surfaceintegrals (const surfaceintegrals& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    surfaceintegral_ (x.surfaceintegral_, f, this)
  {
  }

  surfaceintegrals::
  surfaceintegrals (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    surfaceintegral_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void surfaceintegrals::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // surfaceintegral
      //
      if (n.name () == "surfaceintegral" && n.namespace_ () == "XMLModule")
      {
        ::std::unique_ptr< surfaceintegral_type > r (
          surfaceintegral_traits::create (i, f, this));

        this->surfaceintegral_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  surfaceintegrals* surfaceintegrals::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class surfaceintegrals (*this, f, c);
  }

  surfaceintegrals& surfaceintegrals::
  operator= (const surfaceintegrals& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->surfaceintegral_ = x.surfaceintegral_;
    }

    return *this;
  }

  surfaceintegrals::
  ~surfaceintegrals ()
  {
  }

  // surfaceintegral
  //

  surfaceintegral::
  surfaceintegral (const id_type& id,
                   const name_type& name,
                   const shortname_type& shortname,
                   const unit_type& unit)
  : ::xml_schema::type (),
    expression_ (this),
    id_ (id, this),
    name_ (name, this),
    shortname_ (shortname, this),
    shortname_html_ (this),
    shortname_latex_ (this),
    unit_ (unit, this),
    unit_html_ (this),
    unit_latex_ (this)
  {
  }

  surfaceintegral::
  surfaceintegral (const surfaceintegral& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    expression_ (x.expression_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this),
    shortname_ (x.shortname_, f, this),
    shortname_html_ (x.shortname_html_, f, this),
    shortname_latex_ (x.shortname_latex_, f, this),
    unit_ (x.unit_, f, this),
    unit_html_ (x.unit_html_, f, this),
    unit_latex_ (x.unit_latex_, f, this)
  {
  }

  surfaceintegral::
  surfaceintegral (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    expression_ (this),
    id_ (this),
    name_ (this),
    shortname_ (this),
    shortname_html_ (this),
    shortname_latex_ (this),
    unit_ (this),
    unit_html_ (this),
    unit_latex_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void surfaceintegral::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // expression
      //
      if (n.name () == "expression" && n.namespace_ () == "XMLModule")
      {
        ::std::unique_ptr< expression_type > r (
          expression_traits::create (i, f, this));

        this->expression_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "shortname" && n.namespace_ ().empty ())
      {
        this->shortname_.set (shortname_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "shortname_html" && n.namespace_ ().empty ())
      {
        this->shortname_html_.set (shortname_html_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "shortname_latex" && n.namespace_ ().empty ())
      {
        this->shortname_latex_.set (shortname_latex_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "unit" && n.namespace_ ().empty ())
      {
        this->unit_.set (unit_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "unit_html" && n.namespace_ ().empty ())
      {
        this->unit_html_.set (unit_html_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "unit_latex" && n.namespace_ ().empty ())
      {
        this->unit_latex_.set (unit_latex_traits::create (i, f, this));
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }

    if (!shortname_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "shortname",
        "");
    }

    if (!unit_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "unit",
        "");
    }
  }

  surfaceintegral* surfaceintegral::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class surfaceintegral (*this, f, c);
  }

  surfaceintegral& surfaceintegral::
  operator= (const surfaceintegral& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->expression_ = x.expression_;
      this->id_ = x.id_;
      this->name_ = x.name_;
      this->shortname_ = x.shortname_;
      this->shortname_html_ = x.shortname_html_;
      this->shortname_latex_ = x.shortname_latex_;
      this->unit_ = x.unit_;
      this->unit_html_ = x.unit_html_;
      this->unit_latex_ = x.unit_latex_;
    }

    return *this;
  }

  surfaceintegral::
  ~surfaceintegral ()
  {
  }

  // force
  //

  force::
  force ()
  : ::xml_schema::type (),
    expression_ (this)
  {
  }

  force::
  force (const force& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    expression_ (x.expression_, f, this)
  {
  }

  force::
  force (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    expression_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void force::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // expression
      //
      if (n.name () == "expression" && n.namespace_ () == "XMLModule")
      {
        ::std::unique_ptr< expression_type > r (
          expression_traits::create (i, f, this));

        this->expression_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  force* force::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class force (*this, f, c);
  }

  force& force::
  operator= (const force& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->expression_ = x.expression_;
    }

    return *this;
  }

  force::
  ~force ()
  {
  }

  // volume
  //

  volume::
  volume (const weakforms_volume_type& weakforms_volume)
  : ::xml_schema::type (),
    quantity_ (this),
    function_ (this),
    matrix_form_ (this),
    vector_form_ (this),
    weakforms_volume_ (weakforms_volume, this)
  {
  }

  volume::
  volume (::std::unique_ptr< weakforms_volume_type > weakforms_volume)
  : ::xml_schema::type (),
    quantity_ (this),
    function_ (this),
    matrix_form_ (this),
    vector_form_ (this),
    weakforms_volume_ (std::move (weakforms_volume), this)
  {
  }

  volume::
  volume (const volume& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    quantity_ (x.quantity_, f, this),
    function_ (x.function_, f, this),
    matrix_form_ (x.matrix_form_, f, this),
    vector_form_ (x.vector_form_, f, this),
    weakforms_volume_ (x.weakforms_volume_, f, this)
  {
  }

  volume::
  volume (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    quantity_ (this),
    function_ (this),
    matrix_form_ (this),
    vector_form_ (this),
    weakforms_volume_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void volume::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // quantity
      //
      if (n.name () == "quantity" && n.namespace_ () == "XMLModule")
      {
        ::std::unique_ptr< quantity_type > r (
          quantity_traits::create (i, f, this));

        this->quantity_.push_back (::std::move (r));
        continue;
      }

      // function
      //
      if (n.name () == "function" && n.namespace_ () == "XMLModule")
      {
        ::std::unique_ptr< function_type > r (
          function_traits::create (i, f, this));

        this->function_.push_back (::std::move (r));
        continue;
      }

      // matrix_form
      //
      if (n.name () == "matrix_form" && n.namespace_ () == "XMLModule")
      {
        ::std::unique_ptr< matrix_form_type > r (
          matrix_form_traits::create (i, f, this));

        this->matrix_form_.push_back (::std::move (r));
        continue;
      }

      // vector_form
      //
      if (n.name () == "vector_form" && n.namespace_ () == "XMLModule")
      {
        ::std::unique_ptr< vector_form_type > r (
          vector_form_traits::create (i, f, this));

        this->vector_form_.push_back (::std::move (r));
        continue;
      }

      // weakforms_volume
      //
      if (n.name () == "weakforms_volume" && n.namespace_ () == "XMLModule")
      {
        ::std::unique_ptr< weakforms_volume_type > r (
          weakforms_volume_traits::create (i, f, this));

        if (!weakforms_volume_.present ())
        {
          this->weakforms_volume_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!weakforms_volume_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "weakforms_volume",
        "XMLModule");
    }
  }

  volume* volume::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class volume (*this, f, c);
  }

  volume& volume::
  operator= (const volume& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->quantity_ = x.quantity_;
      this->function_ = x.function_;
      this->matrix_form_ = x.matrix_form_;
      this->vector_form_ = x.vector_form_;
      this->weakforms_volume_ = x.weakforms_volume_;
    }

    return *this;
  }

  volume::
  ~volume ()
  {
  }

  // surface
  //

  surface::
  surface (const weakforms_surface_type& weakforms_surface)
  : ::xml_schema::type (),
    quantity_ (this),
    matrix_form_ (this),
    vector_form_ (this),
    essential_form_ (this),
    weakforms_surface_ (weakforms_surface, this)
  {
  }

  surface::
  surface (::std::unique_ptr< weakforms_surface_type > weakforms_surface)
  : ::xml_schema::type (),
    quantity_ (this),
    matrix_form_ (this),
    vector_form_ (this),
    essential_form_ (this),
    weakforms_surface_ (std::move (weakforms_surface), this)
  {
  }

  surface::
  surface (const surface& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    quantity_ (x.quantity_, f, this),
    matrix_form_ (x.matrix_form_, f, this),
    vector_form_ (x.vector_form_, f, this),
    essential_form_ (x.essential_form_, f, this),
    weakforms_surface_ (x.weakforms_surface_, f, this)
  {
  }

  surface::
  surface (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    quantity_ (this),
    matrix_form_ (this),
    vector_form_ (this),
    essential_form_ (this),
    weakforms_surface_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void surface::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // quantity
      //
      if (n.name () == "quantity" && n.namespace_ () == "XMLModule")
      {
        ::std::unique_ptr< quantity_type > r (
          quantity_traits::create (i, f, this));

        this->quantity_.push_back (::std::move (r));
        continue;
      }

      // matrix_form
      //
      if (n.name () == "matrix_form" && n.namespace_ () == "XMLModule")
      {
        ::std::unique_ptr< matrix_form_type > r (
          matrix_form_traits::create (i, f, this));

        this->matrix_form_.push_back (::std::move (r));
        continue;
      }

      // vector_form
      //
      if (n.name () == "vector_form" && n.namespace_ () == "XMLModule")
      {
        ::std::unique_ptr< vector_form_type > r (
          vector_form_traits::create (i, f, this));

        this->vector_form_.push_back (::std::move (r));
        continue;
      }

      // essential_form
      //
      if (n.name () == "essential_form" && n.namespace_ () == "XMLModule")
      {
        ::std::unique_ptr< essential_form_type > r (
          essential_form_traits::create (i, f, this));

        this->essential_form_.push_back (::std::move (r));
        continue;
      }

      // weakforms_surface
      //
      if (n.name () == "weakforms_surface" && n.namespace_ () == "XMLModule")
      {
        ::std::unique_ptr< weakforms_surface_type > r (
          weakforms_surface_traits::create (i, f, this));

        if (!weakforms_surface_.present ())
        {
          this->weakforms_surface_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!weakforms_surface_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "weakforms_surface",
        "XMLModule");
    }
  }

  surface* surface::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class surface (*this, f, c);
  }

  surface& surface::
  operator= (const surface& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->quantity_ = x.quantity_;
      this->matrix_form_ = x.matrix_form_;
      this->vector_form_ = x.vector_form_;
      this->essential_form_ = x.essential_form_;
      this->weakforms_surface_ = x.weakforms_surface_;
    }

    return *this;
  }

  surface::
  ~surface ()
  {
  }

  // boundary
  //

  boundary::
  boundary (const id_type& id,
            const name_type& name,
            const equation_type& equation)
  : ::xml_schema::type (),
    quantity_ (this),
    linearity_option_ (this),
    id_ (id, this),
    name_ (name, this),
    equation_ (equation, this)
  {
  }

  boundary::
  boundary (const boundary& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    quantity_ (x.quantity_, f, this),
    linearity_option_ (x.linearity_option_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this),
    equation_ (x.equation_, f, this)
  {
  }

  boundary::
  boundary (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    quantity_ (this),
    linearity_option_ (this),
    id_ (this),
    name_ (this),
    equation_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void boundary::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // quantity
      //
      if (n.name () == "quantity" && n.namespace_ () == "XMLModule")
      {
        ::std::unique_ptr< quantity_type > r (
          quantity_traits::create (i, f, this));

        this->quantity_.push_back (::std::move (r));
        continue;
      }

      // linearity_option
      //
      if (n.name () == "linearity_option" && n.namespace_ () == "XMLModule")
      {
        ::std::unique_ptr< linearity_option_type > r (
          linearity_option_traits::create (i, f, this));

        this->linearity_option_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "equation" && n.namespace_ ().empty ())
      {
        this->equation_.set (equation_traits::create (i, f, this));
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }

    if (!equation_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "equation",
        "");
    }
  }

  boundary* boundary::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class boundary (*this, f, c);
  }

  boundary& boundary::
  operator= (const boundary& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->quantity_ = x.quantity_;
      this->linearity_option_ = x.linearity_option_;
      this->id_ = x.id_;
      this->name_ = x.name_;
      this->equation_ = x.equation_;
    }

    return *this;
  }

  boundary::
  ~boundary ()
  {
  }

  // weakforms_surface
  //

  weakforms_surface::
  weakforms_surface ()
  : ::xml_schema::type (),
    group_ (this),
    weakform_surface_ (this)
  {
  }

  weakforms_surface::
  weakforms_surface (const weakforms_surface& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    group_ (x.group_, f, this),
    weakform_surface_ (x.weakform_surface_, f, this)
  {
  }

  weakforms_surface::
  weakforms_surface (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    group_ (this),
    weakform_surface_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void weakforms_surface::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // group
      //
      if (n.name () == "group" && n.namespace_ () == "XMLModule")
      {
        ::std::unique_ptr< group_type > r (
          group_traits::create (i, f, this));

        if (!this->group_)
        {
          this->group_.set (::std::move (r));
          continue;
        }
      }

      // weakform_surface
      //
      if (n.name () == "weakform_surface" && n.namespace_ () == "XMLModule")
      {
        ::std::unique_ptr< weakform_surface_type > r (
          weakform_surface_traits::create (i, f, this));

        this->weakform_surface_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  weakforms_surface* weakforms_surface::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class weakforms_surface (*this, f, c);
  }

  weakforms_surface& weakforms_surface::
  operator= (const weakforms_surface& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->group_ = x.group_;
      this->weakform_surface_ = x.weakform_surface_;
    }

    return *this;
  }

  weakforms_surface::
  ~weakforms_surface ()
  {
  }

  // weakform_surface
  //

  weakform_surface::
  weakform_surface (const analysistype_type& analysistype)
  : ::xml_schema::type (),
    boundary_ (this),
    quantity_ (this),
    function_use_ (this),
    matrix_form_ (this),
    vector_form_ (this),
    analysistype_ (analysistype, this),
    default__ (this)
  {
  }

  weakform_surface::
  weakform_surface (const weakform_surface& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    boundary_ (x.boundary_, f, this),
    quantity_ (x.quantity_, f, this),
    function_use_ (x.function_use_, f, this),
    matrix_form_ (x.matrix_form_, f, this),
    vector_form_ (x.vector_form_, f, this),
    analysistype_ (x.analysistype_, f, this),
    default__ (x.default__, f, this)
  {
  }

  weakform_surface::
  weakform_surface (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    boundary_ (this),
    quantity_ (this),
    function_use_ (this),
    matrix_form_ (this),
    vector_form_ (this),
    analysistype_ (this),
    default__ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void weakform_surface::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // boundary
      //
      if (n.name () == "boundary" && n.namespace_ () == "XMLModule")
      {
        ::std::unique_ptr< boundary_type > r (
          boundary_traits::create (i, f, this));

        this->boundary_.push_back (::std::move (r));
        continue;
      }

      // quantity
      //
      if (n.name () == "quantity" && n.namespace_ () == "XMLModule")
      {
        ::std::unique_ptr< quantity_type > r (
          quantity_traits::create (i, f, this));

        this->quantity_.push_back (::std::move (r));
        continue;
      }

      // function_use
      //
      if (n.name () == "function_use" && n.namespace_ () == "XMLModule")
      {
        ::std::unique_ptr< function_use_type > r (
          function_use_traits::create (i, f, this));

        this->function_use_.push_back (::std::move (r));
        continue;
      }

      // matrix_form
      //
      if (n.name () == "matrix_form" && n.namespace_ () == "XMLModule")
      {
        ::std::unique_ptr< matrix_form_type > r (
          matrix_form_traits::create (i, f, this));

        this->matrix_form_.push_back (::std::move (r));
        continue;
      }

      // vector_form
      //
      if (n.name () == "vector_form" && n.namespace_ () == "XMLModule")
      {
        ::std::unique_ptr< vector_form_type > r (
          vector_form_traits::create (i, f, this));

        this->vector_form_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "analysistype" && n.namespace_ ().empty ())
      {
        this->analysistype_.set (analysistype_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default" && n.namespace_ ().empty ())
      {
        this->default__.set (default_traits::create (i, f, this));
        continue;
      }
    }

    if (!analysistype_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "analysistype",
        "");
    }
  }

  weakform_surface* weakform_surface::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class weakform_surface (*this, f, c);
  }

  weakform_surface& weakform_surface::
  operator= (const weakform_surface& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->boundary_ = x.boundary_;
      this->quantity_ = x.quantity_;
      this->function_use_ = x.function_use_;
      this->matrix_form_ = x.matrix_form_;
      this->vector_form_ = x.vector_form_;
      this->analysistype_ = x.analysistype_;
      this->default__ = x.default__;
    }

    return *this;
  }

  weakform_surface::
  ~weakform_surface ()
  {
  }

  // weakforms_volume
  //

  weakforms_volume::
  weakforms_volume ()
  : ::xml_schema::type (),
    weakform_volume_ (this)
  {
  }

  weakforms_volume::
  weakforms_volume (const weakforms_volume& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    weakform_volume_ (x.weakform_volume_, f, this)
  {
  }

  weakforms_volume::
  weakforms_volume (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    weakform_volume_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void weakforms_volume::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // weakform_volume
      //
      if (n.name () == "weakform_volume" && n.namespace_ () == "XMLModule")
      {
        ::std::unique_ptr< weakform_volume_type > r (
          weakform_volume_traits::create (i, f, this));

        this->weakform_volume_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  weakforms_volume* weakforms_volume::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class weakforms_volume (*this, f, c);
  }

  weakforms_volume& weakforms_volume::
  operator= (const weakforms_volume& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->weakform_volume_ = x.weakform_volume_;
    }

    return *this;
  }

  weakforms_volume::
  ~weakforms_volume ()
  {
  }

  // weakform_volume
  //

  weakform_volume::
  weakform_volume (const analysistype_type& analysistype,
                   const equation_type& equation)
  : ::xml_schema::type (),
    quantity_ (this),
    function_use_ (this),
    linearity_option_ (this),
    analysistype_ (analysistype, this),
    couplingtype_ (this),
    sourceanalysis_ (this),
    equation_ (equation, this)
  {
  }

  weakform_volume::
  weakform_volume (const weakform_volume& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    quantity_ (x.quantity_, f, this),
    function_use_ (x.function_use_, f, this),
    linearity_option_ (x.linearity_option_, f, this),
    analysistype_ (x.analysistype_, f, this),
    couplingtype_ (x.couplingtype_, f, this),
    sourceanalysis_ (x.sourceanalysis_, f, this),
    equation_ (x.equation_, f, this)
  {
  }

  weakform_volume::
  weakform_volume (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    quantity_ (this),
    function_use_ (this),
    linearity_option_ (this),
    analysistype_ (this),
    couplingtype_ (this),
    sourceanalysis_ (this),
    equation_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void weakform_volume::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // quantity
      //
      if (n.name () == "quantity" && n.namespace_ () == "XMLModule")
      {
        ::std::unique_ptr< quantity_type > r (
          quantity_traits::create (i, f, this));

        this->quantity_.push_back (::std::move (r));
        continue;
      }

      // function_use
      //
      if (n.name () == "function_use" && n.namespace_ () == "XMLModule")
      {
        ::std::unique_ptr< function_use_type > r (
          function_use_traits::create (i, f, this));

        this->function_use_.push_back (::std::move (r));
        continue;
      }

      // linearity_option
      //
      if (n.name () == "linearity_option" && n.namespace_ () == "XMLModule")
      {
        ::std::unique_ptr< linearity_option_type > r (
          linearity_option_traits::create (i, f, this));

        this->linearity_option_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "analysistype" && n.namespace_ ().empty ())
      {
        this->analysistype_.set (analysistype_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "couplingtype" && n.namespace_ ().empty ())
      {
        this->couplingtype_.set (couplingtype_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "sourceanalysis" && n.namespace_ ().empty ())
      {
        this->sourceanalysis_.set (sourceanalysis_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "equation" && n.namespace_ ().empty ())
      {
        this->equation_.set (equation_traits::create (i, f, this));
        continue;
      }
    }

    if (!analysistype_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "analysistype",
        "");
    }

    if (!equation_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "equation",
        "");
    }
  }

  weakform_volume* weakform_volume::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class weakform_volume (*this, f, c);
  }

  weakform_volume& weakform_volume::
  operator= (const weakform_volume& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->quantity_ = x.quantity_;
      this->function_use_ = x.function_use_;
      this->linearity_option_ = x.linearity_option_;
      this->analysistype_ = x.analysistype_;
      this->couplingtype_ = x.couplingtype_;
      this->sourceanalysis_ = x.sourceanalysis_;
      this->equation_ = x.equation_;
    }

    return *this;
  }

  weakform_volume::
  ~weakform_volume ()
  {
  }

  // linearity_option
  //

  linearity_option::
  linearity_option (const type_type& type)
  : ::xml_schema::type (),
    matrix_form_ (this),
    vector_form_ (this),
    matrix_transient_form_ (this),
    essential_form_ (this),
    type_ (type, this)
  {
  }

  linearity_option::
  linearity_option (const linearity_option& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    matrix_form_ (x.matrix_form_, f, this),
    vector_form_ (x.vector_form_, f, this),
    matrix_transient_form_ (x.matrix_transient_form_, f, this),
    essential_form_ (x.essential_form_, f, this),
    type_ (x.type_, f, this)
  {
  }

  linearity_option::
  linearity_option (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    matrix_form_ (this),
    vector_form_ (this),
    matrix_transient_form_ (this),
    essential_form_ (this),
    type_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void linearity_option::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // matrix_form
      //
      if (n.name () == "matrix_form" && n.namespace_ () == "XMLModule")
      {
        ::std::unique_ptr< matrix_form_type > r (
          matrix_form_traits::create (i, f, this));

        this->matrix_form_.push_back (::std::move (r));
        continue;
      }

      // vector_form
      //
      if (n.name () == "vector_form" && n.namespace_ () == "XMLModule")
      {
        ::std::unique_ptr< vector_form_type > r (
          vector_form_traits::create (i, f, this));

        this->vector_form_.push_back (::std::move (r));
        continue;
      }

      // matrix_transient_form
      //
      if (n.name () == "matrix_transient_form" && n.namespace_ () == "XMLModule")
      {
        ::std::unique_ptr< matrix_transient_form_type > r (
          matrix_transient_form_traits::create (i, f, this));

        this->matrix_transient_form_.push_back (::std::move (r));
        continue;
      }

      // essential_form
      //
      if (n.name () == "essential_form" && n.namespace_ () == "XMLModule")
      {
        ::std::unique_ptr< essential_form_type > r (
          essential_form_traits::create (i, f, this));

        this->essential_form_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }
  }

  linearity_option* linearity_option::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class linearity_option (*this, f, c);
  }

  linearity_option& linearity_option::
  operator= (const linearity_option& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->matrix_form_ = x.matrix_form_;
      this->vector_form_ = x.vector_form_;
      this->matrix_transient_form_ = x.matrix_transient_form_;
      this->essential_form_ = x.essential_form_;
      this->type_ = x.type_;
    }

    return *this;
  }

  linearity_option::
  ~linearity_option ()
  {
  }

  // matrix_form
  //

  matrix_form::
  matrix_form (const id_type& id)
  : ::xml_schema::type (),
    id_ (id, this),
    i_ (this),
    j_ (this),
    planar_ (this),
    axi_ (this),
    symmetric_ (this),
    symmetric_planar_ (this),
    symmetric_axi_ (this),
    condition_ (this)
  {
  }

  matrix_form::
  matrix_form (const matrix_form& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    id_ (x.id_, f, this),
    i_ (x.i_, f, this),
    j_ (x.j_, f, this),
    planar_ (x.planar_, f, this),
    axi_ (x.axi_, f, this),
    symmetric_ (x.symmetric_, f, this),
    symmetric_planar_ (x.symmetric_planar_, f, this),
    symmetric_axi_ (x.symmetric_axi_, f, this),
    condition_ (x.condition_, f, this)
  {
  }

  matrix_form::
  matrix_form (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    id_ (this),
    i_ (this),
    j_ (this),
    planar_ (this),
    axi_ (this),
    symmetric_ (this),
    symmetric_planar_ (this),
    symmetric_axi_ (this),
    condition_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void matrix_form::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "i" && n.namespace_ ().empty ())
      {
        this->i_.set (i_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "j" && n.namespace_ ().empty ())
      {
        this->j_.set (j_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "planar" && n.namespace_ ().empty ())
      {
        this->planar_.set (planar_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "axi" && n.namespace_ ().empty ())
      {
        this->axi_.set (axi_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "symmetric" && n.namespace_ ().empty ())
      {
        this->symmetric_.set (symmetric_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "symmetric_planar" && n.namespace_ ().empty ())
      {
        this->symmetric_planar_.set (symmetric_planar_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "symmetric_axi" && n.namespace_ ().empty ())
      {
        this->symmetric_axi_.set (symmetric_axi_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "condition" && n.namespace_ ().empty ())
      {
        this->condition_.set (condition_traits::create (i, f, this));
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  matrix_form* matrix_form::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class matrix_form (*this, f, c);
  }

  matrix_form& matrix_form::
  operator= (const matrix_form& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->id_ = x.id_;
      this->i_ = x.i_;
      this->j_ = x.j_;
      this->planar_ = x.planar_;
      this->axi_ = x.axi_;
      this->symmetric_ = x.symmetric_;
      this->symmetric_planar_ = x.symmetric_planar_;
      this->symmetric_axi_ = x.symmetric_axi_;
      this->condition_ = x.condition_;
    }

    return *this;
  }

  matrix_form::
  ~matrix_form ()
  {
  }

  // vector_form
  //

  vector_form::
  vector_form (const id_type& id)
  : ::xml_schema::type (),
    id_ (id, this),
    i_ (this),
    j_ (this),
    planar_ (this),
    axi_ (this),
    variant_ (this),
    coefficient_ (this),
    condition_ (this)
  {
  }

  vector_form::
  vector_form (const vector_form& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    id_ (x.id_, f, this),
    i_ (x.i_, f, this),
    j_ (x.j_, f, this),
    planar_ (x.planar_, f, this),
    axi_ (x.axi_, f, this),
    variant_ (x.variant_, f, this),
    coefficient_ (x.coefficient_, f, this),
    condition_ (x.condition_, f, this)
  {
  }

  vector_form::
  vector_form (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    id_ (this),
    i_ (this),
    j_ (this),
    planar_ (this),
    axi_ (this),
    variant_ (this),
    coefficient_ (this),
    condition_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void vector_form::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "i" && n.namespace_ ().empty ())
      {
        this->i_.set (i_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "j" && n.namespace_ ().empty ())
      {
        this->j_.set (j_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "planar" && n.namespace_ ().empty ())
      {
        this->planar_.set (planar_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "axi" && n.namespace_ ().empty ())
      {
        this->axi_.set (axi_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "variant" && n.namespace_ ().empty ())
      {
        this->variant_.set (variant_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "coefficient" && n.namespace_ ().empty ())
      {
        this->coefficient_.set (coefficient_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "condition" && n.namespace_ ().empty ())
      {
        this->condition_.set (condition_traits::create (i, f, this));
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  vector_form* vector_form::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class vector_form (*this, f, c);
  }

  vector_form& vector_form::
  operator= (const vector_form& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->id_ = x.id_;
      this->i_ = x.i_;
      this->j_ = x.j_;
      this->planar_ = x.planar_;
      this->axi_ = x.axi_;
      this->variant_ = x.variant_;
      this->coefficient_ = x.coefficient_;
      this->condition_ = x.condition_;
    }

    return *this;
  }

  vector_form::
  ~vector_form ()
  {
  }

  // matrix_transient_form
  //

  matrix_transient_form::
  matrix_transient_form (const id_type& id)
  : ::xml_schema::type (),
    id_ (id, this),
    i_ (this),
    j_ (this),
    planar_ (this),
    axi_ (this),
    symmetric_ (this),
    symmetric_planar_ (this),
    symmetric_axi_ (this),
    condition_ (this)
  {
  }

  matrix_transient_form::
  matrix_transient_form (const matrix_transient_form& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    id_ (x.id_, f, this),
    i_ (x.i_, f, this),
    j_ (x.j_, f, this),
    planar_ (x.planar_, f, this),
    axi_ (x.axi_, f, this),
    symmetric_ (x.symmetric_, f, this),
    symmetric_planar_ (x.symmetric_planar_, f, this),
    symmetric_axi_ (x.symmetric_axi_, f, this),
    condition_ (x.condition_, f, this)
  {
  }

  matrix_transient_form::
  matrix_transient_form (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    id_ (this),
    i_ (this),
    j_ (this),
    planar_ (this),
    axi_ (this),
    symmetric_ (this),
    symmetric_planar_ (this),
    symmetric_axi_ (this),
    condition_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void matrix_transient_form::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "i" && n.namespace_ ().empty ())
      {
        this->i_.set (i_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "j" && n.namespace_ ().empty ())
      {
        this->j_.set (j_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "planar" && n.namespace_ ().empty ())
      {
        this->planar_.set (planar_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "axi" && n.namespace_ ().empty ())
      {
        this->axi_.set (axi_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "symmetric" && n.namespace_ ().empty ())
      {
        this->symmetric_.set (symmetric_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "symmetric_planar" && n.namespace_ ().empty ())
      {
        this->symmetric_planar_.set (symmetric_planar_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "symmetric_axi" && n.namespace_ ().empty ())
      {
        this->symmetric_axi_.set (symmetric_axi_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "condition" && n.namespace_ ().empty ())
      {
        this->condition_.set (condition_traits::create (i, f, this));
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  matrix_transient_form* matrix_transient_form::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class matrix_transient_form (*this, f, c);
  }

  matrix_transient_form& matrix_transient_form::
  operator= (const matrix_transient_form& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->id_ = x.id_;
      this->i_ = x.i_;
      this->j_ = x.j_;
      this->planar_ = x.planar_;
      this->axi_ = x.axi_;
      this->symmetric_ = x.symmetric_;
      this->symmetric_planar_ = x.symmetric_planar_;
      this->symmetric_axi_ = x.symmetric_axi_;
      this->condition_ = x.condition_;
    }

    return *this;
  }

  matrix_transient_form::
  ~matrix_transient_form ()
  {
  }

  // essential_form
  //

  essential_form::
  essential_form (const id_type& id)
  : ::xml_schema::type (),
    id_ (id, this),
    i_ (this),
    planar_ (this),
    axi_ (this),
    condition_ (this)
  {
  }

  essential_form::
  essential_form (const essential_form& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    id_ (x.id_, f, this),
    i_ (x.i_, f, this),
    planar_ (x.planar_, f, this),
    axi_ (x.axi_, f, this),
    condition_ (x.condition_, f, this)
  {
  }

  essential_form::
  essential_form (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    id_ (this),
    i_ (this),
    planar_ (this),
    axi_ (this),
    condition_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void essential_form::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "i" && n.namespace_ ().empty ())
      {
        this->i_.set (i_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "planar" && n.namespace_ ().empty ())
      {
        this->planar_.set (planar_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "axi" && n.namespace_ ().empty ())
      {
        this->axi_.set (axi_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "condition" && n.namespace_ ().empty ())
      {
        this->condition_.set (condition_traits::create (i, f, this));
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  essential_form* essential_form::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class essential_form (*this, f, c);
  }

  essential_form& essential_form::
  operator= (const essential_form& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->id_ = x.id_;
      this->i_ = x.i_;
      this->planar_ = x.planar_;
      this->axi_ = x.axi_;
      this->condition_ = x.condition_;
    }

    return *this;
  }

  essential_form::
  ~essential_form ()
  {
  }

  // quantity
  //

  quantity::
  quantity (const id_type& id)
  : ::xml_schema::type (),
    id_ (id, this),
    condition_ (this),
    default__ (this),
    nonlinearity_planar_ (this),
    nonlinearity_axi_ (this),
    dependence_ (this),
    name_ (this),
    shortname_ (this),
    shortname_html_ (this),
    shortname_latex_ (this),
    shortname_dependence_ (this),
    shortname_dependence_html_ (this),
    unit_ (this),
    unit_html_ (this),
    unit_latex_ (this),
    is_source_ (this),
    is_bool_ (this),
    only_if_ (this),
    only_if_not_ (this)
  {
  }

  quantity::
  quantity (const quantity& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    id_ (x.id_, f, this),
    condition_ (x.condition_, f, this),
    default__ (x.default__, f, this),
    nonlinearity_planar_ (x.nonlinearity_planar_, f, this),
    nonlinearity_axi_ (x.nonlinearity_axi_, f, this),
    dependence_ (x.dependence_, f, this),
    name_ (x.name_, f, this),
    shortname_ (x.shortname_, f, this),
    shortname_html_ (x.shortname_html_, f, this),
    shortname_latex_ (x.shortname_latex_, f, this),
    shortname_dependence_ (x.shortname_dependence_, f, this),
    shortname_dependence_html_ (x.shortname_dependence_html_, f, this),
    unit_ (x.unit_, f, this),
    unit_html_ (x.unit_html_, f, this),
    unit_latex_ (x.unit_latex_, f, this),
    is_source_ (x.is_source_, f, this),
    is_bool_ (x.is_bool_, f, this),
    only_if_ (x.only_if_, f, this),
    only_if_not_ (x.only_if_not_, f, this)
  {
  }

  quantity::
  quantity (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    id_ (this),
    condition_ (this),
    default__ (this),
    nonlinearity_planar_ (this),
    nonlinearity_axi_ (this),
    dependence_ (this),
    name_ (this),
    shortname_ (this),
    shortname_html_ (this),
    shortname_latex_ (this),
    shortname_dependence_ (this),
    shortname_dependence_html_ (this),
    unit_ (this),
    unit_html_ (this),
    unit_latex_ (this),
    is_source_ (this),
    is_bool_ (this),
    only_if_ (this),
    only_if_not_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void quantity::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "condition" && n.namespace_ ().empty ())
      {
        this->condition_.set (condition_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default" && n.namespace_ ().empty ())
      {
        this->default__.set (default_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "nonlinearity_planar" && n.namespace_ ().empty ())
      {
        this->nonlinearity_planar_.set (nonlinearity_planar_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "nonlinearity_axi" && n.namespace_ ().empty ())
      {
        this->nonlinearity_axi_.set (nonlinearity_axi_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "dependence" && n.namespace_ ().empty ())
      {
        this->dependence_.set (dependence_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "shortname" && n.namespace_ ().empty ())
      {
        this->shortname_.set (shortname_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "shortname_html" && n.namespace_ ().empty ())
      {
        this->shortname_html_.set (shortname_html_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "shortname_latex" && n.namespace_ ().empty ())
      {
        this->shortname_latex_.set (shortname_latex_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "shortname_dependence" && n.namespace_ ().empty ())
      {
        this->shortname_dependence_.set (shortname_dependence_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "shortname_dependence_html" && n.namespace_ ().empty ())
      {
        this->shortname_dependence_html_.set (shortname_dependence_html_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "unit" && n.namespace_ ().empty ())
      {
        this->unit_.set (unit_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "unit_html" && n.namespace_ ().empty ())
      {
        this->unit_html_.set (unit_html_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "unit_latex" && n.namespace_ ().empty ())
      {
        this->unit_latex_.set (unit_latex_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "is_source" && n.namespace_ ().empty ())
      {
        this->is_source_.set (is_source_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "is_bool" && n.namespace_ ().empty ())
      {
        this->is_bool_.set (is_bool_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "only_if" && n.namespace_ ().empty ())
      {
        this->only_if_.set (only_if_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "only_if_not" && n.namespace_ ().empty ())
      {
        this->only_if_not_.set (only_if_not_traits::create (i, f, this));
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  quantity* quantity::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class quantity (*this, f, c);
  }

  quantity& quantity::
  operator= (const quantity& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->id_ = x.id_;
      this->condition_ = x.condition_;
      this->default__ = x.default__;
      this->nonlinearity_planar_ = x.nonlinearity_planar_;
      this->nonlinearity_axi_ = x.nonlinearity_axi_;
      this->dependence_ = x.dependence_;
      this->name_ = x.name_;
      this->shortname_ = x.shortname_;
      this->shortname_html_ = x.shortname_html_;
      this->shortname_latex_ = x.shortname_latex_;
      this->shortname_dependence_ = x.shortname_dependence_;
      this->shortname_dependence_html_ = x.shortname_dependence_html_;
      this->unit_ = x.unit_;
      this->unit_html_ = x.unit_html_;
      this->unit_latex_ = x.unit_latex_;
      this->is_source_ = x.is_source_;
      this->is_bool_ = x.is_bool_;
      this->only_if_ = x.only_if_;
      this->only_if_not_ = x.only_if_not_;
    }

    return *this;
  }

  quantity::
  ~quantity ()
  {
  }

  // function
  //

  function::
  function (const id_type& id,
            const shortname_type& shortname,
            const type_type& type)
  : ::xml_schema::type (),
    quantity_ (this),
    function_variant_ (this),
    id_ (id, this),
    shortname_ (shortname, this),
    type_ (type, this),
    postprocessor_analysis_ (this),
    postprocessor_linearity_ (this)
  {
  }

  function::
  function (const function& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    quantity_ (x.quantity_, f, this),
    function_variant_ (x.function_variant_, f, this),
    id_ (x.id_, f, this),
    shortname_ (x.shortname_, f, this),
    type_ (x.type_, f, this),
    postprocessor_analysis_ (x.postprocessor_analysis_, f, this),
    postprocessor_linearity_ (x.postprocessor_linearity_, f, this)
  {
  }

  function::
  function (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    quantity_ (this),
    function_variant_ (this),
    id_ (this),
    shortname_ (this),
    type_ (this),
    postprocessor_analysis_ (this),
    postprocessor_linearity_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void function::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // quantity
      //
      if (n.name () == "quantity" && n.namespace_ () == "XMLModule")
      {
        ::std::unique_ptr< quantity_type > r (
          quantity_traits::create (i, f, this));

        this->quantity_.push_back (::std::move (r));
        continue;
      }

      // function_variant
      //
      if (n.name () == "function_variant" && n.namespace_ () == "XMLModule")
      {
        ::std::unique_ptr< function_variant_type > r (
          function_variant_traits::create (i, f, this));

        this->function_variant_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "shortname" && n.namespace_ ().empty ())
      {
        this->shortname_.set (shortname_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "postprocessor_analysis" && n.namespace_ ().empty ())
      {
        this->postprocessor_analysis_.set (postprocessor_analysis_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "postprocessor_linearity" && n.namespace_ ().empty ())
      {
        this->postprocessor_linearity_.set (postprocessor_linearity_traits::create (i, f, this));
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }

    if (!shortname_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "shortname",
        "");
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }
  }

  function* function::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class function (*this, f, c);
  }

  function& function::
  operator= (const function& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->quantity_ = x.quantity_;
      this->function_variant_ = x.function_variant_;
      this->id_ = x.id_;
      this->shortname_ = x.shortname_;
      this->type_ = x.type_;
      this->postprocessor_analysis_ = x.postprocessor_analysis_;
      this->postprocessor_linearity_ = x.postprocessor_linearity_;
    }

    return *this;
  }

  function::
  ~function ()
  {
  }

  // function_variant
  //

  function_variant::
  function_variant (const expr_type& expr)
  : ::xml_schema::type (),
    switch_value_ (this),
    expr_ (expr, this),
    expr_axi_ (this)
  {
  }

  function_variant::
  function_variant (const function_variant& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    switch_value_ (x.switch_value_, f, this),
    expr_ (x.expr_, f, this),
    expr_axi_ (x.expr_axi_, f, this)
  {
  }

  function_variant::
  function_variant (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    switch_value_ (this),
    expr_ (this),
    expr_axi_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void function_variant::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "switch_value" && n.namespace_ ().empty ())
      {
        this->switch_value_.set (switch_value_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "expr" && n.namespace_ ().empty ())
      {
        this->expr_.set (expr_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "expr_axi" && n.namespace_ ().empty ())
      {
        this->expr_axi_.set (expr_axi_traits::create (i, f, this));
        continue;
      }
    }

    if (!expr_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "expr",
        "");
    }
  }

  function_variant* function_variant::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class function_variant (*this, f, c);
  }

  function_variant& function_variant::
  operator= (const function_variant& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->switch_value_ = x.switch_value_;
      this->expr_ = x.expr_;
      this->expr_axi_ = x.expr_axi_;
    }

    return *this;
  }

  function_variant::
  ~function_variant ()
  {
  }

  // function_use
  //

  function_use::
  function_use (const id_type& id)
  : ::xml_schema::type (),
    id_ (id, this)
  {
  }

  function_use::
  function_use (const function_use& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    id_ (x.id_, f, this)
  {
  }

  function_use::
  function_use (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void function_use::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  function_use* function_use::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class function_use (*this, f, c);
  }

  function_use& function_use::
  operator= (const function_use& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->id_ = x.id_;
    }

    return *this;
  }

  function_use::
  ~function_use ()
  {
  }

  // error_calculator
  //

  error_calculator::
  error_calculator ()
  : ::xml_schema::type (),
    calculator_ (this)
  {
  }

  error_calculator::
  error_calculator (const error_calculator& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    calculator_ (x.calculator_, f, this)
  {
  }

  error_calculator::
  error_calculator (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    calculator_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void error_calculator::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // calculator
      //
      if (n.name () == "calculator" && n.namespace_ () == "XMLModule")
      {
        ::std::unique_ptr< calculator_type > r (
          calculator_traits::create (i, f, this));

        this->calculator_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  error_calculator* error_calculator::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class error_calculator (*this, f, c);
  }

  error_calculator& error_calculator::
  operator= (const error_calculator& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->calculator_ = x.calculator_;
    }

    return *this;
  }

  error_calculator::
  ~error_calculator ()
  {
  }

  // calculator
  //

  calculator::
  calculator (const id_type& id,
              const name_type& name)
  : ::xml_schema::type (),
    expression_ (this),
    id_ (id, this),
    name_ (name, this)
  {
  }

  calculator::
  calculator (const calculator& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    expression_ (x.expression_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this)
  {
  }

  calculator::
  calculator (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    expression_ (this),
    id_ (this),
    name_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void calculator::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // expression
      //
      if (n.name () == "expression" && n.namespace_ () == "XMLModule")
      {
        ::std::unique_ptr< expression_type > r (
          expression_traits::create (i, f, this));

        this->expression_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }
  }

  calculator* calculator::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class calculator (*this, f, c);
  }

  calculator& calculator::
  operator= (const calculator& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->expression_ = x.expression_;
      this->id_ = x.id_;
      this->name_ = x.name_;
    }

    return *this;
  }

  calculator::
  ~calculator ()
  {
  }

  // expression
  //

  expression::
  expression (const analysistype_type& analysistype)
  : ::xml_schema::type (),
    analysistype_ (analysistype, this),
    axi_ (this),
    axi_r_ (this),
    axi_z_ (this),
    axi_phi_ (this),
    planar_ (this),
    planar_x_ (this),
    planar_y_ (this),
    planar_z_ (this)
  {
  }

  expression::
  expression (const expression& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    analysistype_ (x.analysistype_, f, this),
    axi_ (x.axi_, f, this),
    axi_r_ (x.axi_r_, f, this),
    axi_z_ (x.axi_z_, f, this),
    axi_phi_ (x.axi_phi_, f, this),
    planar_ (x.planar_, f, this),
    planar_x_ (x.planar_x_, f, this),
    planar_y_ (x.planar_y_, f, this),
    planar_z_ (x.planar_z_, f, this)
  {
  }

  expression::
  expression (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    analysistype_ (this),
    axi_ (this),
    axi_r_ (this),
    axi_z_ (this),
    axi_phi_ (this),
    planar_ (this),
    planar_x_ (this),
    planar_y_ (this),
    planar_z_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void expression::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "analysistype" && n.namespace_ ().empty ())
      {
        this->analysistype_.set (analysistype_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "axi" && n.namespace_ ().empty ())
      {
        this->axi_.set (axi_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "axi_r" && n.namespace_ ().empty ())
      {
        this->axi_r_.set (axi_r_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "axi_z" && n.namespace_ ().empty ())
      {
        this->axi_z_.set (axi_z_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "axi_phi" && n.namespace_ ().empty ())
      {
        this->axi_phi_.set (axi_phi_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "planar" && n.namespace_ ().empty ())
      {
        this->planar_.set (planar_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "planar_x" && n.namespace_ ().empty ())
      {
        this->planar_x_.set (planar_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "planar_y" && n.namespace_ ().empty ())
      {
        this->planar_y_.set (planar_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "planar_z" && n.namespace_ ().empty ())
      {
        this->planar_z_.set (planar_z_traits::create (i, f, this));
        continue;
      }
    }

    if (!analysistype_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "analysistype",
        "");
    }
  }

  expression* expression::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class expression (*this, f, c);
  }

  expression& expression::
  operator= (const expression& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->analysistype_ = x.analysistype_;
      this->axi_ = x.axi_;
      this->axi_r_ = x.axi_r_;
      this->axi_z_ = x.axi_z_;
      this->axi_phi_ = x.axi_phi_;
      this->planar_ = x.planar_;
      this->planar_x_ = x.planar_x_;
      this->planar_y_ = x.planar_y_;
      this->planar_z_ = x.planar_z_;
    }

    return *this;
  }

  expression::
  ~expression ()
  {
  }

  // field_item
  //

  field_item::
  field_item (const field_key_type& field_key,
              const field_value_type& field_value)
  : ::xml_schema::type (),
    field_key_ (field_key, this),
    field_value_ (field_value, this)
  {
  }

  field_item::
  field_item (const field_item& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    field_key_ (x.field_key_, f, this),
    field_value_ (x.field_value_, f, this)
  {
  }

  field_item::
  field_item (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    field_key_ (this),
    field_value_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void field_item::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "field_key" && n.namespace_ ().empty ())
      {
        this->field_key_.set (field_key_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "field_value" && n.namespace_ ().empty ())
      {
        this->field_value_.set (field_value_traits::create (i, f, this));
        continue;
      }
    }

    if (!field_key_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "field_key",
        "");
    }

    if (!field_value_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "field_value",
        "");
    }
  }

  field_item* field_item::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class field_item (*this, f, c);
  }

  field_item& field_item::
  operator= (const field_item& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->field_key_ = x.field_key_;
      this->field_value_ = x.field_value_;
    }

    return *this;
  }

  field_item::
  ~field_item ()
  {
  }
}

#include <ostream>

#include <xsd/cxx/tree/std-ostream-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::std_ostream_plate< 0, char >
  std_ostream_plate_init;
}

namespace XMLModule
{
  ::std::ostream&
  operator<< (::std::ostream& o, const module& i)
  {
    if (i.field ())
    {
      o << ::std::endl << "field: " << *i.field ();
    }

    if (i.coupling ())
    {
      o << ::std::endl << "coupling: " << *i.coupling ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const field& i)
  {
    o << ::std::endl << "general_field: " << i.general_field ();
    o << ::std::endl << "constants: " << i.constants ();
    if (i.macros ())
    {
      o << ::std::endl << "macros: " << *i.macros ();
    }

    o << ::std::endl << "spaces: " << i.spaces ();
    o << ::std::endl << "volume: " << i.volume ();
    o << ::std::endl << "surface: " << i.surface ();
    o << ::std::endl << "error_calculator: " << i.error_calculator ();
    o << ::std::endl << "preprocessor: " << i.preprocessor ();
    o << ::std::endl << "postprocessor: " << i.postprocessor ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const general_field& i)
  {
    o << ::std::endl << "description: " << i.description ();
    o << ::std::endl << "analyses: " << i.analyses ();
    if (i.deformed_shape ())
    {
      o << ::std::endl << "deformed_shape: " << *i.deformed_shape ();
    }

    o << ::std::endl << "id: " << i.id ();
    o << ::std::endl << "name: " << i.name ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const analyses& i)
  {
    for (analyses::analysis_const_iterator
         b (i.analysis ().begin ()), e (i.analysis ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "analysis: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const analysis& i)
  {
    if (i.field_config ())
    {
      o << ::std::endl << "field_config: " << *i.field_config ();
    }

    o << ::std::endl << "id: " << i.id ();
    o << ::std::endl << "name: " << i.name ();
    o << ::std::endl << "solutions: " << i.solutions ();
    o << ::std::endl << "type: " << i.type ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const field_config& i)
  {
    for (field_config::field_item_const_iterator
         b (i.field_item ().begin ()), e (i.field_item ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "field_item: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const coupling& i)
  {
    o << ::std::endl << "general_coupling: " << i.general_coupling ();
    o << ::std::endl << "constants: " << i.constants ();
    o << ::std::endl << "volume: " << i.volume ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const general_coupling& i)
  {
    o << ::std::endl << "description: " << i.description ();
    o << ::std::endl << "modules: " << i.modules ();
    o << ::std::endl << "id: " << i.id ();
    o << ::std::endl << "name: " << i.name ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const modules& i)
  {
    o << ::std::endl << "source: " << i.source ();
    o << ::std::endl << "target: " << i.target ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const source& i)
  {
    o << ::std::endl << "id: " << i.id ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const target& i)
  {
    o << ::std::endl << "id: " << i.id ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const constants& i)
  {
    for (constants::constant_const_iterator
         b (i.constant ().begin ()), e (i.constant ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "constant: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const constant& i)
  {
    o << ::std::endl << "id: " << i.id ();
    o << ::std::endl << "value: " << i.value ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const macros& i)
  {
    for (macros::macro_const_iterator
         b (i.macro ().begin ()), e (i.macro ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "macro: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const macro& i)
  {
    o << ::std::endl << "expression: " << i.expression ();
    o << ::std::endl << "id: " << i.id ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const spaces& i)
  {
    for (spaces::space_const_iterator
         b (i.space ().begin ()), e (i.space ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "space: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const space& i)
  {
    for (space::space_config_const_iterator
         b (i.space_config ().begin ()), e (i.space_config ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "space_config: " << *b;
    }

    o << ::std::endl << "analysistype: " << i.analysistype ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const space_config& i)
  {
    o << ::std::endl << "i: " << i.i ();
    o << ::std::endl << "type: " << i.type ();
    o << ::std::endl << "orderadjust: " << i.orderadjust ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const preprocessor& i)
  {
    for (preprocessor::gui_const_iterator
         b (i.gui ().begin ()), e (i.gui ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "gui: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const gui& i)
  {
    for (gui::group_const_iterator
         b (i.group ().begin ()), e (i.group ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "group: " << *b;
    }

    o << ::std::endl << "type: " << i.type ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const group& i)
  {
    for (group::quantity_const_iterator
         b (i.quantity ().begin ()), e (i.quantity ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "quantity: " << *b;
    }

    for (group::switch_combo_const_iterator
         b (i.switch_combo ().begin ()), e (i.switch_combo ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "switch_combo: " << *b;
    }

    if (i.name ())
    {
      o << ::std::endl << "name: " << *i.name ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const switch_combo& i)
  {
    o << ::std::endl << "switch_option: " << i.switch_option ();
    o << ::std::endl << "id: " << i.id ();
    o << ::std::endl << "name: " << i.name ();
    o << ::std::endl << "implicit_option: " << i.implicit_option ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const switch_option& i)
  {
    o << ::std::endl << "id: " << i.id ();
    o << ::std::endl << "name: " << i.name ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const postprocessor& i)
  {
    o << ::std::endl << "localvariables: " << i.localvariables ();
    o << ::std::endl << "view: " << i.view ();
    o << ::std::endl << "volumeintegrals: " << i.volumeintegrals ();
    o << ::std::endl << "surfaceintegrals: " << i.surfaceintegrals ();
    o << ::std::endl << "force: " << i.force ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const localvariables& i)
  {
    for (localvariables::localvariable_const_iterator
         b (i.localvariable ().begin ()), e (i.localvariable ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "localvariable: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const localvariable& i)
  {
    for (localvariable::expression_const_iterator
         b (i.expression ().begin ()), e (i.expression ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "expression: " << *b;
    }

    if (i.format ())
    {
      o << ::std::endl << "format: " << *i.format ();
    }

    o << ::std::endl << "id: " << i.id ();
    o << ::std::endl << "name: " << i.name ();
    o << ::std::endl << "shortname: " << i.shortname ();
    if (i.shortname_html ())
    {
      o << ::std::endl << "shortname_html: " << *i.shortname_html ();
    }

    if (i.shortname_latex ())
    {
      o << ::std::endl << "shortname_latex: " << *i.shortname_latex ();
    }

    o << ::std::endl << "type: " << i.type ();
    o << ::std::endl << "unit: " << i.unit ();
    if (i.unit_html ())
    {
      o << ::std::endl << "unit_html: " << *i.unit_html ();
    }

    if (i.unit_latex ())
    {
      o << ::std::endl << "unit_latex: " << *i.unit_latex ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const view& i)
  {
    o << ::std::endl << "scalar_view: " << i.scalar_view ();
    o << ::std::endl << "vector_view: " << i.vector_view ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const scalar_view& i)
  {
    for (scalar_view::default_const_iterator
         b (i.default_ ().begin ()), e (i.default_ ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "default: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const vector_view& i)
  {
    for (vector_view::default_const_iterator
         b (i.default_ ().begin ()), e (i.default_ ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "default: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const default_& i)
  {
    o << ::std::endl << "analysistype: " << i.analysistype ();
    o << ::std::endl << "id: " << i.id ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const volumeintegrals& i)
  {
    for (volumeintegrals::volumeintegral_const_iterator
         b (i.volumeintegral ().begin ()), e (i.volumeintegral ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "volumeintegral: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const volumeintegral& i)
  {
    for (volumeintegral::expression_const_iterator
         b (i.expression ().begin ()), e (i.expression ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "expression: " << *b;
    }

    o << ::std::endl << "id: " << i.id ();
    o << ::std::endl << "name: " << i.name ();
    o << ::std::endl << "shortname: " << i.shortname ();
    if (i.shortname_html ())
    {
      o << ::std::endl << "shortname_html: " << *i.shortname_html ();
    }

    if (i.shortname_latex ())
    {
      o << ::std::endl << "shortname_latex: " << *i.shortname_latex ();
    }

    o << ::std::endl << "unit: " << i.unit ();
    if (i.unit_html ())
    {
      o << ::std::endl << "unit_html: " << *i.unit_html ();
    }

    if (i.unit_latex ())
    {
      o << ::std::endl << "unit_latex: " << *i.unit_latex ();
    }

    if (i.eggshell ())
    {
      o << ::std::endl << "eggshell: " << *i.eggshell ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const surfaceintegrals& i)
  {
    for (surfaceintegrals::surfaceintegral_const_iterator
         b (i.surfaceintegral ().begin ()), e (i.surfaceintegral ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "surfaceintegral: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const surfaceintegral& i)
  {
    for (surfaceintegral::expression_const_iterator
         b (i.expression ().begin ()), e (i.expression ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "expression: " << *b;
    }

    o << ::std::endl << "id: " << i.id ();
    o << ::std::endl << "name: " << i.name ();
    o << ::std::endl << "shortname: " << i.shortname ();
    if (i.shortname_html ())
    {
      o << ::std::endl << "shortname_html: " << *i.shortname_html ();
    }

    if (i.shortname_latex ())
    {
      o << ::std::endl << "shortname_latex: " << *i.shortname_latex ();
    }

    o << ::std::endl << "unit: " << i.unit ();
    if (i.unit_html ())
    {
      o << ::std::endl << "unit_html: " << *i.unit_html ();
    }

    if (i.unit_latex ())
    {
      o << ::std::endl << "unit_latex: " << *i.unit_latex ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const force& i)
  {
    for (force::expression_const_iterator
         b (i.expression ().begin ()), e (i.expression ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "expression: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const volume& i)
  {
    for (volume::quantity_const_iterator
         b (i.quantity ().begin ()), e (i.quantity ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "quantity: " << *b;
    }

    for (volume::function_const_iterator
         b (i.function ().begin ()), e (i.function ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "function: " << *b;
    }

    for (volume::matrix_form_const_iterator
         b (i.matrix_form ().begin ()), e (i.matrix_form ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "matrix_form: " << *b;
    }

    for (volume::vector_form_const_iterator
         b (i.vector_form ().begin ()), e (i.vector_form ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "vector_form: " << *b;
    }

    o << ::std::endl << "weakforms_volume: " << i.weakforms_volume ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const surface& i)
  {
    for (surface::quantity_const_iterator
         b (i.quantity ().begin ()), e (i.quantity ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "quantity: " << *b;
    }

    for (surface::matrix_form_const_iterator
         b (i.matrix_form ().begin ()), e (i.matrix_form ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "matrix_form: " << *b;
    }

    for (surface::vector_form_const_iterator
         b (i.vector_form ().begin ()), e (i.vector_form ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "vector_form: " << *b;
    }

    for (surface::essential_form_const_iterator
         b (i.essential_form ().begin ()), e (i.essential_form ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "essential_form: " << *b;
    }

    o << ::std::endl << "weakforms_surface: " << i.weakforms_surface ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const boundary& i)
  {
    for (boundary::quantity_const_iterator
         b (i.quantity ().begin ()), e (i.quantity ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "quantity: " << *b;
    }

    for (boundary::linearity_option_const_iterator
         b (i.linearity_option ().begin ()), e (i.linearity_option ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "linearity_option: " << *b;
    }

    o << ::std::endl << "id: " << i.id ();
    o << ::std::endl << "name: " << i.name ();
    o << ::std::endl << "equation: " << i.equation ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const weakforms_surface& i)
  {
    if (i.group ())
    {
      o << ::std::endl << "group: " << *i.group ();
    }

    for (weakforms_surface::weakform_surface_const_iterator
         b (i.weakform_surface ().begin ()), e (i.weakform_surface ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "weakform_surface: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const weakform_surface& i)
  {
    for (weakform_surface::boundary_const_iterator
         b (i.boundary ().begin ()), e (i.boundary ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "boundary: " << *b;
    }

    for (weakform_surface::quantity_const_iterator
         b (i.quantity ().begin ()), e (i.quantity ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "quantity: " << *b;
    }

    for (weakform_surface::function_use_const_iterator
         b (i.function_use ().begin ()), e (i.function_use ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "function_use: " << *b;
    }

    for (weakform_surface::matrix_form_const_iterator
         b (i.matrix_form ().begin ()), e (i.matrix_form ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "matrix_form: " << *b;
    }

    for (weakform_surface::vector_form_const_iterator
         b (i.vector_form ().begin ()), e (i.vector_form ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "vector_form: " << *b;
    }

    o << ::std::endl << "analysistype: " << i.analysistype ();
    if (i.default_ ())
    {
      o << ::std::endl << "default: " << *i.default_ ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const weakforms_volume& i)
  {
    for (weakforms_volume::weakform_volume_const_iterator
         b (i.weakform_volume ().begin ()), e (i.weakform_volume ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "weakform_volume: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const weakform_volume& i)
  {
    for (weakform_volume::quantity_const_iterator
         b (i.quantity ().begin ()), e (i.quantity ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "quantity: " << *b;
    }

    for (weakform_volume::function_use_const_iterator
         b (i.function_use ().begin ()), e (i.function_use ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "function_use: " << *b;
    }

    for (weakform_volume::linearity_option_const_iterator
         b (i.linearity_option ().begin ()), e (i.linearity_option ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "linearity_option: " << *b;
    }

    o << ::std::endl << "analysistype: " << i.analysistype ();
    if (i.couplingtype ())
    {
      o << ::std::endl << "couplingtype: " << *i.couplingtype ();
    }

    if (i.sourceanalysis ())
    {
      o << ::std::endl << "sourceanalysis: " << *i.sourceanalysis ();
    }

    o << ::std::endl << "equation: " << i.equation ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const linearity_option& i)
  {
    for (linearity_option::matrix_form_const_iterator
         b (i.matrix_form ().begin ()), e (i.matrix_form ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "matrix_form: " << *b;
    }

    for (linearity_option::vector_form_const_iterator
         b (i.vector_form ().begin ()), e (i.vector_form ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "vector_form: " << *b;
    }

    for (linearity_option::matrix_transient_form_const_iterator
         b (i.matrix_transient_form ().begin ()), e (i.matrix_transient_form ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "matrix_transient_form: " << *b;
    }

    for (linearity_option::essential_form_const_iterator
         b (i.essential_form ().begin ()), e (i.essential_form ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "essential_form: " << *b;
    }

    o << ::std::endl << "type: " << i.type ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const matrix_form& i)
  {
    o << ::std::endl << "id: " << i.id ();
    if (i.i ())
    {
      o << ::std::endl << "i: " << *i.i ();
    }

    if (i.j ())
    {
      o << ::std::endl << "j: " << *i.j ();
    }

    if (i.planar ())
    {
      o << ::std::endl << "planar: " << *i.planar ();
    }

    if (i.axi ())
    {
      o << ::std::endl << "axi: " << *i.axi ();
    }

    if (i.symmetric ())
    {
      o << ::std::endl << "symmetric: " << *i.symmetric ();
    }

    if (i.symmetric_planar ())
    {
      o << ::std::endl << "symmetric_planar: " << *i.symmetric_planar ();
    }

    if (i.symmetric_axi ())
    {
      o << ::std::endl << "symmetric_axi: " << *i.symmetric_axi ();
    }

    if (i.condition ())
    {
      o << ::std::endl << "condition: " << *i.condition ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const vector_form& i)
  {
    o << ::std::endl << "id: " << i.id ();
    if (i.i ())
    {
      o << ::std::endl << "i: " << *i.i ();
    }

    if (i.j ())
    {
      o << ::std::endl << "j: " << *i.j ();
    }

    if (i.planar ())
    {
      o << ::std::endl << "planar: " << *i.planar ();
    }

    if (i.axi ())
    {
      o << ::std::endl << "axi: " << *i.axi ();
    }

    if (i.variant ())
    {
      o << ::std::endl << "variant: " << *i.variant ();
    }

    if (i.coefficient ())
    {
      o << ::std::endl << "coefficient: " << *i.coefficient ();
    }

    if (i.condition ())
    {
      o << ::std::endl << "condition: " << *i.condition ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const matrix_transient_form& i)
  {
    o << ::std::endl << "id: " << i.id ();
    if (i.i ())
    {
      o << ::std::endl << "i: " << *i.i ();
    }

    if (i.j ())
    {
      o << ::std::endl << "j: " << *i.j ();
    }

    if (i.planar ())
    {
      o << ::std::endl << "planar: " << *i.planar ();
    }

    if (i.axi ())
    {
      o << ::std::endl << "axi: " << *i.axi ();
    }

    if (i.symmetric ())
    {
      o << ::std::endl << "symmetric: " << *i.symmetric ();
    }

    if (i.symmetric_planar ())
    {
      o << ::std::endl << "symmetric_planar: " << *i.symmetric_planar ();
    }

    if (i.symmetric_axi ())
    {
      o << ::std::endl << "symmetric_axi: " << *i.symmetric_axi ();
    }

    if (i.condition ())
    {
      o << ::std::endl << "condition: " << *i.condition ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const essential_form& i)
  {
    o << ::std::endl << "id: " << i.id ();
    if (i.i ())
    {
      o << ::std::endl << "i: " << *i.i ();
    }

    if (i.planar ())
    {
      o << ::std::endl << "planar: " << *i.planar ();
    }

    if (i.axi ())
    {
      o << ::std::endl << "axi: " << *i.axi ();
    }

    if (i.condition ())
    {
      o << ::std::endl << "condition: " << *i.condition ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const quantity& i)
  {
    o << ::std::endl << "id: " << i.id ();
    if (i.condition ())
    {
      o << ::std::endl << "condition: " << *i.condition ();
    }

    if (i.default_ ())
    {
      o << ::std::endl << "default: " << *i.default_ ();
    }

    if (i.nonlinearity_planar ())
    {
      o << ::std::endl << "nonlinearity_planar: " << *i.nonlinearity_planar ();
    }

    if (i.nonlinearity_axi ())
    {
      o << ::std::endl << "nonlinearity_axi: " << *i.nonlinearity_axi ();
    }

    if (i.dependence ())
    {
      o << ::std::endl << "dependence: " << *i.dependence ();
    }

    if (i.name ())
    {
      o << ::std::endl << "name: " << *i.name ();
    }

    if (i.shortname ())
    {
      o << ::std::endl << "shortname: " << *i.shortname ();
    }

    if (i.shortname_html ())
    {
      o << ::std::endl << "shortname_html: " << *i.shortname_html ();
    }

    if (i.shortname_latex ())
    {
      o << ::std::endl << "shortname_latex: " << *i.shortname_latex ();
    }

    if (i.shortname_dependence ())
    {
      o << ::std::endl << "shortname_dependence: " << *i.shortname_dependence ();
    }

    if (i.shortname_dependence_html ())
    {
      o << ::std::endl << "shortname_dependence_html: " << *i.shortname_dependence_html ();
    }

    if (i.unit ())
    {
      o << ::std::endl << "unit: " << *i.unit ();
    }

    if (i.unit_html ())
    {
      o << ::std::endl << "unit_html: " << *i.unit_html ();
    }

    if (i.unit_latex ())
    {
      o << ::std::endl << "unit_latex: " << *i.unit_latex ();
    }

    if (i.is_source ())
    {
      o << ::std::endl << "is_source: " << *i.is_source ();
    }

    if (i.is_bool ())
    {
      o << ::std::endl << "is_bool: " << *i.is_bool ();
    }

    if (i.only_if ())
    {
      o << ::std::endl << "only_if: " << *i.only_if ();
    }

    if (i.only_if_not ())
    {
      o << ::std::endl << "only_if_not: " << *i.only_if_not ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const function& i)
  {
    for (function::quantity_const_iterator
         b (i.quantity ().begin ()), e (i.quantity ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "quantity: " << *b;
    }

    for (function::function_variant_const_iterator
         b (i.function_variant ().begin ()), e (i.function_variant ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "function_variant: " << *b;
    }

    o << ::std::endl << "id: " << i.id ();
    o << ::std::endl << "shortname: " << i.shortname ();
    o << ::std::endl << "type: " << i.type ();
    if (i.postprocessor_analysis ())
    {
      o << ::std::endl << "postprocessor_analysis: " << *i.postprocessor_analysis ();
    }

    if (i.postprocessor_linearity ())
    {
      o << ::std::endl << "postprocessor_linearity: " << *i.postprocessor_linearity ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const function_variant& i)
  {
    if (i.switch_value ())
    {
      o << ::std::endl << "switch_value: " << *i.switch_value ();
    }

    o << ::std::endl << "expr: " << i.expr ();
    if (i.expr_axi ())
    {
      o << ::std::endl << "expr_axi: " << *i.expr_axi ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const function_use& i)
  {
    o << ::std::endl << "id: " << i.id ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const error_calculator& i)
  {
    for (error_calculator::calculator_const_iterator
         b (i.calculator ().begin ()), e (i.calculator ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "calculator: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const calculator& i)
  {
    for (calculator::expression_const_iterator
         b (i.expression ().begin ()), e (i.expression ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "expression: " << *b;
    }

    o << ::std::endl << "id: " << i.id ();
    o << ::std::endl << "name: " << i.name ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const expression& i)
  {
    o << ::std::endl << "analysistype: " << i.analysistype ();
    if (i.axi ())
    {
      o << ::std::endl << "axi: " << *i.axi ();
    }

    if (i.axi_r ())
    {
      o << ::std::endl << "axi_r: " << *i.axi_r ();
    }

    if (i.axi_z ())
    {
      o << ::std::endl << "axi_z: " << *i.axi_z ();
    }

    if (i.axi_phi ())
    {
      o << ::std::endl << "axi_phi: " << *i.axi_phi ();
    }

    if (i.planar ())
    {
      o << ::std::endl << "planar: " << *i.planar ();
    }

    if (i.planar_x ())
    {
      o << ::std::endl << "planar_x: " << *i.planar_x ();
    }

    if (i.planar_y ())
    {
      o << ::std::endl << "planar_y: " << *i.planar_y ();
    }

    if (i.planar_z ())
    {
      o << ::std::endl << "planar_z: " << *i.planar_z ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const field_item& i)
  {
    o << ::std::endl << "field_key: " << i.field_key ();
    o << ::std::endl << "field_value: " << i.field_value ();
    return o;
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace XMLModule
{
  ::std::unique_ptr< ::XMLModule::module >
  module_ (const ::std::string& u,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::XMLModule::module > (
      ::XMLModule::module_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::XMLModule::module >
  module_ (const ::std::string& u,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::XMLModule::module > (
      ::XMLModule::module_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::XMLModule::module >
  module_ (const ::std::string& u,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::XMLModule::module > (
      ::XMLModule::module_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::XMLModule::module >
  module_ (::std::istream& is,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::XMLModule::module_ (isrc, f, p);
  }

  ::std::unique_ptr< ::XMLModule::module >
  module_ (::std::istream& is,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::XMLModule::module_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::XMLModule::module >
  module_ (::std::istream& is,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::XMLModule::module_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::XMLModule::module >
  module_ (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::XMLModule::module_ (isrc, f, p);
  }

  ::std::unique_ptr< ::XMLModule::module >
  module_ (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::XMLModule::module_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::XMLModule::module >
  module_ (::std::istream& is,
           const ::std::string& sid,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::XMLModule::module_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::XMLModule::module >
  module_ (::xercesc::InputSource& i,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::XMLModule::module > (
      ::XMLModule::module_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::XMLModule::module >
  module_ (::xercesc::InputSource& i,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::XMLModule::module > (
      ::XMLModule::module_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::XMLModule::module >
  module_ (::xercesc::InputSource& i,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::XMLModule::module > (
      ::XMLModule::module_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::XMLModule::module >
  module_ (const ::xercesc::DOMDocument& doc,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::XMLModule::module > (
        ::XMLModule::module_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "module" &&
        n.namespace_ () == "XMLModule")
    {
      ::std::unique_ptr< ::XMLModule::module > r (
        ::xsd::cxx::tree::traits< ::XMLModule::module, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "module",
      "XMLModule");
  }

  ::std::unique_ptr< ::XMLModule::module >
  module_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
           ::xml_schema::flags f,
           const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "module" &&
        n.namespace_ () == "XMLModule")
    {
      ::std::unique_ptr< ::XMLModule::module > r (
        ::xsd::cxx::tree::traits< ::XMLModule::module, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "module",
      "XMLModule");
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, char >
  type_serializer_plate_init;
}

namespace XMLModule
{
  void
  module_ (::std::ostream& o,
           const ::XMLModule::module& s,
           const ::xml_schema::namespace_infomap& m,
           const ::std::string& e,
           ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::XMLModule::module_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  module_ (::std::ostream& o,
           const ::XMLModule::module& s,
           ::xml_schema::error_handler& h,
           const ::xml_schema::namespace_infomap& m,
           const ::std::string& e,
           ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::XMLModule::module_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  module_ (::std::ostream& o,
           const ::XMLModule::module& s,
           ::xercesc::DOMErrorHandler& h,
           const ::xml_schema::namespace_infomap& m,
           const ::std::string& e,
           ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::XMLModule::module_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  module_ (::xercesc::XMLFormatTarget& t,
           const ::XMLModule::module& s,
           const ::xml_schema::namespace_infomap& m,
           const ::std::string& e,
           ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::XMLModule::module_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  module_ (::xercesc::XMLFormatTarget& t,
           const ::XMLModule::module& s,
           ::xml_schema::error_handler& h,
           const ::xml_schema::namespace_infomap& m,
           const ::std::string& e,
           ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::XMLModule::module_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  module_ (::xercesc::XMLFormatTarget& t,
           const ::XMLModule::module& s,
           ::xercesc::DOMErrorHandler& h,
           const ::xml_schema::namespace_infomap& m,
           const ::std::string& e,
           ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::XMLModule::module_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  module_ (::xercesc::DOMDocument& d,
           const ::XMLModule::module& s,
           ::xml_schema::flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "module" &&
        n.namespace_ () == "XMLModule")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "module",
        "XMLModule");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  module_ (const ::XMLModule::module& s,
           const ::xml_schema::namespace_infomap& m,
           ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "module",
        "XMLModule",
        m, f));

    ::XMLModule::module_ (*d, s, f);
    return d;
  }

  void
  operator<< (::xercesc::DOMElement& e, const module& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // field
    //
    if (i.field ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "field",
          "XMLModule",
          e));

      s << *i.field ();
    }

    // coupling
    //
    if (i.coupling ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "coupling",
          "XMLModule",
          e));

      s << *i.coupling ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const field& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // general_field
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "general_field",
          "XMLModule",
          e));

      s << i.general_field ();
    }

    // constants
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "constants",
          "XMLModule",
          e));

      s << i.constants ();
    }

    // macros
    //
    if (i.macros ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "macros",
          "XMLModule",
          e));

      s << *i.macros ();
    }

    // spaces
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "spaces",
          "XMLModule",
          e));

      s << i.spaces ();
    }

    // volume
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "volume",
          "XMLModule",
          e));

      s << i.volume ();
    }

    // surface
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "surface",
          "XMLModule",
          e));

      s << i.surface ();
    }

    // error_calculator
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "error_calculator",
          "XMLModule",
          e));

      s << i.error_calculator ();
    }

    // preprocessor
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "preprocessor",
          "XMLModule",
          e));

      s << i.preprocessor ();
    }

    // postprocessor
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "postprocessor",
          "XMLModule",
          e));

      s << i.postprocessor ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const general_field& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // description
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "description",
          "XMLModule",
          e));

      s << i.description ();
    }

    // analyses
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "analyses",
          "XMLModule",
          e));

      s << i.analyses ();
    }

    // deformed_shape
    //
    if (i.deformed_shape ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "deformed_shape",
          e));

      a << *i.deformed_shape ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.id ();
    }

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << i.name ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const analyses& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // analysis
    //
    for (analyses::analysis_const_iterator
         b (i.analysis ().begin ()), n (i.analysis ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "analysis",
          "XMLModule",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const analysis& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // field_config
    //
    if (i.field_config ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "field_config",
          "XMLModule",
          e));

      s << *i.field_config ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.id ();
    }

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << i.name ();
    }

    // solutions
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "solutions",
          e));

      a << i.solutions ();
    }

    // type
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "type",
          e));

      a << i.type ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const field_config& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // field_item
    //
    for (field_config::field_item_const_iterator
         b (i.field_item ().begin ()), n (i.field_item ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "field_item",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const coupling& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // general_coupling
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "general_coupling",
          "XMLModule",
          e));

      s << i.general_coupling ();
    }

    // constants
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "constants",
          "XMLModule",
          e));

      s << i.constants ();
    }

    // volume
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "volume",
          "XMLModule",
          e));

      s << i.volume ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const general_coupling& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // description
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "description",
          "XMLModule",
          e));

      s << i.description ();
    }

    // modules
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "modules",
          "XMLModule",
          e));

      s << i.modules ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.id ();
    }

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << i.name ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const modules& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // source
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "source",
          "XMLModule",
          e));

      s << i.source ();
    }

    // target
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "target",
          "XMLModule",
          e));

      s << i.target ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const source& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.id ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const target& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.id ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const constants& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // constant
    //
    for (constants::constant_const_iterator
         b (i.constant ().begin ()), n (i.constant ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "constant",
          "XMLModule",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const constant& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.id ();
    }

    // value
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "value",
          e));

      a << ::xml_schema::as_double(i.value ());
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const macros& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // macro
    //
    for (macros::macro_const_iterator
         b (i.macro ().begin ()), n (i.macro ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "macro",
          "XMLModule",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const macro& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // expression
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "expression",
          e));

      a << i.expression ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.id ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const spaces& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // space
    //
    for (spaces::space_const_iterator
         b (i.space ().begin ()), n (i.space ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "space",
          "XMLModule",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const space& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // space_config
    //
    for (space::space_config_const_iterator
         b (i.space_config ().begin ()), n (i.space_config ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "space_config",
          "XMLModule",
          e));

      s << *b;
    }

    // analysistype
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "analysistype",
          e));

      a << i.analysistype ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const space_config& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // i
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "i",
          e));

      a << i.i ();
    }

    // type
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "type",
          e));

      a << i.type ();
    }

    // orderadjust
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "orderadjust",
          e));

      a << i.orderadjust ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const preprocessor& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // gui
    //
    for (preprocessor::gui_const_iterator
         b (i.gui ().begin ()), n (i.gui ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "gui",
          "XMLModule",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const gui& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // group
    //
    for (gui::group_const_iterator
         b (i.group ().begin ()), n (i.group ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "group",
          "XMLModule",
          e));

      s << *b;
    }

    // type
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "type",
          e));

      a << i.type ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const group& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // quantity
    //
    for (group::quantity_const_iterator
         b (i.quantity ().begin ()), n (i.quantity ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "quantity",
          "XMLModule",
          e));

      s << *b;
    }

    // switch_combo
    //
    for (group::switch_combo_const_iterator
         b (i.switch_combo ().begin ()), n (i.switch_combo ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "switch_combo",
          "XMLModule",
          e));

      s << *b;
    }

    // name
    //
    if (i.name ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.name ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const switch_combo& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // switch_option
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "switch_option",
          "XMLModule",
          e));

      s << i.switch_option ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.id ();
    }

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << i.name ();
    }

    // implicit_option
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "implicit_option",
          e));

      a << i.implicit_option ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const switch_option& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.id ();
    }

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << i.name ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const postprocessor& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // localvariables
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "localvariables",
          "XMLModule",
          e));

      s << i.localvariables ();
    }

    // view
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "view",
          "XMLModule",
          e));

      s << i.view ();
    }

    // volumeintegrals
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "volumeintegrals",
          "XMLModule",
          e));

      s << i.volumeintegrals ();
    }

    // surfaceintegrals
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "surfaceintegrals",
          "XMLModule",
          e));

      s << i.surfaceintegrals ();
    }

    // force
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "force",
          "XMLModule",
          e));

      s << i.force ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const localvariables& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // localvariable
    //
    for (localvariables::localvariable_const_iterator
         b (i.localvariable ().begin ()), n (i.localvariable ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "localvariable",
          "XMLModule",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const localvariable& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // expression
    //
    for (localvariable::expression_const_iterator
         b (i.expression ().begin ()), n (i.expression ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "expression",
          "XMLModule",
          e));

      s << *b;
    }

    // format
    //
    if (i.format ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "format",
          e));

      a << *i.format ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.id ();
    }

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << i.name ();
    }

    // shortname
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "shortname",
          e));

      a << i.shortname ();
    }

    // shortname_html
    //
    if (i.shortname_html ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "shortname_html",
          e));

      a << *i.shortname_html ();
    }

    // shortname_latex
    //
    if (i.shortname_latex ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "shortname_latex",
          e));

      a << *i.shortname_latex ();
    }

    // type
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "type",
          e));

      a << i.type ();
    }

    // unit
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "unit",
          e));

      a << i.unit ();
    }

    // unit_html
    //
    if (i.unit_html ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "unit_html",
          e));

      a << *i.unit_html ();
    }

    // unit_latex
    //
    if (i.unit_latex ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "unit_latex",
          e));

      a << *i.unit_latex ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const view& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // scalar_view
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "scalar_view",
          "XMLModule",
          e));

      s << i.scalar_view ();
    }

    // vector_view
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "vector_view",
          "XMLModule",
          e));

      s << i.vector_view ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const scalar_view& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // default
    //
    for (scalar_view::default_const_iterator
         b (i.default_ ().begin ()), n (i.default_ ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "default",
          "XMLModule",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const vector_view& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // default
    //
    for (vector_view::default_const_iterator
         b (i.default_ ().begin ()), n (i.default_ ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "default",
          "XMLModule",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const default_& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // analysistype
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "analysistype",
          e));

      a << i.analysistype ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.id ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const volumeintegrals& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // volumeintegral
    //
    for (volumeintegrals::volumeintegral_const_iterator
         b (i.volumeintegral ().begin ()), n (i.volumeintegral ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "volumeintegral",
          "XMLModule",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const volumeintegral& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // expression
    //
    for (volumeintegral::expression_const_iterator
         b (i.expression ().begin ()), n (i.expression ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "expression",
          "XMLModule",
          e));

      s << *b;
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.id ();
    }

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << i.name ();
    }

    // shortname
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "shortname",
          e));

      a << i.shortname ();
    }

    // shortname_html
    //
    if (i.shortname_html ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "shortname_html",
          e));

      a << *i.shortname_html ();
    }

    // shortname_latex
    //
    if (i.shortname_latex ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "shortname_latex",
          e));

      a << *i.shortname_latex ();
    }

    // unit
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "unit",
          e));

      a << i.unit ();
    }

    // unit_html
    //
    if (i.unit_html ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "unit_html",
          e));

      a << *i.unit_html ();
    }

    // unit_latex
    //
    if (i.unit_latex ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "unit_latex",
          e));

      a << *i.unit_latex ();
    }

    // eggshell
    //
    if (i.eggshell ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "eggshell",
          e));

      a << *i.eggshell ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const surfaceintegrals& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // surfaceintegral
    //
    for (surfaceintegrals::surfaceintegral_const_iterator
         b (i.surfaceintegral ().begin ()), n (i.surfaceintegral ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "surfaceintegral",
          "XMLModule",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const surfaceintegral& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // expression
    //
    for (surfaceintegral::expression_const_iterator
         b (i.expression ().begin ()), n (i.expression ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "expression",
          "XMLModule",
          e));

      s << *b;
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.id ();
    }

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << i.name ();
    }

    // shortname
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "shortname",
          e));

      a << i.shortname ();
    }

    // shortname_html
    //
    if (i.shortname_html ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "shortname_html",
          e));

      a << *i.shortname_html ();
    }

    // shortname_latex
    //
    if (i.shortname_latex ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "shortname_latex",
          e));

      a << *i.shortname_latex ();
    }

    // unit
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "unit",
          e));

      a << i.unit ();
    }

    // unit_html
    //
    if (i.unit_html ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "unit_html",
          e));

      a << *i.unit_html ();
    }

    // unit_latex
    //
    if (i.unit_latex ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "unit_latex",
          e));

      a << *i.unit_latex ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const force& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // expression
    //
    for (force::expression_const_iterator
         b (i.expression ().begin ()), n (i.expression ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "expression",
          "XMLModule",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const volume& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // quantity
    //
    for (volume::quantity_const_iterator
         b (i.quantity ().begin ()), n (i.quantity ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "quantity",
          "XMLModule",
          e));

      s << *b;
    }

    // function
    //
    for (volume::function_const_iterator
         b (i.function ().begin ()), n (i.function ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "function",
          "XMLModule",
          e));

      s << *b;
    }

    // matrix_form
    //
    for (volume::matrix_form_const_iterator
         b (i.matrix_form ().begin ()), n (i.matrix_form ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "matrix_form",
          "XMLModule",
          e));

      s << *b;
    }

    // vector_form
    //
    for (volume::vector_form_const_iterator
         b (i.vector_form ().begin ()), n (i.vector_form ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "vector_form",
          "XMLModule",
          e));

      s << *b;
    }

    // weakforms_volume
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "weakforms_volume",
          "XMLModule",
          e));

      s << i.weakforms_volume ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const surface& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // quantity
    //
    for (surface::quantity_const_iterator
         b (i.quantity ().begin ()), n (i.quantity ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "quantity",
          "XMLModule",
          e));

      s << *b;
    }

    // matrix_form
    //
    for (surface::matrix_form_const_iterator
         b (i.matrix_form ().begin ()), n (i.matrix_form ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "matrix_form",
          "XMLModule",
          e));

      s << *b;
    }

    // vector_form
    //
    for (surface::vector_form_const_iterator
         b (i.vector_form ().begin ()), n (i.vector_form ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "vector_form",
          "XMLModule",
          e));

      s << *b;
    }

    // essential_form
    //
    for (surface::essential_form_const_iterator
         b (i.essential_form ().begin ()), n (i.essential_form ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "essential_form",
          "XMLModule",
          e));

      s << *b;
    }

    // weakforms_surface
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "weakforms_surface",
          "XMLModule",
          e));

      s << i.weakforms_surface ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const boundary& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // quantity
    //
    for (boundary::quantity_const_iterator
         b (i.quantity ().begin ()), n (i.quantity ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "quantity",
          "XMLModule",
          e));

      s << *b;
    }

    // linearity_option
    //
    for (boundary::linearity_option_const_iterator
         b (i.linearity_option ().begin ()), n (i.linearity_option ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "linearity_option",
          "XMLModule",
          e));

      s << *b;
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.id ();
    }

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << i.name ();
    }

    // equation
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "equation",
          e));

      a << i.equation ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const weakforms_surface& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // group
    //
    if (i.group ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "group",
          "XMLModule",
          e));

      s << *i.group ();
    }

    // weakform_surface
    //
    for (weakforms_surface::weakform_surface_const_iterator
         b (i.weakform_surface ().begin ()), n (i.weakform_surface ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "weakform_surface",
          "XMLModule",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const weakform_surface& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // boundary
    //
    for (weakform_surface::boundary_const_iterator
         b (i.boundary ().begin ()), n (i.boundary ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "boundary",
          "XMLModule",
          e));

      s << *b;
    }

    // quantity
    //
    for (weakform_surface::quantity_const_iterator
         b (i.quantity ().begin ()), n (i.quantity ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "quantity",
          "XMLModule",
          e));

      s << *b;
    }

    // function_use
    //
    for (weakform_surface::function_use_const_iterator
         b (i.function_use ().begin ()), n (i.function_use ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "function_use",
          "XMLModule",
          e));

      s << *b;
    }

    // matrix_form
    //
    for (weakform_surface::matrix_form_const_iterator
         b (i.matrix_form ().begin ()), n (i.matrix_form ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "matrix_form",
          "XMLModule",
          e));

      s << *b;
    }

    // vector_form
    //
    for (weakform_surface::vector_form_const_iterator
         b (i.vector_form ().begin ()), n (i.vector_form ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "vector_form",
          "XMLModule",
          e));

      s << *b;
    }

    // analysistype
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "analysistype",
          e));

      a << i.analysistype ();
    }

    // default
    //
    if (i.default_ ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "default",
          e));

      a << *i.default_ ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const weakforms_volume& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // weakform_volume
    //
    for (weakforms_volume::weakform_volume_const_iterator
         b (i.weakform_volume ().begin ()), n (i.weakform_volume ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "weakform_volume",
          "XMLModule",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const weakform_volume& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // quantity
    //
    for (weakform_volume::quantity_const_iterator
         b (i.quantity ().begin ()), n (i.quantity ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "quantity",
          "XMLModule",
          e));

      s << *b;
    }

    // function_use
    //
    for (weakform_volume::function_use_const_iterator
         b (i.function_use ().begin ()), n (i.function_use ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "function_use",
          "XMLModule",
          e));

      s << *b;
    }

    // linearity_option
    //
    for (weakform_volume::linearity_option_const_iterator
         b (i.linearity_option ().begin ()), n (i.linearity_option ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "linearity_option",
          "XMLModule",
          e));

      s << *b;
    }

    // analysistype
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "analysistype",
          e));

      a << i.analysistype ();
    }

    // couplingtype
    //
    if (i.couplingtype ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "couplingtype",
          e));

      a << *i.couplingtype ();
    }

    // sourceanalysis
    //
    if (i.sourceanalysis ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "sourceanalysis",
          e));

      a << *i.sourceanalysis ();
    }

    // equation
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "equation",
          e));

      a << i.equation ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const linearity_option& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // matrix_form
    //
    for (linearity_option::matrix_form_const_iterator
         b (i.matrix_form ().begin ()), n (i.matrix_form ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "matrix_form",
          "XMLModule",
          e));

      s << *b;
    }

    // vector_form
    //
    for (linearity_option::vector_form_const_iterator
         b (i.vector_form ().begin ()), n (i.vector_form ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "vector_form",
          "XMLModule",
          e));

      s << *b;
    }

    // matrix_transient_form
    //
    for (linearity_option::matrix_transient_form_const_iterator
         b (i.matrix_transient_form ().begin ()), n (i.matrix_transient_form ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "matrix_transient_form",
          "XMLModule",
          e));

      s << *b;
    }

    // essential_form
    //
    for (linearity_option::essential_form_const_iterator
         b (i.essential_form ().begin ()), n (i.essential_form ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "essential_form",
          "XMLModule",
          e));

      s << *b;
    }

    // type
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "type",
          e));

      a << i.type ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const matrix_form& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.id ();
    }

    // i
    //
    if (i.i ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "i",
          e));

      a << *i.i ();
    }

    // j
    //
    if (i.j ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "j",
          e));

      a << *i.j ();
    }

    // planar
    //
    if (i.planar ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "planar",
          e));

      a << *i.planar ();
    }

    // axi
    //
    if (i.axi ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "axi",
          e));

      a << *i.axi ();
    }

    // symmetric
    //
    if (i.symmetric ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "symmetric",
          e));

      a << *i.symmetric ();
    }

    // symmetric_planar
    //
    if (i.symmetric_planar ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "symmetric_planar",
          e));

      a << *i.symmetric_planar ();
    }

    // symmetric_axi
    //
    if (i.symmetric_axi ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "symmetric_axi",
          e));

      a << *i.symmetric_axi ();
    }

    // condition
    //
    if (i.condition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "condition",
          e));

      a << *i.condition ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const vector_form& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.id ();
    }

    // i
    //
    if (i.i ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "i",
          e));

      a << *i.i ();
    }

    // j
    //
    if (i.j ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "j",
          e));

      a << *i.j ();
    }

    // planar
    //
    if (i.planar ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "planar",
          e));

      a << *i.planar ();
    }

    // axi
    //
    if (i.axi ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "axi",
          e));

      a << *i.axi ();
    }

    // variant
    //
    if (i.variant ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "variant",
          e));

      a << *i.variant ();
    }

    // coefficient
    //
    if (i.coefficient ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "coefficient",
          e));

      a << *i.coefficient ();
    }

    // condition
    //
    if (i.condition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "condition",
          e));

      a << *i.condition ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const matrix_transient_form& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.id ();
    }

    // i
    //
    if (i.i ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "i",
          e));

      a << *i.i ();
    }

    // j
    //
    if (i.j ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "j",
          e));

      a << *i.j ();
    }

    // planar
    //
    if (i.planar ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "planar",
          e));

      a << *i.planar ();
    }

    // axi
    //
    if (i.axi ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "axi",
          e));

      a << *i.axi ();
    }

    // symmetric
    //
    if (i.symmetric ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "symmetric",
          e));

      a << *i.symmetric ();
    }

    // symmetric_planar
    //
    if (i.symmetric_planar ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "symmetric_planar",
          e));

      a << *i.symmetric_planar ();
    }

    // symmetric_axi
    //
    if (i.symmetric_axi ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "symmetric_axi",
          e));

      a << *i.symmetric_axi ();
    }

    // condition
    //
    if (i.condition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "condition",
          e));

      a << *i.condition ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const essential_form& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.id ();
    }

    // i
    //
    if (i.i ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "i",
          e));

      a << *i.i ();
    }

    // planar
    //
    if (i.planar ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "planar",
          e));

      a << *i.planar ();
    }

    // axi
    //
    if (i.axi ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "axi",
          e));

      a << *i.axi ();
    }

    // condition
    //
    if (i.condition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "condition",
          e));

      a << *i.condition ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const quantity& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.id ();
    }

    // condition
    //
    if (i.condition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "condition",
          e));

      a << *i.condition ();
    }

    // default
    //
    if (i.default_ ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "default",
          e));

      a << ::xml_schema::as_decimal(*i.default_ ());
    }

    // nonlinearity_planar
    //
    if (i.nonlinearity_planar ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "nonlinearity_planar",
          e));

      a << *i.nonlinearity_planar ();
    }

    // nonlinearity_axi
    //
    if (i.nonlinearity_axi ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "nonlinearity_axi",
          e));

      a << *i.nonlinearity_axi ();
    }

    // dependence
    //
    if (i.dependence ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "dependence",
          e));

      a << *i.dependence ();
    }

    // name
    //
    if (i.name ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.name ();
    }

    // shortname
    //
    if (i.shortname ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "shortname",
          e));

      a << *i.shortname ();
    }

    // shortname_html
    //
    if (i.shortname_html ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "shortname_html",
          e));

      a << *i.shortname_html ();
    }

    // shortname_latex
    //
    if (i.shortname_latex ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "shortname_latex",
          e));

      a << *i.shortname_latex ();
    }

    // shortname_dependence
    //
    if (i.shortname_dependence ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "shortname_dependence",
          e));

      a << *i.shortname_dependence ();
    }

    // shortname_dependence_html
    //
    if (i.shortname_dependence_html ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "shortname_dependence_html",
          e));

      a << *i.shortname_dependence_html ();
    }

    // unit
    //
    if (i.unit ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "unit",
          e));

      a << *i.unit ();
    }

    // unit_html
    //
    if (i.unit_html ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "unit_html",
          e));

      a << *i.unit_html ();
    }

    // unit_latex
    //
    if (i.unit_latex ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "unit_latex",
          e));

      a << *i.unit_latex ();
    }

    // is_source
    //
    if (i.is_source ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "is_source",
          e));

      a << *i.is_source ();
    }

    // is_bool
    //
    if (i.is_bool ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "is_bool",
          e));

      a << *i.is_bool ();
    }

    // only_if
    //
    if (i.only_if ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "only_if",
          e));

      a << *i.only_if ();
    }

    // only_if_not
    //
    if (i.only_if_not ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "only_if_not",
          e));

      a << *i.only_if_not ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const function& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // quantity
    //
    for (function::quantity_const_iterator
         b (i.quantity ().begin ()), n (i.quantity ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "quantity",
          "XMLModule",
          e));

      s << *b;
    }

    // function_variant
    //
    for (function::function_variant_const_iterator
         b (i.function_variant ().begin ()), n (i.function_variant ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "function_variant",
          "XMLModule",
          e));

      s << *b;
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.id ();
    }

    // shortname
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "shortname",
          e));

      a << i.shortname ();
    }

    // type
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "type",
          e));

      a << i.type ();
    }

    // postprocessor_analysis
    //
    if (i.postprocessor_analysis ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "postprocessor_analysis",
          e));

      a << *i.postprocessor_analysis ();
    }

    // postprocessor_linearity
    //
    if (i.postprocessor_linearity ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "postprocessor_linearity",
          e));

      a << *i.postprocessor_linearity ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const function_variant& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // switch_value
    //
    if (i.switch_value ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "switch_value",
          e));

      a << *i.switch_value ();
    }

    // expr
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "expr",
          e));

      a << i.expr ();
    }

    // expr_axi
    //
    if (i.expr_axi ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "expr_axi",
          e));

      a << *i.expr_axi ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const function_use& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.id ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const error_calculator& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // calculator
    //
    for (error_calculator::calculator_const_iterator
         b (i.calculator ().begin ()), n (i.calculator ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "calculator",
          "XMLModule",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const calculator& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // expression
    //
    for (calculator::expression_const_iterator
         b (i.expression ().begin ()), n (i.expression ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "expression",
          "XMLModule",
          e));

      s << *b;
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.id ();
    }

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << i.name ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const expression& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // analysistype
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "analysistype",
          e));

      a << i.analysistype ();
    }

    // axi
    //
    if (i.axi ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "axi",
          e));

      a << *i.axi ();
    }

    // axi_r
    //
    if (i.axi_r ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "axi_r",
          e));

      a << *i.axi_r ();
    }

    // axi_z
    //
    if (i.axi_z ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "axi_z",
          e));

      a << *i.axi_z ();
    }

    // axi_phi
    //
    if (i.axi_phi ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "axi_phi",
          e));

      a << *i.axi_phi ();
    }

    // planar
    //
    if (i.planar ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "planar",
          e));

      a << *i.planar ();
    }

    // planar_x
    //
    if (i.planar_x ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "planar_x",
          e));

      a << *i.planar_x ();
    }

    // planar_y
    //
    if (i.planar_y ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "planar_y",
          e));

      a << *i.planar_y ();
    }

    // planar_z
    //
    if (i.planar_z ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "planar_z",
          e));

      a << *i.planar_z ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const field_item& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // field_key
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "field_key",
          e));

      a << i.field_key ();
    }

    // field_value
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "field_value",
          e));

      a << i.field_value ();
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

