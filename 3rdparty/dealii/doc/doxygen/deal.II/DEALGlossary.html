<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>The deal.II Library: Glossary</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="http://www.dealii.org/deal.ico"></link>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2014 by the deal.II authors"></meta>
<meta name="deal.II-version" content="8.1.0"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 8.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Glossary </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This glossary explains a few terms that are frequently used in the documentation of classes of deal.II. The glossary often only gives a microscopic view of a particular concept; if you struggle with the bigger picture, it may therefore also be worth to consult the global overview of classes on the <a class="el" href="index.html">index</a> page.</p>
<dl>
<dt class="glossary"><a class="anchor" id="GlossActive"></a><b>Active cells</b> </dt>
<dd><p class="startdd">A cell, face or edge is defined as <em>active</em> if it is not refined any further, i.e., if it does not have children. Unless working with a multigrid algorithm, active cells are the only ones carrying degrees of freedom.</p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossArtificialCell"></a><b>Artificial cells</b> </dt>
<dd><p class="startdd">If a mesh is distributed across multiple MPI processes using the <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> class, each processor stores only the cells it owns, one layer of adjacent cells that are owned by other processors (called <a class="el" href="DEALGlossary.html#GlossGhostCell">ghost cells</a>), all coarse level cells, and all cells that are necessary to maintain the invariant that adjacent cells must differ by at most one refinement level. The cells stored on each process that are not owned by this process and that are not ghost cells are called "artificial cells", and for these cells the predicate <code>cell-&gt;is_artificial()</code> returns true. Artificial cells are guaranteed to exist in the globally distributed mesh but they may be further refined on other processors. See the <a class="el" href="DEALGlossary.html#distributed_paper">Distributed Computing paper</a> for more information.</p>
<p>The concept of artificial cells has no meaning for triangulations that store the entire mesh on each processor, i.e. the <a class="el" href="classTriangulation.html">Triangulation</a> class. </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossBlockLA"></a><b>Block (linear algebra)</b>  </dt>
<dd><p class="startdd">It is often convenient to treat a matrix or vector as a collection of individual blocks. For example, in <a class="el" href="step_20.html">step-20</a> (and other tutorial programs), we want to consider the global linear system <img class="formulaInl" alt="$Ax=b$" src="form_26.png"/> in the form </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} \left(\begin{array}{cc} M &amp; B^T \\ B &amp; 0 \end{array}\right) \left(\begin{array}{cc} U \\ P \end{array}\right) = \left(\begin{array}{cc} F \\ G \end{array}\right), \end{eqnarray*}" src="form_147.png"/>
</p>
<p> where <img class="formulaInl" alt="$U,P$" src="form_148.png"/> are the values of velocity and pressure degrees of freedom, respectively, <img class="formulaInl" alt="$M$" src="form_103.png"/> is the mass matrix on the velocity space, <img class="formulaInl" alt="$B$" src="form_105.png"/> corresponds to the negative divergence operator, and <img class="formulaInl" alt="$B^T$" src="form_149.png"/> is its transpose and corresponds to the negative gradient.</p>
<p>Using such a decomposition into blocks, one can then define preconditioners that are based on the individual operators that are present in a system of equations (for example the Schur complement, in the case of <a class="el" href="step_20.html">step-20</a>), rather than the entire matrix. In essence, blocks are used to reflect the structure of a PDE system in linear algebra, in particular allowing for modular solvers for problems with multiple solution components. On the other hand, the matrix and right hand side vector can also treated as a unit, which is convenient for example during assembly of the linear system when one may not want to make a distinction between the individual components, or for an outer Krylov space solver that doesn't care about the block structure (e.g. if only the preconditioner needs the block structure).</p>
<p>Splitting matrices and vectors into blocks is supported by the <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>, <a class="el" href="classBlockVector.html">BlockVector</a>, and related classes. See the overview of the various linear algebra classes in the <a class="el" href="group__LAC.html">Linear algebra classes</a> module. The objects present two interfaces: one that makes the object look like a matrix or vector with global indexing operations, and one that makes the object look like a collection of sub-blocks that can be individually addressed. Depending on context, one may wish to use one or the other interface.</p>
<p>Typically, one defines the sub-structure of a matrix or vector by grouping the degrees of freedom that make up groups of physical quantities (for example all velocities) into individual blocks of the linear system. This is defined in more detail below in the glossary entry on <a class="el" href="DEALGlossary.html#GlossBlock">Block (finite element)</a>. </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossBlock"></a><b>Block (finite element)</b> </dt>
<dd><p class="startdd"><em>Intent:</em> Blocks are a generalization of <a class="el" href="DEALGlossary.html#GlossComponent">components</a> in that they group together one or more components of a vector-valued finite element that one would like to consider jointly. One often wants to do this to define operators that correspond to the structure of a (part of a) differential operator acting on the vector-valued solution, such as the Schur complement solver in <a class="el" href="step_20.html">step-20</a>, or the block solvers and preconditioners of <a class="el" href="step_22.html">step-22</a>.</p>
<p>For the purpose of a discretization, blocks are the better concept to use since it is not always possible to address individual components of a solution. This is, in particular, the case for non-<a class="el" href="DEALGlossary.html#GlossPrimitive">primitive</a> elements. Take for instance the solution of the mixed Laplacian system with the <a class="el" href="classFE__RaviartThomas.html">FE_RaviartThomas</a> element (see <a class="el" href="step_20.html">step-20</a>). There, the first <code>dim</code> components are the directional velocities. Since the shape functions are linear combinations of those, these <code>dim</code> components constitute only a single block. On the other hand, the pressure variable is scalar and would form a the second block, but in the <code>dim+1</code>st component.</p>
<p>The minimal size of each block is dictated by the underlying finite element (a block consists of a single component for scalar elements, but in the case of the <a class="el" href="classFE__RaviartThomas.html">FE_RaviartThomas</a>, for example, a block consists of <code>dim</code> components). However, several such minimal blocks can be grouped together into user defined blocks at will, and in accordance with the application. For instance, for the <b>Q</b><sub>2</sub><sup><em>d</em></sup>-<b>Q</b><sub>1</sub> (Taylor-Hood) Stokes element, there are <em>d</em>+1 components each of which could in principle form its own block. But we are typically more interested in having only two blocks, one of which consists of all the velocity vector components (i.e. this block would have <em>d</em> components) and the other having only the single pressure component.</p>
<p><em>Implementation:</em> deal.II has a number of different finite element classes, all of which are derived from the <a class="el" href="classFiniteElement.html">FiniteElement</a> base class (see the <a class="el" href="group__feall.html">module on finite element classes</a>). With one exception, whether they are scalar or vector valued, they all define a single block: all vector components the finite element defines through its <a class="el" href="classFiniteElementData.html#a8d0f50693017e6c0f9d1ed774a847cd0">FiniteElement::n_components()</a> function form a single block, i.e. <a class="el" href="classFiniteElementData.html#a9a6381005298cdd2440fabc8d9b870c6">FiniteElement::n_blocks()</a> returns one.</p>
<p>The exception is the <a class="el" href="classFESystem.html">FESystem</a> class that takes multiple simpler elements and connects them into more complicated ones. Consequently, it can have more than one block. A <a class="el" href="classFESystem.html">FESystem</a> has as many blocks as it has base elements times their multiplicity (see the constructors of <a class="el" href="classFESystem.html">FESystem</a> to understand this statement). In other words, it does not care how many blocks each base element has, and consequently you can produce a Stokes element that has only two blocks by creating the object </p>
<div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> (<a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> (<a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(2), dim), 1,</div>
<div class="line">               <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(1), 1);</div>
</div><!-- fragment --><p> On the other hand, we could have produced a similar object with dim+1 blocks using </p>
<div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> (<a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(2), dim,</div>
<div class="line">               <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(1), 1);</div>
</div><!-- fragment --><p> With the exception of the number of blocks, the two objects are the same for all practical purposes, however.</p>
<p><em>Global degrees of freedom:</em> While we have defined blocks above in terms of the vector components of a vector-valued solution function (or, equivalently, in terms of the vector-valued finite element space), every shape function of a finite element is part of one block or another. Consequently, we can partition all degrees of freedom defined on a <a class="el" href="classDoFHandler.html">DoFHandler</a> into individual blocks. Since by default the <a class="el" href="classDoFHandler.html">DoFHandler</a> class enumerates degrees of freedom in a more or less random way, you will first want to call the <a class="el" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a> function to make sure that all degrees of freedom that correspond to a single block are enumerated consecutively.</p>
<p>If you do this, you naturally partition matrices and vectors into blocks as well (see <a class="el" href="DEALGlossary.html#GlossBlockLA">block (linear algebra)). In most cases, when</a> you subdivide a matrix or vector into blocks, you do so by creating one block for each block defined by the finite element (i.e. in most practical cases the <a class="el" href="classFESystem.html">FESystem</a> object). However, this needs not be so: the <a class="el" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a> function allows to group several vector components or finite element blocks into the same logical block (see, for example, the <a class="el" href="step_22.html">step-22</a> or <a class="el" href="step_31.html">step-31</a> tutorial programs, as opposed to <a class="el" href="step_20.html">step-20</a>). As a consequence, using this feature, we can achieve the same result, i.e. subdividing matrices into <img class="formulaInl" alt="$2\times 2$" src="form_150.png"/> blocks and vectors into 2 blocks, for the second way of creating a Stokes element outlined above using an extra argument as we would have using the first way of creating the Stokes element with two blocks right away.</p>
<p>More information on this topic can be found in the documentation of <a class="el" href="classFESystem.html">FESystem</a>, the <a class="el" href="group__vector__valued.html">Handling vector valued problems</a> module and the tutorial programs referenced therein.</p>
<p><em>Selecting blocks:</em> Many functions allow you to restrict their operation to certain vector components or blocks. For example, this is the case for the functions that interpolate boundary values: one may want to only interpolate the boundary values for the velocity block of a finite element field but not the pressure block. The way to do this is by passing a <a class="el" href="classBlockMask.html">BlockMask</a> argument to such functions, see the <a class="el" href="DEALGlossary.html#GlossBlockMask">block mask entry of this glossary</a>. </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossBlockMask"></a><b>Block mask</b>  </dt>
<dd><p class="startdd">In much the same way as one can think of elements as being composed of physical vector components (see <a class="el" href="DEALGlossary.html#GlossComponent">GlossComponent</a>) or logical blocks (see <a class="el" href="DEALGlossary.html#GlossBlock">GlossBlock</a>), there is frequently a need to select a set of such blocks for operations that are not intended to be run on <em>all</em> blocks of a finite element space. Selecting which blocks to work on happens using the <a class="el" href="classBlockMask.html">BlockMask</a> class.</p>
<p>Block masks work in much the same way as component masks, including the fact that the <a class="el" href="classBlockMask.html">BlockMask</a> class has similar semantics to the <a class="el" href="classComponentMask.html">ComponentMask</a> class. See <a class="el" href="DEALGlossary.html#GlossComponentMask">the glossary entry on component masks</a> for more information.</p>
<dl class="section note"><dt>Note</dt><dd>While components and blocks provide two alternate but equally valid viewpoints on finite elements with multiple vector components, the fact is that throughout the library there are far more places where you can pass a <a class="el" href="classComponentMask.html">ComponentMask</a> argument rather than a <a class="el" href="classBlockMask.html">BlockMask</a> argument. Fortunately, one can be converted into the other, using the syntax <code>fe.component_mask(block_mask)</code> where <code>block_mask</code> is a variable of type <a class="el" href="classBlockMask.html">BlockMask</a>. In other words, if you have a block mask but need to call a function that only accepts a component mask, this syntax can be used to obtain the necessary component mask.</dd></dl>
<p><b>Creation of block masks:</b> Block masks are typically created by asking the finite element to generate a block mask from certain selected vector components using code such as this where we create a mask that only denotes the velocity components of a Stokes element (see <a class="el" href="group__vector__valued.html">Handling vector valued problems</a>): </p>
<div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> stokes_fe (<a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>(<a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(2), dim), 1,    <span class="comment">// Q2 element for the velocities</span></div>
<div class="line">                         <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(1),                     1);     <span class="comment">// Q1 element for the pressure</span></div>
<div class="line"><a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div>
<div class="line"><a class="code" href="classBlockMask.html">BlockMask</a> pressure_mask = stokes_fe.<a class="code" href="classBlockMask.html#aeeb5a4080b466dd6c1aaca3fc578b294">block_mask</a> (pressure);</div>
</div><!-- fragment --><p> The result is a block mask that, in 1d as well as 2d and 3d, would have values <code>[false, true]</code>. Similarly, using </p>
<div class="fragment"><div class="line"><a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div>
<div class="line"><a class="code" href="classBlockMask.html">BlockMask</a> velocity_mask = stokes_fe.<a class="code" href="classBlockMask.html#aeeb5a4080b466dd6c1aaca3fc578b294">block_mask</a> (velocities);</div>
</div><!-- fragment --><p> would result in a mask <code>[true, false]</code> in any dimension.</p>
<p>Note, however, that if we had defined the finite element in the following way: </p>
<div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> stokes_fe (<a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(2), dim,    <span class="comment">// Q2 element for the velocities</span></div>
<div class="line">                         <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(1), 1);     <span class="comment">// Q1 element for the pressure</span></div>
</div><!-- fragment --><p> then the code </p>
<div class="fragment"><div class="line"><a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div>
<div class="line"><a class="code" href="classBlockMask.html">BlockMask</a> pressure_mask = stokes_fe.<a class="code" href="classBlockMask.html#aeeb5a4080b466dd6c1aaca3fc578b294">block_mask</a> (pressure);</div>
</div><!-- fragment --><p> would yield a block mask that in 2d has elements <code>[false, false, true]</code> because the element has <code>dim+1</code> components and equally many blocks. See the discussion on what a block represents exactly in the <a class="el" href="DEALGlossary.html#GlossBlock">block entry of this glossary</a>. </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossBoundaryForm"></a><b>Boundary form</b>  </dt>
<dd><p class="startdd">For a dim-dimensional triangulation in dim-dimensional space, the boundary form is a vector defined on faces. It is the vector product of the image of coordinate vectors on the surface of the unit cell. It is a vector normal to the surface, pointing outwards and having the length of the surface element.</p>
<p>A more general definition would be that (at least up to the length of this vector) it is exactly that vector that is necessary when considering integration by parts, i.e. equalities of the form <img class="formulaInl" alt="$\int_\Omega \text{div} \vec \phi = -\int_{\partial\Omega} \vec n \cdot \vec \phi$" src="form_151.png"/>. Using this definition then also explains what this vector should be in the case of domains (and corresponding triangulations) of dimension <code>dim</code> that are embedded in a space <code>spacedim</code>: in that case, the boundary form is still a vector defined on the faces of the triangulation; it is orthogonal to all tangent directions of the boundary and within the tangent plane of the domain. Note that this is compatible with case <code>dim==spacedim</code> since there the tangent plane is the entire space <img class="formulaInl" alt="${\mathbb R}^\text{dim}$" src="form_152.png"/>.</p>
<p>In either case, the length of the vector equals the determinant of the transformation of reference face to the face of the current cell. </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossBoundaryIndicator"></a><b>Boundary indicator</b>  </dt>
<dd><p class="startdd">In a <a class="el" href="classTriangulation.html">Triangulation</a> object, every part of the boundary is associated with a unique number (of type <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>) that is used to identify which boundary geometry object is responsible to generate new points when the mesh is refined. By convention, this boundary indicator is also often used to determine what kinds of boundary conditions are to be applied to a particular part of a boundary. The boundary is composed of the faces of the cells and, in 3d, the edges of these faces.</p>
<p>By default, all boundary indicators of a mesh are zero, unless you are reading from a mesh file that specifically sets them to something different, or unless you use one of the mesh generation functions in namespace <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> that have a 'colorize' option. A typical piece of code that sets the boundary indicator on part of the boundary to something else would look like this, here setting the boundary indicator to 42 for all faces located at <img class="formulaInl" alt="$x=-1$" src="form_153.png"/>: </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="classTriaActiveIterator.html">Triangulation&lt;dim&gt;::active_cell_iterator</a></div>
<div class="line">       cell = triangulation.begin_active();</div>
<div class="line">     cell != triangulation.end();</div>
<div class="line">     ++cell)</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> f=0; f&lt;GeometryInfo&lt;dim&gt;::faces_per_cell; ++f)</div>
<div class="line">    <span class="keywordflow">if</span> (cell-&gt;face(f)-&gt;at_boundary())</div>
<div class="line">      <span class="keywordflow">if</span> (cell-&gt;face(f)-&gt;center()[0] == -1)</div>
<div class="line">        cell-&gt;face(f)-&gt;set_boundary_indicator (42);</div>
</div><!-- fragment --><p> This calls functions <a class="el" href="group__boundary.html#ga0d873908eff8fd51e88be26e51ab5f88">TriaAccessor::set_boundary_indicator</a>. In 3d, it may also be appropriate to call <a class="el" href="group__boundary.html#gac6a1193fe49dddcf65e927641fbc375b">TriaAccessor::set_all_boundary_indicators</a> instead on each of the selected faces. To query the boundary indicator of a particular face or edge, use <a class="el" href="classTriaAccessor.html#a675e7545c66f35f80fdc113cdcf1a632">TriaAccessor::boundary_indicator</a>.</p>
<p>The code above only sets the boundary indicators of a particular part of the boundary, but it does not by itself change the way the <a class="el" href="classTriangulation.html">Triangulation</a> class treats this boundary for the purposes of mesh refinement. For this, you need to call <a class="el" href="group__boundary.html#ga0509d862f0e07071dcff837bd58fd082">Triangulation::set_boundary</a> to associate a boundary object with a particular boundary indicator. This allows the <a class="el" href="classTriangulation.html">Triangulation</a> object to use a different method of finding new points on faces and edges to be refined; the default is to use a <a class="el" href="classStraightBoundary.html">StraightBoundary</a> object for all faces and edges. The results section of <a class="el" href="step_49.html">step-49</a> has a worked example that shows all of this in action.</p>
<p>The second use of boundary indicators is to describe not only which geometry object to use on a particular boundary but to select a part of the boundary for particular boundary conditions. To this end, many of the functions in namespaces <a class="el" href="namespaceDoFTools.html">DoFTools</a> and <a class="el" href="namespaceVectorTools.html">VectorTools</a> take arguments that specify which part of the boundary to work on. Examples are <a class="el" href="namespaceDoFTools.html#ae23173d20bc1b6c56c6d3a4aa2cbae73">DoFTools::make_periodicity_constraints</a>, <a class="el" href="namespaceDoFTools.html#a3443bf48ca8a7dc319c91f813b10d614">DoFTools::extract_boundary_dofs</a>, <a class="el" href="group__constraints.html#ga2a8572710e0cbec24e8497dd79e15a87">DoFTools::make_zero_boundary_constraints</a> and <a class="el" href="namespaceVectorTools.html#a199f38e07822b47e5b5957c21ce35d1b">VectorTools::interpolate_boundary_values</a>, <a class="el" href="group__constraints.html#gac705b8be8d8abc9ec2f3d6ca17f2ed20">VectorTools::compute_no_normal_flux_constraints</a>.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classBoundary.html">Boundary</a> indicators are inherited from mother faces and edges to their children upon mesh refinement. Some more information about boundary indicators is also presented in a section of the documentation of the <a class="el" href="classTriangulation.html">Triangulation</a> class.</dd>
<dd>
For meshes embedded in a higher dimension (i.e., for which the 'dim' template argument to the <a class="el" href="classTriangulation.html">Triangulation</a> class is less than the 'spacedim' argument &ndash; sometimes called the 'codimension one' or 'codimension two' case), the <a class="el" href="classTriangulation.html">Triangulation</a> also stores boundary indicators for cells, not just faces and edges. In this case, the boundary object associated with a particular boundary indicator is also used to move the new center points of cells back onto the manifold that the triangulation describes whenever a cell is refined.</dd>
<dd>
For parallel triangulations of type <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>, it is not enough to set boundary indicators only once at the beginning. See the long discussion on this topic in the class documentation of <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> . </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__boundary.html">The module on boundaries</a></dd></dl>
</dd>
<dt class="glossary"><a class="anchor" id="GlossComponent"></a><b>Component</b>  </dt>
<dd><p class="startdd">When considering systems of equations in which the solution is not just a single scalar function, we say that we have a <em>vector system</em> with a <em>vector-valued solution</em>. For example, the vector solution in the elasticity equation considered in <a class="el" href="step_8.html">step-8</a> is <img class="formulaInl" alt="$u=(u_x,u_y,u_z)^T$" src="form_154.png"/> consisting of the displacements in each of the three coordinate directions. The solution then has three elements. Similarly, the 3d Stokes equation considered in <a class="el" href="step_22.html">step-22</a> has four elements: <img class="formulaInl" alt="$u=(v_x,v_y,v_z,p)^T$" src="form_155.png"/>. We call the elements of the vector-valued solution <em>components</em> in deal.II. To be well-posed, for the solution to have <img class="formulaInl" alt="$n$" src="form_156.png"/> components, there need to be <img class="formulaInl" alt="$n$" src="form_156.png"/> partial differential equations to describe them. This concept is discussed in great detail in the <a class="el" href="group__vector__valued.html">Handling vector valued problems</a> module.</p>
<p>In finite element programs, one frequently wants to address individual elements (components) of this vector-valued solution, or sets of components. For example, we do this extensively in <a class="el" href="step_8.html">step-8</a>, and a lot of documentation is also provided in the module on <a class="el" href="group__vector__valued.html">Handling vector valued problems</a>. If you are thinking only in terms of the partial differential equation (not in terms of its discretization), then the concept of <em>components</em> is the natural one.</p>
<p>On the other hand, when talking about finite elements and degrees of freedom, <em>components</em> are not always the correct concept because components are not always individually addressable. In particular, this is the case for <a class="el" href="DEALGlossary.html#GlossPrimitive">non-primitive finite elements</a>. Similarly, one may not always <em>want</em> to address individual components but rather sets of components &mdash; e.g. all velocity components together, and separate from the pressure in the Stokes system, without further splitting the velocities into their individual components. In either case, the correct concept to think in is that of a <a class="el" href="DEALGlossary.html#GlossBlock">block</a>. Since each component, if individually addressable, is also a block, thinking in terms of blocks is most frequently the better strategy.</p>
<p>For a given finite element, the number of components can be queried using the <a class="el" href="classFiniteElementData.html#a8d0f50693017e6c0f9d1ed774a847cd0">FiniteElementData::n_components()</a> function, and you can find out which vector components are nonzero for a given finite element shape function using <a class="el" href="classFiniteElement.html#a0a976cfdc58da9322c1cf1240cca4a86">FiniteElement::get_nonzero_components()</a>. The values and gradients of individual components of a shape function (if the element is primitive) can be queried using the <a class="el" href="classFiniteElement.html#aefcc7c236f03ca92cbce5cd1d838cc09">FiniteElement::shape_value_component()</a> and <a class="el" href="classFiniteElement.html#aa251d27289ecc281cdd43753ccc748fb">FiniteElement::shape_grad_component()</a> functions on the reference cell. The <a class="el" href="classFEValuesBase.html#a55a507d64ae810232dc0e8bdbf7ee4c1">FEValues::shape_value_component()</a> and <a class="el" href="classFEValuesBase.html#a836dd15035c0493714a284ee3d0e0a16">FEValues::shape_grad_component()</a> functions do the same on a real cell. See also the documentation of the <a class="el" href="classFiniteElement.html">FiniteElement</a> and <a class="el" href="classFEValues.html">FEValues</a> classes.</p>
<p><em>Selecting components:</em> Many functions allow you to restrict their operation to certain vector components or blocks. For example, this is the case for the functions that interpolate boundary values: one may want to only interpolate the boundary values for the velocity components of a finite element field but not the pressure component. The way to do this is by passing a <a class="el" href="classComponentMask.html">ComponentMask</a> argument to such functions, see the <a class="el" href="DEALGlossary.html#GlossComponentMask">component mask entry of this glossary</a>. </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossComponentMask"></a><b>Component mask</b>  </dt>
<dd><p class="startdd">When using vector-valued elements (see <a class="el" href="group__vector__valued.html">Handling vector valued problems</a>) to solve systems of equations, one frequently wants to restrict some operations to only certain solution variables. For example, when solving the Stokes equations, one may wish to only interpolate boundary values for the velocity components but not the pressure. In deal.II, this is typically done by passing functions a <em>component mask</em>. Component masks are always specified as a <a class="el" href="classComponentMask.html">ComponentMask</a> object which one can think of as an array with as many entries as the finite element has components (e.g., in the Stokes case, there are <code>dim+1</code> components) and where each entry is either true or false. In the example where we would like to interpolate boundary values only for the velocity components of the Stokes system, this component mask would then be <code>[true, true, false]</code> in 2d and <code>[true, true, true, false]</code> in 3d to indicate that no boundary values shall be set for the pressure variable (the last of the <code>dim+1</code> vector components of the solution.</p>
<p>There are many functions that take such component masks, for example DoFTools::make_zero_boundary_values, <a class="el" href="namespaceVectorTools.html#a199f38e07822b47e5b5957c21ce35d1b">VectorTools::interpolate_boundary_values</a>, <a class="el" href="classKellyErrorEstimator.html#ae1f3149bcc7653baa5ef0a2ac88070b9">KellyErrorEstimator::estimate</a>, etc. In some cases, there are multiple functions with these names but only some of them have a component mask argument.</p>
<p><b>Semantics of component masks:</b> Many of the functions that take a component mask object that has been default constructed to indicate <em>all components</em>, i.e., as if the vector had the correct length and was filled with only <code>true</code> values. The reason is that default initialized objects can be constructed in place using the code snippet <code><a class="el" href="classComponentMask.html">ComponentMask()</a></code> and can thus be used as a default argument in function signatures.</p>
<p>In other words, <a class="el" href="classComponentMask.html">ComponentMask</a> objects can be in one of two states: They can have been initialized by a vector of booleans with a nonzero length; in that case, they represent a mask of a particular length where some elements may be true and others may be false. Or, the <a class="el" href="classComponentMask.html">ComponentMask</a> may have been default initialized (using the default constructor) in which case it represents an array of indefinite length (i.e., a length appropriate to the circumstances) in which <em>every entry</em> is true.</p>
<p><b>Creation of component masks:</b> Component masks are typically created by asking the finite element to generate a component mask from certain selected components using code such as this where we create a mask that only denotes the velocity components of a Stokes element (see <a class="el" href="group__vector__valued.html">Handling vector valued problems</a>): </p>
<div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> stokes_fe (<a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(2), dim,    <span class="comment">// Q2 element for the velocities</span></div>
<div class="line">                         <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(1), 1);     <span class="comment">// Q1 element for the pressure</span></div>
<div class="line"><a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div>
<div class="line"><a class="code" href="classComponentMask.html">ComponentMask</a> pressure_mask = stokes_fe.component_mask (pressure);</div>
</div><!-- fragment --><p> The result is a component mask that, in 2d, would have values <code>[false, false, true]</code>. Similarly, using </p>
<div class="fragment"><div class="line"><a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div>
<div class="line"><a class="code" href="classComponentMask.html">ComponentMask</a> velocity_mask = stokes_fe.component_mask (velocities);</div>
</div><!-- fragment --><p> would result in a mask <code>[true, true, false]</code> in 2d. Of course, in 3d, the result would be <code>[true, true, true, false]</code>.</p>
<dl class="section note"><dt>Note</dt><dd>Just as one can think of composed elements as being made up of <a class="el" href="DEALGlossary.html#GlossComponent">components</a> or <a class="el" href="DEALGlossary.html#GlossBlock">blocks</a>, there are component masks (represented by the <a class="el" href="classComponentMask.html">ComponentMask</a> class) and <a class="el" href="DEALGlossary.html#GlossBlockMask">block masks</a> (represented by the <a class="el" href="classBlockMask.html">BlockMask</a> class). The <a class="el" href="classFiniteElement.html">FiniteElement</a> class has functions that convert between the two kinds of objects.</dd>
<dd>
Not all component masks actually make sense. For example, if you have a <a class="el" href="classFE__RaviartThomas.html">FE_RaviartThomas</a> object in 2d, then it doesn't make any sense to have a component mask of the form <code>[true, false]</code> because you try to select individual vector components of a finite element where each shape function has both <img class="formulaInl" alt="$x$" src="form_9.png"/> and <img class="formulaInl" alt="$y$" src="form_10.png"/> velocities. In essence, while you can of course create such a component mask, there is nothing you can do with it. </dd></dl>
</dd>
<dt class="glossary"><a class="anchor" id="GlossCompress"></a><b>Compressing distributed vectors and matrices</b>  </dt>
<dd><p class="startdd">For parallel computations, deal.II uses the vector and matrix classes defined in the <a class="el" href="namespacePETScWrappers.html">PETScWrappers</a> and <a class="el" href="namespaceTrilinosWrappers.html">TrilinosWrappers</a> namespaces. When running programs in parallel using MPI, these classes only store a certain number of rows or elements on the current processor, whereas the rest of the vector or matrix is stored on the other processors that belong to our MPI universe. This presents a certain problem when you assemble linear systems: we add elements to the matrix and right hand side vectors that may or may not be stored locally. Sometimes, we may also want to just <em>set</em> an element, not add to it.</p>
<p>Both PETSc and Trilinos allow adding to or setting elements that are not locally stored. In that case, they write the value that we want to store or add into a cache, and we need to call one of the functions <a class="el" href="classTrilinosWrappers_1_1VectorBase.html#ab725379d6c0b5a5b154843e7610bab2a">TrilinosWrappers::VectorBase::compress()</a>, <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afc390e218faf682f0ae27f25568d787f">TrilinosWrappers::SparseMatrix::compress()</a>, <a class="el" href="classPETScWrappers_1_1VectorBase.html#ada4d248898b40dca7070261493cef21b">PETScWrappers::VectorBase::compress()</a> or <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a8009bfff8d1f0c5bf2f937fe432cc07d">PETScWrappers::MatrixBase::compress()</a> which will then ship the values in the cache to the MPI process that owns the element to which it is supposed to be added or written to. Due to the MPI model that only allows to initiate communication from the sender side (i.e. in particular, it is not a remote procedure call), these functions are collective, i.e. they need to be called by all processors.</p>
<p>There is one snag, however: both PETSc and Trilinos need to know whether the operation that these <code>compress()</code> functions invoke applies to adding elements or setting them. In some cases, not all processors may be adding elements, for example if a processor does not own any cells when using a very coarse (initial) mesh. For this reason, compress() takes an argument of type <a class="el" href="structVectorOperation.html">VectorOperation</a>, which can be either ::add, or ::insert. This argument is required for vectors and matrices starting with the 7.3 release.</p>
<p>In olde releases we also proposed fake add/set operations. Those were the cause of many bugs and deadlocks, so the usage of <a class="el" href="structVectorOperation.html">VectorOperation</a> is now required.</p>
<p>In short, you need to call compress() in the following cases (and only in those cases, though calling compress() in other cases just costs some performance):</p>
<ol type="1">
<li>At the end of your assembly loop on matrices and vectors. This needs to be done if you write entries directly or if you use <a class="el" href="classConstraintMatrix.html#aa9f3612a8fc51eafa34252bb436e8ae4">ConstraintMatrix::distribute_local_to_global</a>. Use VectorOperation::add.</li>
<li>When you are done setting individual elements in a matrix/vector before any other operations are done (adding to elements, other operations like scaling, solving, reading, etc.). Use VectorOperation::insert.</li>
<li>Like in 2., but for adding values to individual elements. Use VectorOperation::add.</li>
</ol>
<p>All other operations like scaling or adding vectors, assignments, calls into deal.II (<a class="el" href="namespaceVectorTools.html">VectorTools</a>, <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a>, ...) or solvers do not require calls to compress(). </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossDoF"></a><b>Degree of freedom</b>  </dt>
<dd><p class="startdd">The term "degree of freedom" (often abbreviated as "DoF") is commonly used in the finite element community to indicate two slightly different, but related things. The first is that we'd like to represent the finite element solution as a linear combination of shape function, in the form <img class="formulaInl" alt="$u_h(\mathbf x) = \sum_{j=0}^{N-1} U_j \varphi_j(\mathbf x)$" src="form_157.png"/>. Here, <img class="formulaInl" alt="$U_j$" src="form_122.png"/> is a vector of expension coefficients. Because we don't know their values yet (we will compute them as the solution of a linear or nonlinear system), they are called "unknowns" or "degrees of freedom". The second meaning of the term con be explained as follows: A mathematical description of finite element problem is often to say that we are looking for a finite dimensional function <img class="formulaInl" alt="$u_h \in V_h$" src="form_158.png"/> that satisfies some set of equations (e.g. <img class="formulaInl" alt="$a(u_h,\varphi_h)=(f,\varphi_h)$" src="form_159.png"/> for all test functions <img class="formulaInl" alt="$\varphi_h\in V_h$" src="form_160.png"/>). In other words, all we say here that the solution needs to lie in some space <img class="formulaInl" alt="$V_h$" src="form_120.png"/>. However, to actually solve this problem on a computer we need to choose a basis of this space; this is the set of shape functions <img class="formulaInl" alt="$\varphi_j(\mathbf x)$" src="form_161.png"/> we have used above in the expansion of <img class="formulaInl" alt="$u_h(\mathbf x)$" src="form_162.png"/> with coefficients <img class="formulaInl" alt="$U_j$" src="form_122.png"/>. There are of course many bases of the space <img class="formulaInl" alt="$V_h$" src="form_120.png"/>, but we will specifically choose the one that is described by the finite element functions that are traditionally defined locally on the cells of the mesh. Describing "degrees of freedom" in this context requires us to simply <em>enumerate</em> the basis functions of the space <img class="formulaInl" alt="$V_h$" src="form_120.png"/>. For <img class="formulaInl" alt="$Q_1$" src="form_37.png"/> elements this means simply enumerating the vertices of the mesh in some way, but for higher elements one also has to enumerate the shape functions that are associated with edges, faces, or cell interiors of the mesh. The class that provides this enumeration of the basis functions of <img class="formulaInl" alt="$V_h$" src="form_120.png"/> is called <a class="el" href="classDoFHandler.html">DoFHandler</a>. The process of enumerating degrees of freedom is referred to as "distributing DoFs" in deal.II. </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossDirectionFlag"></a><b>Direction flags</b>  </dt>
<dd><p class="startdd">The <em>direction flag</em> is used in triangulations embedded in a higher dimensional space to denote the orientation of cells and make the manifold oriented. It is accessed using <a class="el" href="classCellAccessor.html#ae308f879468cfe0ec2a1ecf6a9989780">CellAccessor::direction_flag()</a> and set by the <a class="el" href="classTriangulation.html">Triangulation</a> class upon creation of a triangulation. You can change all direction flags of a triangulation using the <a class="el" href="classTriangulation.html#afdc34248a9ba0c38fd0020256a8def5c">Triangulation::flip_all_direction_flags()</a> function.</p>
<p>The flag is necessary to make cases like this work: assume we have a one-dimensional mesh embedded in a two-dimensional space,</p>
<div class="image">
<img src="direction_flag.png" alt="direction_flag.png"/>
<div class="caption">
One dimensional mesh in two dimensions</div></div>
<p> In one dimensional meshes in one dimensional space, we can always make sure that the location of the left vertex of a cell has a smaller value than the location of the right vertex. However, if we embed a mesh in a higher dimensional space, we can no longer do this. For example, the cells in the mesh above may be described by the following vertex sets: <code>(0,1), (1,2), (3,2), (4,3), (4,5)</code>. (As a side remark, note that here we have vertices &ndash; e.g. vertex 2 &ndash; that are the right end points of more than one cell.) If we define the normal to each cell as that unit vector that is right perpendicular to the vector that connects the first to the second vertex of the line, then we would end up with the following picture:</p>
<div class="image">
<img src="direction_flag_normals.png" alt="direction_flag_normals.png"/>
<div class="caption">
Normal vectors</div></div>
<p> In other words, this one-dimensional manifold is not oriented. We could in principle revert the order of vertices when creating such a mesh (though there are good reasons not to do so, for example because this mesh may have resulted from extracting the surface mesh of a two dimensional mesh, and we want to preserve the order of vertices of each line segment because they currently match the order of vertices of the faces of the 2d cells). An alternative strategy, chosen in deal.II, is to simply associate with each cell whether the normal should be the left or right normal to the cell. (The default is right normals.) In the example above, the flags for the five cells would be <code>true, true, false, false, true</code>. Multiplying the right normal with plus or minus one, depending on the value of the flag on each cell, yields a set of normal vectors that orient the manifold.</p>
<p>Similar issues happen with two-dimensional meshes in three space dimensions. We note that it would not be possible to find consistent direction flags if the two-dimensional manifold is not orientable; such manifolds are not currently supported by deal.II. </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossDistorted"></a><b>Distorted cells</b>  </dt>
<dd><p class="startdd">A <em>distorted cell</em> is a cell for which the mapping from the reference cell to real cell has a Jacobian whose determinant is non-positive somewhere in the cell. Typically, we only check the sign of this determinant at the vertices of the cell. The function <a class="el" href="structGeometryInfo.html#acb85adcb01576bd42127aa5af1733ef7">GeometryInfo::alternating_form_at_vertices</a> computes these determinants at the vertices.</p>
<p>By way of example, if all of the determinants are of roughly equal value and on the order of <img class="formulaInl" alt="$h^\text{dim}$" src="form_163.png"/> then the cell is well-shaped. For example, a square cell or face has determinants equal to <img class="formulaInl" alt="$h^\text{dim}$" src="form_163.png"/> whereas a strongly sheared parallelogram has a determinant much smaller. Similarly, a cell with very unequal edge lengths will have widely varying determinants. Conversely, a pinched cell in which the location of two or more vertices is collapsed to a single point has a zero determinant at this location. Finally, an inverted or twisted cell in which the location of two vertices is out of order will have negative determinants.</p>
<p>The following two images show a well-formed, a pinched, and a twisted cell for both 2d and 3d:</p>
<div class="image">
<img src="distorted_2d.png" alt="distorted_2d.png"/>
<div class="caption">
A well-formed, a pinched, and a twisted cell in 2d.</div></div>
 <div class="image">
<img src="distorted_3d.png" alt="distorted_3d.png"/>
<div class="caption">
A well-formed, a pinched, and a twisted cell in 3d.</div></div>
 <p>Distorted cells can appear in two different ways: The original coarse mesh can already contain such cells, or they can be created as the result of mesh refinement if the boundary description in use is sufficiently irregular.</p>
<p>If the appropriate flag is given upon creation of a triangulation, the function <a class="el" href="classTriangulation.html#a5b6edd805a4d8b91d016080bf43233c1">Triangulation::create_triangulation</a>, which is called by the various functions in <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> and <a class="el" href="classGridIn.html">GridIn</a> (but can also be called from user code, see <a class="el" href="step_14.html">step-14</a>, will signal the creation of coarse meshes with distorted cells by throwing an exception of type <a class="el" href="structTriangulation_1_1DistortedCellList.html">Triangulation::DistortedCellList</a>. There are legitimate cases for creating meshes with distorted cells (in particular collapsed/pinched cells) if you don't intend to assemble anything on these cells. For example, consider a case where one would like to simulate the behavior of an elastic material with a fluid-filled crack such as an oil reservoir. If the pressure becomes too large, the crack is closed &ndash; and the cells that discretize the crack volume are collapsed to zero volume. As long as you don't integrate over these cells to simulate the behavior of the fluid (of which there isn't any if the crack has zero volume), such meshes are perfectly legitimate. As a consequence, <a class="el" href="classTriangulation.html#a5b6edd805a4d8b91d016080bf43233c1">Triangulation::create_triangulation</a> does not simply abort the program, but throws an exception that contains a list of cells that are distorted; this exception can be caught and, if you believe that you can ignore this condition, you can react by doing nothing with the caught exception.</p>
<p>The second case in which distorted cells can appear is through mesh refinement when we have curved boundaries. Consider, for example, the following case where the dashed line shows the exact boundary that the lower edge of the cell is supposed to approximate (let's assume for simplicity that the left, top and right edges are interior edges and therefore will be considered as straight; in fact, for this particular case in 2d where only one side of a cell is at the boundary we have special code that avoids the situation depicted, but you will get the general idea of the problem that holds in 3d or if more than one side of the cell is at the boundary):</p>
<div class="image">
<img src="distorted_2d_refinement_01.png" alt="distorted_2d_refinement_01.png"/>
<div class="caption">
One cell with an edge approximating a curved boundary</div></div>
<p> Now, if this cell is refined, we first split all edges and place new mid-points on them. For the left, top and right edge, this is trivial: because they are considered straight, we just take the point in the middle between the two vertices. For the lower edge, the <a class="el" href="classTriangulation.html">Triangulation</a> class asks the <a class="el" href="classBoundary.html">Boundary</a> object associated with this boundary (and in particular the Boundary::new_point_on_line function) where the new point should lie. The four old vertices and the four new points are shown here:</p>
<div class="image">
<img src="distorted_2d_refinement_02.png" alt="distorted_2d_refinement_02.png"/>
<div class="caption">
Cell after edge refinement</div></div>
<p> The last step is to compute the location of the new point in the interior of the cell. By default, it is chosen as the average location (arithmetic mean of the coordinates) of these 8 points (in 3d, the 26 surrounding points have different weights, but the idea is the same):</p>
<div class="image">
<img src="distorted_2d_refinement_03.png" alt="distorted_2d_refinement_03.png"/>
<div class="caption">
Cell after edge refinement</div></div>
<p> The problem with that is, of course, that the bottom two child cells are twisted, whereas the top two children are well-shaped. While such meshes can happen with sufficiently irregular boundary descriptions (and if the coarse mesh is entirely inadequate to resolve the complexity of the boundary), the <a class="el" href="classTriangulation.html">Triangulation</a> class does not know what to do in such situations. Consequently, the <a class="el" href="classTriangulation.html#aaedd900205c1879d8d9ef6ffe7d1a554">Triangulation::execute_coarsening_and_refinement</a> function does create such meshes, but it keeps a list of cells whose children are distorted. If this list is non-empty at the end of a refinement step, it will throw an exception of type <a class="el" href="structTriangulation_1_1DistortedCellList.html">Triangulation::DistortedCellList</a> that contains those cells that have distorted children. The caller of <a class="el" href="classTriangulation.html#aaedd900205c1879d8d9ef6ffe7d1a554">Triangulation::execute_coarsening_and_refinement</a> can then decide what to do with this situation.</p>
<p>One way to deal with this problem is to use the <a class="el" href="namespaceGridTools.html#acfe914816bd29721d7fedf2c3c18f830">GridTools::fix_up_distorted_child_cells</a> function that attempts to fix up exactly these cells if possible by moving around the node at the center of the cell.</p>
<p>Note that the <a class="el" href="classTriangulation.html">Triangulation</a> class does not test for the presence of distorted cells by default, since the determination whether a cell is distorted or not is not a cheap operation. If you want a <a class="el" href="classTriangulation.html">Triangulation</a> object to test for distortion of cells, you need to specify this upon creation of the object by passing the appropriate flag.</p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="distributed_paper"></a> <b>Distributed computing paper</b>  </dt>
<dd><p class="startdd">The "distributed computing paper" is a paper by W. Bangerth, C. Burstedde, T. Heister and M. Kronbichler titled "Algorithms and Data
   Structures for Massively Parallel Generic Finite Element Codes" that describes the implementation of parallel distributed computing in deal.II, i.e. computations where not only the linear system is split onto different machines as in, for example, <a class="el" href="step_17.html">step-17</a>, but also the <a class="el" href="classTriangulation.html">Triangulation</a> and <a class="el" href="classDoFHandler.html">DoFHandler</a> objects. In essence, it is a guide to the <a class="el" href="namespaceparallel_1_1distributed.html">parallel::distributed</a> namespace and the techniques used in <a class="el" href="step_40.html">step-40</a>.</p>
<p>The full reference for the paper is as follows: </p>
<div class="fragment"><div class="line">@Article{BBHK11,</div>
<div class="line">  author =       {Wolfgang Bangerth and Carsten Burstedde and Timo Heister</div>
<div class="line">                  and Martin Kronbichler},</div>
<div class="line">  title =        {Algorithms and data structures <span class="keywordflow">for</span> massively parallel <span class="keyword">generic</span></div>
<div class="line">  adaptive finite element codes},</div>
<div class="line">  journal =      {ACM Trans. Math. Softw.},</div>
<div class="line">  year =         2011,</div>
<div class="line">  <a class="code" href="namespaceGridTools.html#a4ff265d387af7b430f5aec7005faace6">volume</a> =       38,</div>
<div class="line">  pages =        {14/1--28}}</div>
</div><!-- fragment --><p> It is also available as <a href="http://iamcs.tamu.edu/file_dl.php?type=preprint&amp;preprint_id=237">IAMCS preprint 2011-187</a>.</p>
<p>For massively parallel computations, deal.II builds on the <a href="http://www.p4est.org/" target="_top">p4est</a> library. If you use this functionality, please also cite the p4est paper listed at their website. </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossFaceOrientation"></a><b>Face orientation</b> </dt>
<dd><p class="startdd">In a triangulation, the normal vector to a face can be deduced from the face orientation by applying the right hand side rule (x,y -&gt; normal). We note, that in the standard orientation of faces in 2d, faces 0 and 2 have normals that point into the cell, and faces 1 and 3 have normals pointing outward. In 3d, faces 0, 2, and 4 have normals that point into the cell, while the normals of faces 1, 3, and 5 point outward. This information, again, can be queried from <a class="el" href="structGeometryInfo.html#aa6779325d3f85b1caeac06ef885fce11">GeometryInfo&lt;dim&gt;::unit_normal_orientation</a>.</p>
<p>However, it turns out that a significant number of 3d meshes cannot satisfy this convention. This is due to the fact that the face convention for one cell already implies something for the neighbor, since they share a common face and fixing it for the first cell also fixes the normal vectors of the opposite faces of both cells. It is easy to construct cases of loops of cells for which this leads to cases where we cannot find orientations for all faces that are consistent with this convention.</p>
<p>For this reason, above convention is only what we call the <em>standard orientation</em>. deal.II actually allows faces in 3d to have either the standard direction, or its opposite, in which case the lines that make up a cell would have reverted orders, and the normal vector would have the opposite direction. You can ask a cell whether a given face has standard orientation by calling <code>cell-&gt;face_orientation(face_no)</code>: if the result is <code>true</code>, then the face has standard orientation, otherwise its normal vector is pointing the other direction. There are not very many places in application programs where you need this information actually, but a few places in the library make use of this. Note that in 2d, the result is always <code>true</code>. However, while every face in 2d is always in standard orientation, you can sometimes specify something to assume that this is not so; an example is the function <a class="el" href="namespaceDoFTools.html#ae23173d20bc1b6c56c6d3a4aa2cbae73">DoFTools::make_periodicity_constraints()</a>.</p>
<p>There are two other flags that describe the orientation of a face: face_flip and face_rotation. Some documentation for these exists in the <a class="el" href="structGeometryInfo.html">GeometryInfo</a> class. An example of their use in user code is given in the <a class="el" href="namespaceDoFTools.html#ae23173d20bc1b6c56c6d3a4aa2cbae73">DoFTools::make_periodicity_constraints</a> function.</p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossGeneralizedSupport"></a><b>Generalized support points</b> </dt>
<dd><p class="startdd">While <a class="el" href="DEALGlossary.html#GlossSupport">support points</a> allow very simple interpolation into the finite element space, their concept is restricted to <a class="el" href="DEALGlossary.html#GlossLagrange">Lagrange elements</a>. For other elements, more general interpolation operators can be defined, often relying on integral values or moments. Since these integral values are again computed using a quadrature rule, we consider them a generalization of support points.</p>
<p>Note that there is no simple relation between <a class="el" href="DEALGlossary.html#GlossShape">shape functions</a> and generalized support points, unlike for regular <a class="el" href="DEALGlossary.html#GlossSupport">support points</a>. Instead, <a class="el" href="classFiniteElement.html">FiniteElement</a> defines a couple of interpolation functions doing the actual interpolation.</p>
<p>If a finite element is Lagrangian, generalized support points and support points coincide. </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossGhostCell"></a><b>Ghost cells</b> </dt>
<dd><p class="startdd">If a mesh is distributed across multiple MPI processes using the <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> class, each processor stores only the cells it owns, one layer of adjacent cells that are owned by other processors, all coarse level cells, and all cells that are necessary to maintain the invariant that adjacent cells must differ by at most one refinement level. The cells stored on each process that are not owned by this process but that are adjacent to the ones owned by this process are called "ghost cells", and for these cells the predicate <code>cell-&gt;is_ghost()</code> returns true. Ghost cells are guaranteed to exist in the globally distributed mesh, i.e. these cells are actually owned by another process and are not further refined there. See the <a class="el" href="DEALGlossary.html#distributed_paper">Distributed Computing paper</a> for more information.</p>
<p>The concept of ghost cells has no meaning for triangulations that store the entire mesh on each processor, i.e. the <a class="el" href="classTriangulation.html">Triangulation</a> class. </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="hp_paper"></a><b>hp paper</b> </dt>
<dd><p class="startdd">The "hp paper" is a paper by W. Bangerth and O. Kayser-Herold, titled "Data Structures and Requirements for hp Finite Element Software", that describes many of the algorithms and data structures used in the implementation of the hp framework of deal.II. In particular, it summarizes many of the tricky points that have to be considered for hp finite elements using continuous elements.</p>
<p>The full reference for this paper is as follows: </p>
<div class="fragment"><div class="line">Article{BK07,</div>
<div class="line">  author =       {Wolfgang Bangerth and Oliver Kayser-Herold},</div>
<div class="line">  title =        {Data Structures and Requirements <span class="keywordflow">for</span> hp Finite Element</div>
<div class="line">                  Software},</div>
<div class="line">  journal =      {ACM Trans. Math. Softw.},</div>
<div class="line">  year =         2009,</div>
<div class="line">  <a class="code" href="namespaceGridTools.html#a4ff265d387af7b430f5aec7005faace6">volume</a> =       36,</div>
<div class="line">  number =       1,</div>
<div class="line">  pages =        {4/1--4/31}</div>
<div class="line">}</div>
</div><!-- fragment --><p> It is available as Technical Report ISC-07-04-MATH from the <a href="http://www.isc.tamu.edu/publications-reports/technical_reports">Institute for Scientific Computation, Texas A&amp;M University</a>, and also from <a href="http://www.math.tamu.edu/~bangerth/publications.html">http://www.math.tamu.edu/~bangerth/publications.html</a> .</p>
<p>The numerical examples shown in that paper are generated with a slightly modified version of <a class="el" href="step_27.html">step-27</a>. The main difference to that tutorial program is that various operations in the program were timed for the paper to compare different options and show that <img class="formulaInl" alt="$hp$" src="form_1.png"/> methods are really not all that expensive. </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossInterpolation"></a><b>Interpolation with finite elements</b> </dt>
<dd><p class="startdd">The purpose of interpolation with finite elements is computing a vector of coefficients representing a finite element function, such that the <a class="el" href="DEALGlossary.html#GlossNodes">node values</a> of the original function and the finite element function coincide. Therefore, the interpolation process consists of evaluating all <a class="el" href="DEALGlossary.html#GlossNodes">node functionals</a> <em>N<sub>i</sub></em> for the given function <em>f</em> and store the result as entry <em>i</em> in the coefficient vector.</p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossLagrange"></a><b>Lagrange elements</b> </dt>
<dd><p class="startdd">Finite elements based on Lagrangian interpolation at <a class="el" href="DEALGlossary.html#GlossSupport">support points</a>.</p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossLocallyOwnedCell"></a><b>Locally owned cell</b> </dt>
<dd><p class="startdd">This concept identifies a subset of all cells when using distributed meshes, see the <a class="el" href="group__distributed.html">Parallel computing with multiple processors using distributed memory</a> module. In such meshes, each cell is owned by exactly one processor. The locally owned ones are those owned by the current processor. </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossLocallyOwnedDof"></a><b>Locally owned degrees of freedom</b> </dt>
<dd><p class="startdd">This concept identifies a subset of all degrees of freedom when using distributed meshes, see the <a class="el" href="group__distributed.html">Parallel computing with multiple processors using distributed memory</a> module. Locally owned degrees of freedom live on locally owned cells. Since degrees of freedom are owned by only one processor, degrees of freedom on interfaces between cells owned by different processors may be owned by one or the other, so not all degrees of freedom on a locally owned cell are also locally owned degrees of freedom.</p>
<p>Locally owned DoFs are a subset of the <a class="el" href="DEALGlossary.html#GlossLocallyActiveDof">locally active DoFs</a>.</p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossLocallyActiveDof"></a><b>Locally active degrees of freedom</b> </dt>
<dd><p class="startdd">This concept identifies a subset of all degrees of freedom when using distributed meshes, see the <a class="el" href="group__distributed.html">Parallel computing with multiple processors using distributed memory</a> module. Locally active degrees of freedom are those that live on locally owned cells. Degrees of freedom on interfaces between cells owned by different processors therefore belong to the set of locally active degrees of freedom for more than one processor.</p>
<p>Locally active DoFs are a superset of the <a class="el" href="DEALGlossary.html#GlossLocallyOwnedDof">locally owned DoFs</a> and a subset of the <a class="el" href="DEALGlossary.html#GlossLocallyRelevantDof">locally relevant DoFs</a>. </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossLocallyRelevantDof"></a><b>Locally relevant degrees of freedom</b> </dt>
<dd><p class="startdd">This concept identifies a subset of all degrees of freedom when using distributed meshes, see the <a class="el" href="group__distributed.html">Parallel computing with multiple processors using distributed memory</a> module. Locally relevant degrees of freedom are those that live on locally owned or ghost cells. Consequently, they may be owned by different processors.</p>
<p>Locally relevant DoFs are a superset of the <a class="el" href="DEALGlossary.html#GlossLocallyActiveDof">locally active DoFs.</a> </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossMaterialId"></a><b>Material id</b> </dt>
<dd><p class="startdd">Each cell of a triangulation has associated with it a property called "material id". It is commonly used in problems with heterogeneous coefficients to identify which part of the domain a cell is in and, consequently, which value the coefficient should have on this particular cell. The material id is inherited from mother to child cell upon mesh refinement.</p>
<p>The material id is set and queried using the <a class="el" href="classCellAccessor.html#a835e03f0bf287e79f0d3a6dfd7dfb8d1">CellAccessor::material_id</a>, <a class="el" href="classCellAccessor.html#abe9098e74cd5e1bec7c01abbbf056e13">CellAccessor::set_material_id</a> and <a class="el" href="classCellAccessor.html#ab01c9bd81b8927366f451a7b5d06adbc">CellAccessor::recursively_set_material_id</a> functions. </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="mg_paper"></a><b>Multigrid paper</b> </dt>
<dd><p class="startdd">The "multigrid paper" is a paper by B. Janssen and G. Kanschat, titled "Adaptive multilevel methods with local smoothing", that describes many of the algorithms and data structures used in the implementation of the multigrid framework of deal.II. It underlies the implementation of the classes that are used in <a class="el" href="step_16.html">step-16</a> for multigrid methods.</p>
<p>The full reference for this paper is as follows: </p>
<div class="fragment"><div class="line">Article{JK10,</div>
<div class="line">  author =       {B. Janssen and G. Kanschat},</div>
<div class="line">  title =        {Adaptive multilevel methods with local smoothing},</div>
<div class="line">  journal =      {submitted},</div>
<div class="line">  year =         2010</div>
<div class="line">}</div>
</div><!-- fragment --><p> It is available as Technical Report IAMCS-2009-131 from the <a href="http://iamcs.tamu.edu/research_sub.php?tab_sub=research&amp;cms_id=8">Institute for Applied Mathematics and Computational Science, Texas A&amp;M University</a>. </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossNodes"></a><b>Node values or node functionals</b>  </dt>
<dd><p class="startdd">It is customary to define a <a class="el" href="classFiniteElement.html">FiniteElement</a> as a pair consisting of a local function space and a set of node values <img class="formulaInl" alt="$N_i$" src="form_164.png"/> on the mesh cells (usually defined on the <a class="el" href="DEALGlossary.html#GlossReferenceCell">reference cell</a>). Then, the basis of the local function space is chosen such that <img class="formulaInl" alt="$N_i(v_j) = \delta_{ij}$" src="form_165.png"/>, the Kronecker delta.</p>
<p>This splitting has several advantages, concerning analysis as well as implementation. For the analysis, it means that conformity with certain spaces (<a class="el" href="classFiniteElementData.html#a0cd5f34c3ab828fac31004f3b52921a1">FiniteElementData::Conformity</a>), e.g. continuity, is up to the node values. In deal.II, it helps simplifying the implementation of more complex elements like <a class="el" href="classFE__RaviartThomas.html">FE_RaviartThomas</a> considerably.</p>
<p>Examples for node functionals are values in <a class="el" href="DEALGlossary.html#GlossSupport">support points</a> and moments with respect to Legendre polynomials. Let us give some examples:</p>
<table class="doxtable">
<tr>
<th>Element </th><th><a class="el" href="classFunction.html">Function</a> space </th><th>Node values </th></tr>
<tr>
<th><a class="el" href="classFE__Q.html">FE_Q</a>, <a class="el" href="classFE__DGQ.html">FE_DGQ</a> </th><td><em>Q<sub>k</sub></em> </td><td>values in support points </td></tr>
<tr>
<th><a class="el" href="classFE__DGP.html">FE_DGP</a> </th><td><em>P<sub>k</sub></em> </td><td>moments with respect to Legendre polynomials </td></tr>
<tr>
<th><a class="el" href="classFE__RaviartThomas.html">FE_RaviartThomas</a> (2d) </th><td><em>Q<sub>k+1,k</sub> x Q<sub>k,k+1</sub></em> </td><td>moments on edges and in the interior </td></tr>
<tr>
<th><a class="el" href="classFE__RaviartThomasNodal.html">FE_RaviartThomasNodal</a> </th><td><em>Q<sub>k+1,k</sub> x Q<sub>k,k+1</sub></em> </td><td>Gauss points on edges(faces) and anisotropic Gauss points in the interior </td></tr>
</table>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossPrimitive"></a><b>Primitive finite elements</b> </dt>
<dd><p class="startdd">A finite element (described by its shape functions) is primitive if there is a unique relation from shape function number to vector <a class="el" href="DEALGlossary.html#GlossComponent">component</a>. What this means is that each shape function of a vector-valued element has exactly one nonzero component if an element is primitive. This includes, in particular, all scalar elements as well as vector-valued elements assembled via the <a class="el" href="classFESystem.html">FESystem</a> class from other primitive (for example scalar) elements as shown in <a class="el" href="step_8.html">step-8</a>, <a class="el" href="step_29.html">step-29</a>, <a class="el" href="step_22.html">step-22</a> and several others. On the other hand, the <a class="el" href="classFE__RaviartThomas.html">FE_RaviartThomas</a> class used in <a class="el" href="step_20.html">step-20</a> and <a class="el" href="step_21.html">step-21</a>, or the <a class="el" href="classFE__Nedelec.html">FE_Nedelec</a> class provide non-primitive finite elements because there, each vector-value shape function may have several non-zero components.</p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossReferenceCell"></a><b>Reference cell</b> </dt>
<dd><p class="startdd">The hypercube [0,1]<sup>dim</sup>, on which all parametric finite element shape functions are defined. Many properties of the reference cell are described by the <a class="el" href="structGeometryInfo.html">GeometryInfo</a> class.</p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossSerialization"></a><b>Serialization</b>  </dt>
<dd><p class="startdd">The term "serialization" refers to the process of writing the state of an object to a stream and later retrieve it again. A typical use case is to save the state of a program to disk for possible later resurrection, often in the context of checkpoint/restart strategies for long running computations or on computers that aren't very reliable (e.g. on very large clusters where individual nodes occasionally fail and then bring down an entire MPI job). In either case, one wants to occasionally save the state of the program so that, upon failure, one can restart it at that point rather than having to run it again from the beginning.</p>
<p>deal.II implements serialization facilities by implementing the necessary interfaces for the <a href="http://www.boost.org/doc/libs/1_46_1/libs/serialization/doc/index.html" target="_top">BOOST serialization</a> library. See there for examples on how to save and restore objects. </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossShape"></a><b>Shape functions</b> </dt>
<dd><p class="startdd">The restriction of the finite element basis functions to a single grid cell.</p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossSubdomainId"></a><b>Subdomain id</b> </dt>
<dd><p class="startdd">Each cell of a triangulation has associated with it a property called the "subdomain id" that can be queried using a call like <code>cell-&gt;subdomain_id()</code> and that can be set for example by using <code>cell-&gt;set_subdomain_id(13)</code>. (These calls resolve to <a class="el" href="classCellAccessor.html#a154d3931d2fb2e477bb383db571ac0f6">CellAccessor::subdomain_id()</a> and <a class="el" href="classCellAccessor.html#ad34738e065d63bd73b138928ccaae349">CellAccessor::set_subdomain_id()</a>, respectively.) While in principle this property can be used in any way application programs deem useful (it is simply an integer associated with each cell that can indicate whatever you want), at least for programs that run in parallel it usually denotes the processor a cell is associated with.</p>
<p>For programs that are parallelized based on MPI but where each processor stores the entire triangulation (as in, for example, <a class="el" href="step_18.html">step-18</a>, but not in <a class="el" href="step_32.html">step-32</a>), subdomain ids are assigned to cells by partitioning a mesh, and each MPI process then only works on those cells it "owns", i.e. that belong to a subdomain that the processor is associated with (traditionally, this is the case for the subdomain id whose numerical value coincides with the rank of the MPI process within the MPI communicator). Partitioning is typically done using the GridTools::partition() function, but any other method can also be used to do this.</p>
<p>On the other hand, for programs that are parallelized using MPI but where meshes are held distributed across several processors using the <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> and parallel::distributed::DoFHandler classes, the subdomain id of cells are tied to the processor that owns the cell. In other words, querying the subdomain id of a cell tells you if the cell is owned by the current processor (i.e. if <code>cell-&gt;subdomain_id() == triangulation.parallel::distributed::Triangulation::locally_owned_subdomain()</code>) or by another processor. In the parallel distributed case, subdomain ids are only assigned to cells that the current processor owns as well as the immediately adjacent <a class="el" href="DEALGlossary.html#GlossGhostCell">ghost cells</a>. Cells further away are held on each processor to ensure that every MPI process has access to the full coarse grid as well as to ensure the invariant that neighboring cells differ by at most one refinement level. These cells are called "artificial" (see <a class="el" href="DEALGlossary.html#GlossArtificialCell">here</a>) and have the special subdomain id value types::artificial_subdomain_id.</p>
<p>In addition to regular subdomain ids, there is a second, closely related set of flags that are associated with each cell: "level subdomain ids." These exist not only for active cells but, in fact, for every cell in a mesh hierarchy. Their meaning is entirely analogous to the regular subdomain ids, but they are read and written by the <a class="el" href="classCellAccessor.html#a6a603c4ffeb90974fa7be9f5d85a81a4">CellAccessor::level_subdomain_id()</a> and <a class="el" href="classCellAccessor.html#aabcb6cdb81d137af8816324b25119e0e">CellAccessor::set_level_subdomain_id()</a> functions. </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossSupport"></a><b>Support points</b> </dt>
<dd><p class="startdd">Support points are by definition those points <img class="formulaInl" alt="$p_i$" src="form_166.png"/>, such that for the shape functions <img class="formulaInl" alt="$v_j$" src="form_167.png"/> holds <img class="formulaInl" alt="$v_j(p_i) = \delta_{ij}$" src="form_168.png"/>. Therefore, a finite element interpolation can be defined uniquely by the values in the support points.</p>
<p>Lagrangian elements fill the vector accessed by FiniteElementBase::get_unit_support_points(), such that the function FiniteElementBase::has_support_points() returns <code>true</code>. Naturally, these support points are on the <a class="el" href="DEALGlossary.html#GlossReferenceCell">reference cell</a>. Then, <a class="el" href="classFEValues.html">FEValues</a> can be used (in conjunction with a <a class="el" href="classMapping.html">Mapping</a>) to access support points on the actual grid cells.</p>
<dl class="section note"><dt>Note</dt><dd>The concept of <a class="el" href="DEALGlossary.html#GlossSupport">support points</a> is restricted to the finite element families based on Lagrange interpolation. For a more general concept, see <a class="el" href="DEALGlossary.html#GlossGeneralizedSupport">generalized support points</a>. </dd></dl>
</dd>
<dt class="glossary"><a class="anchor" id="GlossTargetComponent"></a><b>Target component</b> </dt>
<dd><p class="startdd">When vectors and matrices are grouped into blocks by component, it is often desirable to collect several of the original components into a single one. This could be for instance, grouping the velocities of a Stokes system into a single block.</p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossUnitCell"></a><b>Unit cell</b> </dt>
<dd><p class="startdd">See <a class="el" href="DEALGlossary.html#GlossReferenceCell">Reference cell</a>.</p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossUnitSupport"></a><b>Unit support points</b> </dt>
<dd><p class="startdd">These are the <a class="el" href="DEALGlossary.html#GlossSupport">support points</a> on the reference cell, defined in FiniteElementBase. For example, the usual Q1 element in 1d has support points at <code>x=0</code> and <code>x=1</code> (and similarly, in higher dimensions at the vertices of the unit square or cube). On the other hand, higher order Lagrangian elements have unit support points also in the interior of the unit line, square, or cube. </p>
<p class="enddd"></p>
</dd>
<dt class="glossary"><a class="anchor" id="GlossUserFlags"></a><b>User flags</b> </dt>
<dd><p class="startdd">A triangulation offers one bit per line, quad, etc for user flags. This field can be accessed as all other data using iterators, using the syntax </p>
<div class="fragment"><div class="line">cell-&gt;set_user_flag();                <span class="comment">// set the user flag of a cell</span></div>
<div class="line"><span class="keywordflow">if</span> (cell-&gt;user_flag_set() == <span class="keyword">false</span>)   <span class="comment">// if cell hasn&#39;t been flagged yet</span></div>
<div class="line">  {</div>
<div class="line">     cell-&gt;face(0)-&gt;set_user_flag();  <span class="comment">// flag its first face</span></div>
<div class="line">  }</div>
</div><!-- fragment --><p> Typically, this user flag is used if an algorithm walks over all cells and needs information whether another cell, e.g. a neighbor, has already been processed. Similarly, it can be used to flag faces, quads or lines at the boundary for which some operation has already been performed. The latter is often useful since a loop such as </p>
<div class="fragment"><div class="line"><span class="comment">// in 3d</span></div>
<div class="line"><span class="keywordflow">for</span> (cell=dof_handler.begin_active();</div>
<div class="line">     cell!=dof_handler.end(); ++cell)</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> l=0; l&lt;GeometryInfo&lt;dim&gt;::lines_per_cell; ++l)</div>
<div class="line">    <span class="keywordflow">if</span> (cell-&gt;line(l)-&gt;at_boundary())</div>
<div class="line">      {</div>
<div class="line">         <span class="keywordflow">do</span> something with <span class="keyword">this</span> line</div>
<div class="line">      }</div>
</div><!-- fragment --><p> encounters some boundary lines more than once. Consequently, one would set the user flag of the line in the body of the loop, and only enter the body if the user flag had not previously been set. There are a number of additional functions that can be accessed through the iterator interface; see the <a class="el" href="classTriaAccessor.html">TriaAccessor</a> class for more information. Note that there are no user flags that can be associated with vertices; however, since vertices are numbered consecutively, this can easily be emulated in user code using a vector of bools.</p>
<p>There are two functions, <a class="el" href="classTriangulation.html#aaf0b21f16759e23f3d0d731301eec4fb">Triangulation::save_user_flags</a> and <a class="el" href="classTriangulation.html#af3612ed3c7f7f9cccd3003d85b6f7350">Triangulation::load_user_flags</a> which write and read these flags to and from a stream or a vector of bools. Unlike <a class="el" href="classTriangulation.html#abf284939143dc421b87dfb40756c1e71">Triangulation::save_refine_flags</a> and <a class="el" href="classTriangulation.html#a43fc07c3f9e1f02658ca556f41087c85">Triangulation::load_refine_flags</a>, these two functions store and read the flags of all used lines, quads, etc, i.e., not only of the active ones.</p>
<p>If you want to store more specific user flags, you can use the functions <a class="el" href="classTriangulation.html#a998ac27a1c0e2cd403bbeff5f0e55a07">Triangulation::save_user_flags_line</a> and <a class="el" href="classTriangulation.html#a25190c31d16cde2a01fa0f2318aa0b74">Triangulation::load_user_flags_line</a> and the similarly for quads, etc.</p>
<p>As for the refinement and coarsening flags, there exist two versions of these functions, one which reads/writes from a stream and one which does so from a <code>vector&lt;bool&gt;</code>. The latter is used to store flags temporarily, while the first is used to store them in a file.</p>
<p>It is good practice to clear the user flags using the <a class="el" href="classTriangulation.html#aaa726b33b52f694cfca48fae8e761661">Triangulation::clear_user_flags()</a> function before usage, since it is often necessary to use the flags in more than one function. If the flags may be in use at the time a function that needs them is called, then this function should save and restore the flags as described above.</p>
<dl class="section note"><dt>Note</dt><dd>If more information than just a single boolean flag needs to be stored with a cell, line, or face, then see about <a class="el" href="DEALGlossary.html#GlossUserData">user data</a>. </dd></dl>
</dd>
<dt class="glossary"><a class="anchor" id="GlossUserData"></a><b>User pointers and user indices</b> </dt>
<dd><p class="startdd">Just like the <a class="el" href="DEALGlossary.html#GlossUserFlags">user flags</a>, the <a class="el" href="classTriangulation.html">Triangulation</a> class offers a field for each line, quad and hex in which to store more descriptive data than just a single boolean flag. This is called "user data" and the data that can be stored in it is either a single unsigned integer or a void pointer. Both are typically used to index into a bigger array that contains more detailed data an application wants to attach to a mesh entity.</p>
<p>User data is stored and retrieved in the following manner: </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (cell=dof_handler.begin_active();</div>
<div class="line">     cell!=dof_handler.end(); ++cell)</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> l=0; l&lt;GeometryInfo&lt;dim&gt;::lines_per_cell; ++l)</div>
<div class="line">    <span class="keywordflow">if</span> (cell-&gt;line(l)-&gt;at_boundary())</div>
<div class="line">      {</div>
<div class="line">        cell-&gt;line(l)-&gt;set_user_index(42);</div>
<div class="line">      }</div>
</div><!-- fragment --><p> Similarly, there are functions <a class="el" href="classTriaAccessor.html#a3ea4e3d51d96d3c45e7fcd229cf4443d">TriaAccessor::set_user_pointer</a> to set a pointer, and <a class="el" href="classTriaAccessor.html#a532f03a3139203fe80724ca69dd6b031">TriaAccessor::user_index</a> and <a class="el" href="classTriaAccessor.html#a9c0ce458171d13d49ab7d8d1ec2564f0">TriaAccessor::user_pointer</a> to retrieve the index and pointer. To clear all user indices or pointers, use <a class="el" href="classTriangulation.html#a26562806fd764afdffb973dce92554e8">Triangulation::clear_user_data()</a>. As with flags, there are functions that allow to save and restore user data, either for all entities of the mesh hierarchy or for lines, quads or hexes separately. There are a number of additional functions that can be accessed through the iterator interface; see the <a class="el" href="classTriaAccessor.html">TriaAccessor</a> class for more information.</p>
<dl class="section note"><dt>Note</dt><dd>User pointers and user indices are stored in the same place. In order to avoid unwanted conversions, <a class="el" href="classTriangulation.html">Triangulation</a> checks which one of them is in use and does not allow access to the other one, until <a class="el" href="classTriangulation.html#a26562806fd764afdffb973dce92554e8">Triangulation::clear_user_data()</a> has been called.</dd>
<dd>
The usual warning about the missing type safety of <code>void</code> pointers are obviously in place here; responsibility for correctness of types etc lies entirely with the user of the pointer.</dd></dl>
</dd>
<dt class="glossary"><a class="anchor" id="workstream_paper"></a><b>WorkStream paper</b> </dt>
<dd><p class="startdd">The "%WorkStream paper" is a paper by B. Turcksin, M. Kronbichler and W. Bangerth that discusses the design and implementation of <a class="el" href="namespaceWorkStream.html">WorkStream</a>. <a class="el" href="namespaceWorkStream.html">WorkStream</a> is, at its core, a design pattern, i.e., something that is used over and over in finite element codes and that can, consequently, be implemented generically. In particular, the paper lays out the motivation for this pattern and then proposes different ways of implementing it. It also compares the performance of different implementations.</p>
<p>The paper is currently in preparation. </p>
<p class="enddd"></p>
</dd>
</dl>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jan 27 2014 15:26:05 for The deal.II Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
