<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>The deal.II Library: DoFTools Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="http://www.dealii.org/deal.ico"></link>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2014 by the deal.II authors"></meta>
<meta name="deal.II-version" content="8.1.0"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 8.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">DoFTools Namespace Reference<div class="ingroups"><a class="el" href="group__dofs.html">Degrees of Freedom</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ad31df71a29dd76de9b4ab241b2527160"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> { <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">none</a>, 
<a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">always</a>, 
<a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a155b9e72113d7008c60732d350bfbb7a">nonzero</a>
 }</td></tr>
<tr class="separator:ad31df71a29dd76de9b4ab241b2527160"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac6684ffe63aafe7a1d4cf252e102caca"><td class="memTemplParams" colspan="2">template&lt;class DH , typename Number &gt; </td></tr>
<tr class="memitem:ac6684ffe63aafe7a1d4cf252e102caca"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#ac6684ffe63aafe7a1d4cf252e102caca">distribute_cell_to_dof_vector</a> (const DH &amp;dof_handler, const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;cell_data, <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;dof_data, const unsigned <a class="el" href="classint.html">int</a> component=0)</td></tr>
<tr class="separator:ac6684ffe63aafe7a1d4cf252e102caca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac12e7f8dc1671065e2f0c87b1ed22d3d"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ac12e7f8dc1671065e2f0c87b1ed22d3d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#ac12e7f8dc1671065e2f0c87b1ed22d3d">extract_dofs</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask, std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;selected_dofs)</td></tr>
<tr class="separator:ac12e7f8dc1671065e2f0c87b1ed22d3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a787b0459452c3853d9e1bd427cb91c2d"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a787b0459452c3853d9e1bd427cb91c2d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a787b0459452c3853d9e1bd427cb91c2d">extract_dofs</a> (const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask, std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;selected_dofs)</td></tr>
<tr class="separator:a787b0459452c3853d9e1bd427cb91c2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5f443bc8e1e01d9cb321f0243af9c56"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:af5f443bc8e1e01d9cb321f0243af9c56"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#af5f443bc8e1e01d9cb321f0243af9c56">extract_dofs</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classBlockMask.html">BlockMask</a> &amp;block_mask, std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;selected_dofs)</td></tr>
<tr class="separator:af5f443bc8e1e01d9cb321f0243af9c56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab288dce13bec720c161eafa45d118c1a"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ab288dce13bec720c161eafa45d118c1a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#ab288dce13bec720c161eafa45d118c1a">extract_dofs</a> (const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classBlockMask.html">BlockMask</a> &amp;block_mask, std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;selected_dofs)</td></tr>
<tr class="separator:ab288dce13bec720c161eafa45d118c1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99e57408ccd16ea3f3dec4df8796e949"><td class="memTemplParams" colspan="2">template&lt;class DH &gt; </td></tr>
<tr class="memitem:a99e57408ccd16ea3f3dec4df8796e949"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a99e57408ccd16ea3f3dec4df8796e949">extract_level_dofs</a> (const unsigned <a class="el" href="classint.html">int</a> level, const DH &amp;dof, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask, std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;selected_dofs)</td></tr>
<tr class="separator:a99e57408ccd16ea3f3dec4df8796e949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29e7f96d7f886750692139f80eff964f"><td class="memTemplParams" colspan="2">template&lt;class DH &gt; </td></tr>
<tr class="memitem:a29e7f96d7f886750692139f80eff964f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a29e7f96d7f886750692139f80eff964f">extract_level_dofs</a> (const unsigned <a class="el" href="classint.html">int</a> level, const DH &amp;dof, const <a class="el" href="classBlockMask.html">BlockMask</a> &amp;component_mask, std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;selected_dofs)</td></tr>
<tr class="separator:a29e7f96d7f886750692139f80eff964f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3443bf48ca8a7dc319c91f813b10d614"><td class="memTemplParams" colspan="2">template&lt;class DH &gt; </td></tr>
<tr class="memitem:a3443bf48ca8a7dc319c91f813b10d614"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a3443bf48ca8a7dc319c91f813b10d614">extract_boundary_dofs</a> (const DH &amp;dof_handler, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask, std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;selected_dofs, const std::set&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> &gt; &amp;boundary_indicators=std::set&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> &gt;())</td></tr>
<tr class="separator:a3443bf48ca8a7dc319c91f813b10d614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3805e1a03726a653d15f8f87d74d2cc0"><td class="memTemplParams" colspan="2">template&lt;class DH &gt; </td></tr>
<tr class="memitem:a3805e1a03726a653d15f8f87d74d2cc0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a3805e1a03726a653d15f8f87d74d2cc0">extract_boundary_dofs</a> (const DH &amp;dof_handler, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask, <a class="el" href="classIndexSet.html">IndexSet</a> &amp;selected_dofs, const std::set&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> &gt; &amp;boundary_indicators=std::set&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> &gt;())</td></tr>
<tr class="separator:a3805e1a03726a653d15f8f87d74d2cc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70b2e7f03218907bf10b3b82c2813f3d"><td class="memTemplParams" colspan="2">template&lt;class DH &gt; </td></tr>
<tr class="memitem:a70b2e7f03218907bf10b3b82c2813f3d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a70b2e7f03218907bf10b3b82c2813f3d">extract_dofs_with_support_on_boundary</a> (const DH &amp;dof_handler, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask, std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;selected_dofs, const std::set&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> &gt; &amp;boundary_indicators=std::set&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> &gt;())</td></tr>
<tr class="separator:a70b2e7f03218907bf10b3b82c2813f3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93147b0911ad1a77fa3bdac768a43573"><td class="memTemplParams" colspan="2">template&lt;class DH &gt; </td></tr>
<tr class="memitem:a93147b0911ad1a77fa3bdac768a43573"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a93147b0911ad1a77fa3bdac768a43573">extract_constant_modes</a> (const DH &amp;dof_handler, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask, std::vector&lt; std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &gt; &amp;constant_modes)</td></tr>
<tr class="separator:a93147b0911ad1a77fa3bdac768a43573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1b36185489f9082fb5fdd81c6e7ff0c"><td class="memTemplParams" colspan="2">template&lt;class DH &gt; </td></tr>
<tr class="memitem:af1b36185489f9082fb5fdd81c6e7ff0c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#af1b36185489f9082fb5fdd81c6e7ff0c">get_active_fe_indices</a> (const DH &amp;dof_handler, std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;active_fe_indices)</td></tr>
<tr class="separator:af1b36185489f9082fb5fdd81c6e7ff0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a048c0faf9a9836e42b96f3f022b9e137"><td class="memTemplParams" colspan="2">template&lt;class DH &gt; </td></tr>
<tr class="memitem:a048c0faf9a9836e42b96f3f022b9e137"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a048c0faf9a9836e42b96f3f022b9e137">count_dofs_per_component</a> (const DH &amp;dof_handler, std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;dofs_per_component, const <a class="el" href="classbool.html">bool</a> vector_valued_once=false, std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; target_component=std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;())</td></tr>
<tr class="separator:a048c0faf9a9836e42b96f3f022b9e137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab82a3ef025ecca0f1bd7d8c1232d49ee"><td class="memTemplParams" colspan="2">template&lt;class DH &gt; </td></tr>
<tr class="memitem:ab82a3ef025ecca0f1bd7d8c1232d49ee"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#ab82a3ef025ecca0f1bd7d8c1232d49ee">count_dofs_per_block</a> (const DH &amp;dof, std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;dofs_per_block, const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;target_block=std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;())</td></tr>
<tr class="separator:ab82a3ef025ecca0f1bd7d8c1232d49ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99dd876d3a452deb4281d35e6c3a3e9f"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a99dd876d3a452deb4281d35e6c3a3e9f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a99dd876d3a452deb4281d35e6c3a3e9f">count_dofs_per_component</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;dofs_per_component, std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; target_component) <a class="el" href="group__Sparsity.html#ga0849dabf81f46d4d964e251c286784dd">DEAL_II_DEPRECATED</a></td></tr>
<tr class="separator:a99dd876d3a452deb4281d35e6c3a3e9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf101e71f1ed2458bbbfd94e6bf96594"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:acf101e71f1ed2458bbbfd94e6bf96594"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#acf101e71f1ed2458bbbfd94e6bf96594">compute_intergrid_constraints</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;coarse_grid, const unsigned <a class="el" href="classint.html">int</a> coarse_component, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;fine_grid, const unsigned <a class="el" href="classint.html">int</a> fine_component, const <a class="el" href="classInterGridMap.html">InterGridMap</a>&lt; <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &gt; &amp;coarse_to_fine_grid_map, <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints)</td></tr>
<tr class="separator:acf101e71f1ed2458bbbfd94e6bf96594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a024b972c7426a7cae7c7d4a1037f6723"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a024b972c7426a7cae7c7d4a1037f6723"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a024b972c7426a7cae7c7d4a1037f6723">compute_intergrid_transfer_representation</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;coarse_grid, const unsigned <a class="el" href="classint.html">int</a> coarse_component, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;fine_grid, const unsigned <a class="el" href="classint.html">int</a> fine_component, const <a class="el" href="classInterGridMap.html">InterGridMap</a>&lt; <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &gt; &amp;coarse_to_fine_grid_map, std::vector&lt; std::map&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>, float &gt; &gt; &amp;transfer_representation)</td></tr>
<tr class="separator:a024b972c7426a7cae7c7d4a1037f6723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea9fa329f0c4a00ee55782a9e0810db4"><td class="memTemplParams" colspan="2">template&lt;class DH &gt; </td></tr>
<tr class="memitem:aea9fa329f0c4a00ee55782a9e0810db4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#aea9fa329f0c4a00ee55782a9e0810db4">map_dof_to_boundary_indices</a> (const DH &amp;dof_handler, std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;mapping)</td></tr>
<tr class="separator:aea9fa329f0c4a00ee55782a9e0810db4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d4009b0841978f536aba2eac326c3a9"><td class="memTemplParams" colspan="2">template&lt;class DH &gt; </td></tr>
<tr class="memitem:a0d4009b0841978f536aba2eac326c3a9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a0d4009b0841978f536aba2eac326c3a9">map_dof_to_boundary_indices</a> (const DH &amp;dof_handler, const std::set&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> &gt; &amp;boundary_indicators, std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;mapping)</td></tr>
<tr class="separator:a0d4009b0841978f536aba2eac326c3a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10af6ba7adc43214e7b9f6815588f2aa"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a10af6ba7adc43214e7b9f6815588f2aa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a10af6ba7adc43214e7b9f6815588f2aa">map_dofs_to_support_points</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &gt; &amp;support_points)</td></tr>
<tr class="separator:a10af6ba7adc43214e7b9f6815588f2aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51e1e9f315add4b27edf56bba8a23b39"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a51e1e9f315add4b27edf56bba8a23b39"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a51e1e9f315add4b27edf56bba8a23b39">map_dofs_to_support_points</a> (const ::<a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &gt; &amp;support_points)</td></tr>
<tr class="separator:a51e1e9f315add4b27edf56bba8a23b39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4cd504dde0bf69ceb302b0bdf1ec494"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ad4cd504dde0bf69ceb302b0bdf1ec494"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#ad4cd504dde0bf69ceb302b0bdf1ec494">map_dofs_to_support_points</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, std::map&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>, <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &gt; &amp;support_points)</td></tr>
<tr class="separator:ad4cd504dde0bf69ceb302b0bdf1ec494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef1e4f3734a3bb0ed9d087e31178d359"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:aef1e4f3734a3bb0ed9d087e31178d359"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#aef1e4f3734a3bb0ed9d087e31178d359">map_dofs_to_support_points</a> (const ::<a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, std::map&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>, <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &gt; &amp;support_points)</td></tr>
<tr class="separator:aef1e4f3734a3bb0ed9d087e31178d359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a453bc87abb48ec5d10a0d80098b107b7"><td class="memTemplParams" colspan="2">template&lt;class DH , class Comp &gt; </td></tr>
<tr class="memitem:a453bc87abb48ec5d10a0d80098b107b7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a453bc87abb48ec5d10a0d80098b107b7">map_support_points_to_dofs</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; DH::dimension, DH::space_dimension &gt; &amp;mapping, const DH &amp;dof_handler, std::map&lt; <a class="el" href="classPoint.html">Point</a>&lt; DH::space_dimension &gt;, <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>, Comp &gt; &amp;point_to_index_map)</td></tr>
<tr class="separator:a453bc87abb48ec5d10a0d80098b107b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06f51715ec147af4902546355cfb4276"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a06f51715ec147af4902546355cfb4276"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a06f51715ec147af4902546355cfb4276">convert_couplings_to_blocks</a> (const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> &gt; &amp;table_by_component, std::vector&lt; <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> &gt; &gt; &amp;tables_by_block)</td></tr>
<tr class="separator:a06f51715ec147af4902546355cfb4276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a8572710e0cbec24e8497dd79e15a87"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, template&lt; int, int &gt; class DH&gt; </td></tr>
<tr class="memitem:ga2a8572710e0cbec24e8497dd79e15a87"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga2a8572710e0cbec24e8497dd79e15a87">make_zero_boundary_constraints</a> (const DH&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> boundary_indicator, <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;zero_boundary_constraints, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:ga2a8572710e0cbec24e8497dd79e15a87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e92f453a12cc02226a476ffdac6af3a"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, template&lt; int, int &gt; class DH&gt; </td></tr>
<tr class="memitem:ga0e92f453a12cc02226a476ffdac6af3a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga0e92f453a12cc02226a476ffdac6af3a">make_zero_boundary_constraints</a> (const DH&lt; dim, spacedim &gt; &amp;dof, <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;zero_boundary_constraints, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:ga0e92f453a12cc02226a476ffdac6af3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad019edb74f34dc6f550bba83a6922662"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ad019edb74f34dc6f550bba83a6922662"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#ad019edb74f34dc6f550bba83a6922662">convert_couplings_to_blocks</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> &gt; &amp;table_by_component, std::vector&lt; <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> &gt; &gt; &amp;tables_by_block)</td></tr>
<tr class="separator:ad019edb74f34dc6f550bba83a6922662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ff250bdce22971e55037d83ef6a706e"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a0ff250bdce22971e55037d83ef6a706e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a0ff250bdce22971e55037d83ef6a706e">dof_couplings_from_component_couplings</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe, const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> &gt; &amp;component_couplings)</td></tr>
<tr class="separator:a0ff250bdce22971e55037d83ef6a706e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54f5ca7f0a47ad33e6d6e2adc1761b28"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a54f5ca7f0a47ad33e6d6e2adc1761b28"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a54f5ca7f0a47ad33e6d6e2adc1761b28">dof_couplings_from_component_couplings</a> (const <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt; &amp;fe, const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> &gt; &amp;component_couplings)</td></tr>
<tr class="separator:a54f5ca7f0a47ad33e6d6e2adc1761b28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51c93a81b48b0879730f2ec459af9783"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga51c93a81b48b0879730f2ec459af9783">DeclException0</a> (ExcFiniteElementsDontMatch)</td></tr>
<tr class="separator:ga51c93a81b48b0879730f2ec459af9783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga044394ead1b6613f5eb7a4c0e74b2b5d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga044394ead1b6613f5eb7a4c0e74b2b5d">DeclException0</a> (ExcGridNotCoarser)</td></tr>
<tr class="separator:ga044394ead1b6613f5eb7a4c0e74b2b5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56ee9b282be48fdc83565a67c64674c7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga56ee9b282be48fdc83565a67c64674c7">DeclException0</a> (ExcGridsDontMatch)</td></tr>
<tr class="separator:ga56ee9b282be48fdc83565a67c64674c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga336e8e90cc9cda7a8542ed8f5fc55029"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga336e8e90cc9cda7a8542ed8f5fc55029">DeclException0</a> (ExcNoFESelected)</td></tr>
<tr class="separator:ga336e8e90cc9cda7a8542ed8f5fc55029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bef6c1580e69f6e07a10a719b4af1af"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga3bef6c1580e69f6e07a10a719b4af1af">DeclException0</a> (ExcInvalidBoundaryIndicator)</td></tr>
<tr class="separator:ga3bef6c1580e69f6e07a10a719b4af1af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Sparsity Pattern Generation</div></td></tr>
<tr class="memitem:gab627b1d4845c9526521dbd1be83469dc"><td class="memTemplParams" colspan="2">template&lt;class DH , class SparsityPattern &gt; </td></tr>
<tr class="memitem:gab627b1d4845c9526521dbd1be83469dc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#gab627b1d4845c9526521dbd1be83469dc">make_sparsity_pattern</a> (const DH &amp;dof, <a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;sparsity_pattern, const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints=<a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a>(), const <a class="el" href="classbool.html">bool</a> keep_constrained_dofs=true, const <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a> subdomain_id=<a class="el" href="namespacenumbers.html#a6fe5acece133d890bee8cc49ccd8ebfb">numbers::invalid_subdomain_id</a>)</td></tr>
<tr class="separator:gab627b1d4845c9526521dbd1be83469dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga250c261f4dba6c77834b2fa8d3bf7f5c"><td class="memTemplParams" colspan="2">template&lt;class DH , class SparsityPattern &gt; </td></tr>
<tr class="memitem:ga250c261f4dba6c77834b2fa8d3bf7f5c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga250c261f4dba6c77834b2fa8d3bf7f5c">make_sparsity_pattern</a> (const DH &amp;dof, const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> &gt; &amp;coupling, <a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;sparsity_pattern, const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints=<a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a>(), const <a class="el" href="classbool.html">bool</a> keep_constrained_dofs=true, const <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a> subdomain_id=<a class="el" href="namespacenumbers.html#a6fe5acece133d890bee8cc49ccd8ebfb">numbers::invalid_subdomain_id</a>)</td></tr>
<tr class="separator:ga250c261f4dba6c77834b2fa8d3bf7f5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9fe6189e8235d2fcaa0b6e4f5c249620"><td class="memTemplParams" colspan="2">template&lt;class DH , class SparsityPattern &gt; </td></tr>
<tr class="memitem:ga9fe6189e8235d2fcaa0b6e4f5c249620"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga9fe6189e8235d2fcaa0b6e4f5c249620">make_sparsity_pattern</a> (const DH &amp;dof, const std::vector&lt; std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &gt; &amp;mask, <a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;sparsity_pattern) <a class="el" href="group__Sparsity.html#ga0849dabf81f46d4d964e251c286784dd">DEAL_II_DEPRECATED</a></td></tr>
<tr class="separator:ga9fe6189e8235d2fcaa0b6e4f5c249620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3473fa2eb6d555499a53d1f59600beff"><td class="memTemplParams" colspan="2">template&lt;class DH , class SparsityPattern &gt; </td></tr>
<tr class="memitem:ga3473fa2eb6d555499a53d1f59600beff"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga3473fa2eb6d555499a53d1f59600beff">make_sparsity_pattern</a> (const DH &amp;dof_row, const DH &amp;dof_col, <a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;sparsity)</td></tr>
<tr class="separator:ga3473fa2eb6d555499a53d1f59600beff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60b493fa4c36d86a15c8599eef8c0e32"><td class="memTemplParams" colspan="2">template&lt;class DH , class SparsityPattern &gt; </td></tr>
<tr class="memitem:ga60b493fa4c36d86a15c8599eef8c0e32"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga60b493fa4c36d86a15c8599eef8c0e32">make_boundary_sparsity_pattern</a> (const DH &amp;dof, const std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;dof_to_boundary_mapping, <a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;sparsity_pattern)</td></tr>
<tr class="separator:ga60b493fa4c36d86a15c8599eef8c0e32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0f7a1d36c8b92a17bf8c4d939d56fb1"><td class="memTemplParams" colspan="2">template&lt;class DH , class SparsityPattern &gt; </td></tr>
<tr class="memitem:gae0f7a1d36c8b92a17bf8c4d939d56fb1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#gae0f7a1d36c8b92a17bf8c4d939d56fb1">make_boundary_sparsity_pattern</a> (const DH &amp;dof, const typename <a class="el" href="structFunctionMap.html">FunctionMap</a>&lt; DH::space_dimension &gt;::type &amp;boundary_indicators, const std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;dof_to_boundary_mapping, <a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;sparsity)</td></tr>
<tr class="separator:gae0f7a1d36c8b92a17bf8c4d939d56fb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c77cf114c08113c66eb68904dab7f02"><td class="memTemplParams" colspan="2">template&lt;class DH , class SparsityPattern &gt; </td></tr>
<tr class="memitem:ga3c77cf114c08113c66eb68904dab7f02"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga3c77cf114c08113c66eb68904dab7f02">make_flux_sparsity_pattern</a> (const DH &amp;dof_handler, <a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;sparsity_pattern)</td></tr>
<tr class="separator:ga3c77cf114c08113c66eb68904dab7f02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7e3920b3d248d53e65997d8bce110a2"><td class="memTemplParams" colspan="2">template&lt;class DH , class SparsityPattern &gt; </td></tr>
<tr class="memitem:gaf7e3920b3d248d53e65997d8bce110a2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#gaf7e3920b3d248d53e65997d8bce110a2">make_flux_sparsity_pattern</a> (const DH &amp;dof_handler, <a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;sparsity_pattern, const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints, const <a class="el" href="classbool.html">bool</a> keep_constrained_dofs=true, const <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a> subdomain_id=<a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>)</td></tr>
<tr class="separator:gaf7e3920b3d248d53e65997d8bce110a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3fda57552521d870cc7737b1fde71014"><td class="memTemplParams" colspan="2">template&lt;class DH , class SparsityPattern &gt; </td></tr>
<tr class="memitem:ga3fda57552521d870cc7737b1fde71014"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga3fda57552521d870cc7737b1fde71014">make_flux_sparsity_pattern</a> (const DH &amp;dof, <a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;sparsity, const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> &gt; &amp;int_mask, const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> &gt; &amp;flux_mask)</td></tr>
<tr class="separator:ga3fda57552521d870cc7737b1fde71014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Hanging Nodes</div></td></tr>
<tr class="memitem:gabe9d21d4bb33ce556a6e6e80c2bf4b41"><td class="memTemplParams" colspan="2">template&lt;class DH &gt; </td></tr>
<tr class="memitem:gabe9d21d4bb33ce556a6e6e80c2bf4b41"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#gabe9d21d4bb33ce556a6e6e80c2bf4b41">make_hanging_node_constraints</a> (const DH &amp;dof_handler, <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints)</td></tr>
<tr class="separator:gabe9d21d4bb33ce556a6e6e80c2bf4b41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86bd4cc354a5278005202d57257c178c"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ga86bd4cc354a5278005202d57257c178c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga86bd4cc354a5278005202d57257c178c">extract_hanging_node_dofs</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;selected_dofs)</td></tr>
<tr class="separator:ga86bd4cc354a5278005202d57257c178c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Periodic Boundary Conditions</div></td></tr>
<tr class="memitem:ae23173d20bc1b6c56c6d3a4aa2cbae73"><td class="memTemplParams" colspan="2">template&lt;typename FaceIterator &gt; </td></tr>
<tr class="memitem:ae23173d20bc1b6c56c6d3a4aa2cbae73"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#ae23173d20bc1b6c56c6d3a4aa2cbae73">make_periodicity_constraints</a> (const FaceIterator &amp;face_1, const typename <a class="el" href="structidentity.html">identity</a>&lt; FaceIterator &gt;::type &amp;face_2,::<a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraint_matrix, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>(), const <a class="el" href="classbool.html">bool</a> face_orientation=true, const <a class="el" href="classbool.html">bool</a> face_flip=false, const <a class="el" href="classbool.html">bool</a> face_rotation=false)</td></tr>
<tr class="separator:ae23173d20bc1b6c56c6d3a4aa2cbae73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5a4314d099943086c94ed7fc40a68f3"><td class="memTemplParams" colspan="2">template&lt;typename DH &gt; </td></tr>
<tr class="memitem:ae5a4314d099943086c94ed7fc40a68f3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#ae5a4314d099943086c94ed7fc40a68f3">make_periodicity_constraints</a> (const DH &amp;dof_handler, const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> b_id1, const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> b_id2, const <a class="el" href="classint.html">int</a> direction,::<a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraint_matrix, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:ae5a4314d099943086c94ed7fc40a68f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6c4e4e628ed1e91d9bd2bf8a0a2ed35"><td class="memTemplParams" colspan="2">template&lt;typename DH &gt; </td></tr>
<tr class="memitem:ae6c4e4e628ed1e91d9bd2bf8a0a2ed35"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#ae6c4e4e628ed1e91d9bd2bf8a0a2ed35">make_periodicity_constraints</a> (const DH &amp;dof_handler, const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> b_id1, const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> b_id2, const <a class="el" href="classint.html">int</a> direction,::<a class="el" href="classTensor.html">Tensor</a>&lt; 1, DH::space_dimension &gt; &amp;offset,::<a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraint_matrix, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:ae6c4e4e628ed1e91d9bd2bf8a0a2ed35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e4b3e5e6a35b3d58412b90c134c06e3"><td class="memTemplParams" colspan="2">template&lt;typename DH &gt; </td></tr>
<tr class="memitem:a9e4b3e5e6a35b3d58412b90c134c06e3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a9e4b3e5e6a35b3d58412b90c134c06e3">make_periodicity_constraints</a> (const DH &amp;dof_handler, const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> b_id, const <a class="el" href="classint.html">int</a> direction,::<a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraint_matrix, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:a9e4b3e5e6a35b3d58412b90c134c06e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b0a5fc2f560a364c71748a0b9bc1c2a"><td class="memTemplParams" colspan="2">template&lt;typename DH &gt; </td></tr>
<tr class="memitem:a2b0a5fc2f560a364c71748a0b9bc1c2a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a2b0a5fc2f560a364c71748a0b9bc1c2a">make_periodicity_constraints</a> (const DH &amp;dof_handler, const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> b_id, const <a class="el" href="classint.html">int</a> direction,::<a class="el" href="classTensor.html">Tensor</a>&lt; 1, DH::space_dimension &gt; &amp;offset,::<a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraint_matrix, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:a2b0a5fc2f560a364c71748a0b9bc1c2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1e47a85c21c37c77eee96dfd81c3123"><td class="memTemplParams" colspan="2">template&lt;typename DH &gt; </td></tr>
<tr class="memitem:ad1e47a85c21c37c77eee96dfd81c3123"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#ad1e47a85c21c37c77eee96dfd81c3123">make_periodicity_constraints</a> (const std::vector&lt; <a class="el" href="structGridTools_1_1PeriodicFacePair.html">GridTools::PeriodicFacePair</a>&lt; typename DH::cell_iterator &gt; &gt; &amp;periodic_faces,::<a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraint_matrix, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:ad1e47a85c21c37c77eee96dfd81c3123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Parallelization and domain decomposition</div></td></tr>
<tr class="memitem:a670cceec4eaad94c7d4fd44a1e54684e"><td class="memTemplParams" colspan="2">template&lt;class DH &gt; </td></tr>
<tr class="memitem:a670cceec4eaad94c7d4fd44a1e54684e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a670cceec4eaad94c7d4fd44a1e54684e">extract_subdomain_dofs</a> (const DH &amp;dof_handler, const <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a> subdomain_id, std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;selected_dofs)</td></tr>
<tr class="separator:a670cceec4eaad94c7d4fd44a1e54684e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a085f6c6785dda73f1540bce6b9ac1215"><td class="memTemplParams" colspan="2">template&lt;class DH &gt; </td></tr>
<tr class="memitem:a085f6c6785dda73f1540bce6b9ac1215"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a085f6c6785dda73f1540bce6b9ac1215">extract_locally_owned_dofs</a> (const DH &amp;dof_handler, <a class="el" href="classIndexSet.html">IndexSet</a> &amp;dof_set)</td></tr>
<tr class="separator:a085f6c6785dda73f1540bce6b9ac1215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3de42868eedd688d16cd7f0105b55b4"><td class="memTemplParams" colspan="2">template&lt;class DH &gt; </td></tr>
<tr class="memitem:ab3de42868eedd688d16cd7f0105b55b4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#ab3de42868eedd688d16cd7f0105b55b4">extract_locally_active_dofs</a> (const DH &amp;dof_handler, <a class="el" href="classIndexSet.html">IndexSet</a> &amp;dof_set)</td></tr>
<tr class="separator:ab3de42868eedd688d16cd7f0105b55b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf1b404a747264c19057374732186020"><td class="memTemplParams" colspan="2">template&lt;class DH &gt; </td></tr>
<tr class="memitem:aaf1b404a747264c19057374732186020"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#aaf1b404a747264c19057374732186020">extract_locally_relevant_dofs</a> (const DH &amp;dof_handler, <a class="el" href="classIndexSet.html">IndexSet</a> &amp;dof_set)</td></tr>
<tr class="separator:aaf1b404a747264c19057374732186020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21ed56f06e60447282b0948cfed2537c"><td class="memTemplParams" colspan="2">template&lt;class DH &gt; </td></tr>
<tr class="memitem:a21ed56f06e60447282b0948cfed2537c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a21ed56f06e60447282b0948cfed2537c">get_subdomain_association</a> (const DH &amp;dof_handler, std::vector&lt; <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a> &gt; &amp;subdomain)</td></tr>
<tr class="separator:a21ed56f06e60447282b0948cfed2537c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95c92f74cc712dd820ed42d39ae45e10"><td class="memTemplParams" colspan="2">template&lt;class DH &gt; </td></tr>
<tr class="memitem:a95c92f74cc712dd820ed42d39ae45e10"><td class="memTemplItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a95c92f74cc712dd820ed42d39ae45e10">count_dofs_with_subdomain_association</a> (const DH &amp;dof_handler, const <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a> subdomain)</td></tr>
<tr class="separator:a95c92f74cc712dd820ed42d39ae45e10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a240e10d665a8ac819961505c0c80811d"><td class="memTemplParams" colspan="2">template&lt;class DH &gt; </td></tr>
<tr class="memitem:a240e10d665a8ac819961505c0c80811d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a240e10d665a8ac819961505c0c80811d">count_dofs_with_subdomain_association</a> (const DH &amp;dof_handler, const <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a> subdomain, std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;n_dofs_on_subdomain)</td></tr>
<tr class="separator:a240e10d665a8ac819961505c0c80811d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12a8cd7efa980f18561ced31e51fb3d4"><td class="memTemplParams" colspan="2">template&lt;class DH &gt; </td></tr>
<tr class="memitem:a12a8cd7efa980f18561ced31e51fb3d4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classIndexSet.html">IndexSet</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a12a8cd7efa980f18561ced31e51fb3d4">dof_indices_with_subdomain_association</a> (const DH &amp;dof_handler, const <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a> subdomain)</td></tr>
<tr class="separator:a12a8cd7efa980f18561ced31e51fb3d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Dof indices for patches</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Create structures containing a large set of degrees of freedom for small patches of cells. The resulting objects can be used in <a class="el" href="classRelaxationBlockSOR.html">RelaxationBlockSOR</a> and related classes to implement Schwarz preconditioners and smoothers, where the subdomains consist of small numbers of cells only. </p>
</div></td></tr>
<tr class="memitem:afaef07da690a1356732c806bed0f02c6"><td class="memTemplParams" colspan="2">template&lt;class DH , class Sparsity &gt; </td></tr>
<tr class="memitem:afaef07da690a1356732c806bed0f02c6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#afaef07da690a1356732c806bed0f02c6">make_cell_patches</a> (Sparsity &amp;block_list, const DH &amp;dof_handler, const unsigned <a class="el" href="classint.html">int</a> level, const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;selected_dofs=std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt;(), <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> offset=0)</td></tr>
<tr class="separator:afaef07da690a1356732c806bed0f02c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad46592434d04dd1b0b7b545e549021f0"><td class="memTemplParams" colspan="2">template&lt;class DH &gt; </td></tr>
<tr class="memitem:ad46592434d04dd1b0b7b545e549021f0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#ad46592434d04dd1b0b7b545e549021f0">make_vertex_patches</a> (<a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;block_list, const DH &amp;dof_handler, const unsigned <a class="el" href="classint.html">int</a> level, const <a class="el" href="classbool.html">bool</a> interior_dofs_only, const <a class="el" href="classbool.html">bool</a> boundary_patches=false, const <a class="el" href="classbool.html">bool</a> level_boundary_patches=false, const <a class="el" href="classbool.html">bool</a> single_cell_patches=false)</td></tr>
<tr class="separator:ad46592434d04dd1b0b7b545e549021f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2866a8b7f331a5a4c3d8b275f95abf72"><td class="memTemplParams" colspan="2">template&lt;class DH &gt; </td></tr>
<tr class="memitem:a2866a8b7f331a5a4c3d8b275f95abf72"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a2866a8b7f331a5a4c3d8b275f95abf72">make_child_patches</a> (<a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;block_list, const DH &amp;dof_handler, const unsigned <a class="el" href="classint.html">int</a> level, const <a class="el" href="classbool.html">bool</a> interior_dofs_only, const <a class="el" href="classbool.html">bool</a> boundary_dofs=false)</td></tr>
<tr class="separator:a2866a8b7f331a5a4c3d8b275f95abf72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2122dd7faaa8b70fc97ecad1565876d2"><td class="memTemplParams" colspan="2">template&lt;class DH &gt; </td></tr>
<tr class="memitem:a2122dd7faaa8b70fc97ecad1565876d2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a2122dd7faaa8b70fc97ecad1565876d2">make_single_patch</a> (<a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;block_list, const DH &amp;dof_handler, const unsigned <a class="el" href="classint.html">int</a> level, const <a class="el" href="classbool.html">bool</a> interior_dofs_only=false)</td></tr>
<tr class="separator:a2122dd7faaa8b70fc97ecad1565876d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This is a collection of functions operating on, and manipulating the numbers of degrees of freedom. The documentation of the member functions will provide more information, but for functions that exist in multiple versions, there are sections in this global documentation stating some commonalities.</p>
<p>All member functions are static, so there is no need to create an object of class <a class="el" href="namespaceDoFTools.html">DoFTools</a>.</p>
<h3>Setting up sparsity patterns</h3>
<p>When assembling system matrices, the entries are usually of the form <img class="formulaInl" alt="$a_{ij} = a(\phi_i, \phi_j)$" src="form_398.png"/>, where <img class="formulaInl" alt="$a$" src="form_399.png"/> is a bilinear functional, often an integral. When using sparse matrices, we therefore only need to reserve space for those <img class="formulaInl" alt="$a_{ij}$" src="form_400.png"/> only, which are nonzero, which is the same as to say that the basis functions <img class="formulaInl" alt="$\phi_i$" src="form_204.png"/> and <img class="formulaInl" alt="$\phi_j$" src="form_401.png"/> have a nonempty intersection of their support. Since the support of basis functions is bound only on cells on which they are located or to which they are adjacent, to determine the sparsity pattern it is sufficient to loop over all cells and connect all basis functions on each cell with all other basis functions on that cell. There may be finite elements for which not all basis functions on a cell connect with each other, but no use of this case is made since no examples where this occurs are known to the author.</p>
<h3>DoF numberings on boundaries</h3>
<p>When projecting the traces of functions to the boundary or parts thereof, one needs to build matrices and vectors that act only on those degrees of freedom that are located on the boundary, rather than on all degrees of freedom. One could do that by simply building matrices in which the entries for all interior DoFs are zero, but such matrices are always very rank deficient and not very practical to work with.</p>
<p>What is needed instead in this case is a numbering of the boundary degrees of freedom, i.e. we should enumerate all the degrees of freedom that are sitting on the boundary, and exclude all other (interior) degrees of freedom. The <a class="el" href="namespaceDoFTools.html#aea9fa329f0c4a00ee55782a9e0810db4">map_dof_to_boundary_indices()</a> function does exactly this: it provides a vector with as many entries as there are degrees of freedom on the whole domain, with each entry being the number in the numbering of the boundary or <a class="el" href="classDoFHandler.html#ae55efc004dadcafb52a8f6b6894e30fa">DoFHandler::invalid_dof_index</a> if the dof is not on the boundary.</p>
<p>With this vector, one can get, for any given degree of freedom, a unique number among those DoFs that sit on the boundary; or, if your DoF was interior to the domain, the result would be <a class="el" href="classDoFHandler.html#ae55efc004dadcafb52a8f6b6894e30fa">DoFHandler::invalid_dof_index</a>. We need this mapping, for example, to build the mass matrix on the boundary (for this, see <a class="el" href="group__constraints.html#ga60b493fa4c36d86a15c8599eef8c0e32">make_boundary_sparsity_pattern()</a> function, the corresponding section below, as well as the <a class="el" href="namespaceMatrixCreator.html">MatrixCreator</a> class documentation).</p>
<p>Actually, there are two <a class="el" href="namespaceDoFTools.html#aea9fa329f0c4a00ee55782a9e0810db4">map_dof_to_boundary_indices()</a> functions, one producing a numbering for all boundary degrees of freedom and one producing a numbering for only parts of the boundary, namely those parts for which the boundary indicator is listed in a set of indicators given to the function. The latter case is needed if, for example, we would only want to project the boundary values for the Dirichlet part of the boundary. You then give the function a list of boundary indicators referring to Dirichlet parts on which the projection is to be performed. The parts of the boundary on which you want to project need not be contiguous; however, it is not guaranteed that the indices of each of the boundary parts are continuous, i.e. the indices of degrees of freedom on different parts may be intermixed.</p>
<p>Degrees of freedom on the boundary but not on one of the specified boundary parts are given the index <a class="el" href="classDoFHandler.html#ae55efc004dadcafb52a8f6b6894e30fa">DoFHandler::invalid_dof_index</a>, as if they were in the interior. If no boundary indicator was given or if no face of a cell has a boundary indicator contained in the given list, the vector of new indices consists solely of <a class="el" href="classDoFHandler.html#ae55efc004dadcafb52a8f6b6894e30fa">DoFHandler::invalid_dof_index</a>.</p>
<p>(As a side note, for corner cases: The question what a degree of freedom on the boundary is, is not so easy. It should really be a degree of freedom of which the respective basis function has nonzero values on the boundary. At least for Lagrange elements this definition is equal to the statement that the off-point, or what deal.II calls support_point, of the shape function, i.e. the point where the function assumes its nominal value (for Lagrange elements this is the point where it has the function value 1), is located on the boundary. We do not check this directly, the criterion is rather defined through the information the finite element class gives: the <a class="el" href="classFiniteElement.html">FiniteElement</a> class defines the numbers of basis functions per vertex, per line, and so on and the basis functions are numbered after this information; a basis function is to be considered to be on the face of a cell (and thus on the boundary if the cell is at the boundary) according to it belonging to a vertex, line, etc but not to the interior of the cell. The finite element uses the same cell-wise numbering so that we can say that if a degree of freedom was numbered as one of the dofs on lines, we assume that it is located on the line. Where the off-point actually is, is a secret of the finite element (well, you can ask it, but we don't do it here) and not relevant in this context.)</p>
<h3>Setting up sparsity patterns for boundary matrices</h3>
<p>In some cases, one wants to only work with DoFs that sit on the boundary. One application is, for example, if rather than interpolating non-homogenous boundary values, one would like to project them. For this, we need two things: a way to identify nodes that are located on (parts of) the boundary, and a way to build matrices out of only degrees of freedom that are on the boundary (i.e. much smaller matrices, in which we do not even build the large zero block that stems from the fact that most degrees of freedom have no support on the boundary of the domain). The first of these tasks is done by the <a class="el" href="namespaceDoFTools.html#aea9fa329f0c4a00ee55782a9e0810db4">map_dof_to_boundary_indices()</a> function of this class (described above).</p>
<p>The second part requires us first to build a sparsity pattern for the couplings between boundary nodes, and then to actually build the components of this matrix. While actually computing the entries of these small boundary matrices is discussed in the <a class="el" href="namespaceMatrixCreator.html">MatrixCreator</a> class, the creation of the sparsity pattern is done by the create_boundary_sparsity_pattern() function. For its work, it needs to have a numbering of all those degrees of freedom that are on those parts of the boundary that we are interested in. You can get this from the <a class="el" href="namespaceDoFTools.html#aea9fa329f0c4a00ee55782a9e0810db4">map_dof_to_boundary_indices()</a> function. It then builds the sparsity pattern corresponding to integrals like <img class="formulaInl" alt="$\int_\Gamma \varphi_{b2d(i)} \varphi_{b2d(j)} dx$" src="form_402.png"/>, where <img class="formulaInl" alt="$i$" src="form_77.png"/> and <img class="formulaInl" alt="$j$" src="form_391.png"/> are indices into the matrix, and <img class="formulaInl" alt="$b2d(i)$" src="form_403.png"/> is the global DoF number of a degree of freedom sitting on a boundary (i.e., <img class="formulaInl" alt="$b2d$" src="form_404.png"/> is the inverse of the mapping returned by <a class="el" href="namespaceDoFTools.html#aea9fa329f0c4a00ee55782a9e0810db4">map_dof_to_boundary_indices()</a> function).</p>
<dl class="section author"><dt>Author</dt><dd>Wolfgang Bangerth, Guido Kanschat and others </dd></dl>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ad31df71a29dd76de9b4ab241b2527160"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">DoFTools::Coupling</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The flags used in tables by certain <code>make_*_pattern</code> functions to describe whether two components of the solution couple in the bilinear forms corresponding to cell or face terms. An example of using these flags is shown in the introduction of <a class="el" href="step_46.html">step-46</a>.</p>
<p>In the descriptions of the individual elements below, remember that these flags are used as elements of tables of size <a class="el" href="classFiniteElementData.html#a8d0f50693017e6c0f9d1ed774a847cd0">FiniteElement::n_components</a> times <a class="el" href="classFiniteElementData.html#a8d0f50693017e6c0f9d1ed774a847cd0">FiniteElement::n_components</a> where each element indicates whether two components do or do not couple. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba"></a>none&#160;</td><td class="fielddoc">
<p>Two components do not couple. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec"></a>always&#160;</td><td class="fielddoc">
<p>Two components do couple. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad31df71a29dd76de9b4ab241b2527160a155b9e72113d7008c60732d350bfbb7a"></a>nonzero&#160;</td><td class="fielddoc">
<p>Two components couple only if their shape functions are both nonzero on a given face. This flag is only used when computing integrals over faces of cells. </p>
</td></tr>
</table>

<p>Definition at line <a class="el" href="dof__tools_8h_source.html#l00203">203</a> of file <a class="el" href="dof__tools_8h_source.html">dof_tools.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ae23173d20bc1b6c56c6d3a4aa2cbae73"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FaceIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::make_periodicity_constraints </td>
          <td>(</td>
          <td class="paramtype">const FaceIterator &amp;&#160;</td>
          <td class="paramname"><em>face_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="structidentity.html">identity</a>&lt; FaceIterator &gt;::type &amp;&#160;</td>
          <td class="paramname"><em>face_2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraint_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_orientation</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_flip</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_rotation</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Insert the (algebraic) constraints due to periodic boundary conditions into a <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> <code>constraint_matrix</code>.</p>
<p>Given a pair of not necessarily active boundary faces <code>face_1</code> and <code>face_2</code>, this functions constrains all DoFs associated with the boundary described by <code>face_1</code> to the respective DoFs of the boundary described by <code>face_2</code>. More precisely:</p>
<p>If <code>face_1</code> and <code>face_2</code> are both active faces it adds the DoFs of <code>face_1</code> to the list of constrained DoFs in <code>constraint_matrix</code> and adds entries to constrain them to the corresponding values of the DoFs on <code>face_2</code>. This happens on a purely algebraic level, meaning, the global DoF with (local face) index <code>i</code> on <code>face_1</code> gets constraint to the DoF with (local face) index <code>i</code> on <code>face_2</code> (possibly corrected for orientation, see below).</p>
<p>Otherwise, if <code>face_1</code> and <code>face_2</code> are not active faces, this function loops recursively over the children of <code>face_1</code> and <code>face_2</code>. If only one of the two faces is active, then we recursively iterate over the children of the non-active ones and make sure that the solution function on the refined side equals that on the non-refined face in much the same way as we enforce hanging node constraints at places where differently refined cells come together. (However, unlike hanging nodes, we do not enforce the requirement that there be only a difference of one refinement level between the two sides of the domain you would like to be periodic).</p>
<p>This routine only constrains DoFs that are not already constrained. If this routine encounters a DoF that already is constrained (for instance by Dirichlet boundary conditions), the old setting of the constraint (dofs the entry is constrained to, inhomogeneities) is kept and nothing happens.</p>
<p>The flags in the <code>component_mask</code> (see <a class="el" href="DEALGlossary.html#GlossComponentMask">GlossComponentMask</a>) denote which components of the finite element space shall be constrained with periodic boundary conditions. If it is left as specified by the default value all components are constrained. If it is different from the default value, it is assumed that the number of entries equals the number of components the finite element. This can be used to enforce periodicity in only one variable in a system of equations.</p>
<p><code>face_orientation</code>, <code>face_flip</code> and <code>face_rotation</code> describe an orientation that should be applied to <code>face_1</code> prior to matching and constraining DoFs. This has nothing to do with the actual orientation of the given faces in their respective cells (which for boundary faces is always the default) but instead how you want to see periodicity to be enforced. For example, by using these flags, you can enforce a condition of the kind <img class="formulaInl" alt="$u(0,y)=u(1,1-y)$" src="form_407.png"/> (i.e., a Moebius band) or in 3d a twisted torus. More precisely, these flags match local face DoF indices in the following manner:</p>
<p>In 2d: <code>face_orientation</code> must always be <code>true</code>, <code>face_rotation</code> is always <code>false</code>, and face_flip has the meaning of <code>line_flip</code>; this implies e.g. for <code>Q1</code>:</p>
<div class="fragment"><div class="line">face_orientation = <span class="keyword">true</span>, face_flip = <span class="keyword">false</span>, face_rotation = <span class="keyword">false</span>:</div>
<div class="line"></div>
<div class="line">    face1:           face2:</div>
<div class="line"></div>
<div class="line">    1                1</div>
<div class="line">    |        &lt;--&gt;    |</div>
<div class="line">    0                0</div>
<div class="line"></div>
<div class="line">    Resulting constraints: 0 &lt;-&gt; 0, 1 &lt;-&gt; 1</div>
<div class="line"></div>
<div class="line">    (Numbers denote local face DoF indices.)</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">face_orientation = <span class="keyword">true</span>, face_flip = <span class="keyword">true</span>, face_rotation = <span class="keyword">false</span>:</div>
<div class="line"></div>
<div class="line">    face1:           face2:</div>
<div class="line"></div>
<div class="line">    0                1</div>
<div class="line">    |        &lt;--&gt;    |</div>
<div class="line">    1                0</div>
<div class="line"></div>
<div class="line">    Resulting constraints: 1 &lt;-&gt; 0, 0 &lt;-&gt; 1</div>
</div><!-- fragment --><p>And similarly for the case of Q1 in 3d:</p>
<div class="fragment"><div class="line">face_orientation = <span class="keyword">true</span>, face_flip = <span class="keyword">false</span>, face_rotation = <span class="keyword">false</span>:</div>
<div class="line"></div>
<div class="line">    face1:           face2:</div>
<div class="line"></div>
<div class="line">    2 - 3            2 - 3</div>
<div class="line">    |   |    &lt;--&gt;    |   |</div>
<div class="line">    0 - 1            0 - 1</div>
<div class="line"></div>
<div class="line">    Resulting constraints: 0 &lt;-&gt; 0, 1 &lt;-&gt; 1, 2 &lt;-&gt; 2, 3 &lt;-&gt; 3</div>
<div class="line"></div>
<div class="line">    (Numbers denote local face DoF indices.)</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">face_orientation = <span class="keyword">false</span>, face_flip = <span class="keyword">false</span>, face_rotation = <span class="keyword">false</span>:</div>
<div class="line"></div>
<div class="line">    face1:           face2:</div>
<div class="line"></div>
<div class="line">    1 - 3            2 - 3</div>
<div class="line">    |   |    &lt;--&gt;    |   |</div>
<div class="line">    0 - 2            0 - 1</div>
<div class="line"></div>
<div class="line">    Resulting constraints: 0 &lt;-&gt; 0, 2 &lt;-&gt; 1, 1 &lt;-&gt; 2, 3 &lt;-&gt; 3</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">face_orientation = <span class="keyword">true</span>, face_flip = <span class="keyword">true</span>, face_rotation = <span class="keyword">false</span>:</div>
<div class="line"></div>
<div class="line">    face1:           face2:</div>
<div class="line"></div>
<div class="line">    1 - 0            2 - 3</div>
<div class="line">    |   |    &lt;--&gt;    |   |</div>
<div class="line">    3 - 2            0 - 1</div>
<div class="line"></div>
<div class="line">    Resulting constraints: 3 &lt;-&gt; 0, 2 &lt;-&gt; 1, 1 &lt;-&gt; 2, 0 &lt;-&gt; 3</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">face_orientation = <span class="keyword">true</span>, face_flip = <span class="keyword">false</span>, face_rotation = <span class="keyword">true</span></div>
<div class="line"></div>
<div class="line">    face1:           face2:</div>
<div class="line"></div>
<div class="line">    0 - 2            2 - 3</div>
<div class="line">    |   |    &lt;--&gt;    |   |</div>
<div class="line">    1 - 3            0 - 1</div>
<div class="line"></div>
<div class="line">    Resulting constraints: 1 &lt;-&gt; 0, 3 &lt;-&gt; 1, 0 &lt;-&gt; 2, 2 &lt;-&gt; 3</div>
<div class="line"></div>
<div class="line">and any combination of that...</div>
</div><!-- fragment --><p>More information on the topic can be found in the <a class="el" href="DEALGlossary.html#GlossFaceOrientation">glossary</a> article.</p>
<dl class="section note"><dt>Note</dt><dd>For <a class="el" href="classDoFHandler.html">DoFHandler</a> objects that are built on a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#ad7660c5fb6d0589d0b7a8ddc1d13a22b">parallel::distributed::Triangulation::add_periodicity</a> has to be called before.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Matthias Maier, 2012 </dd></dl>

</div>
</div>
<a class="anchor" id="ae5a4314d099943086c94ed7fc40a68f3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DH &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::make_periodicity_constraints </td>
          <td>(</td>
          <td class="paramtype">const DH &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>b_id1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>b_id2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraint_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Insert the (algebraic) constraints due to periodic boundary conditions into a <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> <code>constraint_matrix</code>.</p>
<p>This function serves as a high level interface for the make_periodicity_constraints function that takes face_iterator arguments.</p>
<p>Define a 'first' boundary as all boundary faces having boundary_id <code>b_id1</code> and a 'second' boundary consisting of all faces belonging to <code>b_id2</code>.</p>
<p>This function tries to match all faces belonging to the first boundary with faces belonging to the second boundary with the help of <code>orthogonal_equality</code>.</p>
<p>If this matching is successful it constrains all DoFs associated with the 'first' boundary to the respective DoFs of the 'second' boundary respecting the relative orientation of the two faces.</p>
<p>This routine only constrains DoFs that are not already constrained. If this routine encounters a DoF that already is constrained (for instance by Dirichlet boundary conditions), the old setting of the constraint (dofs the entry is constrained to, inhomogeneities) is kept and nothing happens.</p>
<p>The flags in the last parameter, <code>component_mask</code> (see <a class="el" href="DEALGlossary.html#GlossComponentMask">GlossComponentMask</a>) denote which components of the finite element space shall be constrained with periodic boundary conditions. If it is left as specified by the default value all components are constrained. If it is different from the default value, it is assumed that the number of entries equals the number of components in the boundary functions and the finite element, and those components in the given boundary function will be used for which the respective flag was set in the component mask.</p>
<dl class="section note"><dt>Note</dt><dd>For <a class="el" href="classDoFHandler.html">DoFHandler</a> objects that are built on a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#ad7660c5fb6d0589d0b7a8ddc1d13a22b">parallel::distributed::Triangulation::add_periodicity</a> has to be called before.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a></dd></dl>
<dl class="section author"><dt>Author</dt><dd>Matthias Maier, 2012 </dd></dl>

</div>
</div>
<a class="anchor" id="ae6c4e4e628ed1e91d9bd2bf8a0a2ed35"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DH &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::make_periodicity_constraints </td>
          <td>(</td>
          <td class="paramtype">const DH &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>b_id1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>b_id2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="classTensor.html">Tensor</a>&lt; 1, DH::space_dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraint_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above but with an optional argument <code>offset</code>.</p>
<p>The <code>offset</code> is a vector tangential to the faces that is added to the location of vertices of the 'first' boundary when attempting to match them to the corresponding vertices of the 'second' boundary via <code>orthogonal_equality</code>. This can be used to implement conditions such as <img class="formulaInl" alt="$u(0,y)=u(1,y+1)$" src="form_408.png"/>.</p>
<dl class="section note"><dt>Note</dt><dd>For <a class="el" href="classDoFHandler.html">DoFHandler</a> objects that are built on a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#ad7660c5fb6d0589d0b7a8ddc1d13a22b">parallel::distributed::Triangulation::add_periodicity</a> has to be called before.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a></dd></dl>
<dl class="section author"><dt>Author</dt><dd>Daniel Arndt, 2013, Matthias Maier, 2012 </dd></dl>

</div>
</div>
<a class="anchor" id="a9e4b3e5e6a35b3d58412b90c134c06e3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DH &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::make_periodicity_constraints </td>
          <td>(</td>
          <td class="paramtype">const DH &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>b_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraint_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This compatibility version of make_periodicity_constraints only works on grids with cells in <a class="el" href="DEALGlossary.html#GlossFaceOrientation">standard orientation</a>.</p>
<p>Instead of defining a 'first' and 'second' boundary with the help of two boundary_indicators this function defines a 'left' boundary as all faces with local face index <code>2*dimension</code> and boundary indicator <code>b_id</code> and, similarly, a 'right' boundary consisting of all face with local face index <code>2*dimension+1</code> and boundary indicator <code>b_id</code>.</p>
<dl class="section note"><dt>Note</dt><dd>This version of make_periodicity_constraints will not work on meshes with cells not in <a class="el" href="DEALGlossary.html#GlossFaceOrientation">standard orientation</a>.</dd>
<dd>
For <a class="el" href="classDoFHandler.html">DoFHandler</a> objects that are built on a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#ad7660c5fb6d0589d0b7a8ddc1d13a22b">parallel::distributed::Triangulation::add_periodicity</a> has to be called before.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2b0a5fc2f560a364c71748a0b9bc1c2a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DH &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::make_periodicity_constraints </td>
          <td>(</td>
          <td class="paramtype">const DH &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>b_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="classTensor.html">Tensor</a>&lt; 1, DH::space_dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraint_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above but with an optional argument <code>offset</code>.</p>
<p>The <code>offset</code> is a vector tangential to the faces that is added to the location of vertices of the 'first' boundary when attempting to match them to the corresponding vertices of the 'second' boundary via <code>orthogonal_equality</code>. This can be used to implement conditions such as <img class="formulaInl" alt="$u(0,y)=u(1,y+1)$" src="form_408.png"/>.</p>
<dl class="section note"><dt>Note</dt><dd>This version of make_periodicity_constraints will not work on meshes with cells not in <a class="el" href="DEALGlossary.html#GlossFaceOrientation">standard orientation</a>.</dd>
<dd>
For <a class="el" href="classDoFHandler.html">DoFHandler</a> objects that are built on a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#ad7660c5fb6d0589d0b7a8ddc1d13a22b">parallel::distributed::Triangulation::add_periodicity</a> has to be called before.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad1e47a85c21c37c77eee96dfd81c3123"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DH &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::make_periodicity_constraints </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structGridTools_1_1PeriodicFacePair.html">GridTools::PeriodicFacePair</a>&lt; typename DH::cell_iterator &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>periodic_faces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraint_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above but the periodicity information is given by <code>periodic_faces</code>. This std::vector can be created by <a class="el" href="namespaceGridTools.html#af53b71bf72e4473c48c7e8458d38f066">GridTools::collect_periodic_faces</a>.</p>
<dl class="section note"><dt>Note</dt><dd>For <a class="el" href="classDoFHandler.html">DoFHandler</a> objects that are built on a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#ad7660c5fb6d0589d0b7a8ddc1d13a22b">parallel::distributed::Triangulation::add_periodicity</a> has to be called before. </dd></dl>

</div>
</div>
<a class="anchor" id="ac6684ffe63aafe7a1d4cf252e102caca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DH , typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::distribute_cell_to_dof_vector </td>
          <td>(</td>
          <td class="paramtype">const DH &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>cell_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Take a vector of values which live on cells (e.g. an error per cell) and distribute it to the dofs in such a way that a finite element field results, which can then be further processed, e.g. for output. You should note that the resulting field will not be continuous at hanging nodes. This can, however, easily be arranged by calling the appropriate <code>distribute</code> function of a <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> object created for this <a class="el" href="classDoFHandler.html">DoFHandler</a> object, after the vector has been fully assembled.</p>
<p>It is assumed that the number of elements in <code>cell_data</code> equals the number of active cells and that the number of elements in <code>dof_data</code> equals <code>dof_handler.n_dofs()</code>.</p>
<p>Note that the input vector may be a vector of any data type as long as it is convertible to <code>double</code>. The output vector, being a data vector on a DoF handler, always consists of elements of type <code>double</code>.</p>
<p>In case the finite element used by this <a class="el" href="classDoFHandler.html">DoFHandler</a> consists of more than one component, you need to specify which component in the output vector should be used to store the finite element field in; the default is zero (no other value is allowed if the finite element consists only of one component). All other components of the vector remain untouched, i.e. their contents are not changed.</p>
<p>This function cannot be used if the finite element in use has shape functions that are non-zero in more than one vector component (in deal.II speak: they are non-primitive). </p>

</div>
</div>
<a class="anchor" id="ac12e7f8dc1671065e2f0c87b1ed22d3d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::extract_dofs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>selected_dofs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract the indices of the degrees of freedom belonging to certain vector components of a vector-valued finite element. The <code>component_mask</code> defines which components or blocks of an <a class="el" href="classFESystem.html">FESystem</a> are to be extracted from the <a class="el" href="classDoFHandler.html">DoFHandler</a> <code>dof</code>. The entries in the output array <code>selected_dofs</code> corresponding to degrees of freedom belonging to these components are then flagged <code>true</code>, while all others are set to <code>false</code>.</p>
<p>The size of <code>component_mask</code> must be compatible with the number of components in the <a class="el" href="classFiniteElement.html">FiniteElement</a> used by <code>dof</code>. The size of <code>selected_dofs</code> must equal <a class="el" href="classDoFHandler.html#a54e7270f2ba6206604f794114b39a2aa">DoFHandler::n_dofs()</a>. Previous contents of this array are overwritten.</p>
<p>If the finite element under consideration is not primitive, i.e., some or all of its shape functions are non-zero in more than one vector component (which holds, for example, for <a class="el" href="classFE__Nedelec.html">FE_Nedelec</a> or <a class="el" href="classFE__RaviartThomas.html">FE_RaviartThomas</a> elements), then shape functions cannot be associated with a single vector component. In this case, if <em>one</em> shape vector component of this element is flagged in <code>component_mask</code> (see <a class="el" href="DEALGlossary.html#GlossComponentMask">GlossComponentMask</a>), then this is equivalent to selecting <em>all</em> vector components corresponding to this non-primitive base element.</p>
<dl class="section note"><dt>Note</dt><dd>If the <code>blocks</code> argument is true, </dd></dl>

</div>
</div>
<a class="anchor" id="a787b0459452c3853d9e1bd427cb91c2d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::extract_dofs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>selected_dofs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The same function as above, but for a <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>. </p>

</div>
</div>
<a class="anchor" id="af5f443bc8e1e01d9cb321f0243af9c56"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::extract_dofs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockMask.html">BlockMask</a> &amp;&#160;</td>
          <td class="paramname"><em>block_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>selected_dofs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is the equivalent to the <a class="el" href="namespaceDoFTools.html#ac12e7f8dc1671065e2f0c87b1ed22d3d">DoFTools::extract_dofs()</a> functions above except that the selection of which degrees of freedom to extract is not done based on components (see <a class="el" href="DEALGlossary.html#GlossComponent">GlossComponent</a>) but instead based on whether they are part of a particular block (see <a class="el" href="DEALGlossary.html#GlossBlock">GlossBlock</a>). Consequently, the second argument is not a <a class="el" href="classComponentMask.html">ComponentMask</a> but a <a class="el" href="classBlockMask.html">BlockMask</a> object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dof_handler</td><td>The <a class="el" href="classDoFHandler.html">DoFHandler</a> object from which to extract degrees of freedom </td></tr>
    <tr><td class="paramname">block_mask</td><td>The block mask that describes which blocks to consider (see <a class="el" href="DEALGlossary.html#GlossBlockMask">GlossBlockMask</a>) </td></tr>
    <tr><td class="paramname">selected_dofs</td><td>A vector of length <a class="el" href="classDoFHandler.html#a54e7270f2ba6206604f794114b39a2aa">DoFHandler::n_dofs()</a> in which those entries are true that correspond to the selected blocks. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab288dce13bec720c161eafa45d118c1a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::extract_dofs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockMask.html">BlockMask</a> &amp;&#160;</td>
          <td class="paramname"><em>block_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>selected_dofs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The same function as above, but for a <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>. </p>

</div>
</div>
<a class="anchor" id="a99e57408ccd16ea3f3dec4df8796e949"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DH &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::extract_level_dofs </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DH &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>selected_dofs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Do the same thing as the corresponding <a class="el" href="namespaceDoFTools.html#ac12e7f8dc1671065e2f0c87b1ed22d3d">extract_dofs()</a> function for one level of a multi-grid DoF numbering. </p>

</div>
</div>
<a class="anchor" id="a29e7f96d7f886750692139f80eff964f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DH &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::extract_level_dofs </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DH &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockMask.html">BlockMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>selected_dofs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Do the same thing as the corresponding <a class="el" href="namespaceDoFTools.html#ac12e7f8dc1671065e2f0c87b1ed22d3d">extract_dofs()</a> function for one level of a multi-grid DoF numbering. </p>

</div>
</div>
<a class="anchor" id="a3443bf48ca8a7dc319c91f813b10d614"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DH &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::extract_boundary_dofs </td>
          <td>(</td>
          <td class="paramtype">const DH &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>selected_dofs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_indicators</em> = <code>std::set&lt;&#160;<a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract all degrees of freedom which are at the boundary and belong to specified components of the solution. The function returns its results in the last non-default-valued parameter which contains <code>true</code> if a degree of freedom is at the boundary and belongs to one of the selected components, and <code>false</code> otherwise. The function is used in <a class="el" href="step_15.html">step-15</a>.</p>
<p>By specifying the <code>boundary_indicator</code> variable, you can select which boundary indicators the faces have to have on which the degrees of freedom are located that shall be extracted. If it is an empty list, then all boundary indicators are accepted.</p>
<p>The size of <code>component_mask</code> (see <a class="el" href="DEALGlossary.html#GlossComponentMask">GlossComponentMask</a>) shall equal the number of components in the finite element used by <code>dof</code>. The size of <code>selected_dofs</code> shall equal <code>dof_handler.n_dofs()</code>. Previous contents of this array or overwritten.</p>
<p>Using the usual convention, if a shape function is non-zero in more than one component (i.e. it is non-primitive), then the element in the component mask is used that corresponds to the first non-zero components. Elements in the mask corresponding to later components are ignored.</p>
<dl class="section note"><dt>Note</dt><dd>This function will not work for <a class="el" href="classDoFHandler.html">DoFHandler</a> objects that are built on a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object. The reasons is that the output argument <code>selected_dofs</code> has to have a length equal to <em>all</em> global degrees of freedom. Consequently, this does not scale to very large problems. If you need the functionality of this function for parallel triangulations, then you need to use the other <a class="el" href="namespaceDoFTools.html#a3443bf48ca8a7dc319c91f813b10d614">DoFTools::extract_boundary_dofs</a> function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dof_handler</td><td>The object that describes which degrees of freedom live on which cell </td></tr>
    <tr><td class="paramname">component_mask</td><td>A mask denoting the vector components of the finite element that should be considered (see also <a class="el" href="DEALGlossary.html#GlossComponentMask">GlossComponentMask</a>). </td></tr>
    <tr><td class="paramname">selected_dofs</td><td>The <a class="el" href="classIndexSet.html">IndexSet</a> object that is returned and that will contain the indices of degrees of freedom that are located on the boundary (and correspond to the selected vector components and boundary indicators, depending on the values of the <code>component_mask</code> and <code>boundary_indicators</code> arguments). </td></tr>
    <tr><td class="paramname">boundary_indicators</td><td>If empty, this function extracts the indices of the degrees of freedom for all parts of the boundary. If it is a non-empty list, then the function only considers boundary faces with the boundary indicators listed in this argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3805e1a03726a653d15f8f87d74d2cc0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DH &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::extract_boundary_dofs </td>
          <td>(</td>
          <td class="paramtype">const DH &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>selected_dofs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_indicators</em> = <code>std::set&lt;&#160;<a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function does the same as the previous one but it returns its result as an <a class="el" href="classIndexSet.html">IndexSet</a> rather than a std::vector&lt;bool&gt;. Thus, it can also be called for <a class="el" href="classDoFHandler.html">DoFHandler</a> objects that are defined on <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> objects.</p>
<dl class="section note"><dt>Note</dt><dd>If the <a class="el" href="classDoFHandler.html">DoFHandler</a> object is indeed defined on a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>, then the <code>selected_dofs</code> index set will contain only those degrees of freedom on the boundary that belong to the locally relevant set (see <a class="el" href="DEALGlossary.html#GlossLocallyRelevantDof">locally relevant DoFs</a>).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dof_handler</td><td>The object that describes which degrees of freedom live on which cell </td></tr>
    <tr><td class="paramname">component_mask</td><td>A mask denoting the vector components of the finite element that should be considered (see also <a class="el" href="DEALGlossary.html#GlossComponentMask">GlossComponentMask</a>). </td></tr>
    <tr><td class="paramname">selected_dofs</td><td>The <a class="el" href="classIndexSet.html">IndexSet</a> object that is returned and that will contain the indices of degrees of freedom that are located on the boundary (and correspond to the selected vector components and boundary indicators, depending on the values of the <code>component_mask</code> and <code>boundary_indicators</code> arguments). </td></tr>
    <tr><td class="paramname">boundary_indicators</td><td>If empty, this function extracts the indices of the degrees of freedom for all parts of the boundary. If it is a non-empty list, then the function only considers boundary faces with the boundary indicators listed in this argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a70b2e7f03218907bf10b3b82c2813f3d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DH &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::extract_dofs_with_support_on_boundary </td>
          <td>(</td>
          <td class="paramtype">const DH &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>selected_dofs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_indicators</em> = <code>std::set&lt;&#160;<a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is similar to the <a class="el" href="namespaceDoFTools.html#a3443bf48ca8a7dc319c91f813b10d614">extract_boundary_dofs()</a> function but it extracts those degrees of freedom whose shape functions are nonzero on at least part of the selected boundary. For continuous elements, this is exactly the set of shape functions whose degrees of freedom are defined on boundary faces. On the other hand, if the finite element in used is a discontinuous element, all degrees of freedom are defined in the inside of cells and consequently none would be boundary degrees of freedom. Several of those would have shape functions that are nonzero on the boundary, however. This function therefore extracts all those for which the <a class="el" href="classFiniteElement.html#a04ad0cca5800a68b8149d34865227d9d">FiniteElement::has_support_on_face</a> function says that it is nonzero on any face on one of the selected boundary parts.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a670cceec4eaad94c7d4fd44a1e54684e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DH &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::extract_subdomain_dofs </td>
          <td>(</td>
          <td class="paramtype">const DH &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a>&#160;</td>
          <td class="paramname"><em>subdomain_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>selected_dofs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flag all those degrees of freedom which are on cells with the given subdomain id. Note that DoFs on faces can belong to cells with differing subdomain ids, so the sets of flagged degrees of freedom are not mutually exclusive for different subdomain ids.</p>
<p>If you want to get a unique association of degree of freedom with subdomains, use the <code>get_subdomain_association</code> function. </p>

</div>
</div>
<a class="anchor" id="a085f6c6785dda73f1540bce6b9ac1215"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DH &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::extract_locally_owned_dofs </td>
          <td>(</td>
          <td class="paramtype">const DH &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>dof_set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract the set of global DoF indices that are owned by the current processor. For regular <a class="el" href="classDoFHandler.html">DoFHandler</a> objects, this set is the complete set with all DoF indices. In either case, it equals what <a class="el" href="classDoFHandler.html#ab1a158372361c4d0a1fa3d7f3ea13b9e">DoFHandler::locally_owned_dofs()</a> returns. </p>

</div>
</div>
<a class="anchor" id="ab3de42868eedd688d16cd7f0105b55b4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DH &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::extract_locally_active_dofs </td>
          <td>(</td>
          <td class="paramtype">const DH &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>dof_set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract the set of global DoF indices that are active on the current <a class="el" href="classDoFHandler.html">DoFHandler</a>. For regular DoFHandlers, these are all DoF indices, but for <a class="el" href="classDoFHandler.html">DoFHandler</a> objects built on <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> this set is a superset of <a class="el" href="classDoFHandler.html#ab1a158372361c4d0a1fa3d7f3ea13b9e">DoFHandler::locally_owned_dofs()</a> and contains all DoF indices that live on all locally owned cells (including on the interface to ghost cells). However, it does not contain the DoF indices that are exclusively defined on ghost or artificial cells (see <a class="el" href="DEALGlossary.html#GlossArtificialCell">the glossary</a>).</p>
<p>The degrees of freedom identified by this function equal those obtained from the <a class="el" href="namespaceDoFTools.html#a12a8cd7efa980f18561ced31e51fb3d4">dof_indices_with_subdomain_association()</a> function when called with the locally owned subdomain id. </p>

</div>
</div>
<a class="anchor" id="aaf1b404a747264c19057374732186020"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DH &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::extract_locally_relevant_dofs </td>
          <td>(</td>
          <td class="paramtype">const DH &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>dof_set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract the set of global DoF indices that are active on the current <a class="el" href="classDoFHandler.html">DoFHandler</a>. For regular DoFHandlers, these are all DoF indices, but for <a class="el" href="classDoFHandler.html">DoFHandler</a> objects built on <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> this set is the union of <a class="el" href="classDoFHandler.html#ab1a158372361c4d0a1fa3d7f3ea13b9e">DoFHandler::locally_owned_dofs()</a> and the DoF indices on all ghost cells. In essence, it is the DoF indices on all cells that are not artificial (see <a class="el" href="DEALGlossary.html#GlossArtificialCell">the glossary</a>). </p>

</div>
</div>
<a class="anchor" id="a21ed56f06e60447282b0948cfed2537c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DH &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::get_subdomain_association </td>
          <td>(</td>
          <td class="paramtype">const DH &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>subdomain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For each DoF, return in the output array to which subdomain (as given by the <code>cell-&gt;subdomain_id()</code> function) it belongs. The output array is supposed to have the right size already when calling this function.</p>
<p>Note that degrees of freedom associated with faces, edges, and vertices may be associated with multiple subdomains if they are sitting on partition boundaries. In these cases, we put them into one of the associated partitions in an undefined way. This may sometimes lead to different numbers of degrees of freedom in partitions, even if the number of cells is perfectly equidistributed. While this is regrettable, it is not a problem in practice since the number of degrees of freedom on partition boundaries is asymptotically vanishing as we refine the mesh as long as the number of partitions is kept constant.</p>
<p>This function returns the association of each DoF with one subdomain. If you are looking for the association of each <em>cell</em> with a subdomain, either query the <code>cell-&gt;subdomain_id()</code> function, or use the <code><a class="el" href="namespaceGridTools.html#ae0cb61bdd7e17c6b1589bdd16891e561">GridTools::get_subdomain_association</a></code> function.</p>
<p>Note that this function is of questionable use for <a class="el" href="classDoFHandler.html">DoFHandler</a> objects built on <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> since in that case ownership of individual degrees of freedom by MPI processes is controlled by the DoF handler object, not based on some geometric algorithm in conjunction with subdomain id. In particular, the degrees of freedom identified by the functions in this namespace as associated with a subdomain are not the same the <a class="el" href="classDoFHandler.html">DoFHandler</a> class identifies as those it owns. </p>

</div>
</div>
<a class="anchor" id="a95c92f74cc712dd820ed42d39ae45e10"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DH &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> DoFTools::count_dofs_with_subdomain_association </td>
          <td>(</td>
          <td class="paramtype">const DH &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a>&#160;</td>
          <td class="paramname"><em>subdomain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Count how many degrees of freedom are uniquely associated with the given <code>subdomain</code> index.</p>
<p>Note that there may be rare cases where cells with the given <code>subdomain</code> index exist, but none of its degrees of freedom are actually associated with it. In that case, the returned value will be zero.</p>
<p>This function will generate an exception if there are no cells with the given <code>subdomain</code> index.</p>
<p>This function returns the number of DoFs associated with one subdomain. If you are looking for the association of <em>cells</em> with this subdomain, use the <code><a class="el" href="namespaceGridTools.html#a8c212a30784bec20b1ae13fad3fd579c">GridTools::count_cells_with_subdomain_association</a></code> function.</p>
<p>Note that this function is of questionable use for <a class="el" href="classDoFHandler.html">DoFHandler</a> objects built on <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> since in that case ownership of individual degrees of freedom by MPI processes is controlled by the DoF handler object, not based on some geometric algorithm in conjunction with subdomain id. In particular, the degrees of freedom identified by the functions in this namespace as associated with a subdomain are not the same the <a class="el" href="classDoFHandler.html">DoFHandler</a> class identifies as those it owns. </p>

</div>
</div>
<a class="anchor" id="a240e10d665a8ac819961505c0c80811d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DH &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::count_dofs_with_subdomain_association </td>
          <td>(</td>
          <td class="paramtype">const DH &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a>&#160;</td>
          <td class="paramname"><em>subdomain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>n_dofs_on_subdomain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Count how many degrees of freedom are uniquely associated with the given <code>subdomain</code> index.</p>
<p>This function does what the previous one does except that it splits the result among the vector components of the finite element in use by the <a class="el" href="classDoFHandler.html">DoFHandler</a> object. The last argument (which must have a length equal to the number of vector components) will therefore store how many degrees of freedom of each vector component are associated with the given subdomain.</p>
<p>Note that this function is of questionable use for <a class="el" href="classDoFHandler.html">DoFHandler</a> objects built on <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> since in that case ownership of individual degrees of freedom by MPI processes is controlled by the DoF handler object, not based on some geometric algorithm in conjunction with subdomain id. In particular, the degrees of freedom identified by the functions in this namespace as associated with a subdomain are not the same the <a class="el" href="classDoFHandler.html">DoFHandler</a> class identifies as those it owns. </p>

</div>
</div>
<a class="anchor" id="a12a8cd7efa980f18561ced31e51fb3d4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DH &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexSet.html">IndexSet</a> DoFTools::dof_indices_with_subdomain_association </td>
          <td>(</td>
          <td class="paramtype">const DH &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a>&#160;</td>
          <td class="paramname"><em>subdomain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a set of indices that denotes the degrees of freedom that live on the given subdomain, i.e. that are on cells owned by the current processor. Note that this includes the ones that this subdomain "owns" (i.e. the ones for which <a class="el" href="namespaceDoFTools.html#a21ed56f06e60447282b0948cfed2537c">get_subdomain_association()</a> returns a value equal to the subdomain given here and that are selected by the extract_locally_owned() function) but also all of those that sit on the boundary between the given subdomain and other subdomain. In essence, degrees of freedom that sit on boundaries between subdomain will be in the index sets returned by this function for more than one subdomain.</p>
<p>Note that this function is of questionable use for <a class="el" href="classDoFHandler.html">DoFHandler</a> objects built on <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> since in that case ownership of individual degrees of freedom by MPI processes is controlled by the DoF handler object, not based on some geometric algorithm in conjunction with subdomain id. In particular, the degrees of freedom identified by the functions in this namespace as associated with a subdomain are not the same the <a class="el" href="classDoFHandler.html">DoFHandler</a> class identifies as those it owns. </p>

</div>
</div>
<a class="anchor" id="afaef07da690a1356732c806bed0f02c6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DH , class Sparsity &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::make_cell_patches </td>
          <td>(</td>
          <td class="paramtype">Sparsity &amp;&#160;</td>
          <td class="paramname"><em>block_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DH &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>selected_dofs</em> = <code>std::vector&lt;&#160;<a class="el" href="classbool.html">bool</a>&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create an incidence matrix that for every cell on a given level of a multilevel <a class="el" href="classDoFHandler.html">DoFHandler</a> flags which degrees of freedom are associated with the corresponding cell. This data structure is matrix with as many rows as there are cells on a given level, as many rows as there are degrees of freedom on this level, and entries that are either true or false. This data structure is conveniently represented by a <a class="el" href="classSparsityPattern.html">SparsityPattern</a> object.</p>
<dl class="section note"><dt>Note</dt><dd>The ordering of rows (cells) follows the ordering of the standard cell iterators. </dd></dl>

</div>
</div>
<a class="anchor" id="ad46592434d04dd1b0b7b545e549021f0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DH &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::make_vertex_patches </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>block_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DH &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>interior_dofs_only</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>boundary_patches</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>level_boundary_patches</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>single_cell_patches</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create an incidence matrix that for every vertex on a given level of a multilevel <a class="el" href="classDoFHandler.html">DoFHandler</a> flags which degrees of freedom are associated with the adjacent cells. This data structure is matrix with as many rows as there are vertices on a given level, as many rows as there are degrees of freedom on this level, and entries that are either true or false. This data structure is conveniently represented by a <a class="el" href="classSparsityPattern.html">SparsityPattern</a> object. The sparsity pattern may be empty when entering this function and will be reinitialized to the correct size.</p>
<p>The function has some boolean arguments (listed below) controlling details of the generated patches. The default settings are those for Arnold-Falk-Winther type smoothers for divergence and curl conforming finite elements with essential boundary conditions. Other applications are possible, in particular changing <code>boundary_patches</code> for non-essential boundary conditions.</p>
<ul>
<li><code>block_list</code>: the <a class="el" href="classSparsityPattern.html">SparsityPattern</a> into which the patches will be stored.</li>
</ul>
<ul>
<li><code>dof_handler</code>: The multilevel dof handler providing the topology operated on.</li>
</ul>
<ul>
<li><code>interior_dofs_only</code>: for each patch of cells around a vertex, collect only the interior degrees of freedom of the patch and disregard those on the boundary of the patch. This is for instance the setting for smoothers of Arnold-Falk-Winther type.</li>
</ul>
<ul>
<li><code>boundary_patches</code>: include patches around vertices at the boundary of the domain. If not, only patches around interior vertices will be generated.</li>
</ul>
<ul>
<li><code>level_boundary_patches</code>: same for refinement edges towards coarser cells.</li>
</ul>
<ul>
<li><code>single_cell_patches</code>: if not true, patches containing a single cell are eliminated. </li>
</ul>

</div>
</div>
<a class="anchor" id="a2866a8b7f331a5a4c3d8b275f95abf72"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DH &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::make_child_patches </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>block_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DH &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>interior_dofs_only</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>boundary_dofs</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create an incidence matrix that for every cell on a given level of a multilevel <a class="el" href="classDoFHandler.html">DoFHandler</a> flags which degrees of freedom are associated with children of this cell. This data structure is conveniently represented by a <a class="el" href="classSparsityPattern.html">SparsityPattern</a> object.</p>
<p>Create a sparsity pattern which in each row lists the degrees of freedom associated to the cells which are the children of the same cell. The sparsity pattern may be empty when entering this function and will be reinitialized to the correct size.</p>
<p>The function has some boolean arguments (listed below) controlling details of the generated patches. The default settings are those for Arnold-Falk-Winther type smoothers for divergence and curl conforming finite elements with essential boundary conditions. Other applications are possible, in particular changing <code>boundary_dofs</code> for non-essential boundary conditions.</p>
<p>Since the patches are defined through refinement, th</p>
<ul>
<li><code>block_list</code>: the <a class="el" href="classSparsityPattern.html">SparsityPattern</a> into which the patches will be stored.</li>
</ul>
<ul>
<li><code>dof_handler</code>: The multilevel dof handler providing the topology operated on.</li>
</ul>
<ul>
<li><code>interior_dofs_only</code>: for each patch of cells around a vertex, collect only the interior degrees of freedom of the patch and disregard those on the boundary of the patch. This is for instance the setting for smoothers of Arnold-Falk-Winther type.</li>
</ul>
<ul>
<li><code>boundary_dofs</code>: include degrees of freedom, which would have excluded by <code>interior_dofs_only</code>, but are lying on the boundary of the domain, and thus need smoothing. This parameter has no effect if <code>interior_dofs_only</code> is false. </li>
</ul>

</div>
</div>
<a class="anchor" id="a2122dd7faaa8b70fc97ecad1565876d2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DH &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::make_single_patch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>block_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DH &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>interior_dofs_only</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a block list with only a single patch, which in turn contains all degrees of freedom on the given level.</p>
<p>This function is mostly a closure on level 0 for functions like <a class="el" href="namespaceDoFTools.html#a2866a8b7f331a5a4c3d8b275f95abf72">make_child_patches()</a> and <a class="el" href="namespaceDoFTools.html#ad46592434d04dd1b0b7b545e549021f0">make_vertex_patches()</a>, which may produce an empty patch list.</p>
<ul>
<li><code>block_list</code>: the <a class="el" href="classSparsityPattern.html">SparsityPattern</a> into which the patches will be stored.</li>
</ul>
<ul>
<li><code>dof_handler</code>: The multilevel dof handler providing the topology operated on.</li>
</ul>
<ul>
<li><code>level</code> The grid level used for building the list.</li>
</ul>
<ul>
<li><code>interior_dofs_only</code>: if true, exclude degrees of freedom on the boundary of the domain. </li>
</ul>

</div>
</div>
<a class="anchor" id="a93147b0911ad1a77fa3bdac768a43573"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DH &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::extract_constant_modes </td>
          <td>(</td>
          <td class="paramtype">const DH &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>constant_modes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract a vector that represents the constant modes of the <a class="el" href="classDoFHandler.html">DoFHandler</a> for the components chosen by <code>component_mask</code> (see <a class="el" href="DEALGlossary.html#GlossComponentMask">GlossComponentMask</a>). The constant modes on a discretization are the null space of a Laplace operator on the selected components with Neumann boundary conditions applied. The null space is a necessary ingredient for obtaining a good AMG preconditioner when using the class <a class="el" href="classTrilinosWrappers_1_1PreconditionAMG.html">TrilinosWrappers::PreconditionAMG</a>. Since the ML AMG package only works on algebraic properties of the respective matrix, it has no chance to detect whether the matrix comes from a scalar or a vector valued problem. However, a near null space supplies exactly the needed information about these components. The null space will consist of as many vectors as there are true arguments in <code>component_mask</code> (see <a class="el" href="DEALGlossary.html#GlossComponentMask">GlossComponentMask</a>), each of which will be one in one vector component and zero in all others. We store this object in a vector of vectors, where the outer vector is of the size of the number of selected components, and each inner vector has as many components as there are (locally owned) degrees of freedom in the selected components. Note that any matrix associated with this null space must have been constructed using the same <code>component_mask</code> argument, since the numbering of DoFs is done relative to the selected dofs, not to all dofs.</p>
<p>The main reason for this program is the use of the null space with the AMG preconditioner. </p>

</div>
</div>
<a class="anchor" id="af1b36185489f9082fb5fdd81c6e7ff0c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DH &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::get_active_fe_indices </td>
          <td>(</td>
          <td class="paramtype">const DH &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>active_fe_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For each active cell of a <a class="el" href="classDoFHandler.html">DoFHandler</a> or <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>, extract the active finite element index and fill the vector given as second argument. This vector is assumed to have as many entries as there are active cells.</p>
<p>For non-hp <a class="el" href="classDoFHandler.html">DoFHandler</a> objects given as first argument, the returned vector will consist of only zeros, indicating that all cells use the same finite element. For a <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>, the values may be different, though. </p>

</div>
</div>
<a class="anchor" id="a048c0faf9a9836e42b96f3f022b9e137"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DH &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::count_dofs_per_component </td>
          <td>(</td>
          <td class="paramtype">const DH &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dofs_per_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>vector_valued_once</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td>
          <td class="paramname"><em>target_component</em> = <code>std::vector&lt;&#160;unsigned&#160;<a class="el" href="classint.html">int</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Count how many degrees of freedom out of the total number belong to each component. If the number of components the finite element has is one (i.e. you only have one scalar variable), then the number in this component obviously equals the total number of degrees of freedom. Otherwise, the sum of the DoFs in all the components needs to equal the total number.</p>
<p>However, the last statement does not hold true if the finite element is not primitive, i.e. some or all of its shape functions are non-zero in more than one vector component. This applies, for example, to the Nedelec or Raviart-Thomas elements. In this case, a degree of freedom is counted in each component in which it is non-zero, so that the sum mentioned above is greater than the total number of degrees of freedom.</p>
<p>This behavior can be switched off by the optional parameter <code>vector_valued_once</code>. If this is <code>true</code>, the number of components of a nonprimitive vector valued element is collected only in the first component. All other components will have a count of zero.</p>
<p>The additional optional argument <code>target_component</code> allows for a re-sorting and grouping of components. To this end, it contains for each component the component number it shall be counted as. Having the same number entered several times sums up several components as the same. One of the applications of this argument is when you want to form block matrices and vectors, but want to pack several components into the same block (for example, when you have <code>dim</code> velocities and one pressure, to put all velocities into one block, and the pressure into another).</p>
<p>The result is returned in <code>dofs_per_component</code>. Note that the size of <code>dofs_per_component</code> needs to be enough to hold all the indices specified in <code>target_component</code>. If this is not the case, an assertion is thrown. The indices not targeted by target_components are left untouched. </p>

</div>
</div>
<a class="anchor" id="ab82a3ef025ecca0f1bd7d8c1232d49ee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DH &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::count_dofs_per_block </td>
          <td>(</td>
          <td class="paramtype">const DH &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dofs_per_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>target_block</em> = <code>std::vector&lt;&#160;unsigned&#160;<a class="el" href="classint.html">int</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Count the degrees of freedom in each block. This function is similar to <a class="el" href="namespaceDoFTools.html#a048c0faf9a9836e42b96f3f022b9e137">count_dofs_per_component()</a>, with the difference that the counting is done by blocks. See <a class="el" href="DEALGlossary.html#GlossBlock">blocks</a> in the glossary for details. Again the vectors are assumed to have the correct size before calling this function. If this is not the case, an assertion is thrown.</p>
<p>This function is used in the <a class="el" href="step_22.html">step-22</a>, <a class="el" href="step_31.html">step-31</a>, and <a class="el" href="step_32.html">step-32</a> tutorial programs.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The dofs_per_block variable has as many components as the finite element used by the dof_handler argument has blocks, or alternatively as many blocks as are enumerated in the target_blocks argument if given. </dd></dl>

</div>
</div>
<a class="anchor" id="a99dd876d3a452deb4281d35e6c3a3e9f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::count_dofs_per_component </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dofs_per_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td>
          <td class="paramname"><em>target_component</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000109">Deprecated:</a></b></dt><dd>See the previous function with the same name for a description. This function exists for compatibility with older versions only. </dd></dl>

</div>
</div>
<a class="anchor" id="acf101e71f1ed2458bbbfd94e6bf96594"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::compute_intergrid_constraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>coarse_grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>coarse_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fine_grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>fine_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classInterGridMap.html">InterGridMap</a>&lt; <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>coarse_to_fine_grid_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function can be used when different variables shall be discretized on different grids, where one grid is coarser than the other. This idea might seem nonsensical at first, but has reasonable applications in inverse (parameter estimation) problems, where there might not be enough information to recover the parameter on the same grid as the state variable; furthermore, the smoothness properties of state variable and parameter might not be too much related, so using different grids might be an alternative to using stronger regularization of the problem.</p>
<p>The basic idea of this function is explained in the following. Let us, for convenience, denote by <code>parameter grid'' the coarser of the two grids, and by</code>state grid'' the finer of the two. We furthermore assume that the finer grid can be obtained by refinement of the coarser one, i.e. the fine grid is at least as much refined as the coarse grid at each point of the domain. Then, each shape function on the coarse grid can be represented as a linear combination of shape functions on the fine grid (assuming identical ansatz spaces). Thus, if we discretize as usual, using shape functions on the fine grid, we can consider the restriction that the parameter variable shall in fact be discretized by shape functions on the coarse grid as a constraint. These constraints are linear and happen to have the form managed by the ``ConstraintMatrix'' class.</p>
<p>The construction of these constraints is done as follows: for each of the degrees of freedom (i.e. shape functions) on the coarse grid, we compute its representation on the fine grid, i.e. how the linear combination of shape functions on the fine grid looks like that resembles the shape function on the coarse grid. From this information, we can then compute the constraints which have to hold if a solution of a linear equation on the fine grid shall be representable on the coarse grid. The exact algorithm how these constraints can be computed is rather complicated and is best understood by reading the source code, which contains many comments.</p>
<p>Before explaining the use of this function, we would like to state that the total number of degrees of freedom used for the discretization is not reduced by the use of this function, i.e. even though we discretize one variable on a coarser grid, the total number of degrees of freedom is that of the fine grid. This seems to be counter-productive, since it does not give us a benefit from using a coarser grid. The reason why it may be useful to choose this approach nonetheless is three-fold: first, as stated above, there might not be enough information to recover a parameter on a fine grid, i.e. we chose to discretize it on the coarse grid not to save DoFs, but for other reasons. Second, the ``ConstraintMatrix'' includes the constraints into the linear system of equations, by which constrained nodes become dummy nodes; we may therefore exclude them from the linear algebra, for example by sorting them to the back of the DoF numbers and simply calling the solver for the upper left block of the matrix which works on the non-constrained nodes only, thus actually realizing the savings in numerical effort from the reduced number of actual degrees of freedom. The third reason is that for some or other reason we have chosen to use two different grids, it may be actually quite difficult to write a function that assembles the system matrix for finite element spaces on different grids; using the approach of constraints as with this function allows to use standard techniques when discretizing on only one grid (the finer one) without having to take care of the fact that one or several of the variable actually belong to different grids.</p>
<p>The use of this function is as follows: it accepts as parameters two DoF Handlers, the first of which refers to the coarse grid and the second of which is the fine grid. On both, a finite element is represented by the DoF handler objects, which will usually have several components, which may belong to different finite elements. The second and fourth parameter of this function therefore state which variable on the coarse grid shall be used to restrict the stated component on the fine grid. Of course, the finite elements used for the respective components on the two grids need to be the same. An example may clarify this: consider the parameter estimation mentioned briefly above; there, on the fine grid the whole discretization is done, thus the variables are <code>u'',</code>q'', and the Lagrange multiplier ``lambda'', which are discretized using continuous linear, piecewise constant discontinuous, and continuous linear elements, respectively. Only the parameter ``q'' shall be represented on the coarse grid, thus the <a class="el" href="classDoFHandler.html">DoFHandler</a> object on the coarse grid represents only one variable, discretized using piecewise constant discontinuous elements. Then, the parameter denoting the component on the coarse grid would be zero (the only possible choice, since the variable on the coarse grid is scalar), and one on the fine grid (corresponding to the variable <code>q''; zero would be</code>u'', two would be ``lambda''). Furthermore, an object of type IntergridMap is needed; this could in principle be generated by the function itself from the two <a class="el" href="classDoFHandler.html">DoFHandler</a> objects, but since it is probably available anyway in programs that use this function, we shall use it instead of re-generating it. Finally, the computed constraints are entered into a variable of type <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a>; the constraints are added, i.e. previous contents which may have, for example, be obtained from hanging nodes, are not deleted, so that you only need one object of this type. </p>

</div>
</div>
<a class="anchor" id="a024b972c7426a7cae7c7d4a1037f6723"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::compute_intergrid_transfer_representation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>coarse_grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>coarse_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fine_grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>fine_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classInterGridMap.html">InterGridMap</a>&lt; <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>coarse_to_fine_grid_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::map&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>, float &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>transfer_representation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function generates a matrix such that when a vector of data with as many elements as there are degrees of freedom of this component on the coarse grid is multiplied to this matrix, we obtain a vector with as many elements are there are global degrees of freedom on the fine grid. All the elements of the other components of the finite element fields on the fine grid are not touched.</p>
<p>The output of this function is a compressed format that can be given to the <code>reinit</code> functions of the <a class="el" href="classSparsityPattern.html">SparsityPattern</a> ad <a class="el" href="classSparseMatrix.html">SparseMatrix</a> classes. </p>

</div>
</div>
<a class="anchor" id="aea9fa329f0c4a00ee55782a9e0810db4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DH &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::map_dof_to_boundary_indices </td>
          <td>(</td>
          <td class="paramtype">const DH &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a mapping from degree of freedom indices to the index of that degree of freedom on the boundary. After this operation, <code>mapping[dof]</code> gives the index of the degree of freedom with global number <code>dof</code> in the list of degrees of freedom on the boundary. If the degree of freedom requested is not on the boundary, the value of <code>mapping[dof]</code> is <code>invalid_dof_index</code>. This function is mainly used when setting up matrices and vectors on the boundary from the trial functions, which have global numbers, while the matrices and vectors use numbers of the trial functions local to the boundary.</p>
<p>Prior content of <code>mapping</code> is deleted. </p>

</div>
</div>
<a class="anchor" id="a0d4009b0841978f536aba2eac326c3a9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DH &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::map_dof_to_boundary_indices </td>
          <td>(</td>
          <td class="paramtype">const DH &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_indicators</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as the previous function, except that only those parts of the boundary are considered for which the boundary indicator is listed in the second argument.</p>
<p>See the general doc of this class for more information.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a10af6ba7adc43214e7b9f6815588f2aa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::map_dofs_to_support_points </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>support_points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a list of support points (see this <a class="el" href="DEALGlossary.html#GlossSupport">glossary entry</a>) for all the degrees of freedom handled by this DoF handler object. This function, of course, only works if the finite element object used by the DoF handler object actually provides support points, i.e. no edge elements or the like. Otherwise, an exception is thrown.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given array must have a length of as many elements as there are degrees of freedom.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The precondition to this function that the output argument needs to have size equal to the total number of degrees of freedom makes this function unsuitable for the case that the given <a class="el" href="classDoFHandler.html">DoFHandler</a> object derives from a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object. Consequently, this function will produce an error if called with such a <a class="el" href="classDoFHandler.html">DoFHandler</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a51e1e9f315add4b27edf56bba8a23b39"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::map_dofs_to_support_points </td>
          <td>(</td>
          <td class="paramtype">const ::<a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>support_points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as the previous function but for the hp case. </p>

</div>
</div>
<a class="anchor" id="ad4cd504dde0bf69ceb302b0bdf1ec494"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::map_dofs_to_support_points </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>, <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>support_points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is a version of the above map_dofs_to_support_points function that doesn't simply return a vector of support points (see this <a class="el" href="DEALGlossary.html#GlossSupport">glossary entry</a>) with one entry for each global degree of freedom, but instead a map that maps from the DoFs index to its location. The point of this function is that it is also usable in cases where the <a class="el" href="classDoFHandler.html">DoFHandler</a> is based on a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object. In such cases, each processor will not be able to determine the support point location of all DoFs, and worse no processor may be able to hold a vector that would contain the locations of all DoFs even if they were known. As a consequence, this function constructs a map from those DoFs for which we can know the locations (namely, those DoFs that are locally relevant (see <a class="el" href="DEALGlossary.html#GlossLocallyRelevantDof">locally relevant DoFs</a>) to their locations.</p>
<p>For non-distributed triangulations, the map returned as <code>support_points</code> is of course dense, i.e., every DoF is to be found in it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mapping</td><td>The mapping from the reference cell to the real cell on which DoFs are defined. </td></tr>
    <tr><td class="paramname">dof_handler</td><td>The object that describes which DoF indices live on which cell of the triangulation. </td></tr>
    <tr><td class="paramname">support_points</td><td>A map that for every locally relevant DoF index contains the corresponding location in real space coordinates. Previous content of this object is deleted in this function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aef1e4f3734a3bb0ed9d087e31178d359"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::map_dofs_to_support_points </td>
          <td>(</td>
          <td class="paramtype">const ::<a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>, <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>support_points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as the previous function but for the hp case. </p>

</div>
</div>
<a class="anchor" id="a453bc87abb48ec5d10a0d80098b107b7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DH , class Comp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::map_support_points_to_dofs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; DH::dimension, DH::space_dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DH &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="classPoint.html">Point</a>&lt; DH::space_dimension &gt;, <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>, Comp &gt; &amp;&#160;</td>
          <td class="paramname"><em>point_to_index_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is the opposite function to the one above. It generates a map where the keys are the support points of the degrees of freedom, while the values are the DoF indices. For a definition of support points, see this <a class="el" href="DEALGlossary.html#GlossSupport">glossary entry</a>.</p>
<p>Since there is no natural order in the space of points (except for the 1d case), you have to provide a map with an explicitly specified comparator object. This function is therefore templatized on the comparator object. Previous content of the map object is deleted in this function.</p>
<p>Just as with the function above, it is assumed that the finite element in use here actually supports the notion of support points of all its components. </p>

</div>
</div>
<a class="anchor" id="a06f51715ec147af4902546355cfb4276"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::convert_couplings_to_blocks </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTable.html">Table</a>&lt; 2, Coupling &gt; &amp;&#160;</td>
          <td class="paramname"><em>table_by_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTable.html">Table</a>&lt; 2, Coupling &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>tables_by_block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Map a coupling table from the user friendly organization by components to the organization by blocks. Specializations of this function for <a class="el" href="classDoFHandler.html">DoFHandler</a> and <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a> are required due to the different results of their finite element access.</p>
<p>The return vector will be initialized to the correct length inside this function. </p>

</div>
</div>
<a class="anchor" id="ad019edb74f34dc6f550bba83a6922662"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::convert_couplings_to_blocks </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTable.html">Table</a>&lt; 2, Coupling &gt; &amp;&#160;</td>
          <td class="paramname"><em>table_by_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTable.html">Table</a>&lt; 2, Coupling &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>tables_by_block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Map a coupling table from the user friendly organization by components to the organization by blocks. Specializations of this function for <a class="el" href="classDoFHandler.html">DoFHandler</a> and <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a> are required due to the different results of their finite element access.</p>
<p>The return vector will be initialized to the correct length inside this function. </p>

</div>
</div>
<a class="anchor" id="a0ff250bdce22971e55037d83ef6a706e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTable.html">Table</a>&lt;2,<a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a>&gt; DoFTools::dof_couplings_from_component_couplings </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTable.html">Table</a>&lt; 2, Coupling &gt; &amp;&#160;</td>
          <td class="paramname"><em>component_couplings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a finite element and a table how the vector components of it couple with each other, compute and return a table that describes how the individual shape functions couple with each other. </p>

</div>
</div>
<a class="anchor" id="a54f5ca7f0a47ad33e6d6e2adc1761b28"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classTable.html">Table</a>&lt;2,<a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a>&gt; &gt; DoFTools::dof_couplings_from_component_couplings </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTable.html">Table</a>&lt; 2, Coupling &gt; &amp;&#160;</td>
          <td class="paramname"><em>component_couplings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same function as above for a collection of finite elements, returning a collection of tables.</p>
<p>The function currently treats DoFTools::Couplings::nonzero the same as DoFTools::Couplings::always . </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jan 27 2014 15:27:23 for The deal.II Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
