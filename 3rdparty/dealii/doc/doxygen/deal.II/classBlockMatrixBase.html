<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>The deal.II Library: BlockMatrixBase&lt; MatrixType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="http://www.dealii.org/deal.ico"></link>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2014 by the deal.II authors"></meta>
<meta name="deal.II-version" content="8.1.0"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 8.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classBlockMatrixBase-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">BlockMatrixBase&lt; MatrixType &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__Matrix1.html">Basic matrices</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="block__matrix__base_8h_source.html">block_matrix_base.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for BlockMatrixBase&lt; MatrixType &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classBlockMatrixBase__inherit__graph.svg" width="1107" height="264"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBlockMatrixBase_1_1TemporaryData.html">TemporaryData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a20fc90a926e752327723e46607d3883a"><td class="memItemLeft" align="right" valign="top">typedef MatrixType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a20fc90a926e752327723e46607d3883a">BlockType</a></td></tr>
<tr class="separator:a20fc90a926e752327723e46607d3883a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eb07137f869e160f4ff3d616d6a38ff"><td class="memItemLeft" align="right" valign="top">typedef BlockType::value_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a8eb07137f869e160f4ff3d616d6a38ff">value_type</a></td></tr>
<tr class="separator:a8eb07137f869e160f4ff3d616d6a38ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaeabb70b6b948deef7571acdf37caa3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaaeabb70b6b948deef7571acdf37caa3"></a>
typedef <a class="el" href="classBlockMatrixBase.html#a8eb07137f869e160f4ff3d616d6a38ff">value_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>pointer</b></td></tr>
<tr class="separator:aaaeabb70b6b948deef7571acdf37caa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb97d1ea757c8f50a23c701fdc8682fb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acb97d1ea757c8f50a23c701fdc8682fb"></a>
typedef const <a class="el" href="classBlockMatrixBase.html#a8eb07137f869e160f4ff3d616d6a38ff">value_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>const_pointer</b></td></tr>
<tr class="separator:acb97d1ea757c8f50a23c701fdc8682fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af696269ed2383a617ae9135e37e420c4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af696269ed2383a617ae9135e37e420c4"></a>
typedef <a class="el" href="classBlockMatrixBase.html#a8eb07137f869e160f4ff3d616d6a38ff">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>reference</b></td></tr>
<tr class="separator:af696269ed2383a617ae9135e37e420c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5f9547270c77143cd801f0034f25b07"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad5f9547270c77143cd801f0034f25b07"></a>
typedef const <a class="el" href="classBlockMatrixBase.html#a8eb07137f869e160f4ff3d616d6a38ff">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>const_reference</b></td></tr>
<tr class="separator:ad5f9547270c77143cd801f0034f25b07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b714a48f81d4f063db36cc00f760266"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9b714a48f81d4f063db36cc00f760266"></a>
typedef <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b></td></tr>
<tr class="separator:a9b714a48f81d4f063db36cc00f760266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bf8eede36d34cb284ccbcb7e4848aa7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8bf8eede36d34cb284ccbcb7e4848aa7"></a>
typedef <a class="el" href="classMatrixIterator.html">MatrixIterator</a><br class="typebreak"/>
&lt; <a class="el" href="classBlockMatrixIterators_1_1Accessor.html">BlockMatrixIterators::Accessor</a><br class="typebreak"/>
&lt; <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>, false &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b></td></tr>
<tr class="separator:a8bf8eede36d34cb284ccbcb7e4848aa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac53adf73ef18f53a9913f44bc3e62267"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac53adf73ef18f53a9913f44bc3e62267"></a>
typedef <a class="el" href="classMatrixIterator.html">MatrixIterator</a><br class="typebreak"/>
&lt; <a class="el" href="classBlockMatrixIterators_1_1Accessor.html">BlockMatrixIterators::Accessor</a><br class="typebreak"/>
&lt; <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>, true &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b></td></tr>
<tr class="separator:ac53adf73ef18f53a9913f44bc3e62267"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7dbd4e4863db821ddb7c06737e334af5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a7dbd4e4863db821ddb7c06737e334af5">BlockMatrixBase</a> ()</td></tr>
<tr class="separator:a7dbd4e4863db821ddb7c06737e334af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb3e4a1d8bcee1b7cfb69ee955435ea5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#afb3e4a1d8bcee1b7cfb69ee955435ea5">~BlockMatrixBase</a> ()</td></tr>
<tr class="separator:afb3e4a1d8bcee1b7cfb69ee955435ea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac60e3f81c6bacc4202f4dd951514f616"><td class="memTemplParams" colspan="2">template&lt;class BlockMatrixType &gt; </td></tr>
<tr class="memitem:ac60e3f81c6bacc4202f4dd951514f616"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#ac60e3f81c6bacc4202f4dd951514f616">copy_from</a> (const BlockMatrixType &amp;source)</td></tr>
<tr class="separator:ac60e3f81c6bacc4202f4dd951514f616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e54eb8c095bf2191a29c36a7784a5b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockMatrixBase.html#a20fc90a926e752327723e46607d3883a">BlockType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a1e54eb8c095bf2191a29c36a7784a5b6">block</a> (const unsigned <a class="el" href="classint.html">int</a> row, const unsigned <a class="el" href="classint.html">int</a> column)</td></tr>
<tr class="separator:a1e54eb8c095bf2191a29c36a7784a5b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02a36e22ecb84edce0be2ae2482b1e84"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classBlockMatrixBase.html#a20fc90a926e752327723e46607d3883a">BlockType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a02a36e22ecb84edce0be2ae2482b1e84">block</a> (const unsigned <a class="el" href="classint.html">int</a> row, const unsigned <a class="el" href="classint.html">int</a> column) const </td></tr>
<tr class="separator:a02a36e22ecb84edce0be2ae2482b1e84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88d0cb82568ba6586a19bf95e02e11cc"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a88d0cb82568ba6586a19bf95e02e11cc">m</a> () const </td></tr>
<tr class="separator:a88d0cb82568ba6586a19bf95e02e11cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d336056be98cf22fccd3af6c6d13acc"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a0d336056be98cf22fccd3af6c6d13acc">n</a> () const </td></tr>
<tr class="separator:a0d336056be98cf22fccd3af6c6d13acc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3be7caeebd5e4d1e0a9392f052229dd9"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a3be7caeebd5e4d1e0a9392f052229dd9">n_block_rows</a> () const </td></tr>
<tr class="separator:a3be7caeebd5e4d1e0a9392f052229dd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ebbdbd7b9e8b930f4f6c5edc6c0ef43"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a3ebbdbd7b9e8b930f4f6c5edc6c0ef43">n_block_cols</a> () const </td></tr>
<tr class="separator:a3ebbdbd7b9e8b930f4f6c5edc6c0ef43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9784ec81d727db00f7dbfdc9859ee029"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a9784ec81d727db00f7dbfdc9859ee029">set</a> (const size_type i, const size_type j, const <a class="el" href="classBlockMatrixBase.html#a8eb07137f869e160f4ff3d616d6a38ff">value_type</a> value)</td></tr>
<tr class="separator:a9784ec81d727db00f7dbfdc9859ee029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6afa3a2f54b3a76ef38d8883d55a104"><td class="memTemplParams" colspan="2">template&lt;typename number &gt; </td></tr>
<tr class="memitem:ac6afa3a2f54b3a76ef38d8883d55a104"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#ac6afa3a2f54b3a76ef38d8883d55a104">set</a> (const std::vector&lt; size_type &gt; &amp;indices, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;full_matrix, const <a class="el" href="classbool.html">bool</a> elide_zero_values=false)</td></tr>
<tr class="separator:ac6afa3a2f54b3a76ef38d8883d55a104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd4af16696853c4a9463031fabe748a7"><td class="memTemplParams" colspan="2">template&lt;typename number &gt; </td></tr>
<tr class="memitem:afd4af16696853c4a9463031fabe748a7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#afd4af16696853c4a9463031fabe748a7">set</a> (const std::vector&lt; size_type &gt; &amp;row_indices, const std::vector&lt; size_type &gt; &amp;col_indices, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;full_matrix, const <a class="el" href="classbool.html">bool</a> elide_zero_values=false)</td></tr>
<tr class="separator:afd4af16696853c4a9463031fabe748a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc0f8f8fd5343815c3f7586478f3226d"><td class="memTemplParams" colspan="2">template&lt;typename number &gt; </td></tr>
<tr class="memitem:adc0f8f8fd5343815c3f7586478f3226d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#adc0f8f8fd5343815c3f7586478f3226d">set</a> (const size_type row, const std::vector&lt; size_type &gt; &amp;col_indices, const std::vector&lt; number &gt; &amp;values, const <a class="el" href="classbool.html">bool</a> elide_zero_values=false)</td></tr>
<tr class="separator:adc0f8f8fd5343815c3f7586478f3226d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78136f111eaa3f476a1981528be0d1bd"><td class="memTemplParams" colspan="2">template&lt;typename number &gt; </td></tr>
<tr class="memitem:a78136f111eaa3f476a1981528be0d1bd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a78136f111eaa3f476a1981528be0d1bd">set</a> (const size_type row, const size_type n_cols, const size_type *col_indices, const number *values, const <a class="el" href="classbool.html">bool</a> elide_zero_values=false)</td></tr>
<tr class="separator:a78136f111eaa3f476a1981528be0d1bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8fe7a35a3336d251a4b3aa2c3ed9748"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#ad8fe7a35a3336d251a4b3aa2c3ed9748">add</a> (const size_type i, const size_type j, const <a class="el" href="classBlockMatrixBase.html#a8eb07137f869e160f4ff3d616d6a38ff">value_type</a> value)</td></tr>
<tr class="separator:ad8fe7a35a3336d251a4b3aa2c3ed9748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acec5bc680c14603ef59da590d0db0f4a"><td class="memTemplParams" colspan="2">template&lt;typename number &gt; </td></tr>
<tr class="memitem:acec5bc680c14603ef59da590d0db0f4a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#acec5bc680c14603ef59da590d0db0f4a">add</a> (const std::vector&lt; size_type &gt; &amp;indices, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;full_matrix, const <a class="el" href="classbool.html">bool</a> elide_zero_values=true)</td></tr>
<tr class="separator:acec5bc680c14603ef59da590d0db0f4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0254582e171452592759674d9074e1b7"><td class="memTemplParams" colspan="2">template&lt;typename number &gt; </td></tr>
<tr class="memitem:a0254582e171452592759674d9074e1b7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a0254582e171452592759674d9074e1b7">add</a> (const std::vector&lt; size_type &gt; &amp;row_indices, const std::vector&lt; size_type &gt; &amp;col_indices, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;full_matrix, const <a class="el" href="classbool.html">bool</a> elide_zero_values=true)</td></tr>
<tr class="separator:a0254582e171452592759674d9074e1b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00b25e1191e6a59ec8885912e50bd686"><td class="memTemplParams" colspan="2">template&lt;typename number &gt; </td></tr>
<tr class="memitem:a00b25e1191e6a59ec8885912e50bd686"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a00b25e1191e6a59ec8885912e50bd686">add</a> (const size_type row, const std::vector&lt; size_type &gt; &amp;col_indices, const std::vector&lt; number &gt; &amp;values, const <a class="el" href="classbool.html">bool</a> elide_zero_values=true)</td></tr>
<tr class="separator:a00b25e1191e6a59ec8885912e50bd686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02c963b73dfee26bb1160755b40aad8d"><td class="memTemplParams" colspan="2">template&lt;typename number &gt; </td></tr>
<tr class="memitem:a02c963b73dfee26bb1160755b40aad8d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a02c963b73dfee26bb1160755b40aad8d">add</a> (const size_type row, const size_type n_cols, const size_type *col_indices, const number *values, const <a class="el" href="classbool.html">bool</a> elide_zero_values=true, const <a class="el" href="classbool.html">bool</a> col_indices_are_sorted=false)</td></tr>
<tr class="separator:a02c963b73dfee26bb1160755b40aad8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ee9987ece33a052d2b7a44034a8a01a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a9ee9987ece33a052d2b7a44034a8a01a">add</a> (const <a class="el" href="classBlockMatrixBase.html#a8eb07137f869e160f4ff3d616d6a38ff">value_type</a> factor, const <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; MatrixType &gt; &amp;matrix)</td></tr>
<tr class="separator:a9ee9987ece33a052d2b7a44034a8a01a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05dba529c66f16824c6d5a3d7556a9d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockMatrixBase.html#a8eb07137f869e160f4ff3d616d6a38ff">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a05dba529c66f16824c6d5a3d7556a9d8">operator()</a> (const size_type i, const size_type j) const </td></tr>
<tr class="separator:a05dba529c66f16824c6d5a3d7556a9d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61cb14f36985fd00392c73f501ae1182"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockMatrixBase.html#a8eb07137f869e160f4ff3d616d6a38ff">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a61cb14f36985fd00392c73f501ae1182">el</a> (const size_type i, const size_type j) const </td></tr>
<tr class="separator:a61cb14f36985fd00392c73f501ae1182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9510b6d16827743a0f8b01038faf804a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockMatrixBase.html#a8eb07137f869e160f4ff3d616d6a38ff">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a9510b6d16827743a0f8b01038faf804a">diag_element</a> (const size_type i) const </td></tr>
<tr class="separator:a9510b6d16827743a0f8b01038faf804a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74954a421ab950fef132131c2eb6b5f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a74954a421ab950fef132131c2eb6b5f9">compress</a> (::VectorOperation::values operation)</td></tr>
<tr class="separator:a74954a421ab950fef132131c2eb6b5f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af10f8bd6971c066796de82e23a8f6536"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#af10f8bd6971c066796de82e23a8f6536">compress</a> () <a class="el" href="group__Sparsity.html#ga0849dabf81f46d4d964e251c286784dd">DEAL_II_DEPRECATED</a></td></tr>
<tr class="separator:af10f8bd6971c066796de82e23a8f6536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2190cc18dbc94dfb98d99d1d62ef4fb5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a2190cc18dbc94dfb98d99d1d62ef4fb5">operator*=</a> (const <a class="el" href="classBlockMatrixBase.html#a8eb07137f869e160f4ff3d616d6a38ff">value_type</a> factor)</td></tr>
<tr class="separator:a2190cc18dbc94dfb98d99d1d62ef4fb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e772b9ccf9ea814802a81948190517f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a5e772b9ccf9ea814802a81948190517f">operator/=</a> (const <a class="el" href="classBlockMatrixBase.html#a8eb07137f869e160f4ff3d616d6a38ff">value_type</a> factor)</td></tr>
<tr class="separator:a5e772b9ccf9ea814802a81948190517f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65ae9a332e5af0847292f5e0e797a29c"><td class="memTemplParams" colspan="2">template&lt;class BlockVectorType &gt; </td></tr>
<tr class="memitem:a65ae9a332e5af0847292f5e0e797a29c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a65ae9a332e5af0847292f5e0e797a29c">vmult_add</a> (BlockVectorType &amp;dst, const BlockVectorType &amp;src) const </td></tr>
<tr class="separator:a65ae9a332e5af0847292f5e0e797a29c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac18f4ce2a08ade62fc92bca990e9efe8"><td class="memTemplParams" colspan="2">template&lt;class BlockVectorType &gt; </td></tr>
<tr class="memitem:ac18f4ce2a08ade62fc92bca990e9efe8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#ac18f4ce2a08ade62fc92bca990e9efe8">Tvmult_add</a> (BlockVectorType &amp;dst, const BlockVectorType &amp;src) const </td></tr>
<tr class="separator:ac18f4ce2a08ade62fc92bca990e9efe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3141c3e8ae8caaacab5f7835fc7155a8"><td class="memTemplParams" colspan="2">template&lt;class BlockVectorType &gt; </td></tr>
<tr class="memitem:a3141c3e8ae8caaacab5f7835fc7155a8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classBlockMatrixBase.html#a8eb07137f869e160f4ff3d616d6a38ff">value_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a3141c3e8ae8caaacab5f7835fc7155a8">matrix_norm_square</a> (const BlockVectorType &amp;v) const </td></tr>
<tr class="separator:a3141c3e8ae8caaacab5f7835fc7155a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a702a8e7d82515cbe7a656fb2acf8efc5"><td class="memTemplParams" colspan="2">template&lt;class BlockVectorType &gt; </td></tr>
<tr class="memitem:a702a8e7d82515cbe7a656fb2acf8efc5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classBlockMatrixBase.html#a8eb07137f869e160f4ff3d616d6a38ff">value_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a702a8e7d82515cbe7a656fb2acf8efc5">matrix_scalar_product</a> (const BlockVectorType &amp;u, const BlockVectorType &amp;v) const </td></tr>
<tr class="separator:a702a8e7d82515cbe7a656fb2acf8efc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4f7c91ed21db94115362a783944b372"><td class="memTemplParams" colspan="2">template&lt;class BlockVectorType &gt; </td></tr>
<tr class="memitem:ac4f7c91ed21db94115362a783944b372"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classBlockMatrixBase.html#a8eb07137f869e160f4ff3d616d6a38ff">value_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#ac4f7c91ed21db94115362a783944b372">residual</a> (BlockVectorType &amp;dst, const BlockVectorType &amp;x, const BlockVectorType &amp;b) const </td></tr>
<tr class="separator:ac4f7c91ed21db94115362a783944b372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2020c6aaf0377c08674dacb2d70a0ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#ab2020c6aaf0377c08674dacb2d70a0ec">print</a> (std::ostream &amp;out, const <a class="el" href="classbool.html">bool</a> alternative_output=false) const </td></tr>
<tr class="separator:ab2020c6aaf0377c08674dacb2d70a0ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80251837872592496f08d63deb87cd0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrixIterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a80251837872592496f08d63deb87cd0c">begin</a> ()</td></tr>
<tr class="separator:a80251837872592496f08d63deb87cd0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a969257f13a198e3b39372c513d3dc5aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrixIterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a969257f13a198e3b39372c513d3dc5aa">end</a> ()</td></tr>
<tr class="separator:a969257f13a198e3b39372c513d3dc5aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed413af2409b398fd003acf6a33f351e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrixIterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#aed413af2409b398fd003acf6a33f351e">begin</a> (const size_type r)</td></tr>
<tr class="separator:aed413af2409b398fd003acf6a33f351e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9494559d41237c44b235153035bcce4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrixIterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#af9494559d41237c44b235153035bcce4">end</a> (const size_type r)</td></tr>
<tr class="separator:af9494559d41237c44b235153035bcce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad711f0c596f8637850097de28e6be90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrixIterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#aad711f0c596f8637850097de28e6be90">begin</a> () const </td></tr>
<tr class="separator:aad711f0c596f8637850097de28e6be90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ba5a1a0e06e8e05df0e39a73c9afb69"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrixIterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a6ba5a1a0e06e8e05df0e39a73c9afb69">end</a> () const </td></tr>
<tr class="separator:a6ba5a1a0e06e8e05df0e39a73c9afb69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa205315cdb9499b1c2fce97dc6ea0e8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrixIterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#aa205315cdb9499b1c2fce97dc6ea0e8c">begin</a> (const size_type r) const </td></tr>
<tr class="separator:aa205315cdb9499b1c2fce97dc6ea0e8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3135f568f387aadce9b4e17f7ee9a50e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrixIterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a3135f568f387aadce9b4e17f7ee9a50e">end</a> (const size_type r) const </td></tr>
<tr class="separator:a3135f568f387aadce9b4e17f7ee9a50e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf40890fbe9829656d64e84661090b5b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classBlockIndices.html">BlockIndices</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#adf40890fbe9829656d64e84661090b5b">get_row_indices</a> () const </td></tr>
<tr class="separator:adf40890fbe9829656d64e84661090b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fa830be0da7ca86db423b66d0ae379e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classBlockIndices.html">BlockIndices</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a9fa830be0da7ca86db423b66d0ae379e">get_column_indices</a> () const </td></tr>
<tr class="separator:a9fa830be0da7ca86db423b66d0ae379e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51704f137327afe2a1f4863a73a47701"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a51704f137327afe2a1f4863a73a47701">memory_consumption</a> () const </td></tr>
<tr class="separator:a51704f137327afe2a1f4863a73a47701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga883efa07ce2dd925e08fc7e2483df848"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga883efa07ce2dd925e08fc7e2483df848">DeclException4</a> (ExcIncompatibleRowNumbers, <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;The blocks [&quot;&lt;&lt; arg1&lt;&lt;  ','&lt;&lt; arg2&lt;&lt; &quot;] and [&quot;&lt;&lt; arg3&lt;&lt;  ','&lt;&lt; arg4&lt;&lt; &quot;] have differing row numbers.&quot;)</td></tr>
<tr class="separator:ga883efa07ce2dd925e08fc7e2483df848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga313fbc1e2870a55944e84215f19b44f8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga313fbc1e2870a55944e84215f19b44f8">DeclException4</a> (ExcIncompatibleColNumbers, <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;The blocks [&quot;&lt;&lt; arg1&lt;&lt;  ','&lt;&lt; arg2&lt;&lt; &quot;] and [&quot;&lt;&lt; arg3&lt;&lt;  ','&lt;&lt; arg4&lt;&lt; &quot;] have differing column numbers.&quot;)</td></tr>
<tr class="separator:ga313fbc1e2870a55944e84215f19b44f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSubscriptor"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSubscriptor')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSubscriptor.html">Subscriptor</a></td></tr>
<tr class="memitem:ae5541017c0966b0af345db75895106f2 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#ae5541017c0966b0af345db75895106f2">Subscriptor</a> ()</td></tr>
<tr class="separator:ae5541017c0966b0af345db75895106f2 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367fce3122075f05f168d14f114b4c65 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a367fce3122075f05f168d14f114b4c65">Subscriptor</a> (const <a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;)</td></tr>
<tr class="separator:a367fce3122075f05f168d14f114b4c65 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c6c557e06110d2127fa6459119e94af inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a6c6c557e06110d2127fa6459119e94af">~Subscriptor</a> ()</td></tr>
<tr class="separator:a6c6c557e06110d2127fa6459119e94af inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24ee69d4b3cf9690d1208b2443cbbb80 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a24ee69d4b3cf9690d1208b2443cbbb80">operator=</a> (const <a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;)</td></tr>
<tr class="separator:a24ee69d4b3cf9690d1208b2443cbbb80 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3422499827ecd52f1d12d65eb6cc3125 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a3422499827ecd52f1d12d65eb6cc3125">subscribe</a> (const char *identifier=0) const </td></tr>
<tr class="separator:a3422499827ecd52f1d12d65eb6cc3125 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b4839b1cffc18781144ede1744b35ea inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a2b4839b1cffc18781144ede1744b35ea">unsubscribe</a> (const char *identifier=0) const </td></tr>
<tr class="separator:a2b4839b1cffc18781144ede1744b35ea inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b45274c8e1936bff024df01d618e86f inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a7b45274c8e1936bff024df01d618e86f">n_subscriptions</a> () const </td></tr>
<tr class="separator:a7b45274c8e1936bff024df01d618e86f inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbbc5f845063b1f23223b7ac96e89e13 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#adbbc5f845063b1f23223b7ac96e89e13">list_subscribers</a> () const </td></tr>
<tr class="separator:adbbc5f845063b1f23223b7ac96e89e13 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2f0251d20c6a5295024de3b2e9b4359 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac2f0251d20c6a5295024de3b2e9b4359">DeclException3</a> (ExcInUse, <a class="el" href="classint.html">int</a>, char *, std::string &amp;,&lt;&lt; &quot;Object of class &quot;&lt;&lt; arg2&lt;&lt; &quot; is still used by &quot;&lt;&lt; arg1&lt;&lt; &quot; other objects.\n&quot;&lt;&lt; &quot;(Additional information: &quot;&lt;&lt; arg3&lt;&lt; &quot;)\n&quot;&lt;&lt; &quot;Note the entry in the Frequently Asked Questions of &quot;&lt;&lt; &quot;deal.II (linked to from http://www.dealii.org/) for &quot;&lt;&lt; &quot;more information on what this error means.&quot;)</td></tr>
<tr class="separator:gac2f0251d20c6a5295024de3b2e9b4359 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e000d9ce953da6afe4bbbaca4397344 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga9e000d9ce953da6afe4bbbaca4397344">DeclException2</a> (ExcNoSubscriber, char *, char *,&lt;&lt; &quot;No subscriber with identifier \&quot;&quot;&lt;&lt; arg2&lt;&lt; &quot;\&quot; did <a class="el" href="classSubscriptor.html#a3422499827ecd52f1d12d65eb6cc3125">subscribe</a> to this object of class &quot;&lt;&lt; arg1)</td></tr>
<tr class="separator:ga9e000d9ce953da6afe4bbbaca4397344 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38 inherit pub_methods_classSubscriptor"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38 inherit pub_methods_classSubscriptor"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:a68efd17a8330ab676d9cd711029b0f38 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a2c94c4773a37d8672d23ca782bd50234"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a2c94c4773a37d8672d23ca782bd50234">clear</a> ()</td></tr>
<tr class="separator:a2c94c4773a37d8672d23ca782bd50234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6acb9f7db404d81437b2007fd9368d97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a6acb9f7db404d81437b2007fd9368d97">collect_sizes</a> ()</td></tr>
<tr class="separator:a6acb9f7db404d81437b2007fd9368d97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c170f8c06fe52005a8588420c762d1b"><td class="memTemplParams" colspan="2">template&lt;class BlockVectorType &gt; </td></tr>
<tr class="memitem:a4c170f8c06fe52005a8588420c762d1b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a4c170f8c06fe52005a8588420c762d1b">vmult_block_block</a> (BlockVectorType &amp;dst, const BlockVectorType &amp;src) const </td></tr>
<tr class="separator:a4c170f8c06fe52005a8588420c762d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f0047410cde6d35fe3e8e9ca48cc229"><td class="memTemplParams" colspan="2">template&lt;class BlockVectorType , class VectorType &gt; </td></tr>
<tr class="memitem:a9f0047410cde6d35fe3e8e9ca48cc229"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a9f0047410cde6d35fe3e8e9ca48cc229">vmult_block_nonblock</a> (BlockVectorType &amp;dst, const <a class="el" href="classVectorType.html">VectorType</a> &amp;src) const </td></tr>
<tr class="separator:a9f0047410cde6d35fe3e8e9ca48cc229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25621eb2e8f1a51c802d5c1328df941d"><td class="memTemplParams" colspan="2">template&lt;class BlockVectorType , class VectorType &gt; </td></tr>
<tr class="memitem:a25621eb2e8f1a51c802d5c1328df941d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a25621eb2e8f1a51c802d5c1328df941d">vmult_nonblock_block</a> (<a class="el" href="classVectorType.html">VectorType</a> &amp;dst, const BlockVectorType &amp;src) const </td></tr>
<tr class="separator:a25621eb2e8f1a51c802d5c1328df941d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c342aacbd7b14d7c385b1b4abb0cfb1"><td class="memTemplParams" colspan="2">template&lt;class VectorType &gt; </td></tr>
<tr class="memitem:a9c342aacbd7b14d7c385b1b4abb0cfb1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a9c342aacbd7b14d7c385b1b4abb0cfb1">vmult_nonblock_nonblock</a> (<a class="el" href="classVectorType.html">VectorType</a> &amp;dst, const <a class="el" href="classVectorType.html">VectorType</a> &amp;src) const </td></tr>
<tr class="separator:a9c342aacbd7b14d7c385b1b4abb0cfb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5778d1ae1c22f2f1da64c35d2c1ce499"><td class="memTemplParams" colspan="2">template&lt;class BlockVectorType &gt; </td></tr>
<tr class="memitem:a5778d1ae1c22f2f1da64c35d2c1ce499"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a5778d1ae1c22f2f1da64c35d2c1ce499">Tvmult_block_block</a> (BlockVectorType &amp;dst, const BlockVectorType &amp;src) const </td></tr>
<tr class="separator:a5778d1ae1c22f2f1da64c35d2c1ce499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42b645af6fef99f1f473fc3906c3cf08"><td class="memTemplParams" colspan="2">template&lt;class BlockVectorType , class VectorType &gt; </td></tr>
<tr class="memitem:a42b645af6fef99f1f473fc3906c3cf08"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a42b645af6fef99f1f473fc3906c3cf08">Tvmult_block_nonblock</a> (BlockVectorType &amp;dst, const <a class="el" href="classVectorType.html">VectorType</a> &amp;src) const </td></tr>
<tr class="separator:a42b645af6fef99f1f473fc3906c3cf08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6761d7f8ec17573e128193b8b204ecc1"><td class="memTemplParams" colspan="2">template&lt;class BlockVectorType , class VectorType &gt; </td></tr>
<tr class="memitem:a6761d7f8ec17573e128193b8b204ecc1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a6761d7f8ec17573e128193b8b204ecc1">Tvmult_nonblock_block</a> (<a class="el" href="classVectorType.html">VectorType</a> &amp;dst, const BlockVectorType &amp;src) const </td></tr>
<tr class="separator:a6761d7f8ec17573e128193b8b204ecc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacfdeeda1a6dd7b4bccae69c51836888"><td class="memTemplParams" colspan="2">template&lt;class VectorType &gt; </td></tr>
<tr class="memitem:aacfdeeda1a6dd7b4bccae69c51836888"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#aacfdeeda1a6dd7b4bccae69c51836888">Tvmult_nonblock_nonblock</a> (<a class="el" href="classVectorType.html">VectorType</a> &amp;dst, const <a class="el" href="classVectorType.html">VectorType</a> &amp;src) const </td></tr>
<tr class="separator:aacfdeeda1a6dd7b4bccae69c51836888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f52ce530c3028e0d3194a719cb82576"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a6f52ce530c3028e0d3194a719cb82576">prepare_add_operation</a> ()</td></tr>
<tr class="separator:a6f52ce530c3028e0d3194a719cb82576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79d3d021b1004a8fb027b50e0862c149"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a79d3d021b1004a8fb027b50e0862c149">prepare_set_operation</a> ()</td></tr>
<tr class="separator:a79d3d021b1004a8fb027b50e0862c149"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:aa401f344887a4647a9a14ef41629aed9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockIndices.html">BlockIndices</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#aa401f344887a4647a9a14ef41629aed9">row_block_indices</a></td></tr>
<tr class="separator:aa401f344887a4647a9a14ef41629aed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10666cbe2741f71f6cf17ebedaf9080d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a10666cbe2741f71f6cf17ebedaf9080d"></a>
<a class="el" href="classBlockIndices.html">BlockIndices</a>&#160;</td><td class="memItemRight" valign="bottom"><b>column_block_indices</b></td></tr>
<tr class="separator:a10666cbe2741f71f6cf17ebedaf9080d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad051169f783aabc549769dd6ef98a698"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="classSmartPointer.html">SmartPointer</a><br class="typebreak"/>
&lt; <a class="el" href="classBlockMatrixBase.html#a20fc90a926e752327723e46607d3883a">BlockType</a>, <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a><br class="typebreak"/>
&lt; MatrixType &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#ad051169f783aabc549769dd6ef98a698">sub_objects</a></td></tr>
<tr class="separator:ad051169f783aabc549769dd6ef98a698"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a8696751203ad45336dfb8523d7803610"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structBlockMatrixBase_1_1TemporaryData.html">TemporaryData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a8696751203ad45336dfb8523d7803610">temporary_data</a></td></tr>
<tr class="separator:a8696751203ad45336dfb8523d7803610"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a0d51bb7a4b7573dc73fdaab49f87e0a8"><td class="memTemplParams" colspan="2">template&lt;typename , bool &gt; </td></tr>
<tr class="memitem:a0d51bb7a4b7573dc73fdaab49f87e0a8"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a0d51bb7a4b7573dc73fdaab49f87e0a8">BlockMatrixIterators::Accessor</a></td></tr>
<tr class="separator:a0d51bb7a4b7573dc73fdaab49f87e0a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a985d93fe783ebe7faf8173673a64e66b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a985d93fe783ebe7faf8173673a64e66b"></a>
template&lt;typename &gt; </td></tr>
<tr class="memitem:a985d93fe783ebe7faf8173673a64e66b"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MatrixIterator</b></td></tr>
<tr class="separator:a985d93fe783ebe7faf8173673a64e66b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename MatrixType&gt;<br/>
class BlockMatrixBase&lt; MatrixType &gt;</h3>

<p>Blocked matrix class. The behaviour of objects of this type is almost as for the usual matrix objects, with most of the functions being implemented in both classes. The main difference is that the matrix represented by this object is composed of an array of matrices (e.g. of type SparseMatrix&lt;number&gt;) and all accesses to the elements of this object are relayed to accesses of the base matrices. The actual type of the individual blocks of this matrix is the type of the template argument, and can, for example be the usual <a class="el" href="classSparseMatrix.html">SparseMatrix</a> or <a class="el" href="classPETScWrappers_1_1SparseMatrix.html">PETScWrappers::SparseMatrix</a>.</p>
<p>In addition to the usual matrix access and linear algebra functions, there are functions <a class="el" href="classBlockMatrixBase.html#a1e54eb8c095bf2191a29c36a7784a5b6">block()</a> which allow access to the different blocks of the matrix. This may, for example, be of help when you want to implement Schur complement methods, or block preconditioners, where each block belongs to a specific component of the equation you are presently discretizing.</p>
<p>Note that the numbers of blocks and rows are implicitly determined by the sparsity pattern objects used.</p>
<p>Objects of this type are frequently used when a system of differential equations has solutions with variables that fall into different classes. For example, solutions of the Stokes or Navier-Stokes equations have <code>dim</code> velocity components and one pressure component. In this case, it may make sense to consider the linear system of equations as a system of 2x2 blocks, and one can construct preconditioners or solvers based on this 2x2 block structure. This class can help you in these cases, as it allows to view the matrix alternatively as one big matrix, or as a number of individual blocks.</p>
<h3>Inheriting from this class</h3>
<p>Since this class simply forwards its calls to the subobjects (if necessary after adjusting indices denoting which subobject is meant), this class is completely independent of the actual type of the subobject. The functions that set up block matrices and destroy them, however, have to be implemented in derived classes. These functions also have to fill the data members provided by this base class, as they are only used passively in this class.</p>
<p>Most of the functions take a vector or block vector argument. These functions can, in general, only successfully be compiled if the individual blocks of this matrix implement the respective functions operating on the vector type in question. For example, if you have a block sparse matrix over deal.II <a class="el" href="classSparseMatrix.html">SparseMatrix</a> objects, then you will likely not be able to form the matrix-vector multiplication with a block vector over <a class="el" href="classPETScWrappers_1_1SparseMatrix.html">PETScWrappers::SparseMatrix</a> objects. If you attempt anyway, you will likely get a number of compiler errors.</p>
<dl class="section note"><dt>Note</dt><dd>Instantiations for this template are provided for <code>&lt;float&gt; and &lt;double&gt;</code>; others can be generated in application programs (see the section on <a class="el" href="Instantiations.html">Template instantiations</a> in the manual).</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="DEALGlossary.html#GlossBlockLA">Block (linear algebra)</a> </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Wolfgang Bangerth, 2000, 2004 </dd></dl>

<p>Definition at line <a class="el" href="block__indices_8h_source.html#l00248">248</a> of file <a class="el" href="block__indices_8h_source.html">block_indices.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a20fc90a926e752327723e46607d3883a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef MatrixType <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; MatrixType &gt;::<a class="el" href="classBlockMatrixBase.html#a20fc90a926e752327723e46607d3883a">BlockType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Typedef the type of the underlying matrix. </p>

<p>Definition at line <a class="el" href="block__matrix__base_8h_source.html#l00389">389</a> of file <a class="el" href="block__matrix__base_8h_source.html">block_matrix_base.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8eb07137f869e160f4ff3d616d6a38ff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef BlockType::value_type <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; MatrixType &gt;::<a class="el" href="classBlockMatrixBase.html#a8eb07137f869e160f4ff3d616d6a38ff">value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type of matrix entries. In analogy to the STL container classes. </p>

<p>Definition at line <a class="el" href="block__matrix__base_8h_source.html#l00395">395</a> of file <a class="el" href="block__matrix__base_8h_source.html">block_matrix_base.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a7dbd4e4863db821ddb7c06737e334af5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; MatrixType &gt;::<a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default constructor. </p>

</div>
</div>
<a class="anchor" id="afb3e4a1d8bcee1b7cfb69ee955435ea5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; MatrixType &gt;::~<a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ac60e3f81c6bacc4202f4dd951514f616"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType&gt; </div>
<div class="memtemplate">
template&lt;class BlockMatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&amp; <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; MatrixType &gt;::copy_from </td>
          <td>(</td>
          <td class="paramtype">const BlockMatrixType &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy the given matrix to this one. The operation throws an error if the sparsity patterns of the two involved matrices do not point to the same object, since in this case the copy operation is cheaper. Since this operation is notheless not for free, we do not make it available through <a class="el" href="classSubscriptor.html#a24ee69d4b3cf9690d1208b2443cbbb80">operator=()</a>, since this may lead to unwanted usage, e.g. in copy arguments to functions, which should really be arguments by reference.</p>
<p>The source matrix may be a matrix of arbitrary type, as long as its data type is convertible to the data type of this matrix.</p>
<p>The function returns a reference to <code>this</code>. </p>

</div>
</div>
<a class="anchor" id="a1e54eb8c095bf2191a29c36a7784a5b6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockMatrixBase.html#a20fc90a926e752327723e46607d3883a">BlockType</a>&amp; <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; MatrixType &gt;::block </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>column</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access the block with the given coordinates. </p>

</div>
</div>
<a class="anchor" id="a02a36e22ecb84edce0be2ae2482b1e84"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classBlockMatrixBase.html#a20fc90a926e752327723e46607d3883a">BlockType</a>&amp; <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; MatrixType &gt;::block </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>column</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access the block with the given coordinates. Version for constant objects. </p>

</div>
</div>
<a class="anchor" id="a88d0cb82568ba6586a19bf95e02e11cc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; MatrixType &gt;::m </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the dimension of the image space. To remember: the matrix is of dimension <img class="formulaInl" alt="$m \times n$" src="form_280.png"/>. </p>

</div>
</div>
<a class="anchor" id="a0d336056be98cf22fccd3af6c6d13acc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; MatrixType &gt;::n </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the dimension of the range space. To remember: the matrix is of dimension <img class="formulaInl" alt="$m \times n$" src="form_280.png"/>. </p>

</div>
</div>
<a class="anchor" id="a3be7caeebd5e4d1e0a9392f052229dd9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; MatrixType &gt;::n_block_rows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of blocks in a column. Returns zero if no sparsity pattern is presently associated to this matrix. </p>

</div>
</div>
<a class="anchor" id="a3ebbdbd7b9e8b930f4f6c5edc6c0ef43"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; MatrixType &gt;::n_block_cols </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of blocks in a row. Returns zero if no sparsity pattern is presently associated to this matrix. </p>

</div>
</div>
<a class="anchor" id="a9784ec81d727db00f7dbfdc9859ee029"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; MatrixType &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html#a8eb07137f869e160f4ff3d616d6a38ff">value_type</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the element <code>(i,j)</code> to <code>value</code>. Throws an error if the entry does not exist or if <code>value</code> is not a finite number. Still, it is allowed to store zero values in non-existent fields. </p>

</div>
</div>
<a class="anchor" id="ac6afa3a2f54b3a76ef38d8883d55a104"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType&gt; </div>
<div class="memtemplate">
template&lt;typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; MatrixType &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>full_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set all elements given in a <a class="el" href="classFullMatrix.html">FullMatrix</a> into the sparse matrix locations given by <code>indices</code>. In other words, this function writes the elements in <code>full_matrix</code> into the calling matrix, using the local-to-global indexing specified by <code>indices</code> for both the rows and the columns of the matrix. This function assumes a quadratic sparse matrix and a quadratic full_matrix, the usual situation in FE calculations.</p>
<p>The optional parameter <code>elide_zero_values</code> can be used to specify whether zero values should be set anyway or they should be filtered away (and not change the previous content in the respective element if it exists). The default value is <code>false</code>, i.e., even zero values are treated. </p>

</div>
</div>
<a class="anchor" id="afd4af16696853c4a9463031fabe748a7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType&gt; </div>
<div class="memtemplate">
template&lt;typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; MatrixType &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>full_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same function as before, but now including the possibility to use rectangular full_matrices and different local-to-global indexing on rows and columns, respectively. </p>

</div>
</div>
<a class="anchor" id="adc0f8f8fd5343815c3f7586478f3226d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType&gt; </div>
<div class="memtemplate">
template&lt;typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; MatrixType &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set several elements in the specified row of the matrix with column indices as given by <code>col_indices</code> to the respective value.</p>
<p>The optional parameter <code>elide_zero_values</code> can be used to specify whether zero values should be set anyway or they should be filtered away (and not change the previous content in the respective element if it exists). The default value is <code>false</code>, i.e., even zero values are treated. </p>

</div>
</div>
<a class="anchor" id="a78136f111eaa3f476a1981528be0d1bd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType&gt; </div>
<div class="memtemplate">
template&lt;typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; MatrixType &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>n_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type *&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set several elements to values given by <code>values</code> in a given row in columns given by col_indices into the sparse matrix.</p>
<p>The optional parameter <code>elide_zero_values</code> can be used to specify whether zero values should be inserted anyway or they should be filtered away. The default value is <code>false</code>, i.e., even zero values are inserted/replaced. </p>

</div>
</div>
<a class="anchor" id="ad8fe7a35a3336d251a4b3aa2c3ed9748"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; MatrixType &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html#a8eb07137f869e160f4ff3d616d6a38ff">value_type</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add <code>value</code> to the element (<em>i,j</em>). Throws an error if the entry does not exist or if <code>value</code> is not a finite number. Still, it is allowed to store zero values in non-existent fields. </p>

</div>
</div>
<a class="anchor" id="acec5bc680c14603ef59da590d0db0f4a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType&gt; </div>
<div class="memtemplate">
template&lt;typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; MatrixType &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>full_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add all elements given in a <a class="el" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> into sparse matrix locations given by <code>indices</code>. In other words, this function adds the elements in <code>full_matrix</code> to the respective entries in calling matrix, using the local-to-global indexing specified by <code>indices</code> for both the rows and the columns of the matrix. This function assumes a quadratic sparse matrix and a quadratic full_matrix, the usual situation in FE calculations.</p>
<p>The optional parameter <code>elide_zero_values</code> can be used to specify whether zero values should be added anyway or these should be filtered away and only non-zero data is added. The default value is <code>true</code>, i.e., zero values won't be added into the matrix. </p>

</div>
</div>
<a class="anchor" id="a0254582e171452592759674d9074e1b7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType&gt; </div>
<div class="memtemplate">
template&lt;typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; MatrixType &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>full_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same function as before, but now including the possibility to use rectangular full_matrices and different local-to-global indexing on rows and columns, respectively. </p>

</div>
</div>
<a class="anchor" id="a00b25e1191e6a59ec8885912e50bd686"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType&gt; </div>
<div class="memtemplate">
template&lt;typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; MatrixType &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set several elements in the specified row of the matrix with column indices as given by <code>col_indices</code> to the respective value.</p>
<p>The optional parameter <code>elide_zero_values</code> can be used to specify whether zero values should be added anyway or these should be filtered away and only non-zero data is added. The default value is <code>true</code>, i.e., zero values won't be added into the matrix. </p>

</div>
</div>
<a class="anchor" id="a02c963b73dfee26bb1160755b40aad8d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType&gt; </div>
<div class="memtemplate">
template&lt;typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; MatrixType &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>n_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type *&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>col_indices_are_sorted</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add an array of values given by <code>values</code> in the given global matrix row at columns specified by col_indices in the sparse matrix.</p>
<p>The optional parameter <code>elide_zero_values</code> can be used to specify whether zero values should be added anyway or these should be filtered away and only non-zero data is added. The default value is <code>true</code>, i.e., zero values won't be added into the matrix. </p>

</div>
</div>
<a class="anchor" id="a9ee9987ece33a052d2b7a44034a8a01a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; MatrixType &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html#a8eb07137f869e160f4ff3d616d6a38ff">value_type</a>&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; MatrixType &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add <code>matrix</code> scaled by <code>factor</code> to this matrix, i.e. the matrix <code>factor*matrix</code> is added to <code>this</code>. If the sparsity pattern of the calling matrix does not contain all the elements in the sparsity pattern of the input matrix, this function will throw an exception. </p>

</div>
</div>
<a class="anchor" id="a05dba529c66f16824c6d5a3d7556a9d8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockMatrixBase.html#a8eb07137f869e160f4ff3d616d6a38ff">value_type</a> <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; MatrixType &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the value of the entry (i,j). This may be an expensive operation and you should always take care where to call this function. In order to avoid abuse, this function throws an exception if the wanted element does not exist in the matrix. </p>

</div>
</div>
<a class="anchor" id="a61cb14f36985fd00392c73f501ae1182"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockMatrixBase.html#a8eb07137f869e160f4ff3d616d6a38ff">value_type</a> <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; MatrixType &gt;::el </td>
          <td>(</td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is mostly like operator()() in that it returns the value of the matrix entry <code>(i,j)</code>. The only difference is that if this entry does not exist in the sparsity pattern, then instead of raising an exception, zero is returned. While this may be convenient in some cases, note that it is simple to write algorithms that are slow compared to an optimal solution, since the sparsity of the matrix is not used. </p>

</div>
</div>
<a class="anchor" id="a9510b6d16827743a0f8b01038faf804a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockMatrixBase.html#a8eb07137f869e160f4ff3d616d6a38ff">value_type</a> <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; MatrixType &gt;::diag_element </td>
          <td>(</td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the main diagonal element in the <em>i</em>th row. This function throws an error if the matrix is not quadratic and also if the diagonal blocks of the matrix are not quadratic.</p>
<p>This function is considerably faster than the operator()(), since for quadratic matrices, the diagonal entry may be the first to be stored in each row and access therefore does not involve searching for the right column number. </p>

</div>
</div>
<a class="anchor" id="a74954a421ab950fef132131c2eb6b5f9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; MatrixType &gt;::compress </td>
          <td>(</td>
          <td class="paramtype">::VectorOperation::values&#160;</td>
          <td class="paramname"><em>operation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call the <a class="el" href="classBlockMatrixBase.html#af10f8bd6971c066796de82e23a8f6536">compress()</a> function on all the subblocks of the matrix.</p>
<p>See <a class="el" href="DEALGlossary.html#GlossCompress">Compressing</a>distributed objects" for more information. </p>

</div>
</div>
<a class="anchor" id="af10f8bd6971c066796de82e23a8f6536"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; MatrixType &gt;::compress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000080">Deprecated:</a></b></dt><dd>: use <a class="el" href="classBlockMatrixBase.html#af10f8bd6971c066796de82e23a8f6536">compress()</a> with <a class="el" href="structVectorOperation.html">VectorOperation</a> instead. </dd></dl>

</div>
</div>
<a class="anchor" id="a2190cc18dbc94dfb98d99d1d62ef4fb5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&amp; <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; MatrixType &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html#a8eb07137f869e160f4ff3d616d6a38ff">value_type</a>&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiply the entire matrix by a fixed factor. </p>

</div>
</div>
<a class="anchor" id="a5e772b9ccf9ea814802a81948190517f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&amp; <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; MatrixType &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html#a8eb07137f869e160f4ff3d616d6a38ff">value_type</a>&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Divide the entire matrix by a fixed factor. </p>

</div>
</div>
<a class="anchor" id="a65ae9a332e5af0847292f5e0e797a29c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType&gt; </div>
<div class="memtemplate">
template&lt;class BlockVectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; MatrixType &gt;::vmult_add </td>
          <td>(</td>
          <td class="paramtype">BlockVectorType &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BlockVectorType &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adding Matrix-vector multiplication. Add <img class="formulaInl" alt="$M*src$" src="form_283.png"/> on <img class="formulaInl" alt="$dst$" src="form_126.png"/> with <img class="formulaInl" alt="$M$" src="form_103.png"/> being this matrix. </p>

</div>
</div>
<a class="anchor" id="ac18f4ce2a08ade62fc92bca990e9efe8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType&gt; </div>
<div class="memtemplate">
template&lt;class BlockVectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; MatrixType &gt;::Tvmult_add </td>
          <td>(</td>
          <td class="paramtype">BlockVectorType &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BlockVectorType &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adding Matrix-vector multiplication. Add <em>M<sup>T</sup>src</em> to <em>dst</em> with <em>M</em> being this matrix. This function does the same as <a class="el" href="classBlockMatrixBase.html#a65ae9a332e5af0847292f5e0e797a29c">vmult_add()</a> but takes the transposed matrix. </p>

</div>
</div>
<a class="anchor" id="a3141c3e8ae8caaacab5f7835fc7155a8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType&gt; </div>
<div class="memtemplate">
template&lt;class BlockVectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockMatrixBase.html#a8eb07137f869e160f4ff3d616d6a38ff">value_type</a> <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; MatrixType &gt;::matrix_norm_square </td>
          <td>(</td>
          <td class="paramtype">const BlockVectorType &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the norm of the vector <em>v</em> with respect to the norm induced by this matrix, i.e. <em>v<sup>T</sup>Mv)</em>. This is useful, e.g. in the finite element context, where the <em>L<sup>T</sup></em>-norm of a function equals the matrix norm with respect to the mass matrix of the vector representing the nodal values of the finite element function. Note that even though the function's name might suggest something different, for historic reasons not the norm but its square is returned, as defined above by the scalar product.</p>
<p>Obviously, the matrix needs to be square for this operation. </p>

</div>
</div>
<a class="anchor" id="a702a8e7d82515cbe7a656fb2acf8efc5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType&gt; </div>
<div class="memtemplate">
template&lt;class BlockVectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockMatrixBase.html#a8eb07137f869e160f4ff3d616d6a38ff">value_type</a> <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; MatrixType &gt;::matrix_scalar_product </td>
          <td>(</td>
          <td class="paramtype">const BlockVectorType &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BlockVectorType &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the matrix scalar product <img class="formulaInl" alt="$\left(u,Mv\right)$" src="form_295.png"/>. </p>

</div>
</div>
<a class="anchor" id="ac4f7c91ed21db94115362a783944b372"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType&gt; </div>
<div class="memtemplate">
template&lt;class BlockVectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockMatrixBase.html#a8eb07137f869e160f4ff3d616d6a38ff">value_type</a> <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; MatrixType &gt;::residual </td>
          <td>(</td>
          <td class="paramtype">BlockVectorType &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BlockVectorType &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BlockVectorType &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the residual <em>r=b-Ax</em>. Write the residual into <code>dst</code>. </p>

</div>
</div>
<a class="anchor" id="ab2020c6aaf0377c08674dacb2d70a0ec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; MatrixType &gt;::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>alternative_output</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print the matrix to the given stream, using the format <code>(line,col) value</code>, i.e. one nonzero entry of the matrix per line. The optional flag outputs the sparsity pattern in a different style according to the underlying sparsematrix type. </p>

</div>
</div>
<a class="anchor" id="a80251837872592496f08d63deb87cd0c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrixIterator.html">iterator</a> <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; MatrixType &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>STL-like iterator with the first entry. </p>

</div>
</div>
<a class="anchor" id="a969257f13a198e3b39372c513d3dc5aa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrixIterator.html">iterator</a> <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; MatrixType &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Final iterator. </p>

</div>
</div>
<a class="anchor" id="aed413af2409b398fd003acf6a33f351e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrixIterator.html">iterator</a> <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; MatrixType &gt;::begin </td>
          <td>(</td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>STL-like iterator with the first entry of row <code>r</code>. </p>

</div>
</div>
<a class="anchor" id="af9494559d41237c44b235153035bcce4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrixIterator.html">iterator</a> <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; MatrixType &gt;::end </td>
          <td>(</td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Final iterator of row <code>r</code>. </p>

</div>
</div>
<a class="anchor" id="aad711f0c596f8637850097de28e6be90"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrixIterator.html">const_iterator</a> <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; MatrixType &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>STL-like iterator with the first entry. </p>

</div>
</div>
<a class="anchor" id="a6ba5a1a0e06e8e05df0e39a73c9afb69"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrixIterator.html">const_iterator</a> <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; MatrixType &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Final iterator. </p>

</div>
</div>
<a class="anchor" id="aa205315cdb9499b1c2fce97dc6ea0e8c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrixIterator.html">const_iterator</a> <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; MatrixType &gt;::begin </td>
          <td>(</td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>STL-like iterator with the first entry of row <code>r</code>. </p>

</div>
</div>
<a class="anchor" id="a3135f568f387aadce9b4e17f7ee9a50e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrixIterator.html">const_iterator</a> <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; MatrixType &gt;::end </td>
          <td>(</td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Final iterator of row <code>r</code>. </p>

</div>
</div>
<a class="anchor" id="adf40890fbe9829656d64e84661090b5b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classBlockIndices.html">BlockIndices</a>&amp; <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; MatrixType &gt;::get_row_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a reference to the underlying <a class="el" href="classBlockIndices.html" title="Auxiliary class aiding in the handling of block structures like in BlockVector or FESystem...">BlockIndices</a> data of the rows. </p>

</div>
</div>
<a class="anchor" id="a9fa830be0da7ca86db423b66d0ae379e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classBlockIndices.html">BlockIndices</a>&amp; <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; MatrixType &gt;::get_column_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a reference to the underlying <a class="el" href="classBlockIndices.html" title="Auxiliary class aiding in the handling of block structures like in BlockVector or FESystem...">BlockIndices</a> data of the columns. </p>

</div>
</div>
<a class="anchor" id="a51704f137327afe2a1f4863a73a47701"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; MatrixType &gt;::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine an estimate for the memory consumption (in bytes) of this object. Note that only the memory reserved on the current processor is returned in case this is called in an MPI-based program. </p>

</div>
</div>
<a class="anchor" id="a2c94c4773a37d8672d23ca782bd50234"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; MatrixType &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Release all memory and return to a state just like after having called the default constructor. It also forgets the sparsity pattern it was previously tied to.</p>
<p>This calls clear for all sub-matrices and then resets this object to have no blocks at all.</p>
<p>This function is protected since it may be necessary to release additional structures. A derived class can make it public again, if it is sufficient. </p>

</div>
</div>
<a class="anchor" id="a6acb9f7db404d81437b2007fd9368d97"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; MatrixType &gt;::collect_sizes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function collects the sizes of the sub-objects and stores them in internal arrays, in order to be able to relay global indices into the matrix to indices into the subobjects. You <em>must</em> call this function each time after you have changed the size of the sub-objects.</p>
<p>Derived classes should call this function whenever the size of the sub-objects has changed and the <code>X_block_indices</code> arrays need to be updated.</p>
<p>Note that this function is not public since not all derived classes need to export its interface. For example, for the usual deal.II <a class="el" href="classSparseMatrix.html">SparseMatrix</a> class, the sizes are implicitly determined whenever reinit() is called, and individual blocks cannot be resized. For that class, this function therefore does not have to be public. On the other hand, for the PETSc classes, there is no associated sparsity pattern object that determines the block sizes, and for these the function needs to be publicly available. These classes therefore export this function. </p>

</div>
</div>
<a class="anchor" id="a4c170f8c06fe52005a8588420c762d1b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType&gt; </div>
<div class="memtemplate">
template&lt;class BlockVectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; MatrixType &gt;::vmult_block_block </td>
          <td>(</td>
          <td class="paramtype">BlockVectorType &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BlockVectorType &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Matrix-vector multiplication: let <img class="formulaInl" alt="$dst = M*src$" src="form_281.png"/> with <img class="formulaInl" alt="$M$" src="form_103.png"/> being this matrix.</p>
<p>Due to problems with deriving template arguments between the block and non-block versions of the vmult/Tvmult functions, the actual functions are implemented in derived classes, with implementations forwarding the calls to the implementations provided here under a unique name for which template arguments can be derived by the compiler. </p>

</div>
</div>
<a class="anchor" id="a9f0047410cde6d35fe3e8e9ca48cc229"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType&gt; </div>
<div class="memtemplate">
template&lt;class BlockVectorType , class VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; MatrixType &gt;::vmult_block_nonblock </td>
          <td>(</td>
          <td class="paramtype">BlockVectorType &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Matrix-vector multiplication. Just like the previous function, but only applicable if the matrix has only one block column.</p>
<p>Due to problems with deriving template arguments between the block and non-block versions of the vmult/Tvmult functions, the actual functions are implemented in derived classes, with implementations forwarding the calls to the implementations provided here under a unique name for which template arguments can be derived by the compiler. </p>

</div>
</div>
<a class="anchor" id="a25621eb2e8f1a51c802d5c1328df941d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType&gt; </div>
<div class="memtemplate">
template&lt;class BlockVectorType , class VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; MatrixType &gt;::vmult_nonblock_block </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BlockVectorType &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Matrix-vector multiplication. Just like the previous function, but only applicable if the matrix has only one block row.</p>
<p>Due to problems with deriving template arguments between the block and non-block versions of the vmult/Tvmult functions, the actual functions are implemented in derived classes, with implementations forwarding the calls to the implementations provided here under a unique name for which template arguments can be derived by the compiler. </p>

</div>
</div>
<a class="anchor" id="a9c342aacbd7b14d7c385b1b4abb0cfb1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType&gt; </div>
<div class="memtemplate">
template&lt;class VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; MatrixType &gt;::vmult_nonblock_nonblock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Matrix-vector multiplication. Just like the previous function, but only applicable if the matrix has only one block.</p>
<p>Due to problems with deriving template arguments between the block and non-block versions of the vmult/Tvmult functions, the actual functions are implemented in derived classes, with implementations forwarding the calls to the implementations provided here under a unique name for which template arguments can be derived by the compiler. </p>

</div>
</div>
<a class="anchor" id="a5778d1ae1c22f2f1da64c35d2c1ce499"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType&gt; </div>
<div class="memtemplate">
template&lt;class BlockVectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; MatrixType &gt;::Tvmult_block_block </td>
          <td>(</td>
          <td class="paramtype">BlockVectorType &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BlockVectorType &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Matrix-vector multiplication: let <img class="formulaInl" alt="$dst = M^T*src$" src="form_282.png"/> with <img class="formulaInl" alt="$M$" src="form_103.png"/> being this matrix. This function does the same as vmult() but takes the transposed matrix.</p>
<p>Due to problems with deriving template arguments between the block and non-block versions of the vmult/Tvmult functions, the actual functions are implemented in derived classes, with implementations forwarding the calls to the implementations provided here under a unique name for which template arguments can be derived by the compiler. </p>

</div>
</div>
<a class="anchor" id="a42b645af6fef99f1f473fc3906c3cf08"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType&gt; </div>
<div class="memtemplate">
template&lt;class BlockVectorType , class VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; MatrixType &gt;::Tvmult_block_nonblock </td>
          <td>(</td>
          <td class="paramtype">BlockVectorType &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Matrix-vector multiplication. Just like the previous function, but only applicable if the matrix has only one block row.</p>
<p>Due to problems with deriving template arguments between the block and non-block versions of the vmult/Tvmult functions, the actual functions are implemented in derived classes, with implementations forwarding the calls to the implementations provided here under a unique name for which template arguments can be derived by the compiler. </p>

</div>
</div>
<a class="anchor" id="a6761d7f8ec17573e128193b8b204ecc1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType&gt; </div>
<div class="memtemplate">
template&lt;class BlockVectorType , class VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; MatrixType &gt;::Tvmult_nonblock_block </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BlockVectorType &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Matrix-vector multiplication. Just like the previous function, but only applicable if the matrix has only one block column.</p>
<p>Due to problems with deriving template arguments between the block and non-block versions of the vmult/Tvmult functions, the actual functions are implemented in derived classes, with implementations forwarding the calls to the implementations provided here under a unique name for which template arguments can be derived by the compiler. </p>

</div>
</div>
<a class="anchor" id="aacfdeeda1a6dd7b4bccae69c51836888"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType&gt; </div>
<div class="memtemplate">
template&lt;class VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; MatrixType &gt;::Tvmult_nonblock_nonblock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Matrix-vector multiplication. Just like the previous function, but only applicable if the matrix has only one block.</p>
<p>Due to problems with deriving template arguments between the block and non-block versions of the vmult/Tvmult functions, the actual functions are implemented in derived classes, with implementations forwarding the calls to the implementations provided here under a unique name for which template arguments can be derived by the compiler. </p>

</div>
</div>
<a class="anchor" id="a6f52ce530c3028e0d3194a719cb82576"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; MatrixType &gt;::prepare_add_operation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Some matrix types, in particular PETSc, need to synchronize set and add operations. This has to be done for all matrices in the BlockMatrix. This routine prepares adding of elements by notifying all blocks. Called by all internal routines before adding elements. </p>

</div>
</div>
<a class="anchor" id="a79d3d021b1004a8fb027b50e0862c149"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; MatrixType &gt;::prepare_set_operation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Notifies all blocks to let them prepare for setting elements, see <a class="el" href="classBlockMatrixBase.html#a6f52ce530c3028e0d3194a719cb82576">prepare_add_operation()</a>. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="a0d51bb7a4b7573dc73fdaab49f87e0a8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType&gt; </div>
<div class="memtemplate">
template&lt;typename , bool &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classBlockMatrixIterators_1_1Accessor.html">BlockMatrixIterators::Accessor</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Make the iterator class a friend. We have to work around a compiler bug here again. </p>

<p>Definition at line <a class="el" href="block__matrix__base_8h_source.html#l01325">1325</a> of file <a class="el" href="block__matrix__base_8h_source.html">block_matrix_base.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="aa401f344887a4647a9a14ef41629aed9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockIndices.html">BlockIndices</a> <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; MatrixType &gt;::row_block_indices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Index arrays for rows and columns. </p>

<p>Definition at line <a class="el" href="block__matrix__base_8h_source.html#l01002">1002</a> of file <a class="el" href="block__matrix__base_8h_source.html">block_matrix_base.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad051169f783aabc549769dd6ef98a698"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTable.html">Table</a>&lt;2,<a class="el" href="classSmartPointer.html">SmartPointer</a>&lt;<a class="el" href="classBlockMatrixBase.html#a20fc90a926e752327723e46607d3883a">BlockType</a>, <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt;MatrixType&gt; &gt; &gt; <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; MatrixType &gt;::sub_objects</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Array of sub-matrices. </p>

<p>Definition at line <a class="el" href="block__matrix__base_8h_source.html#l01008">1008</a> of file <a class="el" href="block__matrix__base_8h_source.html">block_matrix_base.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8696751203ad45336dfb8523d7803610"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structBlockMatrixBase_1_1TemporaryData.html">TemporaryData</a> <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; MatrixType &gt;::temporary_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A set of scratch arrays that can be used by the <a class="el" href="classBlockMatrixBase.html#ad8fe7a35a3336d251a4b3aa2c3ed9748">add()</a> and <a class="el" href="classBlockMatrixBase.html#a9784ec81d727db00f7dbfdc9859ee029">set()</a> functions that take pointers to data to pre-sort indices before use. Access from multiple threads is synchronized via the mutex variable that is part of the structure. </p>

<p>Definition at line <a class="el" href="block__matrix__base_8h_source.html#l01317">1317</a> of file <a class="el" href="block__matrix__base_8h_source.html">block_matrix_base.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/deal.II/lac/<a class="el" href="block__indices_8h_source.html">block_indices.h</a></li>
<li>include/deal.II/lac/<a class="el" href="block__matrix__base_8h_source.html">block_matrix_base.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jan 27 2014 15:27:16 for The deal.II Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
