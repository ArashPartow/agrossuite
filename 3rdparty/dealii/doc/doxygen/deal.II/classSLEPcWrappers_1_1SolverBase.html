<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>The deal.II Library: SLEPcWrappers::SolverBase Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="http://www.dealii.org/deal.ico"></link>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2014 by the deal.II authors"></meta>
<meta name="deal.II-version" content="8.1.0"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 8.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceSLEPcWrappers.html">SLEPcWrappers</a></li><li class="navelem"><a class="el" href="classSLEPcWrappers_1_1SolverBase.html">SolverBase</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classSLEPcWrappers_1_1SolverBase-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SLEPcWrappers::SolverBase Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="slepc__solver_8h_source.html">slepc_solver.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for SLEPcWrappers::SolverBase:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classSLEPcWrappers_1_1SolverBase__inherit__graph.svg" width="488" height="408"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSLEPcWrappers_1_1SolverBase_1_1SolverData.html">SolverData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac312fa0fae7a555205277f54e5ab10ad"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSLEPcWrappers_1_1SolverBase.html#ac312fa0fae7a555205277f54e5ab10ad">SolverBase</a> (<a class="el" href="classSolverControl.html">SolverControl</a> &amp;cn, const MPI_Comm &amp;<a class="el" href="classSLEPcWrappers_1_1SolverBase.html#a3ec98bb2955c5521f06ee42ca210b2f8">mpi_communicator</a>)</td></tr>
<tr class="separator:ac312fa0fae7a555205277f54e5ab10ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8febc15da604b336c9054f97971fe147"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSLEPcWrappers_1_1SolverBase.html#a8febc15da604b336c9054f97971fe147">~SolverBase</a> ()</td></tr>
<tr class="separator:a8febc15da604b336c9054f97971fe147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aded0d558ae3478cca7a8c5c49fe6c7f4"><td class="memTemplParams" colspan="2">template&lt;typename OutputVector &gt; </td></tr>
<tr class="memitem:aded0d558ae3478cca7a8c5c49fe6c7f4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSLEPcWrappers_1_1SolverBase.html#aded0d558ae3478cca7a8c5c49fe6c7f4">solve</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html">PETScWrappers::MatrixBase</a> &amp;A, std::vector&lt; PetscScalar &gt; &amp;eigenvalues, std::vector&lt; OutputVector &gt; &amp;eigenvectors, const unsigned <a class="el" href="classint.html">int</a> n_eigenpairs=1)</td></tr>
<tr class="separator:aded0d558ae3478cca7a8c5c49fe6c7f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6feba9c10427e7f780184382f3c055ae"><td class="memTemplParams" colspan="2">template&lt;typename OutputVector &gt; </td></tr>
<tr class="memitem:a6feba9c10427e7f780184382f3c055ae"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSLEPcWrappers_1_1SolverBase.html#a6feba9c10427e7f780184382f3c055ae">solve</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html">PETScWrappers::MatrixBase</a> &amp;A, const <a class="el" href="classPETScWrappers_1_1MatrixBase.html">PETScWrappers::MatrixBase</a> &amp;B, std::vector&lt; PetscScalar &gt; &amp;eigenvalues, std::vector&lt; OutputVector &gt; &amp;eigenvectors, const unsigned <a class="el" href="classint.html">int</a> n_eigenpairs=1)</td></tr>
<tr class="separator:a6feba9c10427e7f780184382f3c055ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a667f98189102667389ee34f0d55fec6a"><td class="memTemplParams" colspan="2">template&lt;typename OutputVector &gt; </td></tr>
<tr class="memitem:a667f98189102667389ee34f0d55fec6a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSLEPcWrappers_1_1SolverBase.html#a667f98189102667389ee34f0d55fec6a">solve</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html">PETScWrappers::MatrixBase</a> &amp;A, const <a class="el" href="classPETScWrappers_1_1MatrixBase.html">PETScWrappers::MatrixBase</a> &amp;B, std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;real_eigenvalues, std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;imag_eigenvalues, std::vector&lt; OutputVector &gt; &amp;real_eigenvectors, std::vector&lt; OutputVector &gt; &amp;imag_eigenvectors, const unsigned <a class="el" href="classint.html">int</a> n_eigenpairs=1)</td></tr>
<tr class="separator:a667f98189102667389ee34f0d55fec6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca26e14986a2412ac3ea518187861696"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSLEPcWrappers_1_1SolverBase.html#aca26e14986a2412ac3ea518187861696">set_initial_vector</a> (const <a class="el" href="classPETScWrappers_1_1VectorBase.html">PETScWrappers::VectorBase</a> &amp;this_initial_vector)</td></tr>
<tr class="separator:aca26e14986a2412ac3ea518187861696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44dfb5cd7267c4eab95ded8c568fb100"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSLEPcWrappers_1_1SolverBase.html#a44dfb5cd7267c4eab95ded8c568fb100">set_transformation</a> (<a class="el" href="classSLEPcWrappers_1_1TransformationBase.html">SLEPcWrappers::TransformationBase</a> &amp;this_transformation)</td></tr>
<tr class="separator:a44dfb5cd7267c4eab95ded8c568fb100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1638a3cbb1c4f5942f90c64d8ed088c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSLEPcWrappers_1_1SolverBase.html#aa1638a3cbb1c4f5942f90c64d8ed088c">set_target_eigenvalue</a> (const PetscScalar &amp;this_target)</td></tr>
<tr class="separator:aa1638a3cbb1c4f5942f90c64d8ed088c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02f0d7db3c68fa561bedfa7a2837f491"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSLEPcWrappers_1_1SolverBase.html#a02f0d7db3c68fa561bedfa7a2837f491">set_which_eigenpairs</a> (EPSWhich <a class="el" href="classSLEPcWrappers_1_1SolverBase.html#ab024295bf5b3ca365eb36fe853003f08">set_which</a>)</td></tr>
<tr class="separator:a02f0d7db3c68fa561bedfa7a2837f491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c29ad67901a701a57f17b8019218b3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSLEPcWrappers_1_1SolverBase.html#a8c29ad67901a701a57f17b8019218b3f">set_problem_type</a> (EPSProblemType <a class="el" href="classSLEPcWrappers_1_1SolverBase.html#ae17618a1f7529347838bd2c4f10a13f5">set_problem</a>)</td></tr>
<tr class="separator:a8c29ad67901a701a57f17b8019218b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34995ca49dec96d45c9c8adc1a71b39f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSLEPcWrappers_1_1SolverBase.html#a34995ca49dec96d45c9c8adc1a71b39f">get_solver_state</a> (const <a class="el" href="classSolverControl.html#afcdeab4b55513dbd766b56e35efecbaa">SolverControl::State</a> state)</td></tr>
<tr class="separator:a34995ca49dec96d45c9c8adc1a71b39f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dd6816be2cd629352d96f92c587f76c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSLEPcWrappers_1_1SolverBase.html#a6dd6816be2cd629352d96f92c587f76c">DeclException0</a> (ExcSLEPcWrappersUsageError)</td></tr>
<tr class="separator:a6dd6816be2cd629352d96f92c587f76c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc0e2f9140d1313312efda928127d6d2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSLEPcWrappers_1_1SolverBase.html#adc0e2f9140d1313312efda928127d6d2">DeclException1</a> (ExcSLEPcError, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;    An error with error number &quot;&lt;&lt; arg1&lt;&lt; &quot; occurred while calling a SLEPc function&quot;)</td></tr>
<tr class="separator:adc0e2f9140d1313312efda928127d6d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97a815e90f2bd5088b3412315bf36630"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSLEPcWrappers_1_1SolverBase.html#a97a815e90f2bd5088b3412315bf36630">DeclException2</a> (ExcSLEPcEigenvectorConvergenceMismatchError, <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;    The number of converged eigenvectors is &quot;&lt;&lt; arg1&lt;&lt; &quot; but &quot;&lt;&lt; arg2&lt;&lt; &quot; were requested. &quot;)</td></tr>
<tr class="separator:a97a815e90f2bd5088b3412315bf36630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58bd319bd6ba7c35be00722dc4ca1e78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSolverControl.html">SolverControl</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSLEPcWrappers_1_1SolverBase.html#a58bd319bd6ba7c35be00722dc4ca1e78">control</a> () const </td></tr>
<tr class="separator:a58bd319bd6ba7c35be00722dc4ca1e78"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aa085486f77c2abf1d7766444830a0403"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSLEPcWrappers_1_1SolverBase.html#aa085486f77c2abf1d7766444830a0403">set_solver_type</a> (EPS &amp;eps) const =0</td></tr>
<tr class="separator:aa085486f77c2abf1d7766444830a0403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab905e8e3612919772998ef2e8f41aaae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSLEPcWrappers_1_1SolverBase.html#ab905e8e3612919772998ef2e8f41aaae">reset</a> ()</td></tr>
<tr class="separator:ab905e8e3612919772998ef2e8f41aaae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a807571d96d6c59b28e7105dcbe6153"><td class="memItemLeft" align="right" valign="top">EPS *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSLEPcWrappers_1_1SolverBase.html#a1a807571d96d6c59b28e7105dcbe6153">get_eps</a> ()</td></tr>
<tr class="separator:a1a807571d96d6c59b28e7105dcbe6153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae047335930066dc6f741fa6132f857e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSLEPcWrappers_1_1SolverBase.html#ae047335930066dc6f741fa6132f857e1">solve</a> (const unsigned <a class="el" href="classint.html">int</a> n_eigenpairs, unsigned <a class="el" href="classint.html">int</a> *n_converged)</td></tr>
<tr class="separator:ae047335930066dc6f741fa6132f857e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bdfaf67ecd695e625f0ae628145a405"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSLEPcWrappers_1_1SolverBase.html#a9bdfaf67ecd695e625f0ae628145a405">get_eigenpair</a> (const unsigned <a class="el" href="classint.html">int</a> index, PetscScalar &amp;eigenvalues, <a class="el" href="classPETScWrappers_1_1VectorBase.html">PETScWrappers::VectorBase</a> &amp;eigenvectors)</td></tr>
<tr class="separator:a9bdfaf67ecd695e625f0ae628145a405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c4a4f15a833d89c2b809d82cd5ec966"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSLEPcWrappers_1_1SolverBase.html#a2c4a4f15a833d89c2b809d82cd5ec966">get_eigenpair</a> (const unsigned <a class="el" href="classint.html">int</a> index, <a class="el" href="classdouble.html">double</a> &amp;real_eigenvalues, <a class="el" href="classdouble.html">double</a> &amp;imag_eigenvalues, <a class="el" href="classPETScWrappers_1_1VectorBase.html">PETScWrappers::VectorBase</a> &amp;real_eigenvectors, <a class="el" href="classPETScWrappers_1_1VectorBase.html">PETScWrappers::VectorBase</a> &amp;imag_eigenvectors)</td></tr>
<tr class="separator:a2c4a4f15a833d89c2b809d82cd5ec966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0383015536cbaee55015033d3572f48"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSLEPcWrappers_1_1SolverBase.html#ad0383015536cbaee55015033d3572f48">set_matrices</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html">PETScWrappers::MatrixBase</a> &amp;A)</td></tr>
<tr class="separator:ad0383015536cbaee55015033d3572f48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb5e48c2c64ad908d618ccab96ee17d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSLEPcWrappers_1_1SolverBase.html#afb5e48c2c64ad908d618ccab96ee17d4">set_matrices</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html">PETScWrappers::MatrixBase</a> &amp;A, const <a class="el" href="classPETScWrappers_1_1MatrixBase.html">PETScWrappers::MatrixBase</a> &amp;B)</td></tr>
<tr class="separator:afb5e48c2c64ad908d618ccab96ee17d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ab23353b0d62383f7e5b2a3f98df5af79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSolverControl.html">SolverControl</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSLEPcWrappers_1_1SolverBase.html#ab23353b0d62383f7e5b2a3f98df5af79">solver_control</a></td></tr>
<tr class="separator:ab23353b0d62383f7e5b2a3f98df5af79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ec98bb2955c5521f06ee42ca210b2f8"><td class="memItemLeft" align="right" valign="top">const MPI_Comm&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSLEPcWrappers_1_1SolverBase.html#a3ec98bb2955c5521f06ee42ca210b2f8">mpi_communicator</a></td></tr>
<tr class="separator:a3ec98bb2955c5521f06ee42ca210b2f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66d0a2729bbd24a6adce0d40e51fab4d"><td class="memItemLeft" align="right" valign="top">PetscScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSLEPcWrappers_1_1SolverBase.html#a66d0a2729bbd24a6adce0d40e51fab4d">target_eigenvalue</a></td></tr>
<tr class="separator:a66d0a2729bbd24a6adce0d40e51fab4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab024295bf5b3ca365eb36fe853003f08"><td class="memItemLeft" align="right" valign="top">EPSWhich&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSLEPcWrappers_1_1SolverBase.html#ab024295bf5b3ca365eb36fe853003f08">set_which</a></td></tr>
<tr class="separator:ab024295bf5b3ca365eb36fe853003f08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae17618a1f7529347838bd2c4f10a13f5"><td class="memItemLeft" align="right" valign="top">EPSProblemType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSLEPcWrappers_1_1SolverBase.html#ae17618a1f7529347838bd2c4f10a13f5">set_problem</a></td></tr>
<tr class="separator:ae17618a1f7529347838bd2c4f10a13f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:a2138eaf6904c3f368c336029730499eb"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSLEPcWrappers_1_1SolverBase.html#a2138eaf6904c3f368c336029730499eb">convergence_test</a> (EPS eps, PetscScalar real_eigenvalue, PetscScalar imag_eigenvalue, PetscReal residual_norm, PetscReal *estimated_error, void *<a class="el" href="classSLEPcWrappers_1_1SolverBase.html#ab23353b0d62383f7e5b2a3f98df5af79">solver_control</a>)</td></tr>
<tr class="separator:a2138eaf6904c3f368c336029730499eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a6a272bd8a356ed21675cb3ce8d297e02"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html">PETScWrappers::MatrixBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSLEPcWrappers_1_1SolverBase.html#a6a272bd8a356ed21675cb3ce8d297e02">opA</a></td></tr>
<tr class="separator:a6a272bd8a356ed21675cb3ce8d297e02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22ae0cd42fc0a3e0e4798192f90f2671"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html">PETScWrappers::MatrixBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSLEPcWrappers_1_1SolverBase.html#a22ae0cd42fc0a3e0e4798192f90f2671">opB</a></td></tr>
<tr class="separator:a22ae0cd42fc0a3e0e4798192f90f2671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9d4c9699f6a5882ec39a2bff261f148"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">PETScWrappers::VectorBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSLEPcWrappers_1_1SolverBase.html#ab9d4c9699f6a5882ec39a2bff261f148">initial_vector</a></td></tr>
<tr class="separator:ab9d4c9699f6a5882ec39a2bff261f148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afce6312a27eea7c4bda847059072303b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSLEPcWrappers_1_1TransformationBase.html">SLEPcWrappers::TransformationBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSLEPcWrappers_1_1SolverBase.html#afce6312a27eea7c4bda847059072303b">transformation</a></td></tr>
<tr class="separator:afce6312a27eea7c4bda847059072303b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac29575adb5357c7570ce107eb9ea7c7d"><td class="memItemLeft" align="right" valign="top">std_cxx1x::shared_ptr&lt; <a class="el" href="structSLEPcWrappers_1_1SolverBase_1_1SolverData.html">SolverData</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSLEPcWrappers_1_1SolverBase.html#ac29575adb5357c7570ce107eb9ea7c7d">solver_data</a></td></tr>
<tr class="separator:ac29575adb5357c7570ce107eb9ea7c7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Base class for solver classes using the SLEPc solvers. Since solvers in SLEPc are selected based on flags passed to a generic solver object, basically all the actual solver calls happen in this class, and derived classes simply set the right flags to select one solver or another, or to set certain parameters for individual solvers. </p>

<p>Definition at line <a class="el" href="slepc__solver_8h_source.html#l00119">119</a> of file <a class="el" href="slepc__solver_8h_source.html">slepc_solver.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ac312fa0fae7a555205277f54e5ab10ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SLEPcWrappers::SolverBase::SolverBase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSolverControl.html">SolverControl</a> &amp;&#160;</td>
          <td class="paramname"><em>cn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>mpi_communicator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. Takes the MPI communicator over which parallel computations are to happen. </p>

</div>
</div>
<a class="anchor" id="a8febc15da604b336c9054f97971fe147"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual SLEPcWrappers::SolverBase::~SolverBase </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aded0d558ae3478cca7a8c5c49fe6c7f4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SLEPcWrappers::SolverBase::solve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html">PETScWrappers::MatrixBase</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; PetscScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>eigenvalues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; OutputVector &gt; &amp;&#160;</td>
          <td class="paramname"><em>eigenvectors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_eigenpairs</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Composite method that solves the eigensystem <img class="formulaInl" alt="$Ax=\lambda x$" src="form_385.png"/>. The eigenvector sent in has to have at least one element that we can use as a template when resizing, since we do not know the parameters of the specific vector class used (i.e. local_dofs for MPI vectors). However, while copying eigenvectors, at least twice the memory size of <code>eigenvectors</code> is being used (and can be more). To avoid doing this, the fairly standard calling sequence executed here is used: Initialise; Set up matrices for solving; Actually solve the system; Gather the solution(s); and reset.</p>
<dl class="section note"><dt>Note</dt><dd>Note that the number of converged eigenvectors can be larger than the number of eigenvectors requested; this is due to a round off error (success) of the eigenproblem solver context. If this is found to be the case we simply do not bother with more eigenpairs than requested, but handle that it may be more than specified by ignoring any extras. By default one eigenvector/eigenvalue pair is computed.</dd></dl>
<p>This is declared here to make it possible to take a std::vector of different <a class="el" href="namespacePETScWrappers.html">PETScWrappers</a> vector types </p>

<p>Definition at line <a class="el" href="slepc__solver_8h_source.html#l00750">750</a> of file <a class="el" href="slepc__solver_8h_source.html">slepc_solver.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6feba9c10427e7f780184382f3c055ae"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SLEPcWrappers::SolverBase::solve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html">PETScWrappers::MatrixBase</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html">PETScWrappers::MatrixBase</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; PetscScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>eigenvalues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; OutputVector &gt; &amp;&#160;</td>
          <td class="paramname"><em>eigenvectors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_eigenpairs</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above, but here a composite method for solving the system <img class="formulaInl" alt="$A x=\lambda B x$" src="form_375.png"/>, for real matrices, vectors, and values <img class="formulaInl" alt="$A, B, x, \lambda$" src="form_386.png"/>. </p>

<p>Definition at line <a class="el" href="slepc__solver_8h_source.html#l00781">781</a> of file <a class="el" href="slepc__solver_8h_source.html">slepc_solver.h</a>.</p>

</div>
</div>
<a class="anchor" id="a667f98189102667389ee34f0d55fec6a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SLEPcWrappers::SolverBase::solve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html">PETScWrappers::MatrixBase</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html">PETScWrappers::MatrixBase</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>real_eigenvalues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>imag_eigenvalues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; OutputVector &gt; &amp;&#160;</td>
          <td class="paramname"><em>real_eigenvectors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; OutputVector &gt; &amp;&#160;</td>
          <td class="paramname"><em>imag_eigenvectors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_eigenpairs</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above, but here a composite method for solving the system <img class="formulaInl" alt="$A x=\lambda B x$" src="form_375.png"/> with real matrices <img class="formulaInl" alt="$A, B$" src="form_387.png"/> and imaginary eigenpairs <img class="formulaInl" alt="$x, \lambda$" src="form_388.png"/>. </p>

<p>Definition at line <a class="el" href="slepc__solver_8h_source.html#l00818">818</a> of file <a class="el" href="slepc__solver_8h_source.html">slepc_solver.h</a>.</p>

</div>
</div>
<a class="anchor" id="aca26e14986a2412ac3ea518187861696"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SLEPcWrappers::SolverBase::set_initial_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">PETScWrappers::VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>this_initial_vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the initial vector for the solver. </p>

</div>
</div>
<a class="anchor" id="a44dfb5cd7267c4eab95ded8c568fb100"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SLEPcWrappers::SolverBase::set_transformation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSLEPcWrappers_1_1TransformationBase.html">SLEPcWrappers::TransformationBase</a> &amp;&#160;</td>
          <td class="paramname"><em>this_transformation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the spectral transformation to be used. </p>

</div>
</div>
<a class="anchor" id="aa1638a3cbb1c4f5942f90c64d8ed088c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SLEPcWrappers::SolverBase::set_target_eigenvalue </td>
          <td>(</td>
          <td class="paramtype">const PetscScalar &amp;&#160;</td>
          <td class="paramname"><em>this_target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set target eigenvalues in the spectrum to be computed. By default, no target is set. </p>

</div>
</div>
<a class="anchor" id="a02f0d7db3c68fa561bedfa7a2837f491"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SLEPcWrappers::SolverBase::set_which_eigenpairs </td>
          <td>(</td>
          <td class="paramtype">EPSWhich&#160;</td>
          <td class="paramname"><em>set_which</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicate which part of the spectrum is to be computed. By default largest magnitude eigenvalues are computed.</p>
<dl class="section note"><dt>Note</dt><dd>For other allowed values see the SLEPc documentation. </dd></dl>

</div>
</div>
<a class="anchor" id="a8c29ad67901a701a57f17b8019218b3f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SLEPcWrappers::SolverBase::set_problem_type </td>
          <td>(</td>
          <td class="paramtype">EPSProblemType&#160;</td>
          <td class="paramname"><em>set_problem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Specify the type of the eigenspectrum problem. This can be used to exploit known symmetries of the matrices that make up the standard/generalized eigenspectrum problem. By default a non-Hermitian problem is assumed.</p>
<dl class="section note"><dt>Note</dt><dd>For other allowed values see the SLEPc documentation. </dd></dl>

</div>
</div>
<a class="anchor" id="a34995ca49dec96d45c9c8adc1a71b39f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SLEPcWrappers::SolverBase::get_solver_state </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSolverControl.html#afcdeab4b55513dbd766b56e35efecbaa">SolverControl::State</a>&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Take the information provided from SLEPc and checks it against deal.II's own <a class="el" href="classSolverControl.html">SolverControl</a> objects to see if convergence has been reached. </p>

</div>
</div>
<a class="anchor" id="a6dd6816be2cd629352d96f92c587f76c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SLEPcWrappers::SolverBase::DeclException0 </td>
          <td>(</td>
          <td class="paramtype">ExcSLEPcWrappersUsageError&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exception. Standard exception. </p>

</div>
</div>
<a class="anchor" id="adc0e2f9140d1313312efda928127d6d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SLEPcWrappers::SolverBase::DeclException1 </td>
          <td>(</td>
          <td class="paramtype">ExcSLEPcError&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot; An error with error number &quot;&lt;&lt; arg1&lt;&lt; &quot; occurred while calling a SLEPc function&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exception. SLEPc error with error number. </p>

</div>
</div>
<a class="anchor" id="a97a815e90f2bd5088b3412315bf36630"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SLEPcWrappers::SolverBase::DeclException2 </td>
          <td>(</td>
          <td class="paramtype">ExcSLEPcEigenvectorConvergenceMismatchError&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot; The number of converged eigenvectors is &quot;&lt;&lt; arg1&lt;&lt; &quot; but &quot;&lt;&lt; arg2&lt;&lt; &quot; were requested. &quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exception. Convergence failure on the number of eigenvectors. </p>

</div>
</div>
<a class="anchor" id="a58bd319bd6ba7c35be00722dc4ca1e78"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSolverControl.html">SolverControl</a>&amp; SLEPcWrappers::SolverBase::control </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access to the object that controls convergence. </p>

</div>
</div>
<a class="anchor" id="aa085486f77c2abf1d7766444830a0403"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SLEPcWrappers::SolverBase::set_solver_type </td>
          <td>(</td>
          <td class="paramtype">EPS &amp;&#160;</td>
          <td class="paramname"><em>eps</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classFunction.html">Function</a> that takes an Eigenvalue Problem <a class="el" href="classSolver.html">Solver</a> context object, and sets the type of solver that is requested by the derived class. </p>

<p>Implemented in <a class="el" href="classSLEPcWrappers_1_1SolverLAPACK.html#a4c745b3c88c64e1f2536c7215463d6fc">SLEPcWrappers::SolverLAPACK</a>, <a class="el" href="classSLEPcWrappers_1_1SolverJacobiDavidson.html#a3c016ee0a83a959f1a314625f334f6e4">SLEPcWrappers::SolverJacobiDavidson</a>, <a class="el" href="classSLEPcWrappers_1_1SolverGeneralizedDavidson.html#aecfebd8e42e81fcb6262a6cc6a43cfff">SLEPcWrappers::SolverGeneralizedDavidson</a>, <a class="el" href="classSLEPcWrappers_1_1SolverPower.html#a1746ecf7808d120de94797cc621474f3">SLEPcWrappers::SolverPower</a>, <a class="el" href="classSLEPcWrappers_1_1SolverLanczos.html#a7f5d89f4e9e19ac49ca202e72eb6a5b8">SLEPcWrappers::SolverLanczos</a>, <a class="el" href="classSLEPcWrappers_1_1SolverArnoldi.html#af701e528d7c40658f7e9e8f263a79733">SLEPcWrappers::SolverArnoldi</a>, and <a class="el" href="classSLEPcWrappers_1_1SolverKrylovSchur.html#afdb9272e72c0a004f9eb984e34b168a1">SLEPcWrappers::SolverKrylovSchur</a>.</p>

</div>
</div>
<a class="anchor" id="ab905e8e3612919772998ef2e8f41aaae"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SLEPcWrappers::SolverBase::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reset the solver, and return memory for eigenvectors </p>

</div>
</div>
<a class="anchor" id="a1a807571d96d6c59b28e7105dcbe6153"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EPS* SLEPcWrappers::SolverBase::get_eps </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Retrieve the SLEPc solver object that is internally used. </p>

</div>
</div>
<a class="anchor" id="ae047335930066dc6f741fa6132f857e1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SLEPcWrappers::SolverBase::solve </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_eigenpairs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned <a class="el" href="classint.html">int</a> *&#160;</td>
          <td class="paramname"><em>n_converged</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Solve the linear system for <code>n_eigenpairs</code> eigenstates. Parameter <code>n_converged</code> contains the actual number of eigenstates that have converged; this can be both fewer or more than n_eigenpairs, depending on the SLEPc eigensolver used. </p>

</div>
</div>
<a class="anchor" id="a9bdfaf67ecd695e625f0ae628145a405"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SLEPcWrappers::SolverBase::get_eigenpair </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PetscScalar &amp;&#160;</td>
          <td class="paramname"><em>eigenvalues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1VectorBase.html">PETScWrappers::VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>eigenvectors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Access the real parts of solutions for a solved eigenvector problem, pair index solutions, <img class="formulaInl" alt="$\text{index}\,\in\,0\hdots \text{n\_converged}-1$" src="form_389.png"/>. </p>

</div>
</div>
<a class="anchor" id="a2c4a4f15a833d89c2b809d82cd5ec966"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SLEPcWrappers::SolverBase::get_eigenpair </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a> &amp;&#160;</td>
          <td class="paramname"><em>real_eigenvalues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a> &amp;&#160;</td>
          <td class="paramname"><em>imag_eigenvalues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1VectorBase.html">PETScWrappers::VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>real_eigenvectors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1VectorBase.html">PETScWrappers::VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>imag_eigenvectors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Access the real and imaginary parts of solutions for a solved eigenvector problem, pair index solutions, <img class="formulaInl" alt="$\text{index}\,\in\,0\hdots \text{n\_converged}-1$" src="form_389.png"/>. </p>

</div>
</div>
<a class="anchor" id="ad0383015536cbaee55015033d3572f48"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SLEPcWrappers::SolverBase::set_matrices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html">PETScWrappers::MatrixBase</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initialize solver for the linear system <img class="formulaInl" alt="$Ax=\lambda x$" src="form_385.png"/>. (Note: this is required before calling solve ()) </p>

</div>
</div>
<a class="anchor" id="afb5e48c2c64ad908d618ccab96ee17d4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SLEPcWrappers::SolverBase::set_matrices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html">PETScWrappers::MatrixBase</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html">PETScWrappers::MatrixBase</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as above, but here initialize solver for the linear system <img class="formulaInl" alt="$A x=\lambda B x$" src="form_375.png"/>. </p>

</div>
</div>
<a class="anchor" id="a2138eaf6904c3f368c336029730499eb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classint.html">int</a> SLEPcWrappers::SolverBase::convergence_test </td>
          <td>(</td>
          <td class="paramtype">EPS&#160;</td>
          <td class="paramname"><em>eps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PetscScalar&#160;</td>
          <td class="paramname"><em>real_eigenvalue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PetscScalar&#160;</td>
          <td class="paramname"><em>imag_eigenvalue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PetscReal&#160;</td>
          <td class="paramname"><em>residual_norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PetscReal *&#160;</td>
          <td class="paramname"><em>estimated_error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>solver_control</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A function that can be used in SLEPc as a callback to check on convergence.</p>
<dl class="section note"><dt>Note</dt><dd>This function is redundant. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="ab23353b0d62383f7e5b2a3f98df5af79"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSolverControl.html">SolverControl</a>&amp; SLEPcWrappers::SolverBase::solver_control</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reference to the object that controls convergence of the iterative solver. </p>

<p>Definition at line <a class="el" href="slepc__solver_8h_source.html#l00269">269</a> of file <a class="el" href="slepc__solver_8h_source.html">slepc_solver.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3ec98bb2955c5521f06ee42ca210b2f8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const MPI_Comm SLEPcWrappers::SolverBase::mpi_communicator</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy of the MPI communicator object to be used for the solver. </p>

<p>Definition at line <a class="el" href="slepc__solver_8h_source.html#l00274">274</a> of file <a class="el" href="slepc__solver_8h_source.html">slepc_solver.h</a>.</p>

</div>
</div>
<a class="anchor" id="a66d0a2729bbd24a6adce0d40e51fab4d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PetscScalar SLEPcWrappers::SolverBase::target_eigenvalue</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Target eigenvalue to solve for. </p>

<p>Definition at line <a class="el" href="slepc__solver_8h_source.html#l00345">345</a> of file <a class="el" href="slepc__solver_8h_source.html">slepc_solver.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab024295bf5b3ca365eb36fe853003f08"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EPSWhich SLEPcWrappers::SolverBase::set_which</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Which portion of the spectrum to solve from. </p>

<p>Definition at line <a class="el" href="slepc__solver_8h_source.html#l00350">350</a> of file <a class="el" href="slepc__solver_8h_source.html">slepc_solver.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae17618a1f7529347838bd2c4f10a13f5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EPSProblemType SLEPcWrappers::SolverBase::set_problem</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the eigenspectrum problem type. </p>

<p>Definition at line <a class="el" href="slepc__solver_8h_source.html#l00355">355</a> of file <a class="el" href="slepc__solver_8h_source.html">slepc_solver.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6a272bd8a356ed21675cb3ce8d297e02"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html">PETScWrappers::MatrixBase</a>* SLEPcWrappers::SolverBase::opA</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The matrix <img class="formulaInl" alt="$A$" src="form_131.png"/> of the generalized eigenvalue problem <img class="formulaInl" alt="$Ax=B\lambda x$" src="form_374.png"/>, or the standard eigenvalue problem <img class="formulaInl" alt="$Ax=\lambda x$" src="form_385.png"/>. </p>

<p>Definition at line <a class="el" href="slepc__solver_8h_source.html#l00364">364</a> of file <a class="el" href="slepc__solver_8h_source.html">slepc_solver.h</a>.</p>

</div>
</div>
<a class="anchor" id="a22ae0cd42fc0a3e0e4798192f90f2671"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html">PETScWrappers::MatrixBase</a>* SLEPcWrappers::SolverBase::opB</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The matrix <img class="formulaInl" alt="$B$" src="form_105.png"/> of the generalized eigenvalue problem <img class="formulaInl" alt="$Ax=B\lambda x$" src="form_374.png"/>. </p>

<p>Definition at line <a class="el" href="slepc__solver_8h_source.html#l00370">370</a> of file <a class="el" href="slepc__solver_8h_source.html">slepc_solver.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab9d4c9699f6a5882ec39a2bff261f148"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">PETScWrappers::VectorBase</a>* SLEPcWrappers::SolverBase::initial_vector</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>An initial vector used to "feed" some SLEPc solvers. </p>

<p>Definition at line <a class="el" href="slepc__solver_8h_source.html#l00375">375</a> of file <a class="el" href="slepc__solver_8h_source.html">slepc_solver.h</a>.</p>

</div>
</div>
<a class="anchor" id="afce6312a27eea7c4bda847059072303b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSLEPcWrappers_1_1TransformationBase.html">SLEPcWrappers::TransformationBase</a>* SLEPcWrappers::SolverBase::transformation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pointer to an an object that describes transformations that can be applied to the eigenvalue problem. </p>

<p>Definition at line <a class="el" href="slepc__solver_8h_source.html#l00381">381</a> of file <a class="el" href="slepc__solver_8h_source.html">slepc_solver.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac29575adb5357c7570ce107eb9ea7c7d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std_cxx1x::shared_ptr&lt;<a class="el" href="structSLEPcWrappers_1_1SolverBase_1_1SolverData.html">SolverData</a>&gt; SLEPcWrappers::SolverBase::solver_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pointer to the <code><a class="el" href="structSLEPcWrappers_1_1SolverBase_1_1SolverData.html">SolverData</a></code> object. </p>

<p>Definition at line <a class="el" href="slepc__solver_8h_source.html#l00428">428</a> of file <a class="el" href="slepc__solver_8h_source.html">slepc_solver.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/deal.II/lac/<a class="el" href="slepc__solver_8h_source.html">slepc_solver.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jan 27 2014 15:27:25 for The deal.II Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
