<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>The deal.II Library: SparseMatrix&lt; number &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="http://www.dealii.org/deal.ico"></link>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2014 by the deal.II authors"></meta>
<meta name="deal.II-version" content="8.1.0"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 8.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classSparseMatrix-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SparseMatrix&lt; number &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="sparse__matrix_8h_source.html">sparse_matrix.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for SparseMatrix&lt; number &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classSparseMatrix__inherit__graph.svg" width="339" height="291"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSparseMatrix_1_1Traits.html">Traits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a1cb2f7d50649c013cdc4167d13f1a744"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a></td></tr>
<tr class="separator:a1cb2f7d50649c013cdc4167d13f1a744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a709fd5b543c70449909e6dd9ac6fc50d"><td class="memItemLeft" align="right" valign="top">typedef number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a709fd5b543c70449909e6dd9ac6fc50d">value_type</a></td></tr>
<tr class="separator:a709fd5b543c70449909e6dd9ac6fc50d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1a755f1f5a3533379cd239c2db5d1d9"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a><br class="typebreak"/>
&lt; number &gt;::<a class="el" href="classSparseMatrix.html#ac1a755f1f5a3533379cd239c2db5d1d9">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#ac1a755f1f5a3533379cd239c2db5d1d9">real_type</a></td></tr>
<tr class="separator:ac1a755f1f5a3533379cd239c2db5d1d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab68b99a09eb5c23f6487c3e2d8fad45b"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="classSparseMatrixIterators_1_1Iterator.html">SparseMatrixIterators::Iterator</a><br class="typebreak"/>
&lt; number, true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#ab68b99a09eb5c23f6487c3e2d8fad45b">const_iterator</a></td></tr>
<tr class="separator:ab68b99a09eb5c23f6487c3e2d8fad45b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0934a2fc123b7772eb9bbafee3ff536c"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="classSparseMatrixIterators_1_1Iterator.html">SparseMatrixIterators::Iterator</a><br class="typebreak"/>
&lt; number, false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a0934a2fc123b7772eb9bbafee3ff536c">iterator</a></td></tr>
<tr class="separator:a0934a2fc123b7772eb9bbafee3ff536c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ga843aba60740407656418a3261e6a10f0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga843aba60740407656418a3261e6a10f0">DeclException2</a> (ExcInvalidIndex, <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;The entry with index &lt;&quot;&lt;&lt; arg1&lt;&lt;  ','&lt;&lt; arg2&lt;&lt; &quot;&gt; does not exist.&quot;)</td></tr>
<tr class="separator:ga843aba60740407656418a3261e6a10f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c6132c7e1262bf12dfc43cc23f4a7fd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga6c6132c7e1262bf12dfc43cc23f4a7fd">DeclException1</a> (ExcInvalidIndex1, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;The index &quot;&lt;&lt; arg1&lt;&lt; &quot; is not in the allowed range.&quot;)</td></tr>
<tr class="separator:ga6c6132c7e1262bf12dfc43cc23f4a7fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga444a68f9dfa4cd5a916e43fb56f4801f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga444a68f9dfa4cd5a916e43fb56f4801f">DeclException0</a> (ExcDifferentSparsityPatterns)</td></tr>
<tr class="separator:ga444a68f9dfa4cd5a916e43fb56f4801f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ab178929c14a89e3c7701b1251c4b0d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga1ab178929c14a89e3c7701b1251c4b0d">DeclException2</a> (ExcIteratorRange, <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;The iterators denote a range of &quot;&lt;&lt; arg1&lt;&lt; &quot; elements, but the given number of rows was &quot;&lt;&lt; arg2)</td></tr>
<tr class="separator:ga1ab178929c14a89e3c7701b1251c4b0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75a01e45a1113469b5c250e3dfeb169e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga75a01e45a1113469b5c250e3dfeb169e">DeclException0</a> (ExcSourceEqualsDestination)</td></tr>
<tr class="separator:ga75a01e45a1113469b5c250e3dfeb169e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors and initalization</div></td></tr>
<tr class="memitem:a0601c85d7c1e4cb11ad5cbf2fd27d593"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a0601c85d7c1e4cb11ad5cbf2fd27d593">SparseMatrix</a> ()</td></tr>
<tr class="separator:a0601c85d7c1e4cb11ad5cbf2fd27d593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1435ec2862610afc1b304dc52508b0f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#ae1435ec2862610afc1b304dc52508b0f">SparseMatrix</a> (const <a class="el" href="classSparseMatrix.html">SparseMatrix</a> &amp;)</td></tr>
<tr class="separator:ae1435ec2862610afc1b304dc52508b0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fd7c8660c196bb350961307b29cc9da"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a0fd7c8660c196bb350961307b29cc9da">SparseMatrix</a> (const <a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;sparsity)</td></tr>
<tr class="separator:a0fd7c8660c196bb350961307b29cc9da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a713953af05d18bdb920a4905fb412793"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a713953af05d18bdb920a4905fb412793">SparseMatrix</a> (const <a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;sparsity, const <a class="el" href="classIdentityMatrix.html">IdentityMatrix</a> &amp;id)</td></tr>
<tr class="separator:a713953af05d18bdb920a4905fb412793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2377111964e6c6945cefc8886ffc1b64"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a2377111964e6c6945cefc8886ffc1b64">~SparseMatrix</a> ()</td></tr>
<tr class="separator:a2377111964e6c6945cefc8886ffc1b64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24805e7fe4b37717961d58da063d65e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a24805e7fe4b37717961d58da063d65e3">operator=</a> (const <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;)</td></tr>
<tr class="separator:a24805e7fe4b37717961d58da063d65e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2af0c70e6edc8c671d9a998de21988c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#ae2af0c70e6edc8c671d9a998de21988c">operator=</a> (const <a class="el" href="classIdentityMatrix.html">IdentityMatrix</a> &amp;id)</td></tr>
<tr class="separator:ae2af0c70e6edc8c671d9a998de21988c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab49ee427d6f810b99c06354f90d4482"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseMatrix.html">SparseMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#aab49ee427d6f810b99c06354f90d4482">operator=</a> (const <a class="el" href="classdouble.html">double</a> d)</td></tr>
<tr class="separator:aab49ee427d6f810b99c06354f90d4482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a938e9611cc4a46102c852a8a43478f7b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a938e9611cc4a46102c852a8a43478f7b">reinit</a> (const <a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;sparsity)</td></tr>
<tr class="separator:a938e9611cc4a46102c852a8a43478f7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e58c65baa9a70517d6dcd6d3371a525"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a5e58c65baa9a70517d6dcd6d3371a525">clear</a> ()</td></tr>
<tr class="separator:a5e58c65baa9a70517d6dcd6d3371a525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Information on the matrix</div></td></tr>
<tr class="memitem:a7a1d8e902545d122cf4a187151faadbd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a7a1d8e902545d122cf4a187151faadbd">empty</a> () const </td></tr>
<tr class="separator:a7a1d8e902545d122cf4a187151faadbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9fca0157b64dc8a61bcdbdece2d7997"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#ad9fca0157b64dc8a61bcdbdece2d7997">m</a> () const </td></tr>
<tr class="separator:ad9fca0157b64dc8a61bcdbdece2d7997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec90ef9011582759280b62cdeecace28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#aec90ef9011582759280b62cdeecace28">n</a> () const </td></tr>
<tr class="separator:aec90ef9011582759280b62cdeecace28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad76dd5f6d4b26cdf43ac7a1c2feb1594"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#ad76dd5f6d4b26cdf43ac7a1c2feb1594">get_row_length</a> (const <a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a> row) const </td></tr>
<tr class="separator:ad76dd5f6d4b26cdf43ac7a1c2feb1594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf50d5cd6709d48a07582efb10c08fc2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#acf50d5cd6709d48a07582efb10c08fc2">n_nonzero_elements</a> () const </td></tr>
<tr class="separator:acf50d5cd6709d48a07582efb10c08fc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4e64fe641e12085681e143307d81d81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#ab4e64fe641e12085681e143307d81d81">n_actually_nonzero_elements</a> (const <a class="el" href="classdouble.html">double</a> threshold=0.) const </td></tr>
<tr class="separator:ab4e64fe641e12085681e143307d81d81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a665947fbcdfc112245dd96d223f1c544"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a665947fbcdfc112245dd96d223f1c544">get_sparsity_pattern</a> () const </td></tr>
<tr class="separator:a665947fbcdfc112245dd96d223f1c544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46cb4a0332852f790d38bd81cad38cdf"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a46cb4a0332852f790d38bd81cad38cdf">memory_consumption</a> () const </td></tr>
<tr class="separator:a46cb4a0332852f790d38bd81cad38cdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a231105aa86cca488901d94b1e1b55ac7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a231105aa86cca488901d94b1e1b55ac7">compress</a> (::VectorOperation::values)</td></tr>
<tr class="separator:a231105aa86cca488901d94b1e1b55ac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Modifying entries</div></td></tr>
<tr class="memitem:a3e77fcfbd1fa3ac83ef4ff2951b24ce3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a3e77fcfbd1fa3ac83ef4ff2951b24ce3">set</a> (const <a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a> i, const <a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a> j, const number value)</td></tr>
<tr class="separator:a3e77fcfbd1fa3ac83ef4ff2951b24ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fdc04dbbf9b8f0071b1f2da21d6e106"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:a2fdc04dbbf9b8f0071b1f2da21d6e106"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a2fdc04dbbf9b8f0071b1f2da21d6e106">set</a> (const std::vector&lt; <a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a> &gt; &amp;indices, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;full_matrix, const <a class="el" href="classbool.html">bool</a> elide_zero_values=false)</td></tr>
<tr class="separator:a2fdc04dbbf9b8f0071b1f2da21d6e106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae96779660698dc3fdd5640f860f14bec"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:ae96779660698dc3fdd5640f860f14bec"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#ae96779660698dc3fdd5640f860f14bec">set</a> (const std::vector&lt; <a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a> &gt; &amp;row_indices, const std::vector&lt; <a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a> &gt; &amp;col_indices, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;full_matrix, const <a class="el" href="classbool.html">bool</a> elide_zero_values=false)</td></tr>
<tr class="separator:ae96779660698dc3fdd5640f860f14bec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01efc87070a6730a10c4dc526bdb7701"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:a01efc87070a6730a10c4dc526bdb7701"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a01efc87070a6730a10c4dc526bdb7701">set</a> (const <a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a> row, const std::vector&lt; <a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a> &gt; &amp;col_indices, const std::vector&lt; number2 &gt; &amp;values, const <a class="el" href="classbool.html">bool</a> elide_zero_values=false)</td></tr>
<tr class="separator:a01efc87070a6730a10c4dc526bdb7701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd783c07fc8b97262201d70a71b5667d"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:afd783c07fc8b97262201d70a71b5667d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#afd783c07fc8b97262201d70a71b5667d">set</a> (const <a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a> row, const <a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a> n_cols, const <a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a> *col_indices, const number2 *values, const <a class="el" href="classbool.html">bool</a> elide_zero_values=false)</td></tr>
<tr class="separator:afd783c07fc8b97262201d70a71b5667d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acabf7629046afdd9077f77f7746a7a3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#acabf7629046afdd9077f77f7746a7a3f">add</a> (const <a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a> i, const <a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a> j, const number value)</td></tr>
<tr class="separator:acabf7629046afdd9077f77f7746a7a3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4a987fd196ead89df045829bcc181a1"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:af4a987fd196ead89df045829bcc181a1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#af4a987fd196ead89df045829bcc181a1">add</a> (const std::vector&lt; <a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a> &gt; &amp;indices, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;full_matrix, const <a class="el" href="classbool.html">bool</a> elide_zero_values=true)</td></tr>
<tr class="separator:af4a987fd196ead89df045829bcc181a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a538fb6831594e3bf994c9d44af68fccc"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:a538fb6831594e3bf994c9d44af68fccc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a538fb6831594e3bf994c9d44af68fccc">add</a> (const std::vector&lt; <a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a> &gt; &amp;row_indices, const std::vector&lt; <a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a> &gt; &amp;col_indices, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;full_matrix, const <a class="el" href="classbool.html">bool</a> elide_zero_values=true)</td></tr>
<tr class="separator:a538fb6831594e3bf994c9d44af68fccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae745cf2afd297c8acdfe33ace4d366f4"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:ae745cf2afd297c8acdfe33ace4d366f4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#ae745cf2afd297c8acdfe33ace4d366f4">add</a> (const <a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a> row, const std::vector&lt; <a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a> &gt; &amp;col_indices, const std::vector&lt; number2 &gt; &amp;values, const <a class="el" href="classbool.html">bool</a> elide_zero_values=true)</td></tr>
<tr class="separator:ae745cf2afd297c8acdfe33ace4d366f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac97efa0f970b0bcf40da82584f71d39c"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:ac97efa0f970b0bcf40da82584f71d39c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#ac97efa0f970b0bcf40da82584f71d39c">add</a> (const <a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a> row, const <a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a> n_cols, const <a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a> *col_indices, const number2 *values, const <a class="el" href="classbool.html">bool</a> elide_zero_values=true, const <a class="el" href="classbool.html">bool</a> col_indices_are_sorted=false)</td></tr>
<tr class="separator:ac97efa0f970b0bcf40da82584f71d39c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebb2ac677d0b2a212b289221ba4a43b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseMatrix.html">SparseMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#aebb2ac677d0b2a212b289221ba4a43b7">operator*=</a> (const number factor)</td></tr>
<tr class="separator:aebb2ac677d0b2a212b289221ba4a43b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99829ea532c57a8de890ee70b1faa24c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseMatrix.html">SparseMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a99829ea532c57a8de890ee70b1faa24c">operator/=</a> (const number factor)</td></tr>
<tr class="separator:a99829ea532c57a8de890ee70b1faa24c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70c1643ae82c4bd45a881c91d0066776"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a70c1643ae82c4bd45a881c91d0066776">symmetrize</a> ()</td></tr>
<tr class="separator:a70c1643ae82c4bd45a881c91d0066776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a443cef0b929aa692be721b9c2d7603bd"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:a443cef0b929aa692be721b9c2d7603bd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a443cef0b929aa692be721b9c2d7603bd">copy_from</a> (const <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; somenumber &gt; &amp;source)</td></tr>
<tr class="separator:a443cef0b929aa692be721b9c2d7603bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9240d87b7695c58c41c93506a4723c08"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator &gt; </td></tr>
<tr class="memitem:a9240d87b7695c58c41c93506a4723c08"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a9240d87b7695c58c41c93506a4723c08">copy_from</a> (const ForwardIterator <a class="el" href="classSparseMatrix.html#a1370b39c0ae075f6617079a7e6e92cb4">begin</a>, const ForwardIterator <a class="el" href="classSparseMatrix.html#ab32d93095dd3d641f65978214bdc8dc8">end</a>)</td></tr>
<tr class="separator:a9240d87b7695c58c41c93506a4723c08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad182785cbf271adb6a29fa470ecde8d7"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:ad182785cbf271adb6a29fa470ecde8d7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#ad182785cbf271adb6a29fa470ecde8d7">copy_from</a> (const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; somenumber &gt; &amp;matrix)</td></tr>
<tr class="separator:ad182785cbf271adb6a29fa470ecde8d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67db0fff36b7fcbf528472e1a95999c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a67db0fff36b7fcbf528472e1a95999c6">copy_from</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">TrilinosWrappers::SparseMatrix</a> &amp;matrix)</td></tr>
<tr class="separator:a67db0fff36b7fcbf528472e1a95999c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a157053c3502b33962ac736cc873a8dbd"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:a157053c3502b33962ac736cc873a8dbd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a157053c3502b33962ac736cc873a8dbd">add</a> (const number factor, const <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; somenumber &gt; &amp;matrix)</td></tr>
<tr class="separator:a157053c3502b33962ac736cc873a8dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Entry Access</div></td></tr>
<tr class="memitem:a8782886b62ad00220bbb91f7c462fa76"><td class="memItemLeft" align="right" valign="top">number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a8782886b62ad00220bbb91f7c462fa76">operator()</a> (const <a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a> i, const <a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a> j) const </td></tr>
<tr class="separator:a8782886b62ad00220bbb91f7c462fa76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6e1aaeb1c587a1ad5e1c8aa9b5301b0"><td class="memItemLeft" align="right" valign="top">number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#ab6e1aaeb1c587a1ad5e1c8aa9b5301b0">el</a> (const <a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a> i, const <a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a> j) const </td></tr>
<tr class="separator:ab6e1aaeb1c587a1ad5e1c8aa9b5301b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac180a838b54e30f5effb0f694c713693"><td class="memItemLeft" align="right" valign="top">number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#ac180a838b54e30f5effb0f694c713693">diag_element</a> (const <a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a> i) const </td></tr>
<tr class="separator:ac180a838b54e30f5effb0f694c713693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a159957553e3a4ca34cee51fdfa4cafa7"><td class="memItemLeft" align="right" valign="top">number &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a159957553e3a4ca34cee51fdfa4cafa7">diag_element</a> (const <a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a> i)</td></tr>
<tr class="separator:a159957553e3a4ca34cee51fdfa4cafa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ddaee1f32d7af004605f426c5d62582"><td class="memItemLeft" align="right" valign="top">number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a9ddaee1f32d7af004605f426c5d62582">raw_entry</a> (const <a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a> row, const <a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a> index) const <a class="el" href="group__Sparsity.html#ga0849dabf81f46d4d964e251c286784dd">DEAL_II_DEPRECATED</a></td></tr>
<tr class="separator:a9ddaee1f32d7af004605f426c5d62582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3822c2697bb048dc59a287c064dc9cfb"><td class="memItemLeft" align="right" valign="top">number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a3822c2697bb048dc59a287c064dc9cfb">global_entry</a> (const <a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a> i) const <a class="el" href="group__Sparsity.html#ga0849dabf81f46d4d964e251c286784dd">DEAL_II_DEPRECATED</a></td></tr>
<tr class="separator:a3822c2697bb048dc59a287c064dc9cfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61897f7afdf238414b274af52c76a3b4"><td class="memItemLeft" align="right" valign="top">number &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a61897f7afdf238414b274af52c76a3b4">global_entry</a> (const <a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a> i) <a class="el" href="group__Sparsity.html#ga0849dabf81f46d4d964e251c286784dd">DEAL_II_DEPRECATED</a></td></tr>
<tr class="separator:a61897f7afdf238414b274af52c76a3b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Multiplications</div></td></tr>
<tr class="memitem:a4b063fdeaeda83e9ee20e7a7dd2e87fc"><td class="memTemplParams" colspan="2">template&lt;class OutVector , class InVector &gt; </td></tr>
<tr class="memitem:a4b063fdeaeda83e9ee20e7a7dd2e87fc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a4b063fdeaeda83e9ee20e7a7dd2e87fc">vmult</a> (OutVector &amp;dst, const InVector &amp;src) const </td></tr>
<tr class="separator:a4b063fdeaeda83e9ee20e7a7dd2e87fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24e7f0a5a593899caf31f920ab359708"><td class="memTemplParams" colspan="2">template&lt;class OutVector , class InVector &gt; </td></tr>
<tr class="memitem:a24e7f0a5a593899caf31f920ab359708"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a24e7f0a5a593899caf31f920ab359708">Tvmult</a> (OutVector &amp;dst, const InVector &amp;src) const </td></tr>
<tr class="separator:a24e7f0a5a593899caf31f920ab359708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cdebf439a80dae23ec9862b346e5440"><td class="memTemplParams" colspan="2">template&lt;class OutVector , class InVector &gt; </td></tr>
<tr class="memitem:a3cdebf439a80dae23ec9862b346e5440"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a3cdebf439a80dae23ec9862b346e5440">vmult_add</a> (OutVector &amp;dst, const InVector &amp;src) const </td></tr>
<tr class="separator:a3cdebf439a80dae23ec9862b346e5440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1181a7f0a37603a2316a16821ec440e8"><td class="memTemplParams" colspan="2">template&lt;class OutVector , class InVector &gt; </td></tr>
<tr class="memitem:a1181a7f0a37603a2316a16821ec440e8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a1181a7f0a37603a2316a16821ec440e8">Tvmult_add</a> (OutVector &amp;dst, const InVector &amp;src) const </td></tr>
<tr class="separator:a1181a7f0a37603a2316a16821ec440e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5993eb7d62b3d24bff92e83f5d2ce6cf"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:a5993eb7d62b3d24bff92e83f5d2ce6cf"><td class="memTemplItemLeft" align="right" valign="top">somenumber&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a5993eb7d62b3d24bff92e83f5d2ce6cf">matrix_norm_square</a> (const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;v) const </td></tr>
<tr class="separator:a5993eb7d62b3d24bff92e83f5d2ce6cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88eca52a335bc26156b52e5af6e38648"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:a88eca52a335bc26156b52e5af6e38648"><td class="memTemplItemLeft" align="right" valign="top">somenumber&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a88eca52a335bc26156b52e5af6e38648">matrix_scalar_product</a> (const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;u, const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;v) const </td></tr>
<tr class="separator:a88eca52a335bc26156b52e5af6e38648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0a1a9142899fd5376415277cd4de6ab"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:ab0a1a9142899fd5376415277cd4de6ab"><td class="memTemplItemLeft" align="right" valign="top">somenumber&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#ab0a1a9142899fd5376415277cd4de6ab">residual</a> (<a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;dst, const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;x, const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;b) const </td></tr>
<tr class="separator:ab0a1a9142899fd5376415277cd4de6ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a503f0e40e8decc907deb10a779c2110b"><td class="memTemplParams" colspan="2">template&lt;typename numberB , typename numberC &gt; </td></tr>
<tr class="memitem:a503f0e40e8decc907deb10a779c2110b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a503f0e40e8decc907deb10a779c2110b">mmult</a> (<a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; numberC &gt; &amp;C, const <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; numberB &gt; &amp;B, const <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;V=<a class="el" href="classVector.html">Vector</a>&lt; number &gt;(), const <a class="el" href="classbool.html">bool</a> rebuild_sparsity_pattern=true) const </td></tr>
<tr class="separator:a503f0e40e8decc907deb10a779c2110b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07ba942c5b7466b3895fed3104fbcc26"><td class="memTemplParams" colspan="2">template&lt;typename numberB , typename numberC &gt; </td></tr>
<tr class="memitem:a07ba942c5b7466b3895fed3104fbcc26"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a07ba942c5b7466b3895fed3104fbcc26">Tmmult</a> (<a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; numberC &gt; &amp;C, const <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; numberB &gt; &amp;B, const <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;V=<a class="el" href="classVector.html">Vector</a>&lt; number &gt;(), const <a class="el" href="classbool.html">bool</a> rebuild_sparsity_pattern=true) const </td></tr>
<tr class="separator:a07ba942c5b7466b3895fed3104fbcc26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Matrix norms</div></td></tr>
<tr class="memitem:af81bbc4329957ee3b52525286dfde99a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseMatrix.html#ac1a755f1f5a3533379cd239c2db5d1d9">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#af81bbc4329957ee3b52525286dfde99a">l1_norm</a> () const </td></tr>
<tr class="separator:af81bbc4329957ee3b52525286dfde99a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41e9f754d2d2ad2d93b196455131258f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseMatrix.html#ac1a755f1f5a3533379cd239c2db5d1d9">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a41e9f754d2d2ad2d93b196455131258f">linfty_norm</a> () const </td></tr>
<tr class="separator:a41e9f754d2d2ad2d93b196455131258f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f6562d657fd27db57b76703de98104e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseMatrix.html#ac1a755f1f5a3533379cd239c2db5d1d9">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a8f6562d657fd27db57b76703de98104e">frobenius_norm</a> () const </td></tr>
<tr class="separator:a8f6562d657fd27db57b76703de98104e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Preconditioning methods</div></td></tr>
<tr class="memitem:ab31798ddc8a7ad8f9b02092252241cd0"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:ab31798ddc8a7ad8f9b02092252241cd0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#ab31798ddc8a7ad8f9b02092252241cd0">precondition_Jacobi</a> (<a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;dst, const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;src, const number omega=1.) const </td></tr>
<tr class="separator:ab31798ddc8a7ad8f9b02092252241cd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e0872ebae78c6684f4fdc4d72eddc91"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:a0e0872ebae78c6684f4fdc4d72eddc91"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a0e0872ebae78c6684f4fdc4d72eddc91">precondition_SSOR</a> (<a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;dst, const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;src, const number omega=1., const std::vector&lt; std::size_t &gt; &amp;pos_right_of_diagonal=std::vector&lt; std::size_t &gt;()) const </td></tr>
<tr class="separator:a0e0872ebae78c6684f4fdc4d72eddc91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61bc5b57ce74c31dfb44bf5dc620532e"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:a61bc5b57ce74c31dfb44bf5dc620532e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a61bc5b57ce74c31dfb44bf5dc620532e">precondition_SOR</a> (<a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;dst, const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;src, const number om=1.) const </td></tr>
<tr class="separator:a61bc5b57ce74c31dfb44bf5dc620532e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bc66daab9f6fc8282a236fa4db3b2e6"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:a8bc66daab9f6fc8282a236fa4db3b2e6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a8bc66daab9f6fc8282a236fa4db3b2e6">precondition_TSOR</a> (<a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;dst, const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;src, const number om=1.) const </td></tr>
<tr class="separator:a8bc66daab9f6fc8282a236fa4db3b2e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ce211a145d0c0316ba9351443b9ebb0"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:a0ce211a145d0c0316ba9351443b9ebb0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a0ce211a145d0c0316ba9351443b9ebb0">SSOR</a> (<a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;v, const number omega=1.) const </td></tr>
<tr class="separator:a0ce211a145d0c0316ba9351443b9ebb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7167da17a920b4e01d590d14c0a317dc"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:a7167da17a920b4e01d590d14c0a317dc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a7167da17a920b4e01d590d14c0a317dc">SOR</a> (<a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;v, const number om=1.) const </td></tr>
<tr class="separator:a7167da17a920b4e01d590d14c0a317dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdc2a51ed293c3e5109118ff0501703f"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:abdc2a51ed293c3e5109118ff0501703f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#abdc2a51ed293c3e5109118ff0501703f">TSOR</a> (<a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;v, const number om=1.) const </td></tr>
<tr class="separator:abdc2a51ed293c3e5109118ff0501703f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab237dbc208a1adfe5e2a7eea15ed8a7"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:aab237dbc208a1adfe5e2a7eea15ed8a7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#aab237dbc208a1adfe5e2a7eea15ed8a7">PSOR</a> (<a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;v, const std::vector&lt; <a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a> &gt; &amp;permutation, const std::vector&lt; <a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a> &gt; &amp;inverse_permutation, const number om=1.) const </td></tr>
<tr class="separator:aab237dbc208a1adfe5e2a7eea15ed8a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee72f32b604abafe4ebe4ad80efbabe1"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:aee72f32b604abafe4ebe4ad80efbabe1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#aee72f32b604abafe4ebe4ad80efbabe1">TPSOR</a> (<a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;v, const std::vector&lt; <a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a> &gt; &amp;permutation, const std::vector&lt; <a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a> &gt; &amp;inverse_permutation, const number om=1.) const </td></tr>
<tr class="separator:aee72f32b604abafe4ebe4ad80efbabe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9abd0eaa7c5ac3e86c12f7feb58e6b3"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:ab9abd0eaa7c5ac3e86c12f7feb58e6b3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#ab9abd0eaa7c5ac3e86c12f7feb58e6b3">Jacobi_step</a> (<a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;v, const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;b, const number om=1.) const </td></tr>
<tr class="separator:ab9abd0eaa7c5ac3e86c12f7feb58e6b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6428ebb9f66bed089e206589bd280bec"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:a6428ebb9f66bed089e206589bd280bec"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a6428ebb9f66bed089e206589bd280bec">SOR_step</a> (<a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;v, const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;b, const number om=1.) const </td></tr>
<tr class="separator:a6428ebb9f66bed089e206589bd280bec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a546421f9dfbf69ec3e5f2f98ca23f6e8"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:a546421f9dfbf69ec3e5f2f98ca23f6e8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a546421f9dfbf69ec3e5f2f98ca23f6e8">TSOR_step</a> (<a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;v, const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;b, const number om=1.) const </td></tr>
<tr class="separator:a546421f9dfbf69ec3e5f2f98ca23f6e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec3403d5495d87bf18fb21e1106fb7e3"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:aec3403d5495d87bf18fb21e1106fb7e3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#aec3403d5495d87bf18fb21e1106fb7e3">SSOR_step</a> (<a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;v, const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;b, const number om=1.) const </td></tr>
<tr class="separator:aec3403d5495d87bf18fb21e1106fb7e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Iterators</div></td></tr>
<tr class="memitem:a1370b39c0ae075f6617079a7e6e92cb4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseMatrix.html#ab68b99a09eb5c23f6487c3e2d8fad45b">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a1370b39c0ae075f6617079a7e6e92cb4">begin</a> () const </td></tr>
<tr class="separator:a1370b39c0ae075f6617079a7e6e92cb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab32d93095dd3d641f65978214bdc8dc8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseMatrix.html#ab68b99a09eb5c23f6487c3e2d8fad45b">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#ab32d93095dd3d641f65978214bdc8dc8">end</a> () const </td></tr>
<tr class="separator:ab32d93095dd3d641f65978214bdc8dc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0872bb70a86280328309c97c78bc39f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseMatrix.html#a0934a2fc123b7772eb9bbafee3ff536c">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#ab0872bb70a86280328309c97c78bc39f">begin</a> ()</td></tr>
<tr class="separator:ab0872bb70a86280328309c97c78bc39f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aa99041df4c848c5b46180327c1e9b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseMatrix.html#a0934a2fc123b7772eb9bbafee3ff536c">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a1aa99041df4c848c5b46180327c1e9b5">end</a> ()</td></tr>
<tr class="separator:a1aa99041df4c848c5b46180327c1e9b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94a962a1abda5bd8cfa0bf9788826639"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseMatrix.html#ab68b99a09eb5c23f6487c3e2d8fad45b">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a94a962a1abda5bd8cfa0bf9788826639">begin</a> (const <a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a> r) const </td></tr>
<tr class="separator:a94a962a1abda5bd8cfa0bf9788826639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36b4ddb4b8e63d243f44cedfd9c2fe45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseMatrix.html#ab68b99a09eb5c23f6487c3e2d8fad45b">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a36b4ddb4b8e63d243f44cedfd9c2fe45">end</a> (const <a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a> r) const </td></tr>
<tr class="separator:a36b4ddb4b8e63d243f44cedfd9c2fe45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc32c2ee41aa5e02b5838ed9e3423919"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseMatrix.html#a0934a2fc123b7772eb9bbafee3ff536c">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#abc32c2ee41aa5e02b5838ed9e3423919">begin</a> (const <a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a> r)</td></tr>
<tr class="separator:abc32c2ee41aa5e02b5838ed9e3423919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5bd553a69c0374c72195d4eb0158696"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseMatrix.html#a0934a2fc123b7772eb9bbafee3ff536c">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#ad5bd553a69c0374c72195d4eb0158696">end</a> (const <a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a> r)</td></tr>
<tr class="separator:ad5bd553a69c0374c72195d4eb0158696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Input/Output</div></td></tr>
<tr class="memitem:a5e22a87c43cdb756df0c3f697c56bc81"><td class="memTemplParams" colspan="2">template&lt;class STREAM &gt; </td></tr>
<tr class="memitem:a5e22a87c43cdb756df0c3f697c56bc81"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a5e22a87c43cdb756df0c3f697c56bc81">print</a> (STREAM &amp;out, const <a class="el" href="classbool.html">bool</a> across=false, const <a class="el" href="classbool.html">bool</a> diagonal_first=true) const </td></tr>
<tr class="separator:a5e22a87c43cdb756df0c3f697c56bc81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af38b1c3e6200698c3d9ea5577436c61c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#af38b1c3e6200698c3d9ea5577436c61c">print_formatted</a> (std::ostream &amp;out, const unsigned <a class="el" href="classint.html">int</a> precision=3, const <a class="el" href="classbool.html">bool</a> scientific=true, const unsigned <a class="el" href="classint.html">int</a> width=0, const char *zero_string=&quot; &quot;, const <a class="el" href="classdouble.html">double</a> denominator=1.) const </td></tr>
<tr class="separator:af38b1c3e6200698c3d9ea5577436c61c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30186c2d07ded3f0325071f50e2b73d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a30186c2d07ded3f0325071f50e2b73d4">print_pattern</a> (std::ostream &amp;out, const <a class="el" href="classdouble.html">double</a> threshold=0.) const </td></tr>
<tr class="separator:a30186c2d07ded3f0325071f50e2b73d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb9f31dc78edfee14243843ef3a5ea88"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#acb9f31dc78edfee14243843ef3a5ea88">block_write</a> (std::ostream &amp;out) const </td></tr>
<tr class="separator:acb9f31dc78edfee14243843ef3a5ea88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b670368c98d6392ff8c9284db0622b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a9b670368c98d6392ff8c9284db0622b2">block_read</a> (std::istream &amp;in)</td></tr>
<tr class="separator:a9b670368c98d6392ff8c9284db0622b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSubscriptor"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSubscriptor')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSubscriptor.html">Subscriptor</a></td></tr>
<tr class="memitem:ae5541017c0966b0af345db75895106f2 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#ae5541017c0966b0af345db75895106f2">Subscriptor</a> ()</td></tr>
<tr class="separator:ae5541017c0966b0af345db75895106f2 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367fce3122075f05f168d14f114b4c65 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a367fce3122075f05f168d14f114b4c65">Subscriptor</a> (const <a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;)</td></tr>
<tr class="separator:a367fce3122075f05f168d14f114b4c65 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c6c557e06110d2127fa6459119e94af inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a6c6c557e06110d2127fa6459119e94af">~Subscriptor</a> ()</td></tr>
<tr class="separator:a6c6c557e06110d2127fa6459119e94af inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24ee69d4b3cf9690d1208b2443cbbb80 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a24ee69d4b3cf9690d1208b2443cbbb80">operator=</a> (const <a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;)</td></tr>
<tr class="separator:a24ee69d4b3cf9690d1208b2443cbbb80 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3422499827ecd52f1d12d65eb6cc3125 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a3422499827ecd52f1d12d65eb6cc3125">subscribe</a> (const char *identifier=0) const </td></tr>
<tr class="separator:a3422499827ecd52f1d12d65eb6cc3125 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b4839b1cffc18781144ede1744b35ea inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a2b4839b1cffc18781144ede1744b35ea">unsubscribe</a> (const char *identifier=0) const </td></tr>
<tr class="separator:a2b4839b1cffc18781144ede1744b35ea inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b45274c8e1936bff024df01d618e86f inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a7b45274c8e1936bff024df01d618e86f">n_subscriptions</a> () const </td></tr>
<tr class="separator:a7b45274c8e1936bff024df01d618e86f inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbbc5f845063b1f23223b7ac96e89e13 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#adbbc5f845063b1f23223b7ac96e89e13">list_subscribers</a> () const </td></tr>
<tr class="separator:adbbc5f845063b1f23223b7ac96e89e13 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2f0251d20c6a5295024de3b2e9b4359 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac2f0251d20c6a5295024de3b2e9b4359">DeclException3</a> (ExcInUse, <a class="el" href="classint.html">int</a>, char *, std::string &amp;,&lt;&lt; &quot;Object of class &quot;&lt;&lt; arg2&lt;&lt; &quot; is still used by &quot;&lt;&lt; arg1&lt;&lt; &quot; other objects.\n&quot;&lt;&lt; &quot;(Additional information: &quot;&lt;&lt; arg3&lt;&lt; &quot;)\n&quot;&lt;&lt; &quot;Note the entry in the Frequently Asked Questions of &quot;&lt;&lt; &quot;deal.II (linked to from http://www.dealii.org/) for &quot;&lt;&lt; &quot;more information on what this error means.&quot;)</td></tr>
<tr class="separator:gac2f0251d20c6a5295024de3b2e9b4359 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e000d9ce953da6afe4bbbaca4397344 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga9e000d9ce953da6afe4bbbaca4397344">DeclException2</a> (ExcNoSubscriber, char *, char *,&lt;&lt; &quot;No subscriber with identifier \&quot;&quot;&lt;&lt; arg2&lt;&lt; &quot;\&quot; did <a class="el" href="classSubscriptor.html#a3422499827ecd52f1d12d65eb6cc3125">subscribe</a> to this object of class &quot;&lt;&lt; arg1)</td></tr>
<tr class="separator:ga9e000d9ce953da6afe4bbbaca4397344 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38 inherit pub_methods_classSubscriptor"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38 inherit pub_methods_classSubscriptor"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:a68efd17a8330ab676d9cd711029b0f38 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a1debf998b61291d913dfac4c8a22eaa7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a1debf998b61291d913dfac4c8a22eaa7">prepare_add</a> ()</td></tr>
<tr class="separator:a1debf998b61291d913dfac4c8a22eaa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f68a9f93813ca167dc9f39624be2f5b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a9f68a9f93813ca167dc9f39624be2f5b">prepare_set</a> ()</td></tr>
<tr class="separator:a9f68a9f93813ca167dc9f39624be2f5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:aabdc599c9e2b98744a56e0ac4f1ebfc7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSmartPointer.html">SmartPointer</a>&lt; const <br class="typebreak"/>
<a class="el" href="classSparsityPattern.html">SparsityPattern</a>, <a class="el" href="classSparseMatrix.html">SparseMatrix</a><br class="typebreak"/>
&lt; number &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#aabdc599c9e2b98744a56e0ac4f1ebfc7">cols</a></td></tr>
<tr class="separator:aabdc599c9e2b98744a56e0ac4f1ebfc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a688afcdab9da4d25ea2c99af308154db"><td class="memItemLeft" align="right" valign="top">number *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a688afcdab9da4d25ea2c99af308154db">val</a></td></tr>
<tr class="separator:a688afcdab9da4d25ea2c99af308154db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad183b90df780534d2143a45d97668de3"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#ad183b90df780534d2143a45d97668de3">max_len</a></td></tr>
<tr class="separator:ad183b90df780534d2143a45d97668de3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ad66f15847b7c27c5898f3b859d6cfe05"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad66f15847b7c27c5898f3b859d6cfe05"></a>
template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:ad66f15847b7c27c5898f3b859d6cfe05"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>SparseMatrix</b></td></tr>
<tr class="separator:ad66f15847b7c27c5898f3b859d6cfe05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3b41703cc0d0eea14c99c2bac2c5149"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab3b41703cc0d0eea14c99c2bac2c5149"></a>
template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:ab3b41703cc0d0eea14c99c2bac2c5149"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>SparseLUDecomposition</b></td></tr>
<tr class="separator:ab3b41703cc0d0eea14c99c2bac2c5149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a821b53e73219682e8d8efdacd3571e62"><td class="memTemplParams" colspan="2"><a class="anchor" id="a821b53e73219682e8d8efdacd3571e62"></a>
template&lt;typename &gt; </td></tr>
<tr class="memitem:a821b53e73219682e8d8efdacd3571e62"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>SparseILU</b></td></tr>
<tr class="separator:a821b53e73219682e8d8efdacd3571e62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac35c04bb7fa6f87652d7749935baaaf1"><td class="memTemplParams" colspan="2">template&lt;typename &gt; </td></tr>
<tr class="memitem:ac35c04bb7fa6f87652d7749935baaaf1"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#ac35c04bb7fa6f87652d7749935baaaf1">BlockMatrixBase</a></td></tr>
<tr class="separator:ac35c04bb7fa6f87652d7749935baaaf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadb72d74c6d5421b8bdf522916064359"><td class="memTemplParams" colspan="2">template&lt;typename , bool &gt; </td></tr>
<tr class="memitem:aadb72d74c6d5421b8bdf522916064359"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#aadb72d74c6d5421b8bdf522916064359">SparseMatrixIterators::Iterator</a></td></tr>
<tr class="separator:aadb72d74c6d5421b8bdf522916064359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8834e738affcd56700ea78a3cbb7e051"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8834e738affcd56700ea78a3cbb7e051"></a>
template&lt;typename , bool &gt; </td></tr>
<tr class="memitem:a8834e738affcd56700ea78a3cbb7e051"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>SparseMatrixIterators::Accessor</b></td></tr>
<tr class="separator:a8834e738affcd56700ea78a3cbb7e051"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename number&gt;<br/>
class SparseMatrix&lt; number &gt;</h3>

<p>Sparse matrix. This class implements the function to store values in the locations of a sparse matrix denoted by a <a class="el" href="classSparsityPattern.html">SparsityPattern</a>. The separation of sparsity pattern and values is done since one can store data elements of different type in these locations without the <a class="el" href="classSparsityPattern.html">SparsityPattern</a> having to know this, and more importantly one can associate more than one matrix with the same sparsity pattern.</p>
<p>The elements of a <a class="el" href="classSparseMatrix.html">SparseMatrix</a> are stored in the same order in which the <a class="el" href="classSparsityPattern.html">SparsityPattern</a> class stores its entries. Within each row, elements are generally stored left-to-right in increasing column index order; the exception to this rule is that if the matrix is square (n_rows() == n_columns()), then the diagonal entry is stored as the first element in each row to make operations like applying a Jacobi or SSOR preconditioner faster. As a consequence, if you traverse the elements of a row of a <a class="el" href="classSparseMatrix.html">SparseMatrix</a> with the help of iterators into this object (using <a class="el" href="classSparseMatrix.html#a1370b39c0ae075f6617079a7e6e92cb4">SparseMatrix::begin</a> and <a class="el" href="classSparseMatrix.html#ab32d93095dd3d641f65978214bdc8dc8">SparseMatrix::end</a>) you will find that the elements are not sorted by column index within each row whenever the matrix is square.</p>
<dl class="section note"><dt>Note</dt><dd>Instantiations for this template are provided for <code>&lt;float&gt; and &lt;double&gt;</code>; others can be generated in application programs (see the section on <a class="el" href="Instantiations.html">Template instantiations</a> in the manual).</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Essentially everyone who has ever worked on deal.II </dd></dl>
<dl class="section date"><dt>Date</dt><dd>1994-2013 </dd></dl>

<p>Definition at line <a class="el" href="trilinos__sparse__matrix_8h_source.html#l00054">54</a> of file <a class="el" href="trilinos__sparse__matrix_8h_source.html">trilinos_sparse_matrix.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a1cb2f7d50649c013cdc4167d13f1a744"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::<a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare type for container size. </p>

<p>Definition at line <a class="el" href="sparse__matrix_8h_source.html#l00499">499</a> of file <a class="el" href="sparse__matrix_8h_source.html">sparse_matrix.h</a>.</p>

</div>
</div>
<a class="anchor" id="a709fd5b543c70449909e6dd9ac6fc50d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef number <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::<a class="el" href="classSparseMatrix.html#a709fd5b543c70449909e6dd9ac6fc50d">value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type of matrix entries. In analogy to the STL container classes. </p>

<p>Definition at line <a class="el" href="sparse__matrix_8h_source.html#l00504">504</a> of file <a class="el" href="sparse__matrix_8h_source.html">sparse_matrix.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac1a755f1f5a3533379cd239c2db5d1d9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt;number&gt;::<a class="el" href="classSparseMatrix.html#ac1a755f1f5a3533379cd239c2db5d1d9">real_type</a> <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::<a class="el" href="classSparseMatrix.html#ac1a755f1f5a3533379cd239c2db5d1d9">real_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare a type that has holds real-valued numbers with the same precision as the template argument to this class. If the template argument of this class is a real data type, then real_type equals the template argument. If the template argument is a std::complex type then real_type equals the type underlying the complex numbers.</p>
<p>This typedef is used to represent the return type of norms. </p>

<p>Definition at line <a class="el" href="sparse__matrix_8h_source.html#l00515">515</a> of file <a class="el" href="sparse__matrix_8h_source.html">sparse_matrix.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab68b99a09eb5c23f6487c3e2d8fad45b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSparseMatrixIterators_1_1Iterator.html">SparseMatrixIterators::Iterator</a>&lt;number,true&gt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::<a class="el" href="classSparseMatrix.html#ab68b99a09eb5c23f6487c3e2d8fad45b">const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Typedef of an STL conforming iterator class walking over all the nonzero entries of this matrix. This iterator cannot change the values of the matrix. </p>

<p>Definition at line <a class="el" href="sparse__matrix_8h_source.html#l00524">524</a> of file <a class="el" href="sparse__matrix_8h_source.html">sparse_matrix.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0934a2fc123b7772eb9bbafee3ff536c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSparseMatrixIterators_1_1Iterator.html">SparseMatrixIterators::Iterator</a>&lt;number,false&gt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::<a class="el" href="classSparseMatrix.html#a0934a2fc123b7772eb9bbafee3ff536c">iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Typedef of an STL conforming iterator class walking over all the nonzero entries of this matrix. This iterator <em>can</em> change the values of the matrix, but of course can't change the sparsity pattern as this is fixed once a sparse matrix is attached to it. </p>

<p>Definition at line <a class="el" href="sparse__matrix_8h_source.html#l00534">534</a> of file <a class="el" href="sparse__matrix_8h_source.html">sparse_matrix.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a0601c85d7c1e4cb11ad5cbf2fd27d593"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DEAL_II_NAMESPACE_OPEN <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::<a class="el" href="classSparseMatrix.html">SparseMatrix</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor; initializes the matrix to be empty, without any structure, i.e. the matrix is not usable at all. This constructor is therefore only useful for matrices which are members of a class. All other matrices should be created at a point in the data flow where all necessary information is available.</p>
<p>You have to initialize the matrix before usage with reinit(const <a class="el" href="classSparsityPattern.html">SparsityPattern</a>&amp;). </p>

<p>Definition at line <a class="el" href="sparse__matrix_8templates_8h_source.html#l00050">50</a> of file <a class="el" href="sparse__matrix_8templates_8h_source.html">sparse_matrix.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae1435ec2862610afc1b304dc52508b0f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::<a class="el" href="classSparseMatrix.html">SparseMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy constructor. This constructor is only allowed to be called if the matrix to be copied is empty. This is for the same reason as for the <a class="el" href="classSparsityPattern.html">SparsityPattern</a>, see there for the details.</p>
<p>If you really want to copy a whole matrix, you can do so by using the <a class="el" href="classSparseMatrix.html#a443cef0b929aa692be721b9c2d7603bd">copy_from()</a> function. </p>

<p>Definition at line <a class="el" href="sparse__matrix_8templates_8h_source.html#l00060">60</a> of file <a class="el" href="sparse__matrix_8templates_8h_source.html">sparse_matrix.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0fd7c8660c196bb350961307b29cc9da"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::<a class="el" href="classSparseMatrix.html">SparseMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>sparsity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor. Takes the given matrix sparsity structure to represent the sparsity pattern of this matrix. You can change the sparsity pattern later on by calling the <a class="el" href="classSparseMatrix.html#a938e9611cc4a46102c852a8a43478f7b">reinit(const SparsityPattern&amp;)</a> function.</p>
<p>You have to make sure that the lifetime of the sparsity structure is at least as long as that of this matrix or as long as reinit(const <a class="el" href="classSparsityPattern.html">SparsityPattern</a>&amp;) is not called with a new sparsity pattern.</p>
<p>The constructor is marked explicit so as to disallow that someone passes a sparsity pattern in place of a sparse matrix to some function, where an empty matrix would be generated then. </p>

<p>Definition at line <a class="el" href="sparse__matrix_8templates_8h_source.html#l00088">88</a> of file <a class="el" href="sparse__matrix_8templates_8h_source.html">sparse_matrix.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a713953af05d18bdb920a4905fb412793"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::<a class="el" href="classSparseMatrix.html">SparseMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>sparsity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIdentityMatrix.html">IdentityMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy constructor: initialize the matrix with the identity matrix. This constructor will throw an exception if the sizes of the sparsity pattern and the identity matrix do not coincide, or if the sparsity pattern does not provide for nonzero entries on the entire diagonal. </p>

<p>Definition at line <a class="el" href="sparse__matrix_8templates_8h_source.html#l00100">100</a> of file <a class="el" href="sparse__matrix_8templates_8h_source.html">sparse_matrix.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2377111964e6c6945cefc8886ffc1b64"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::~<a class="el" href="classSparseMatrix.html">SparseMatrix</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor. Free all memory, but do not release the memory of the sparsity structure. </p>

<p>Definition at line <a class="el" href="sparse__matrix_8templates_8h_source.html#l00118">118</a> of file <a class="el" href="sparse__matrix_8templates_8h_source.html">sparse_matrix.templates.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a24805e7fe4b37717961d58da063d65e3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy operator. Since copying entire sparse matrices is a very expensive operation, we disallow doing so except for the special case of empty matrices of size zero. This doesn't seem particularly useful, but is exactly what one needs if one wanted to have a <code>std::vector&lt;<a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt;double&gt; &gt;</code>: in that case, one can create a vector (which needs the ability to copy objects) of empty matrices that are then later filled with something useful. </p>

<p>Definition at line <a class="el" href="sparse__matrix_8templates_8h_source.html#l00076">76</a> of file <a class="el" href="sparse__matrix_8templates_8h_source.html">sparse_matrix.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae2af0c70e6edc8c671d9a998de21988c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIdentityMatrix.html">IdentityMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy operator: initialize the matrix with the identity matrix. This operator will throw an exception if the sizes of the sparsity pattern and the identity matrix do not coincide, or if the sparsity pattern does not provide for nonzero entries on the entire diagonal. </p>

<p>Definition at line <a class="el" href="sparse__matrix_8templates_8h_source.html#l00183">183</a> of file <a class="el" href="sparse__matrix_8templates_8h_source.html">sparse_matrix.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="aab49ee427d6f810b99c06354f90d4482"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This operator assigns a scalar to a matrix. Since this does usually not make much sense (should we set all matrix entries to this value? Only the nonzero entries of the sparsity pattern?), this operation is only allowed if the actual value to be assigned is zero. This operator only exists to allow for the obvious notation <code>matrix=0</code>, which sets all elements of the matrix to zero, but keep the sparsity pattern previously used. </p>

<p>Definition at line <a class="el" href="sparse__matrix_8templates_8h_source.html#l00148">148</a> of file <a class="el" href="sparse__matrix_8templates_8h_source.html">sparse_matrix.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a938e9611cc4a46102c852a8a43478f7b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>sparsity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reinitialize the sparse matrix with the given sparsity pattern. The latter tells the matrix how many nonzero elements there need to be reserved.</p>
<p>Regarding memory allocation, the same applies as said above.</p>
<p>You have to make sure that the lifetime of the sparsity structure is at least as long as that of this matrix or as long as reinit(const <a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;) is not called with a new sparsity structure.</p>
<p>The elements of the matrix are set to zero by this function. </p>

<p>Reimplemented in <a class="el" href="classSparseLUDecomposition.html#ac5006d95d922d604b3c381611c19475f">SparseLUDecomposition&lt; number &gt;</a>, and <a class="el" href="classSparseMIC.html#af2659f601b4e33002b6ec986c07951a1">SparseMIC&lt; number &gt;</a>.</p>

<p>Definition at line <a class="el" href="sparse__matrix_8templates_8h_source.html#l00201">201</a> of file <a class="el" href="sparse__matrix_8templates_8h_source.html">sparse_matrix.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5e58c65baa9a70517d6dcd6d3371a525"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Release all memory and return to a state just like after having called the default constructor. It also forgets the sparsity pattern it was previously tied to. </p>

<p>Reimplemented in <a class="el" href="classSparseLUDecomposition.html#a37f30fead33f3f9727881bd6b49f9640">SparseLUDecomposition&lt; number &gt;</a>, and <a class="el" href="classSparseMIC.html#a46f02205d446b4ef1322bdd2aaee05db">SparseMIC&lt; number &gt;</a>.</p>

<p>Definition at line <a class="el" href="sparse__matrix_8templates_8h_source.html#l00230">230</a> of file <a class="el" href="sparse__matrix_8templates_8h_source.html">sparse_matrix.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7a1d8e902545d122cf4a187151faadbd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether the object is empty. It is empty if either both dimensions are zero or no <a class="el" href="classSparsityPattern.html">SparsityPattern</a> is associated. </p>

<p>Definition at line <a class="el" href="sparse__matrix_8templates_8h_source.html#l00242">242</a> of file <a class="el" href="sparse__matrix_8templates_8h_source.html">sparse_matrix.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad9fca0157b64dc8a61bcdbdece2d7997"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a> <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::m </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the dimension of the image space. To remember: the matrix is of dimension <img class="formulaInl" alt="$m \times n$" src="form_280.png"/>. </p>

</div>
</div>
<a class="anchor" id="aec90ef9011582759280b62cdeecace28"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a> <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::n </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the dimension of the range space. To remember: the matrix is of dimension <img class="formulaInl" alt="$m \times n$" src="form_280.png"/>. </p>

</div>
</div>
<a class="anchor" id="ad76dd5f6d4b26cdf43ac7a1c2feb1594"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::<a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a> <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::get_row_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of entries in a specific row. </p>

<p>Definition at line <a class="el" href="sparse__matrix_8templates_8h_source.html#l00254">254</a> of file <a class="el" href="sparse__matrix_8templates_8h_source.html">sparse_matrix.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="acf50d5cd6709d48a07582efb10c08fc2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::<a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a> <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::n_nonzero_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of nonzero elements of this matrix. Actually, it returns the number of entries in the sparsity pattern; if any of the entries should happen to be zero, it is counted anyway. </p>

<p>Definition at line <a class="el" href="sparse__matrix_8templates_8h_source.html#l00264">264</a> of file <a class="el" href="sparse__matrix_8templates_8h_source.html">sparse_matrix.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab4e64fe641e12085681e143307d81d81"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::<a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a> <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::n_actually_nonzero_elements </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>threshold</em> = <code>0.</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of actually nonzero elements of this matrix. It is possible to specify the parameter <code>threshold</code> in order to count only the elements that have absolute value greater than the threshold.</p>
<p>Note, that this function does (in contrary to <a class="el" href="classSparseMatrix.html#acf50d5cd6709d48a07582efb10c08fc2">n_nonzero_elements()</a>) not count all entries of the sparsity pattern but only the ones that are nonzero (or whose absolute value is greater than threshold). </p>

<p>Definition at line <a class="el" href="sparse__matrix_8templates_8h_source.html#l00274">274</a> of file <a class="el" href="sparse__matrix_8templates_8h_source.html">sparse_matrix.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a665947fbcdfc112245dd96d223f1c544"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::get_sparsity_pattern </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a (constant) reference to the underlying sparsity pattern of this matrix.</p>
<p>Though the return value is declared <code>const</code>, you should be aware that it may change if you call any nonconstant function of objects which operate on it. </p>

<p>Definition at line <a class="el" href="sparse__matrix_8templates_8h_source.html#l01811">1811</a> of file <a class="el" href="sparse__matrix_8templates_8h_source.html">sparse_matrix.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a46cb4a0332852f790d38bd81cad38cdf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine an estimate for the memory consumption (in bytes) of this object. See <a class="el" href="namespaceMemoryConsumption.html">MemoryConsumption</a>. </p>

<p>Definition at line <a class="el" href="sparse__matrix_8templates_8h_source.html#l01949">1949</a> of file <a class="el" href="sparse__matrix_8templates_8h_source.html">sparse_matrix.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a231105aa86cca488901d94b1e1b55ac7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::compress </td>
          <td>(</td>
          <td class="paramtype">::VectorOperation::values&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dummy function for compatibility with distributed, parallel matrices. </p>

<p>Definition at line <a class="el" href="sparse__matrix_8templates_8h_source.html#l01943">1943</a> of file <a class="el" href="sparse__matrix_8templates_8h_source.html">sparse_matrix.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3e77fcfbd1fa3ac83ef4ff2951b24ce3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the element (<em>i,j</em>) to <code>value</code>. Throws an error if the entry does not exist or if <code>value</code> is not a finite number. Still, it is allowed to store zero values in non-existent fields. </p>

</div>
</div>
<a class="anchor" id="a2fdc04dbbf9b8f0071b1f2da21d6e106"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>full_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set all elements given in a <a class="el" href="classFullMatrix.html">FullMatrix</a> into the sparse matrix locations given by <code>indices</code>. In other words, this function writes the elements in <code>full_matrix</code> into the calling matrix, using the local-to-global indexing specified by <code>indices</code> for both the rows and the columns of the matrix. This function assumes a quadratic sparse matrix and a quadratic full_matrix, the usual situation in FE calculations.</p>
<p>The optional parameter <code>elide_zero_values</code> can be used to specify whether zero values should be set anyway or they should be filtered away (and not change the previous content in the respective element if it exists). The default value is <code>false</code>, i.e., even zero values are treated. </p>

</div>
</div>
<a class="anchor" id="ae96779660698dc3fdd5640f860f14bec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>full_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same function as before, but now including the possibility to use rectangular full_matrices and different local-to-global indexing on rows and columns, respectively. </p>

</div>
</div>
<a class="anchor" id="a01efc87070a6730a10c4dc526bdb7701"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set several elements in the specified row of the matrix with column indices as given by <code>col_indices</code> to the respective value.</p>
<p>The optional parameter <code>elide_zero_values</code> can be used to specify whether zero values should be set anyway or they should be filtered away (and not change the previous content in the respective element if it exists). The default value is <code>false</code>, i.e., even zero values are treated. </p>

</div>
</div>
<a class="anchor" id="afd783c07fc8b97262201d70a71b5667d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a>&#160;</td>
          <td class="paramname"><em>n_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a> *&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number2 *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set several elements to values given by <code>values</code> in a given row in columns given by col_indices into the sparse matrix.</p>
<p>The optional parameter <code>elide_zero_values</code> can be used to specify whether zero values should be inserted anyway or they should be filtered away. The default value is <code>false</code>, i.e., even zero values are inserted/replaced. </p>

<p>Definition at line <a class="el" href="sparse__matrix_8templates_8h_source.html#l00625">625</a> of file <a class="el" href="sparse__matrix_8templates_8h_source.html">sparse_matrix.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="acabf7629046afdd9077f77f7746a7a3f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add <code>value</code> to the element (<em>i,j</em>). Throws an error if the entry does not exist or if <code>value</code> is not a finite number. Still, it is allowed to store zero values in non-existent fields. </p>

</div>
</div>
<a class="anchor" id="af4a987fd196ead89df045829bcc181a1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>full_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add all elements given in a <a class="el" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> into sparse matrix locations given by <code>indices</code>. In other words, this function adds the elements in <code>full_matrix</code> to the respective entries in calling matrix, using the local-to-global indexing specified by <code>indices</code> for both the rows and the columns of the matrix. This function assumes a quadratic sparse matrix and a quadratic full_matrix, the usual situation in FE calculations.</p>
<p>The optional parameter <code>elide_zero_values</code> can be used to specify whether zero values should be added anyway or these should be filtered away and only non-zero data is added. The default value is <code>true</code>, i.e., zero values won't be added into the matrix. </p>

</div>
</div>
<a class="anchor" id="a538fb6831594e3bf994c9d44af68fccc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>full_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same function as before, but now including the possibility to use rectangular full_matrices and different local-to-global indexing on rows and columns, respectively. </p>

</div>
</div>
<a class="anchor" id="ae745cf2afd297c8acdfe33ace4d366f4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set several elements in the specified row of the matrix with column indices as given by <code>col_indices</code> to the respective value.</p>
<p>The optional parameter <code>elide_zero_values</code> can be used to specify whether zero values should be added anyway or these should be filtered away and only non-zero data is added. The default value is <code>true</code>, i.e., zero values won't be added into the matrix. </p>

</div>
</div>
<a class="anchor" id="ac97efa0f970b0bcf40da82584f71d39c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a>&#160;</td>
          <td class="paramname"><em>n_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a> *&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number2 *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>col_indices_are_sorted</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add an array of values given by <code>values</code> in the given global matrix row at columns specified by col_indices in the sparse matrix.</p>
<p>The optional parameter <code>elide_zero_values</code> can be used to specify whether zero values should be added anyway or these should be filtered away and only non-zero data is added. The default value is <code>true</code>, i.e., zero values won't be added into the matrix. </p>

<p>Definition at line <a class="el" href="sparse__matrix_8templates_8h_source.html#l00481">481</a> of file <a class="el" href="sparse__matrix_8templates_8h_source.html">sparse_matrix.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="aebb2ac677d0b2a212b289221ba4a43b7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&amp; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiply the entire matrix by a fixed factor. </p>

</div>
</div>
<a class="anchor" id="a99829ea532c57a8de890ee70b1faa24c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&amp; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Divide the entire matrix by a fixed factor. </p>

</div>
</div>
<a class="anchor" id="a70c1643ae82c4bd45a881c91d0066776"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::symmetrize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Symmetrize the matrix by forming the mean value between the existing matrix and its transpose, <img class="formulaInl" alt="$A = \frac 12(A+A^T)$" src="form_312.png"/>.</p>
<p>This operation assumes that the underlying sparsity pattern represents a symmetric object. If this is not the case, then the result of this operation will not be a symmetric matrix, since it only explicitly symmetrizes by looping over the lower left triangular part for efficiency reasons; if there are entries in the upper right triangle, then these elements are missed in the symmetrization. Symmetrization of the sparsity pattern can be obtain by <a class="el" href="classSparsityPattern.html#ac66c68f4549d4210545758b545b6afb3">SparsityPattern::symmetrize()</a>. </p>

<p>Definition at line <a class="el" href="sparse__matrix_8templates_8h_source.html#l00290">290</a> of file <a class="el" href="sparse__matrix_8templates_8h_source.html">sparse_matrix.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a443cef0b929aa692be721b9c2d7603bd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::copy_from </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy the given matrix to this one. The operation triggers an assertion if the sparsity patterns of the two involved matrices do not point to the same object, since in this case the copy operation is cheaper. Since this operation is notheless not for free, we do not make it available through <code>operator =</code>, since this may lead to unwanted usage, e.g. in copy arguments to functions, which should really be arguments by reference.</p>
<p>The source matrix may be a matrix of arbitrary type, as long as its data type is convertible to the data type of this matrix.</p>
<p>The function returns a reference to <code>*this</code>. </p>

<p>Definition at line <a class="el" href="sparse__matrix_8templates_8h_source.html#l00330">330</a> of file <a class="el" href="sparse__matrix_8templates_8h_source.html">sparse_matrix.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9240d87b7695c58c41c93506a4723c08"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::copy_from </td>
          <td>(</td>
          <td class="paramtype">const ForwardIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ForwardIterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is complete analogous to the <a class="el" href="classSparsityPattern.html#aafd93c00be64a9ab832c68aefaecace6">SparsityPattern::copy_from()</a> function in that it allows to initialize a whole matrix in one step. See there for more information on argument types and their meaning. You can also find a small example on how to use this function there.</p>
<p>The only difference to the cited function is that the objects which the inner iterator points to need to be of type <code>std::pair&lt;unsigned int, value</code>, where <code>value</code> needs to be convertible to the element type of this class, as specified by the <code>number</code> template argument.</p>
<p>Previous content of the matrix is overwritten. Note that the entries specified by the input parameters need not necessarily cover all elements of the matrix. Elements not covered remain untouched. </p>

</div>
</div>
<a class="anchor" id="ad182785cbf271adb6a29fa470ecde8d7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::copy_from </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy the nonzero entries of a full matrix into this object. Previous content is deleted. Note that the underlying sparsity pattern must be appropriate to hold the nonzero entries of the full matrix. </p>

<p>Definition at line <a class="el" href="sparse__matrix_8templates_8h_source.html#l00347">347</a> of file <a class="el" href="sparse__matrix_8templates_8h_source.html">sparse_matrix.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a67db0fff36b7fcbf528472e1a95999c6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::copy_from </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">TrilinosWrappers::SparseMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy the given Trilinos matrix to this one. The operation triggers an assertion if the sparsity patterns of the current object does not contain the location of a non-zero entry of the given argument.</p>
<p>This function assumes that the two matrices have the same sizes.</p>
<p>The function returns a reference to <code>*this</code>. </p>

<p>Definition at line <a class="el" href="sparse__matrix_8templates_8h_source.html#l00365">365</a> of file <a class="el" href="sparse__matrix_8templates_8h_source.html">sparse_matrix.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a157053c3502b33962ac736cc873a8dbd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add <code>matrix</code> scaled by <code>factor</code> to this matrix, i.e. the matrix <code>factor*matrix</code> is added to <code>this</code>. This function throws an error if the sparsity patterns of the two involved matrices do not point to the same object, since in this case the operation is cheaper.</p>
<p>The source matrix may be a sparse matrix over an arbitrary underlying scalar type, as long as its data type is convertible to the data type of this matrix. </p>

<p>Definition at line <a class="el" href="sparse__matrix_8templates_8h_source.html#l00410">410</a> of file <a class="el" href="sparse__matrix_8templates_8h_source.html">sparse_matrix.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8782886b62ad00220bbb91f7c462fa76"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">number <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the value of the entry (<em>i,j</em>). This may be an expensive operation and you should always take care where to call this function. In order to avoid abuse, this function throws an exception if the required element does not exist in the matrix.</p>
<p>In case you want a function that returns zero instead (for entries that are not in the sparsity pattern of the matrix), use the <a class="el" href="classSparseMatrix.html#ab6e1aaeb1c587a1ad5e1c8aa9b5301b0">el()</a> function.</p>
<p>If you are looping over all elements, consider using one of the iterator classes instead, since they are tailored better to a sparse matrix structure. </p>

</div>
</div>
<a class="anchor" id="ab6e1aaeb1c587a1ad5e1c8aa9b5301b0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">number <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::el </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is mostly like operator()() in that it returns the value of the matrix entry (<em>i,j</em>). The only difference is that if this entry does not exist in the sparsity pattern, then instead of raising an exception, zero is returned. While this may be convenient in some cases, note that it is simple to write algorithms that are slow compared to an optimal solution, since the sparsity of the matrix is not used.</p>
<p>If you are looping over all elements, consider using one of the iterator classes instead, since they are tailored better to a sparse matrix structure. </p>

</div>
</div>
<a class="anchor" id="ac180a838b54e30f5effb0f694c713693"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">number <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::diag_element </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the main diagonal element in the <em>i</em>th row. This function throws an error if the matrix is not quadratic (see <a class="el" href="classSparsityPattern.html#a6296e1517f5af7f717cb041888fc675c">SparsityPattern::optimize_diagonal()</a>).</p>
<p>This function is considerably faster than the operator()(), since for quadratic matrices, the diagonal entry may be the first to be stored in each row and access therefore does not involve searching for the right column number. </p>

</div>
</div>
<a class="anchor" id="a159957553e3a4ca34cee51fdfa4cafa7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">number&amp; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::diag_element </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above, but return a writeable reference. You're sure you know what you do? </p>

</div>
</div>
<a class="anchor" id="a9ddaee1f32d7af004605f426c5d62582"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">number <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::raw_entry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access to values in internal mode. Returns the value of the <code>index</code>th entry in <code>row</code>. Here, <code>index</code> refers to the internal representation of the matrix, not the column. Be sure to understand what you are doing here.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000038">Deprecated:</a></b></dt><dd>Use iterator or const_iterator instead! </dd></dl>

</div>
</div>
<a class="anchor" id="a3822c2697bb048dc59a287c064dc9cfb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">number <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::global_entry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is for hackers. Get access to the <em>i</em>th element of this matrix. The elements are stored in a consecutive way, refer to the <a class="el" href="classSparsityPattern.html">SparsityPattern</a> class for more details.</p>
<p>You should use this interface very carefully and only if you are absolutely sure to know what you do. You should also note that the structure of these arrays may change over time. If you change the layout yourself, you should also rename this function to avoid programs relying on outdated information! </p>

</div>
</div>
<a class="anchor" id="a61897f7afdf238414b274af52c76a3b4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">number&amp; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::global_entry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above, but with write access. You certainly know what you do? </p>

</div>
</div>
<a class="anchor" id="a4b063fdeaeda83e9ee20e7a7dd2e87fc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;class OutVector , class InVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::vmult </td>
          <td>(</td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Matrix-vector multiplication: let <em>dst = M*src</em> with <em>M</em> being this matrix.</p>
<p>Note that while this function can operate on all vectors that offer iterator classes, it is only really effective for objects of type <a class="el" href="classVector.html">Vector</a>. For all classes for which iterating over elements, or random member access is expensive, this function is not efficient. In particular, if you want to multiply with <a class="el" href="classBlockVector.html">BlockVector</a> objects, you should consider using a <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a> as well.</p>
<p>Source and destination must not be the same vector. </p>

<p>Definition at line <a class="el" href="sparse__matrix_8templates_8h_source.html#l00708">708</a> of file <a class="el" href="sparse__matrix_8templates_8h_source.html">sparse_matrix.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a24e7f0a5a593899caf31f920ab359708"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;class OutVector , class InVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::Tvmult </td>
          <td>(</td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Matrix-vector multiplication: let <em>dst = M<sup>T</sup>*src</em> with <em>M</em> being this matrix. This function does the same as <a class="el" href="classSparseMatrix.html#a4b063fdeaeda83e9ee20e7a7dd2e87fc">vmult()</a> but takes the transposed matrix.</p>
<p>Note that while this function can operate on all vectors that offer iterator classes, it is only really effective for objects of type <a class="el" href="classVector.html">Vector</a>. For all classes for which iterating over elements, or random member access is expensive, this function is not efficient. In particular, if you want to multiply with <a class="el" href="classBlockVector.html">BlockVector</a> objects, you should consider using a <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a> as well.</p>
<p>Source and destination must not be the same vector. </p>

<p>Definition at line <a class="el" href="sparse__matrix_8templates_8h_source.html#l00736">736</a> of file <a class="el" href="sparse__matrix_8templates_8h_source.html">sparse_matrix.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3cdebf439a80dae23ec9862b346e5440"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;class OutVector , class InVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::vmult_add </td>
          <td>(</td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adding Matrix-vector multiplication. Add <em>M*src</em> on <em>dst</em> with <em>M</em> being this matrix.</p>
<p>Note that while this function can operate on all vectors that offer iterator classes, it is only really effective for objects of type <a class="el" href="classVector.html">Vector</a>. For all classes for which iterating over elements, or random member access is expensive, this function is not efficient. In particular, if you want to multiply with <a class="el" href="classBlockVector.html">BlockVector</a> objects, you should consider using a <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a> as well.</p>
<p>Source and destination must not be the same vector. </p>

<p>Definition at line <a class="el" href="sparse__matrix_8templates_8h_source.html#l00763">763</a> of file <a class="el" href="sparse__matrix_8templates_8h_source.html">sparse_matrix.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1181a7f0a37603a2316a16821ec440e8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;class OutVector , class InVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::Tvmult_add </td>
          <td>(</td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adding Matrix-vector multiplication. Add <em>M<sup>T</sup>*src</em> to <em>dst</em> with <em>M</em> being this matrix. This function does the same as <a class="el" href="classSparseMatrix.html#a3cdebf439a80dae23ec9862b346e5440">vmult_add()</a> but takes the transposed matrix.</p>
<p>Note that while this function can operate on all vectors that offer iterator classes, it is only really effective for objects of type <a class="el" href="classVector.html">Vector</a>. For all classes for which iterating over elements, or random member access is expensive, this function is not efficient. In particular, if you want to multiply with <a class="el" href="classBlockVector.html">BlockVector</a> objects, you should consider using a <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a> as well.</p>
<p>Source and destination must not be the same vector. </p>

<p>Definition at line <a class="el" href="sparse__matrix_8templates_8h_source.html#l00791">791</a> of file <a class="el" href="sparse__matrix_8templates_8h_source.html">sparse_matrix.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5993eb7d62b3d24bff92e83f5d2ce6cf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">somenumber <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::matrix_norm_square </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the square of the norm of the vector <img class="formulaInl" alt="$v$" src="form_292.png"/> with respect to the norm induced by this matrix, i.e. <img class="formulaInl" alt="$\left(v,Mv\right)$" src="form_293.png"/>. This is useful, e.g. in the finite element context, where the <img class="formulaInl" alt="$L_2$" src="form_294.png"/> norm of a function equals the matrix norm with respect to the mass matrix of the vector representing the nodal values of the finite element function.</p>
<p>Obviously, the matrix needs to be quadratic for this operation, and for the result to actually be a norm it also needs to be either real symmetric or complex hermitian.</p>
<p>The underlying template types of both this matrix and the given vector should either both be real or complex-valued, but not mixed, for this function to make sense. </p>

<p>Definition at line <a class="el" href="sparse__matrix_8templates_8h_source.html#l00853">853</a> of file <a class="el" href="sparse__matrix_8templates_8h_source.html">sparse_matrix.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a88eca52a335bc26156b52e5af6e38648"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">somenumber <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::matrix_scalar_product </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the matrix scalar product <img class="formulaInl" alt="$\left(u,Mv\right)$" src="form_295.png"/>. </p>

<p>Definition at line <a class="el" href="sparse__matrix_8templates_8h_source.html#l00917">917</a> of file <a class="el" href="sparse__matrix_8templates_8h_source.html">sparse_matrix.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab0a1a9142899fd5376415277cd4de6ab"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">somenumber <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::residual </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the residual of an equation <em>Mx=b</em>, where the residual is defined to be <em>r=b-Mx</em>. Write the residual into <code>dst</code>. The <em>l<sub>2</sub></em> norm of the residual vector is returned.</p>
<p>Source <em>x</em> and destination <em>dst</em> must not be the same vector. </p>

<p>Definition at line <a class="el" href="sparse__matrix_8templates_8h_source.html#l01302">1302</a> of file <a class="el" href="sparse__matrix_8templates_8h_source.html">sparse_matrix.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a503f0e40e8decc907deb10a779c2110b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;typename numberB , typename numberC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::mmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; numberC &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; numberB &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em> = <code><a class="el" href="classVector.html">Vector</a>&lt;number&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>rebuild_sparsity_pattern</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform the matrix-matrix multiplication <code>C = A * B</code>, or, if an optional vector argument is given, <code>C = A * diag(V) * B</code>, where <code>diag(V)</code> defines a diagonal matrix with the vector entries.</p>
<p>This function assumes that the calling matrix <code>A</code> and <code>B</code> have compatible sizes. The size of <code>C</code> will be set within this function.</p>
<p>The content as well as the sparsity pattern of the matrix C will be changed by this function, so make sure that the sparsity pattern is not used somewhere else in your program. This is an expensive operation, so think twice before you use this function.</p>
<p>There is an optional flag <code>rebuild_sparsity_pattern</code> that can be used to bypass the creation of a new sparsity pattern and instead uses the sparsity pattern stored in <code>C</code>. In that case, make sure that it really fits. The default is to rebuild the sparsity pattern.</p>
<dl class="section note"><dt>Note</dt><dd>Rebuilding the sparsity pattern requires changing it. This means that all other matrices that are associated with this sparsity pattern will then have invalid entries. </dd></dl>

<p>Definition at line <a class="el" href="sparse__matrix_8templates_8h_source.html#l00942">942</a> of file <a class="el" href="sparse__matrix_8templates_8h_source.html">sparse_matrix.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a07ba942c5b7466b3895fed3104fbcc26"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;typename numberB , typename numberC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::Tmmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; numberC &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; numberB &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em> = <code><a class="el" href="classVector.html">Vector</a>&lt;number&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>rebuild_sparsity_pattern</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform the matrix-matrix multiplication with the transpose of <code>this</code>, i.e., <code>C = A<sup>T</sup> * B</code>, or, if an optional vector argument is given, <code>C = A<sup>T</sup> * diag(V) * B</code>, where <code>diag(V)</code> defines a diagonal matrix with the vector entries.</p>
<p>This function assumes that the calling matrix <code>A</code> and <code>B</code> have compatible sizes. The size of <code>C</code> will be set within this function.</p>
<p>The content as well as the sparsity pattern of the matrix C will be changed by this function, so make sure that the sparsity pattern is not used somewhere else in your program. This is an expensive operation, so think twice before you use this function.</p>
<p>There is an optional flag <code>rebuild_sparsity_pattern</code> that can be used to bypass the creation of a new sparsity pattern and instead uses the sparsity pattern stored in <code>C</code>. In that case, make sure that it really fits. The default is to rebuild the sparsity pattern.</p>
<dl class="section note"><dt>Note</dt><dd>Rebuilding the sparsity pattern requires changing it. This means that all other matrices that are associated with this sparsity pattern will then have invalid entries. </dd></dl>

<p>Definition at line <a class="el" href="sparse__matrix_8templates_8h_source.html#l01069">1069</a> of file <a class="el" href="sparse__matrix_8templates_8h_source.html">sparse_matrix.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="af81bbc4329957ee3b52525286dfde99a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::<a class="el" href="classSparseMatrix.html#ac1a755f1f5a3533379cd239c2db5d1d9">real_type</a> <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::l1_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the <img class="formulaInl" alt="$l_1$" src="form_287.png"/>-norm of the matrix, that is <img class="formulaInl" alt="$|M|_1=\max_{\mathrm{all\ columns\ }j}\sum_{\mathrm{all\ rows\ } i} |M_{ij}|$" src="form_313.png"/>, (max. sum of columns). This is the natural matrix norm that is compatible to the <img class="formulaInl" alt="$l_1$" src="form_287.png"/>-norm for vectors, i.e. <img class="formulaInl" alt="$|Mv|_1\leq |M|_1 |v|_1$" src="form_314.png"/>. (cf. Haemmerlin-Hoffmann: Numerische Mathematik) </p>

<p>Definition at line <a class="el" href="sparse__matrix_8templates_8h_source.html#l01197">1197</a> of file <a class="el" href="sparse__matrix_8templates_8h_source.html">sparse_matrix.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a41e9f754d2d2ad2d93b196455131258f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::<a class="el" href="classSparseMatrix.html#ac1a755f1f5a3533379cd239c2db5d1d9">real_type</a> <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::linfty_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the <img class="formulaInl" alt="$l_\infty$" src="form_289.png"/>-norm of the matrix, that is <img class="formulaInl" alt="$|M|_\infty=\max_{\mathrm{all\ rows\ }i}\sum_{\mathrm{all\ columns\ }j} |M_{ij}|$" src="form_315.png"/>, (max. sum of rows). This is the natural matrix norm that is compatible to the <img class="formulaInl" alt="$l_\infty$" src="form_289.png"/>-norm of vectors, i.e. <img class="formulaInl" alt="$|Mv|_\infty \leq |M|_\infty |v|_\infty$" src="form_299.png"/>. (cf. Haemmerlin-Hoffmann: Numerische Mathematik) </p>

<p>Definition at line <a class="el" href="sparse__matrix_8templates_8h_source.html#l01215">1215</a> of file <a class="el" href="sparse__matrix_8templates_8h_source.html">sparse_matrix.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8f6562d657fd27db57b76703de98104e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::<a class="el" href="classSparseMatrix.html#ac1a755f1f5a3533379cd239c2db5d1d9">real_type</a> <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::frobenius_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the frobenius norm of the matrix, i.e. the square root of the sum of squares of all entries in the matrix. </p>

<p>Definition at line <a class="el" href="sparse__matrix_8templates_8h_source.html#l01240">1240</a> of file <a class="el" href="sparse__matrix_8templates_8h_source.html">sparse_matrix.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab31798ddc8a7ad8f9b02092252241cd0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::precondition_Jacobi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>omega</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply the Jacobi preconditioner, which multiplies every element of the <code>src</code> vector by the inverse of the respective diagonal element and multiplies the result with the relaxation factor <code>omega</code>. </p>

<p>Definition at line <a class="el" href="sparse__matrix_8templates_8h_source.html#l01332">1332</a> of file <a class="el" href="sparse__matrix_8templates_8h_source.html">sparse_matrix.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0e0872ebae78c6684f4fdc4d72eddc91"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::precondition_SSOR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>omega</em> = <code>1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>pos_right_of_diagonal</em> = <code>std::vector&lt;std::size_t&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply SSOR preconditioning to <code>src</code> with damping <code>omega</code>. The optional argument <code>pos_right_of_diagonal</code> is supposed to provide an array where each entry specifies the position just right of the diagonal in the global array of nonzeros. </p>

<p>Definition at line <a class="el" href="sparse__matrix_8templates_8h_source.html#l01371">1371</a> of file <a class="el" href="sparse__matrix_8templates_8h_source.html">sparse_matrix.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a61bc5b57ce74c31dfb44bf5dc620532e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::precondition_SOR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>om</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply SOR preconditioning matrix to <code>src</code>. </p>

<p>Definition at line <a class="el" href="sparse__matrix_8templates_8h_source.html#l01500">1500</a> of file <a class="el" href="sparse__matrix_8templates_8h_source.html">sparse_matrix.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8bc66daab9f6fc8282a236fa4db3b2e6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::precondition_TSOR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>om</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply transpose SOR preconditioning matrix to <code>src</code>. </p>

<p>Definition at line <a class="el" href="sparse__matrix_8templates_8h_source.html#l01515">1515</a> of file <a class="el" href="sparse__matrix_8templates_8h_source.html">sparse_matrix.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0ce211a145d0c0316ba9351443b9ebb0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::SSOR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>omega</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform SSOR preconditioning in-place. Apply the preconditioner matrix without copying to a second vector. <code>omega</code> is the relaxation parameter. </p>

<p>Definition at line <a class="el" href="sparse__matrix_8templates_8h_source.html#l01760">1760</a> of file <a class="el" href="sparse__matrix_8templates_8h_source.html">sparse_matrix.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7167da17a920b4e01d590d14c0a317dc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::SOR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>om</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform an SOR preconditioning in-place. <code>omega</code> is the relaxation parameter. </p>

<p>Definition at line <a class="el" href="sparse__matrix_8templates_8h_source.html#l01530">1530</a> of file <a class="el" href="sparse__matrix_8templates_8h_source.html">sparse_matrix.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="abdc2a51ed293c3e5109118ff0501703f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::TSOR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>om</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform a transpose SOR preconditioning in-place. <code>omega</code> is the relaxation parameter. </p>

<p>Definition at line <a class="el" href="sparse__matrix_8templates_8h_source.html#l01557">1557</a> of file <a class="el" href="sparse__matrix_8templates_8h_source.html">sparse_matrix.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="aab237dbc208a1adfe5e2a7eea15ed8a7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::PSOR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>permutation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>inverse_permutation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>om</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform a permuted SOR preconditioning in-place.</p>
<p>The standard SOR method is applied in the order prescribed by <code>permutation</code>, that is, first the row <code>permutation[0]</code>, then <code>permutation[1]</code> and so on. For efficiency reasons, the permutation as well as its inverse are required.</p>
<p><code>omega</code> is the relaxation parameter. </p>

<p>Definition at line <a class="el" href="sparse__matrix_8templates_8h_source.html#l01587">1587</a> of file <a class="el" href="sparse__matrix_8templates_8h_source.html">sparse_matrix.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="aee72f32b604abafe4ebe4ad80efbabe1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::TPSOR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>permutation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>inverse_permutation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>om</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform a transposed permuted SOR preconditioning in-place.</p>
<p>The transposed SOR method is applied in the order prescribed by <code>permutation</code>, that is, first the row <code>permutation[<a class="el" href="classSparseMatrix.html#ad9fca0157b64dc8a61bcdbdece2d7997">m()</a>-1]</code>, then <code>permutation[<a class="el" href="classSparseMatrix.html#ad9fca0157b64dc8a61bcdbdece2d7997">m()</a>-2]</code> and so on. For efficiency reasons, the permutation as well as its inverse are required.</p>
<p><code>omega</code> is the relaxation parameter. </p>

<p>Definition at line <a class="el" href="sparse__matrix_8templates_8h_source.html#l01625">1625</a> of file <a class="el" href="sparse__matrix_8templates_8h_source.html">sparse_matrix.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab9abd0eaa7c5ac3e86c12f7feb58e6b3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::Jacobi_step </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>om</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Do one Jacobi step on <code>v</code>. Performs a direct Jacobi step with right hand side <code>b</code>. This function will need an auxiliary vector, which is acquired from <a class="el" href="classGrowingVectorMemory.html">GrowingVectorMemory</a>. </p>

<p>Definition at line <a class="el" href="sparse__matrix_8templates_8h_source.html#l01662">1662</a> of file <a class="el" href="sparse__matrix_8templates_8h_source.html">sparse_matrix.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6428ebb9f66bed089e206589bd280bec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::SOR_step </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>om</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Do one SOR step on <code>v</code>. Performs a direct SOR step with right hand side <code>b</code>. </p>

<p>Definition at line <a class="el" href="sparse__matrix_8templates_8h_source.html#l01693">1693</a> of file <a class="el" href="sparse__matrix_8templates_8h_source.html">sparse_matrix.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a546421f9dfbf69ec3e5f2f98ca23f6e8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::TSOR_step </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>om</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Do one adjoint SOR step on <code>v</code>. Performs a direct TSOR step with right hand side <code>b</code>. </p>

<p>Definition at line <a class="el" href="sparse__matrix_8templates_8h_source.html#l01720">1720</a> of file <a class="el" href="sparse__matrix_8templates_8h_source.html">sparse_matrix.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="aec3403d5495d87bf18fb21e1106fb7e3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::SSOR_step </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>om</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Do one SSOR step on <code>v</code>. Performs a direct SSOR step with right hand side <code>b</code> by performing TSOR after SOR. </p>

<p>Definition at line <a class="el" href="sparse__matrix_8templates_8h_source.html#l01747">1747</a> of file <a class="el" href="sparse__matrix_8templates_8h_source.html">sparse_matrix.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1370b39c0ae075f6617079a7e6e92cb4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseMatrix.html#ab68b99a09eb5c23f6487c3e2d8fad45b">const_iterator</a> <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>STL-like iterator with the first entry of the matrix. This is the version for constant matrices.</p>
<p>Note the discussion in the general documentation of this class about the order in which elements are accessed. </p>

</div>
</div>
<a class="anchor" id="ab32d93095dd3d641f65978214bdc8dc8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseMatrix.html#ab68b99a09eb5c23f6487c3e2d8fad45b">const_iterator</a> <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Final iterator. This is the version for constant matrices. </p>

</div>
</div>
<a class="anchor" id="ab0872bb70a86280328309c97c78bc39f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseMatrix.html#a0934a2fc123b7772eb9bbafee3ff536c">iterator</a> <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>STL-like iterator with the first entry of the matrix. This is the version for non-constant matrices.</p>
<p>Note the discussion in the general documentation of this class about the order in which elements are accessed. </p>

</div>
</div>
<a class="anchor" id="a1aa99041df4c848c5b46180327c1e9b5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseMatrix.html#a0934a2fc123b7772eb9bbafee3ff536c">iterator</a> <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Final iterator. This is the version for non-constant matrices. </p>

</div>
</div>
<a class="anchor" id="a94a962a1abda5bd8cfa0bf9788826639"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseMatrix.html#ab68b99a09eb5c23f6487c3e2d8fad45b">const_iterator</a> <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a>&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>STL-like iterator with the first entry of row <code>r</code>. This is the version for constant matrices.</p>
<p>Note that if the given row is empty, i.e. does not contain any nonzero entries, then the iterator returned by this function equals <code>end(r)</code>. Note also that the iterator may not be dereferencable in that case.</p>
<p>Note also the discussion in the general documentation of this class about the order in which elements are accessed. </p>

</div>
</div>
<a class="anchor" id="a36b4ddb4b8e63d243f44cedfd9c2fe45"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseMatrix.html#ab68b99a09eb5c23f6487c3e2d8fad45b">const_iterator</a> <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a>&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Final iterator of row <code>r</code>. It points to the first element past the end of line <code>r</code>, or past the end of the entire sparsity pattern. This is the version for constant matrices.</p>
<p>Note that the end iterator is not necessarily dereferencable. This is in particular the case if it is the end iterator for the last row of a matrix. </p>

</div>
</div>
<a class="anchor" id="abc32c2ee41aa5e02b5838ed9e3423919"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseMatrix.html#a0934a2fc123b7772eb9bbafee3ff536c">iterator</a> <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a>&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>STL-like iterator with the first entry of row <code>r</code>. This is the version for non-constant matrices.</p>
<p>Note that if the given row is empty, i.e. does not contain any nonzero entries, then the iterator returned by this function equals <code>end(r)</code>. Note also that the iterator may not be dereferencable in that case.</p>
<p>Note the discussion in the general documentation of this class about the order in which elements are accessed. </p>

</div>
</div>
<a class="anchor" id="ad5bd553a69c0374c72195d4eb0158696"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseMatrix.html#a0934a2fc123b7772eb9bbafee3ff536c">iterator</a> <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#a1cb2f7d50649c013cdc4167d13f1a744">size_type</a>&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Final iterator of row <code>r</code>. It points to the first element past the end of line <code>r</code>, or past the end of the entire sparsity pattern. This is the version for non-constant matrices.</p>
<p>Note that the end iterator is not necessarily dereferencable. This is in particular the case if it is the end iterator for the last row of a matrix. </p>

</div>
</div>
<a class="anchor" id="a5e22a87c43cdb756df0c3f697c56bc81"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;class STREAM &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::print </td>
          <td>(</td>
          <td class="paramtype">STREAM &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>across</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>diagonal_first</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print the matrix to the given stream, using the format <code>(row,column) value</code>, i.e. one nonzero entry of the matrix per line. If <code>across</code> is true, print all entries on a single line, using the format row,column:value.</p>
<p>If the argument <code>diagonal_first</code> is true, diagonal elements of quadratic matrices are printed first in their row, corresponding to the internal storage scheme. If it is false, the elements in a row are written in ascending column order. </p>

</div>
</div>
<a class="anchor" id="af38b1c3e6200698c3d9ea5577436c61c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::print_formatted </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>precision</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>scientific</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>width</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>zero_string</em> = <code>&quot;&#160;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>denominator</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print the matrix in the usual format, i.e. as a matrix and not as a list of nonzero elements. For better readability, elements not in the matrix are displayed as empty space, while matrix elements which are explicitly set to zero are displayed as such.</p>
<p>The parameters allow for a flexible setting of the output format: <code>precision</code> and <code>scientific</code> are used to determine the number format, where <code>scientific = false</code> means fixed point notation. A zero entry for <code>width</code> makes the function compute a width, but it may be changed to a positive value, if output is crude.</p>
<p>Additionally, a character for an empty value may be specified.</p>
<p>Finally, the whole matrix can be multiplied with a common denominator to produce more readable output, even integers.</p>
<dl class="section attention"><dt>Attention</dt><dd>This function may produce <b>large</b> amounts of output if applied to a large matrix! </dd></dl>

<p>Definition at line <a class="el" href="sparse__matrix_8templates_8h_source.html#l01820">1820</a> of file <a class="el" href="sparse__matrix_8templates_8h_source.html">sparse_matrix.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a30186c2d07ded3f0325071f50e2b73d4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::print_pattern </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>threshold</em> = <code>0.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print the actual pattern of the matrix. For each entry with an absolute value larger than threshold, a '*' is printed, a ':' for every value smaller and a '.' for every entry not allocated. </p>

<p>Definition at line <a class="el" href="sparse__matrix_8templates_8h_source.html#l01868">1868</a> of file <a class="el" href="sparse__matrix_8templates_8h_source.html">sparse_matrix.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="acb9f31dc78edfee14243843ef3a5ea88"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::block_write </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write the data of this object en bloc to a file. This is done in a binary mode, so the output is neither readable by humans nor (probably) by other computers using a different operating system of number format.</p>
<p>The purpose of this function is that you can swap out matrices and sparsity pattern if you are short of memory, want to communicate between different programs, or allow objects to be persistent across different runs of the program. </p>

<p>Definition at line <a class="el" href="sparse__matrix_8templates_8h_source.html#l01892">1892</a> of file <a class="el" href="sparse__matrix_8templates_8h_source.html">sparse_matrix.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9b670368c98d6392ff8c9284db0622b2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::block_read </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read data that has previously been written by <a class="el" href="classSparseMatrix.html#acb9f31dc78edfee14243843ef3a5ea88">block_write()</a> from a file. This is done using the inverse operations to the above function, so it is reasonably fast because the bitstream is not interpreted except for a few numbers up front.</p>
<p>The object is resized on this operation, and all previous contents are lost. Note, however, that no checks are performed whether new data and the underlying <a class="el" href="classSparsityPattern.html">SparsityPattern</a> object fit together. It is your responsibility to make sure that the sparsity pattern and the data to be read match.</p>
<p>A primitive form of error checking is performed which will recognize the bluntest attempts to interpret some data as a matrix stored bitwise to a file that wasn't actually created that way, but not more. </p>

<p>Definition at line <a class="el" href="sparse__matrix_8templates_8h_source.html#l01912">1912</a> of file <a class="el" href="sparse__matrix_8templates_8h_source.html">sparse_matrix.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1debf998b61291d913dfac4c8a22eaa7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::prepare_add </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For some matrix storage formats, in particular for the PETSc distributed blockmatrices, set and add operations on individual elements can not be freely mixed. Rather, one has to synchronize operations when one wants to switch from setting elements to adding to elements. <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a> automatically synchronizes the access by calling this helper function for each block. This function ensures that the matrix is in a state that allows adding elements; if it previously already was in this state, the function does nothing. </p>

</div>
</div>
<a class="anchor" id="a9f68a9f93813ca167dc9f39624be2f5b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::prepare_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as <a class="el" href="classSparseMatrix.html#a1debf998b61291d913dfac4c8a22eaa7">prepare_add()</a> but prepare the matrix for setting elements if the representation of elements in this class requires such an operation. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="ac35c04bb7fa6f87652d7749935baaaf1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>To allow it calling private <a class="el" href="classSparseMatrix.html#a1debf998b61291d913dfac4c8a22eaa7">prepare_add()</a> and <a class="el" href="classSparseMatrix.html#a9f68a9f93813ca167dc9f39624be2f5b">prepare_set()</a>. </p>

<p>Definition at line <a class="el" href="sparse__matrix_8h_source.html#l01652">1652</a> of file <a class="el" href="sparse__matrix_8h_source.html">sparse_matrix.h</a>.</p>

</div>
</div>
<a class="anchor" id="aadb72d74c6d5421b8bdf522916064359"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename , bool &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classSparseMatrixIterators_1_1Iterator.html">SparseMatrixIterators::Iterator</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Also give access to internal details to the iterator/accessor classes. </p>

<p>Definition at line <a class="el" href="sparse__matrix_8h_source.html#l01658">1658</a> of file <a class="el" href="sparse__matrix_8h_source.html">sparse_matrix.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="aabdc599c9e2b98744a56e0ac4f1ebfc7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSmartPointer.html">SmartPointer</a>&lt;const <a class="el" href="classSparsityPattern.html">SparsityPattern</a>,<a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt;number&gt; &gt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::cols</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pointer to the sparsity pattern used for this matrix. In order to guarantee that it is not deleted while still in use, we subscribe to it using the <a class="el" href="classSmartPointer.html">SmartPointer</a> class. </p>

<p>Definition at line <a class="el" href="sparse__matrix_8h_source.html#l01626">1626</a> of file <a class="el" href="sparse__matrix_8h_source.html">sparse_matrix.h</a>.</p>

</div>
</div>
<a class="anchor" id="a688afcdab9da4d25ea2c99af308154db"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">number* <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::val</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Array of values for all the nonzero entries. The position within the matrix, i.e. the row and column number for a given entry can only be deduced using the sparsity pattern. The same holds for the more common operation of finding an entry by its coordinates. </p>

<p>Definition at line <a class="el" href="sparse__matrix_8h_source.html#l01634">1634</a> of file <a class="el" href="sparse__matrix_8h_source.html">sparse_matrix.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad183b90df780534d2143a45d97668de3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::max_len</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocated size of <a class="el" href="classSparseMatrix.html#a688afcdab9da4d25ea2c99af308154db">val</a>. This can be larger than the actually used part if the size of the matrix was reduced somewhen in the past by associating a sparsity pattern with a smaller size to this object, using the <a class="el" href="classSparseMatrix.html#a938e9611cc4a46102c852a8a43478f7b">reinit()</a> function. </p>

<p>Definition at line <a class="el" href="sparse__matrix_8h_source.html#l01642">1642</a> of file <a class="el" href="sparse__matrix_8h_source.html">sparse_matrix.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/deal.II/lac/<a class="el" href="trilinos__sparse__matrix_8h_source.html">trilinos_sparse_matrix.h</a></li>
<li>include/deal.II/lac/<a class="el" href="sparse__matrix_8h_source.html">sparse_matrix.h</a></li>
<li>include/deal.II/lac/<a class="el" href="sparse__matrix_8templates_8h_source.html">sparse_matrix.templates.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jan 27 2014 15:27:21 for The deal.II Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
