<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>The deal.II Library: ConstraintMatrix Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="http://www.dealii.org/deal.ico"></link>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2014 by the deal.II authors"></meta>
<meta name="deal.II-version" content="8.1.0"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 8.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a> &#124;
<a href="classConstraintMatrix-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ConstraintMatrix Class Reference<div class="ingroups"><a class="el" href="group__dofs.html">Degrees of Freedom</a> &#124; <a class="el" href="group__constraints.html">Constraints on degrees of freedom</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="constraint__matrix_8h_source.html">constraint_matrix.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ConstraintMatrix:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classConstraintMatrix__inherit__graph.svg" width="128" height="118"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structConstraintMatrix_1_1ConstraintLine.html">ConstraintLine</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a13384243a9580fd6540f0b5bc9ab2e12"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a13384243a9580fd6540f0b5bc9ab2e12">MergeConflictBehavior</a> { <a class="el" href="classConstraintMatrix.html#a13384243a9580fd6540f0b5bc9ab2e12acbfe858c120a4048128ed22a4b7d6d3c">no_conflicts_allowed</a>, 
<a class="el" href="classConstraintMatrix.html#a13384243a9580fd6540f0b5bc9ab2e12a9a973f6cdef8bfbb583f05d520940bd9">left_object_wins</a>, 
<a class="el" href="classConstraintMatrix.html#a13384243a9580fd6540f0b5bc9ab2e12a77ea16e7d833659a57b4cc7ef2aa83ff">right_object_wins</a>
 }</td></tr>
<tr class="separator:a13384243a9580fd6540f0b5bc9ab2e12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71b13eb29cd43c9e87abebf2bf78b2a3"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a></td></tr>
<tr class="separator:a71b13eb29cd43c9e87abebf2bf78b2a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab0441dd6e2b4ac88a06ec8a74842aa67"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#ab0441dd6e2b4ac88a06ec8a74842aa67">ConstraintMatrix</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;local_constraints=<a class="el" href="classIndexSet.html">IndexSet</a>())</td></tr>
<tr class="separator:ab0441dd6e2b4ac88a06ec8a74842aa67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd9abe681db430ed7493b8f86034d2bf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#acd9abe681db430ed7493b8f86034d2bf">ConstraintMatrix</a> (const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraint_matrix)</td></tr>
<tr class="separator:acd9abe681db430ed7493b8f86034d2bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2726821354883ac97fe7e6181de9792"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#ac2726821354883ac97fe7e6181de9792">reinit</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;local_constraints=<a class="el" href="classIndexSet.html">IndexSet</a>())</td></tr>
<tr class="separator:ac2726821354883ac97fe7e6181de9792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b8fcc9dc467d8dda86b192405587ba9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a5b8fcc9dc467d8dda86b192405587ba9">can_store_line</a> (const <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> line_index) const </td></tr>
<tr class="separator:a5b8fcc9dc467d8dda86b192405587ba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a9fbd08cdb7508f948fb2cccb2ce096"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a3a9fbd08cdb7508f948fb2cccb2ce096">get_local_lines</a> () const </td></tr>
<tr class="separator:a3a9fbd08cdb7508f948fb2cccb2ce096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa133ef470eff7de0d26a28610a047753"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#aa133ef470eff7de0d26a28610a047753">add_selected_constraints</a> (const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints_in, const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;filter)</td></tr>
<tr class="separator:aa133ef470eff7de0d26a28610a047753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7af95e790c32be82ccf540bdd8698103"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga7af95e790c32be82ccf540bdd8698103">DeclException0</a> (ExcMatrixIsClosed)</td></tr>
<tr class="separator:ga7af95e790c32be82ccf540bdd8698103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef8e6a0b0677432c92da9cf7d3f352c0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaef8e6a0b0677432c92da9cf7d3f352c0">DeclException0</a> (ExcMatrixNotClosed)</td></tr>
<tr class="separator:gaef8e6a0b0677432c92da9cf7d3f352c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c4e72156e8df7f2befa97bb09f4fee1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga7c4e72156e8df7f2befa97bb09f4fee1">DeclException1</a> (ExcLineInexistant, <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a>,&lt;&lt; &quot;The specified line &quot;&lt;&lt; arg1&lt;&lt; &quot; does not exist.&quot;)</td></tr>
<tr class="separator:ga7c4e72156e8df7f2befa97bb09f4fee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1c38518180e3c74f5ddc41a80216a2b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaa1c38518180e3c74f5ddc41a80216a2b">DeclException4</a> (ExcEntryAlreadyExists, <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a>, <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a>, <a class="el" href="classdouble.html">double</a>, <a class="el" href="classdouble.html">double</a>,&lt;&lt; &quot;The entry for the indices &quot;&lt;&lt; arg1&lt;&lt; &quot; and &quot;&lt;&lt; arg2&lt;&lt; &quot; already exists, but the values &quot;&lt;&lt; arg3&lt;&lt; &quot; (old) and &quot;&lt;&lt; arg4&lt;&lt; &quot; (new) differ &quot;&lt;&lt; &quot;by &quot;&lt;&lt; (arg4-arg3)&lt;&lt; &quot;.&quot;)</td></tr>
<tr class="separator:gaa1c38518180e3c74f5ddc41a80216a2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71bcc4a972fe7d44046cde7f133aa969"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga71bcc4a972fe7d44046cde7f133aa969">DeclException2</a> (ExcDoFConstrainedToConstrainedDoF, <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;You tried to constrain DoF &quot;&lt;&lt; arg1&lt;&lt; &quot; to DoF &quot;&lt;&lt; arg2&lt;&lt; &quot;, but that one is also constrained. This is not allowed!&quot;)</td></tr>
<tr class="separator:ga71bcc4a972fe7d44046cde7f133aa969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ed0b6ff22dfc756ac06f02b3366cf03"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga2ed0b6ff22dfc756ac06f02b3366cf03">DeclException1</a> (ExcDoFIsConstrainedFromBothObjects, <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a>,&lt;&lt; &quot;Degree of freedom &quot;&lt;&lt; arg1&lt;&lt; &quot; is constrained from both object in a <a class="el" href="classConstraintMatrix.html#a08b5378ad8b23e5fb86c71a2c66bff13">merge</a> operation.&quot;)</td></tr>
<tr class="separator:ga2ed0b6ff22dfc756ac06f02b3366cf03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga984c0a6651f6d0aa6268727ccae6a167"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga984c0a6651f6d0aa6268727ccae6a167">DeclException1</a> (ExcDoFIsConstrainedToConstrainedDoF, <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a>,&lt;&lt; &quot;In the given argument a degree of freedom is constrained &quot;&lt;&lt; &quot;to another DoF with number &quot;&lt;&lt; arg1&lt;&lt; &quot;, which however is constrained by this object. This is not&quot;&lt;&lt; &quot; allowed.&quot;)</td></tr>
<tr class="separator:ga984c0a6651f6d0aa6268727ccae6a167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacdc77181919b1a5b82eb5e33098c71f0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gacdc77181919b1a5b82eb5e33098c71f0">DeclException1</a> (ExcRowNotStoredHere, <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a>,&lt;&lt; &quot;The index set given to this constraint matrix indicates &quot;&lt;&lt; &quot;constraints for degree of freedom &quot;&lt;&lt; arg1&lt;&lt; &quot; should not be stored by this object, but a constraint &quot;&lt;&lt; &quot;is being added.&quot;)</td></tr>
<tr class="separator:gacdc77181919b1a5b82eb5e33098c71f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d5b88e04d4a38108d42e2f8d0d9df3f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga9d5b88e04d4a38108d42e2f8d0d9df3f">DeclException2</a> (ExcIncorrectConstraint, <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;While distributing the constraint for DoF &quot;&lt;&lt; arg1&lt;&lt; &quot;, it turns out that one of the processors &quot;&lt;&lt; &quot;who own the &quot;&lt;&lt; arg2&lt;&lt; &quot; degrees of freedom that x_&quot;&lt;&lt; arg1&lt;&lt; &quot; is constrained against does not know about &quot;&lt;&lt; &quot;the constraint on x_&quot;&lt;&lt; arg1&lt;&lt; &quot;. Did you not initialize the <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &quot;&lt;&lt; &quot;with the appropriate locally_relevant set so &quot;&lt;&lt; &quot;that every processor who owns a DoF that constrains &quot;&lt;&lt; &quot;another DoF also knows about this constraint?&quot;)</td></tr>
<tr class="separator:ga9d5b88e04d4a38108d42e2f8d0d9df3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20ebc27629cde21077e53f6c357c4c67"><td class="memTemplParams" colspan="2"><a class="anchor" id="a20ebc27629cde21077e53f6c357c4c67"></a>
template&lt;typename number &gt; </td></tr>
<tr class="memitem:a20ebc27629cde21077e53f6c357c4c67"><td class="memTemplItemLeft" align="right" valign="top">DEAL_II_NAMESPACE_OPEN void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>condense</b> (const <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;uncondensed, <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;condensed) const </td></tr>
<tr class="separator:a20ebc27629cde21077e53f6c357c4c67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Adding constraints</div></td></tr>
<tr class="memitem:a24eb022f65797389badbb6d21da5b708"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a24eb022f65797389badbb6d21da5b708">add_line</a> (const <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> line)</td></tr>
<tr class="separator:a24eb022f65797389badbb6d21da5b708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab97f0436882283ec56368f4b8a9bf85e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#ab97f0436882283ec56368f4b8a9bf85e">add_lines</a> (const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;<a class="el" href="classConstraintMatrix.html#a0f3b653958a9f500be62c61791e42dd0">lines</a>)</td></tr>
<tr class="separator:ab97f0436882283ec56368f4b8a9bf85e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c11118d7fc3117aea42de57062ee6c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a3c11118d7fc3117aea42de57062ee6c3">add_lines</a> (const std::set&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> &gt; &amp;<a class="el" href="classConstraintMatrix.html#a0f3b653958a9f500be62c61791e42dd0">lines</a>)</td></tr>
<tr class="separator:a3c11118d7fc3117aea42de57062ee6c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d5e306f3db7f2e2a7256af61626c445"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a9d5e306f3db7f2e2a7256af61626c445">add_lines</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;<a class="el" href="classConstraintMatrix.html#a0f3b653958a9f500be62c61791e42dd0">lines</a>)</td></tr>
<tr class="separator:a9d5e306f3db7f2e2a7256af61626c445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cd323a407cb379510a68c26e842304e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a4cd323a407cb379510a68c26e842304e">add_entry</a> (const <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> line, const <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> column, const <a class="el" href="classdouble.html">double</a> value)</td></tr>
<tr class="separator:a4cd323a407cb379510a68c26e842304e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c906810edcc1917729cdca50d76c021"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a5c906810edcc1917729cdca50d76c021">add_entries</a> (const <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> line, const std::vector&lt; std::pair&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a>, <a class="el" href="classdouble.html">double</a> &gt; &gt; &amp;col_val_pairs)</td></tr>
<tr class="separator:a5c906810edcc1917729cdca50d76c021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2121ba9d256cbab8e6b8390fb89dda74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a2121ba9d256cbab8e6b8390fb89dda74">set_inhomogeneity</a> (const <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> line, const <a class="el" href="classdouble.html">double</a> value)</td></tr>
<tr class="separator:a2121ba9d256cbab8e6b8390fb89dda74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8056d07faa2a7ed3f158c1b42d56abc8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a8056d07faa2a7ed3f158c1b42d56abc8">close</a> ()</td></tr>
<tr class="separator:a8056d07faa2a7ed3f158c1b42d56abc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08b5378ad8b23e5fb86c71a2c66bff13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a08b5378ad8b23e5fb86c71a2c66bff13">merge</a> (const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;other_constraints, const <a class="el" href="classConstraintMatrix.html#a13384243a9580fd6540f0b5bc9ab2e12">MergeConflictBehavior</a> merge_conflict_behavior=<a class="el" href="classConstraintMatrix.html#a13384243a9580fd6540f0b5bc9ab2e12acbfe858c120a4048128ed22a4b7d6d3c">no_conflicts_allowed</a>)</td></tr>
<tr class="separator:a08b5378ad8b23e5fb86c71a2c66bff13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad971fb29f0a15bf8d30704d2a5ab445e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#ad971fb29f0a15bf8d30704d2a5ab445e">shift</a> (const <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> offset)</td></tr>
<tr class="separator:ad971fb29f0a15bf8d30704d2a5ab445e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24120d0331183f9a63cbe41493a19f6b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a24120d0331183f9a63cbe41493a19f6b">clear</a> ()</td></tr>
<tr class="separator:a24120d0331183f9a63cbe41493a19f6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Querying constraints</div></td></tr>
<tr class="memitem:a92cbfbc16e70c7ba4f93ed6d548d87cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a92cbfbc16e70c7ba4f93ed6d548d87cb">n_constraints</a> () const </td></tr>
<tr class="separator:a92cbfbc16e70c7ba4f93ed6d548d87cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac0dd11d56f41826d958ade7faa0cfe4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#aac0dd11d56f41826d958ade7faa0cfe4">is_constrained</a> (const <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> index) const </td></tr>
<tr class="separator:aac0dd11d56f41826d958ade7faa0cfe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91ee07099e4385280b6cd0770151c1f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a91ee07099e4385280b6cd0770151c1f6">is_identity_constrained</a> (const <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> index) const </td></tr>
<tr class="separator:a91ee07099e4385280b6cd0770151c1f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21b954badf7ee5cf04e0295a32e89b5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a21b954badf7ee5cf04e0295a32e89b5b">are_identity_constrained</a> (const <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> index1, const <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> index2) const </td></tr>
<tr class="separator:a21b954badf7ee5cf04e0295a32e89b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f2373f9f16c2dc2ec3a145c08f8ff79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a5f2373f9f16c2dc2ec3a145c08f8ff79">max_constraint_indirections</a> () const </td></tr>
<tr class="separator:a5f2373f9f16c2dc2ec3a145c08f8ff79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae181e7b571ed96cefdbd187a4970a16e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#ae181e7b571ed96cefdbd187a4970a16e">is_inhomogeneously_constrained</a> (const <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> index) const </td></tr>
<tr class="separator:ae181e7b571ed96cefdbd187a4970a16e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accb6279d07885d6061bd915e3a9283ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#accb6279d07885d6061bd915e3a9283ff">has_inhomogeneities</a> () const </td></tr>
<tr class="separator:accb6279d07885d6061bd915e3a9283ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96b20c2f6162fdde6bafcea825f1cb31"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::pair<br class="typebreak"/>
&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a>, <a class="el" href="classdouble.html">double</a> &gt; &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a96b20c2f6162fdde6bafcea825f1cb31">get_constraint_entries</a> (const <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> line) const </td></tr>
<tr class="separator:a96b20c2f6162fdde6bafcea825f1cb31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78917c8bd905889c623092af2e54f7fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a78917c8bd905889c623092af2e54f7fb">get_inhomogeneity</a> (const <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> line) const </td></tr>
<tr class="separator:a78917c8bd905889c623092af2e54f7fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3206ee452631ab10fd028b24c26aa550"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a3206ee452631ab10fd028b24c26aa550">print</a> (std::ostream &amp;) const </td></tr>
<tr class="separator:a3206ee452631ab10fd028b24c26aa550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a614435ed3d892aa3ac599feda8db6c25"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a614435ed3d892aa3ac599feda8db6c25">write_dot</a> (std::ostream &amp;) const </td></tr>
<tr class="separator:a614435ed3d892aa3ac599feda8db6c25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab70d342fa999cccd064567b98100ceaa"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#ab70d342fa999cccd064567b98100ceaa">memory_consumption</a> () const </td></tr>
<tr class="separator:ab70d342fa999cccd064567b98100ceaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04812585b8ebd156ea680aacc32f5d98"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a04812585b8ebd156ea680aacc32f5d98">resolve_indices</a> (std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;indices) const </td></tr>
<tr class="separator:a04812585b8ebd156ea680aacc32f5d98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Eliminating constraints from linear systems after their creation</div></td></tr>
<tr class="memitem:a66337316e8fbbc786c9f0383d085ab01"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a66337316e8fbbc786c9f0383d085ab01">condense</a> (const <a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;uncondensed, <a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;condensed) const </td></tr>
<tr class="separator:a66337316e8fbbc786c9f0383d085ab01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c543aa9c09a2eeb1f6c89fcd6e67f0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a4c543aa9c09a2eeb1f6c89fcd6e67f0c">condense</a> (<a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;sparsity) const </td></tr>
<tr class="separator:a4c543aa9c09a2eeb1f6c89fcd6e67f0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89592e12d5b3fd3f49d334abd2aec7e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a89592e12d5b3fd3f49d334abd2aec7e1">condense</a> (<a class="el" href="classBlockSparsityPattern.html">BlockSparsityPattern</a> &amp;sparsity) const </td></tr>
<tr class="separator:a89592e12d5b3fd3f49d334abd2aec7e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5045dd1c16712362047a09f8a7fdab57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a5045dd1c16712362047a09f8a7fdab57">condense</a> (<a class="el" href="classCompressedSparsityPattern.html">CompressedSparsityPattern</a> &amp;sparsity) const </td></tr>
<tr class="separator:a5045dd1c16712362047a09f8a7fdab57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a251937c07785568939cd594f70927a54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a251937c07785568939cd594f70927a54">condense</a> (<a class="el" href="classCompressedSetSparsityPattern.html">CompressedSetSparsityPattern</a> &amp;sparsity) const </td></tr>
<tr class="separator:a251937c07785568939cd594f70927a54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02bd8832964dab7141ba308b4807013b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a02bd8832964dab7141ba308b4807013b">condense</a> (<a class="el" href="classCompressedSimpleSparsityPattern.html">CompressedSimpleSparsityPattern</a> &amp;sparsity) const </td></tr>
<tr class="separator:a02bd8832964dab7141ba308b4807013b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9358dc591e0e20d9c436ff681ded0f81"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a9358dc591e0e20d9c436ff681ded0f81">condense</a> (<a class="el" href="classBlockCompressedSparsityPattern.html">BlockCompressedSparsityPattern</a> &amp;sparsity) const </td></tr>
<tr class="separator:a9358dc591e0e20d9c436ff681ded0f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c9a7553ea7692b9cca16261f101a817"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a6c9a7553ea7692b9cca16261f101a817">condense</a> (<a class="el" href="classBlockCompressedSetSparsityPattern.html">BlockCompressedSetSparsityPattern</a> &amp;sparsity) const </td></tr>
<tr class="separator:a6c9a7553ea7692b9cca16261f101a817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367e25c757851dd2bb841045c6b017f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a367e25c757851dd2bb841045c6b017f1">condense</a> (<a class="el" href="classBlockCompressedSimpleSparsityPattern.html">BlockCompressedSimpleSparsityPattern</a> &amp;sparsity) const </td></tr>
<tr class="separator:a367e25c757851dd2bb841045c6b017f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03eb1cae2b287fd730ade4b03435cf5b"><td class="memTemplParams" colspan="2">template&lt;typename number &gt; </td></tr>
<tr class="memitem:a03eb1cae2b287fd730ade4b03435cf5b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a03eb1cae2b287fd730ade4b03435cf5b">condense</a> (const <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;uncondensed, <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;condensed) const <a class="el" href="group__Sparsity.html#ga0849dabf81f46d4d964e251c286784dd">DEAL_II_DEPRECATED</a></td></tr>
<tr class="separator:a03eb1cae2b287fd730ade4b03435cf5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbed1c1ffab4cccd72f29d9e32434d8b"><td class="memTemplParams" colspan="2">template&lt;typename number &gt; </td></tr>
<tr class="memitem:acbed1c1ffab4cccd72f29d9e32434d8b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#acbed1c1ffab4cccd72f29d9e32434d8b">condense</a> (<a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;matrix) const </td></tr>
<tr class="separator:acbed1c1ffab4cccd72f29d9e32434d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f2277dc3def8132b5fa14d7424020fc"><td class="memTemplParams" colspan="2">template&lt;typename number &gt; </td></tr>
<tr class="memitem:a4f2277dc3def8132b5fa14d7424020fc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a4f2277dc3def8132b5fa14d7424020fc">condense</a> (<a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt; &amp;matrix) const </td></tr>
<tr class="separator:a4f2277dc3def8132b5fa14d7424020fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8185bee0894c938b9511c669f42b9291"><td class="memTemplParams" colspan="2">template&lt;class VectorType &gt; </td></tr>
<tr class="memitem:a8185bee0894c938b9511c669f42b9291"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a8185bee0894c938b9511c669f42b9291">condense</a> (const <a class="el" href="classVectorType.html">VectorType</a> &amp;uncondensed, <a class="el" href="classVectorType.html">VectorType</a> &amp;condensed) const <a class="el" href="group__Sparsity.html#ga0849dabf81f46d4d964e251c286784dd">DEAL_II_DEPRECATED</a></td></tr>
<tr class="separator:a8185bee0894c938b9511c669f42b9291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acabb2a68508f976262ea6286f655de71"><td class="memTemplParams" colspan="2">template&lt;class VectorType &gt; </td></tr>
<tr class="memitem:acabb2a68508f976262ea6286f655de71"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#acabb2a68508f976262ea6286f655de71">condense</a> (<a class="el" href="classVectorType.html">VectorType</a> &amp;vec) const </td></tr>
<tr class="separator:acabb2a68508f976262ea6286f655de71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3da0b58d91a1806351fa4ab83d0c52de"><td class="memTemplParams" colspan="2">template&lt;typename number , class VectorType &gt; </td></tr>
<tr class="memitem:a3da0b58d91a1806351fa4ab83d0c52de"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a3da0b58d91a1806351fa4ab83d0c52de">condense</a> (const <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;uncondensed_matrix, const <a class="el" href="classVectorType.html">VectorType</a> &amp;uncondensed_vector, <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;condensed_matrix, <a class="el" href="classVectorType.html">VectorType</a> &amp;condensed_vector) const <a class="el" href="group__Sparsity.html#ga0849dabf81f46d4d964e251c286784dd">DEAL_II_DEPRECATED</a></td></tr>
<tr class="separator:a3da0b58d91a1806351fa4ab83d0c52de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eb1a5d5d17e58f9c9cdc6eb551e075a"><td class="memTemplParams" colspan="2">template&lt;typename number , class VectorType &gt; </td></tr>
<tr class="memitem:a4eb1a5d5d17e58f9c9cdc6eb551e075a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a4eb1a5d5d17e58f9c9cdc6eb551e075a">condense</a> (<a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;matrix, <a class="el" href="classVectorType.html">VectorType</a> &amp;vector) const </td></tr>
<tr class="separator:a4eb1a5d5d17e58f9c9cdc6eb551e075a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e138156c4216abed3277232b86ebcb8"><td class="memTemplParams" colspan="2">template&lt;typename number , class BlockVectorType &gt; </td></tr>
<tr class="memitem:a6e138156c4216abed3277232b86ebcb8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a6e138156c4216abed3277232b86ebcb8">condense</a> (<a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt; &amp;matrix, BlockVectorType &amp;vector) const </td></tr>
<tr class="separator:a6e138156c4216abed3277232b86ebcb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a3e683ed07b7811be4522fc187d811e"><td class="memTemplParams" colspan="2">template&lt;class VectorType &gt; </td></tr>
<tr class="memitem:a0a3e683ed07b7811be4522fc187d811e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a0a3e683ed07b7811be4522fc187d811e">set_zero</a> (<a class="el" href="classVectorType.html">VectorType</a> &amp;vec) const </td></tr>
<tr class="separator:a0a3e683ed07b7811be4522fc187d811e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Eliminating constraints from linear systems during their creation</div></td></tr>
<tr class="memitem:aa9f3612a8fc51eafa34252bb436e8ae4"><td class="memTemplParams" colspan="2">template&lt;class InVector , class OutVector &gt; </td></tr>
<tr class="memitem:aa9f3612a8fc51eafa34252bb436e8ae4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#aa9f3612a8fc51eafa34252bb436e8ae4">distribute_local_to_global</a> (const InVector &amp;local_vector, const std::vector&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> &gt; &amp;local_dof_indices, OutVector &amp;global_vector) const </td></tr>
<tr class="separator:aa9f3612a8fc51eafa34252bb436e8ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65c9b3a10880e101757d0b4ffabbd38c"><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr class="memitem:a65c9b3a10880e101757d0b4ffabbd38c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a65c9b3a10880e101757d0b4ffabbd38c">distribute_local_to_global</a> (const <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;local_vector, const std::vector&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> &gt; &amp;local_dof_indices, <a class="el" href="classVectorType.html">VectorType</a> &amp;global_vector, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;local_matrix) const </td></tr>
<tr class="separator:a65c9b3a10880e101757d0b4ffabbd38c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6b9fca14b899361ed2862574a099a6d"><td class="memTemplParams" colspan="2">template&lt;class VectorType &gt; </td></tr>
<tr class="memitem:ab6b9fca14b899361ed2862574a099a6d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#ab6b9fca14b899361ed2862574a099a6d">distribute_local_to_global</a> (const <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> index, const <a class="el" href="classdouble.html">double</a> value, <a class="el" href="classVectorType.html">VectorType</a> &amp;global_vector) const </td></tr>
<tr class="separator:ab6b9fca14b899361ed2862574a099a6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1032d59cc816d071812febd5fd3c1fd5"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIteratorVec , typename ForwardIteratorInd , class VectorType &gt; </td></tr>
<tr class="memitem:a1032d59cc816d071812febd5fd3c1fd5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a1032d59cc816d071812febd5fd3c1fd5">distribute_local_to_global</a> (ForwardIteratorVec local_vector_begin, ForwardIteratorVec local_vector_end, ForwardIteratorInd local_indices_begin, <a class="el" href="classVectorType.html">VectorType</a> &amp;global_vector) const </td></tr>
<tr class="separator:a1032d59cc816d071812febd5fd3c1fd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0edca3cf6c2c649850b590bc62452c45"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType &gt; </td></tr>
<tr class="memitem:a0edca3cf6c2c649850b590bc62452c45"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a0edca3cf6c2c649850b590bc62452c45">distribute_local_to_global</a> (const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;local_matrix, const std::vector&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> &gt; &amp;local_dof_indices, MatrixType &amp;global_matrix) const </td></tr>
<tr class="separator:a0edca3cf6c2c649850b590bc62452c45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67f9bee1c3e3b1c7a49ddf113385bf6c"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType &gt; </td></tr>
<tr class="memitem:a67f9bee1c3e3b1c7a49ddf113385bf6c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a67f9bee1c3e3b1c7a49ddf113385bf6c">distribute_local_to_global</a> (const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;local_matrix, const std::vector&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> &gt; &amp;row_indices, const std::vector&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> &gt; &amp;col_indices, MatrixType &amp;global_matrix) const </td></tr>
<tr class="separator:a67f9bee1c3e3b1c7a49ddf113385bf6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a355fc5c0b4d237f1ae335f82c8de1332"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename VectorType &gt; </td></tr>
<tr class="memitem:a355fc5c0b4d237f1ae335f82c8de1332"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a355fc5c0b4d237f1ae335f82c8de1332">distribute_local_to_global</a> (const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;local_matrix, const <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;local_vector, const std::vector&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> &gt; &amp;local_dof_indices, MatrixType &amp;global_matrix, <a class="el" href="classVectorType.html">VectorType</a> &amp;global_vector, <a class="el" href="classbool.html">bool</a> use_inhomogeneities_for_rhs=false) const </td></tr>
<tr class="separator:a355fc5c0b4d237f1ae335f82c8de1332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a646ac6aabbc957e439971b8a14d0add8"><td class="memTemplParams" colspan="2">template&lt;typename SparsityType &gt; </td></tr>
<tr class="memitem:a646ac6aabbc957e439971b8a14d0add8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a646ac6aabbc957e439971b8a14d0add8">add_entries_local_to_global</a> (const std::vector&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> &gt; &amp;local_dof_indices, SparsityType &amp;sparsity_pattern, const <a class="el" href="classbool.html">bool</a> keep_constrained_entries=true, const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="classbool.html">bool</a> &gt; &amp;dof_mask=<a class="el" href="classConstraintMatrix.html#a8d93601283d9e32df2192c3ca362ebf5">default_empty_table</a>) const </td></tr>
<tr class="separator:a646ac6aabbc957e439971b8a14d0add8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8560e315f45648df1a6c1d2b093e68d3"><td class="memTemplParams" colspan="2">template&lt;typename SparsityType &gt; </td></tr>
<tr class="memitem:a8560e315f45648df1a6c1d2b093e68d3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a8560e315f45648df1a6c1d2b093e68d3">add_entries_local_to_global</a> (const std::vector&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> &gt; &amp;row_indices, const std::vector&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> &gt; &amp;col_indices, SparsityType &amp;sparsity_pattern, const <a class="el" href="classbool.html">bool</a> keep_constrained_entries=true, const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="classbool.html">bool</a> &gt; &amp;dof_mask=<a class="el" href="classConstraintMatrix.html#a8d93601283d9e32df2192c3ca362ebf5">default_empty_table</a>) const </td></tr>
<tr class="separator:a8560e315f45648df1a6c1d2b093e68d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e087ffed00c38027211757dffd8ea9b"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIteratorVec , typename ForwardIteratorInd , class VectorType &gt; </td></tr>
<tr class="memitem:a0e087ffed00c38027211757dffd8ea9b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a0e087ffed00c38027211757dffd8ea9b">get_dof_values</a> (const <a class="el" href="classVectorType.html">VectorType</a> &amp;global_vector, ForwardIteratorInd local_indices_begin, ForwardIteratorVec local_vector_begin, ForwardIteratorVec local_vector_end) const </td></tr>
<tr class="separator:a0e087ffed00c38027211757dffd8ea9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Dealing with constraints after solving a linear system</div></td></tr>
<tr class="memitem:a7cf6b84c47aa32408f412ae769085bd6"><td class="memTemplParams" colspan="2">template&lt;class VectorType &gt; </td></tr>
<tr class="memitem:a7cf6b84c47aa32408f412ae769085bd6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a7cf6b84c47aa32408f412ae769085bd6">distribute</a> (const <a class="el" href="classVectorType.html">VectorType</a> &amp;condensed, <a class="el" href="classVectorType.html">VectorType</a> &amp;uncondensed) const </td></tr>
<tr class="separator:a7cf6b84c47aa32408f412ae769085bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1676b89d3936a007bb48a9d5210e6f07"><td class="memTemplParams" colspan="2">template&lt;class VectorType &gt; </td></tr>
<tr class="memitem:a1676b89d3936a007bb48a9d5210e6f07"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a1676b89d3936a007bb48a9d5210e6f07">distribute</a> (<a class="el" href="classVectorType.html">VectorType</a> &amp;vec) const </td></tr>
<tr class="separator:a1676b89d3936a007bb48a9d5210e6f07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSubscriptor"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSubscriptor')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSubscriptor.html">Subscriptor</a></td></tr>
<tr class="memitem:ae5541017c0966b0af345db75895106f2 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#ae5541017c0966b0af345db75895106f2">Subscriptor</a> ()</td></tr>
<tr class="separator:ae5541017c0966b0af345db75895106f2 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367fce3122075f05f168d14f114b4c65 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a367fce3122075f05f168d14f114b4c65">Subscriptor</a> (const <a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;)</td></tr>
<tr class="separator:a367fce3122075f05f168d14f114b4c65 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c6c557e06110d2127fa6459119e94af inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a6c6c557e06110d2127fa6459119e94af">~Subscriptor</a> ()</td></tr>
<tr class="separator:a6c6c557e06110d2127fa6459119e94af inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24ee69d4b3cf9690d1208b2443cbbb80 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a24ee69d4b3cf9690d1208b2443cbbb80">operator=</a> (const <a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;)</td></tr>
<tr class="separator:a24ee69d4b3cf9690d1208b2443cbbb80 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3422499827ecd52f1d12d65eb6cc3125 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a3422499827ecd52f1d12d65eb6cc3125">subscribe</a> (const char *identifier=0) const </td></tr>
<tr class="separator:a3422499827ecd52f1d12d65eb6cc3125 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b4839b1cffc18781144ede1744b35ea inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a2b4839b1cffc18781144ede1744b35ea">unsubscribe</a> (const char *identifier=0) const </td></tr>
<tr class="separator:a2b4839b1cffc18781144ede1744b35ea inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b45274c8e1936bff024df01d618e86f inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a7b45274c8e1936bff024df01d618e86f">n_subscriptions</a> () const </td></tr>
<tr class="separator:a7b45274c8e1936bff024df01d618e86f inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbbc5f845063b1f23223b7ac96e89e13 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#adbbc5f845063b1f23223b7ac96e89e13">list_subscribers</a> () const </td></tr>
<tr class="separator:adbbc5f845063b1f23223b7ac96e89e13 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2f0251d20c6a5295024de3b2e9b4359 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac2f0251d20c6a5295024de3b2e9b4359">DeclException3</a> (ExcInUse, <a class="el" href="classint.html">int</a>, char *, std::string &amp;,&lt;&lt; &quot;Object of class &quot;&lt;&lt; arg2&lt;&lt; &quot; is still used by &quot;&lt;&lt; arg1&lt;&lt; &quot; other objects.\n&quot;&lt;&lt; &quot;(Additional information: &quot;&lt;&lt; arg3&lt;&lt; &quot;)\n&quot;&lt;&lt; &quot;Note the entry in the Frequently Asked Questions of &quot;&lt;&lt; &quot;deal.II (linked to from http://www.dealii.org/) for &quot;&lt;&lt; &quot;more information on what this error means.&quot;)</td></tr>
<tr class="separator:gac2f0251d20c6a5295024de3b2e9b4359 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e000d9ce953da6afe4bbbaca4397344 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga9e000d9ce953da6afe4bbbaca4397344">DeclException2</a> (ExcNoSubscriber, char *, char *,&lt;&lt; &quot;No subscriber with identifier \&quot;&quot;&lt;&lt; arg2&lt;&lt; &quot;\&quot; did <a class="el" href="classSubscriptor.html#a3422499827ecd52f1d12d65eb6cc3125">subscribe</a> to this object of class &quot;&lt;&lt; arg1)</td></tr>
<tr class="separator:ga9e000d9ce953da6afe4bbbaca4397344 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38 inherit pub_methods_classSubscriptor"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38 inherit pub_methods_classSubscriptor"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:a68efd17a8330ab676d9cd711029b0f38 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a4cee40b1b2797c8c42cc7b5a0c707517"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a4cee40b1b2797c8c42cc7b5a0c707517">calculate_line_index</a> (const <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> line) const </td></tr>
<tr class="separator:a4cee40b1b2797c8c42cc7b5a0c707517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ee730e1973c0676bfc174a3d12d9248"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename VectorType &gt; </td></tr>
<tr class="memitem:a9ee730e1973c0676bfc174a3d12d9248"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a9ee730e1973c0676bfc174a3d12d9248">distribute_local_to_global</a> (const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;local_matrix, const <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;local_vector, const std::vector&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> &gt; &amp;local_dof_indices, MatrixType &amp;global_matrix, <a class="el" href="classVectorType.html">VectorType</a> &amp;global_vector, <a class="el" href="classbool.html">bool</a> use_inhomogeneities_for_rhs, <a class="el" href="structinternal_1_1bool2type.html">internal::bool2type</a>&lt; false &gt;) const </td></tr>
<tr class="separator:a9ee730e1973c0676bfc174a3d12d9248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af173ddd46331a28bb82d21d522b04d61"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename VectorType &gt; </td></tr>
<tr class="memitem:af173ddd46331a28bb82d21d522b04d61"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#af173ddd46331a28bb82d21d522b04d61">distribute_local_to_global</a> (const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;local_matrix, const <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;local_vector, const std::vector&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> &gt; &amp;local_dof_indices, MatrixType &amp;global_matrix, <a class="el" href="classVectorType.html">VectorType</a> &amp;global_vector, <a class="el" href="classbool.html">bool</a> use_inhomogeneities_for_rhs, <a class="el" href="structinternal_1_1bool2type.html">internal::bool2type</a>&lt; true &gt;) const </td></tr>
<tr class="separator:af173ddd46331a28bb82d21d522b04d61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace822e43c8e8167af16d946d7b0cab64"><td class="memTemplParams" colspan="2">template&lt;typename SparsityType &gt; </td></tr>
<tr class="memitem:ace822e43c8e8167af16d946d7b0cab64"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#ace822e43c8e8167af16d946d7b0cab64">add_entries_local_to_global</a> (const std::vector&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> &gt; &amp;local_dof_indices, SparsityType &amp;sparsity_pattern, const <a class="el" href="classbool.html">bool</a> keep_constrained_entries, const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="classbool.html">bool</a> &gt; &amp;dof_mask, <a class="el" href="structinternal_1_1bool2type.html">internal::bool2type</a>&lt; false &gt;) const </td></tr>
<tr class="separator:ace822e43c8e8167af16d946d7b0cab64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bf32d1ffa681bc4072aa34875d37894"><td class="memTemplParams" colspan="2">template&lt;typename SparsityType &gt; </td></tr>
<tr class="memitem:a0bf32d1ffa681bc4072aa34875d37894"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a0bf32d1ffa681bc4072aa34875d37894">add_entries_local_to_global</a> (const std::vector&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> &gt; &amp;local_dof_indices, SparsityType &amp;sparsity_pattern, const <a class="el" href="classbool.html">bool</a> keep_constrained_entries, const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="classbool.html">bool</a> &gt; &amp;dof_mask, <a class="el" href="structinternal_1_1bool2type.html">internal::bool2type</a>&lt; true &gt;) const </td></tr>
<tr class="separator:a0bf32d1ffa681bc4072aa34875d37894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd032ea43b4ddd6eae2d2ed3b0d45ffd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#abd032ea43b4ddd6eae2d2ed3b0d45ffd">make_sorted_row_list</a> (const std::vector&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> &gt; &amp;local_dof_indices, <a class="el" href="classinternals_1_1GlobalRowsFromLocal.html">internals::GlobalRowsFromLocal</a> &amp;global_rows) const </td></tr>
<tr class="separator:abd032ea43b4ddd6eae2d2ed3b0d45ffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21f5134bab744c1ec293eb83d1d0664e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a21f5134bab744c1ec293eb83d1d0664e">make_sorted_row_list</a> (const std::vector&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> &gt; &amp;local_dof_indices, std::vector&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> &gt; &amp;active_dofs) const </td></tr>
<tr class="separator:a21f5134bab744c1ec293eb83d1d0664e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a957d1a559a898d9f06ce3ee8eedbb04f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a957d1a559a898d9f06ce3ee8eedbb04f">resolve_vector_entry</a> (const <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> i, const <a class="el" href="classinternals_1_1GlobalRowsFromLocal.html">internals::GlobalRowsFromLocal</a> &amp;global_rows, const <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;local_vector, const std::vector&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> &gt; &amp;local_dof_indices, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;local_matrix) const </td></tr>
<tr class="separator:a957d1a559a898d9f06ce3ee8eedbb04f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:a454dc961e571b2890a0046051ae32248"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a454dc961e571b2890a0046051ae32248">check_zero_weight</a> (const std::pair&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a>, <a class="el" href="classdouble.html">double</a> &gt; &amp;p)</td></tr>
<tr class="separator:a454dc961e571b2890a0046051ae32248"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a0f3b653958a9f500be62c61791e42dd0"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structConstraintMatrix_1_1ConstraintLine.html">ConstraintLine</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a0f3b653958a9f500be62c61791e42dd0">lines</a></td></tr>
<tr class="separator:a0f3b653958a9f500be62c61791e42dd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25db0740488705b778ab6eedeec9c1fb"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a25db0740488705b778ab6eedeec9c1fb">lines_cache</a></td></tr>
<tr class="separator:a25db0740488705b778ab6eedeec9c1fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58dd31bd6fceeb6b67fe54017e0750b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIndexSet.html">IndexSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a58dd31bd6fceeb6b67fe54017e0750b5">local_lines</a></td></tr>
<tr class="separator:a58dd31bd6fceeb6b67fe54017e0750b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada29d922494c2b645e418cc311ec872d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#ada29d922494c2b645e418cc311ec872d">sorted</a></td></tr>
<tr class="separator:ada29d922494c2b645e418cc311ec872d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr class="memitem:a8d93601283d9e32df2192c3ca362ebf5"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="classbool.html">bool</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a8d93601283d9e32df2192c3ca362ebf5">default_empty_table</a></td></tr>
<tr class="separator:a8d93601283d9e32df2192c3ca362ebf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class implements dealing with linear (possibly inhomogeneous) constraints on degrees of freedom. The concept and origin of such constraints is extensively described in the <a class="el" href="group__constraints.html">Constraints on degrees of freedom</a> module. The class is meant to deal with a limited number of constraints relative to the total number of degrees of freedom, for example a few per cent up to maybe 30 per cent; and with a linear combination of <em>M</em> other degrees of freedom where <em>M</em> is also relatively small (no larger than at most around the average number of entries per row of a linear system). It is <em>not</em> meant to describe full rank linear systems.</p>
<p>The algorithms used in the implementation of this class are described in some detail in the <a class="el" href="DEALGlossary.html#hp_paper">hp paper</a>. There is also a significant amount of documentation on how to use this class in the <a class="el" href="group__constraints.html">Constraints on degrees of freedom</a> module.</p>
<h3>Description of constraints</h3>
<p>Each "line" in objects of this class corresponds to one constrained degree of freedom, with the number of the line being <em>i</em>, entered by using <a class="el" href="classConstraintMatrix.html#a24eb022f65797389badbb6d21da5b708">add_line()</a> or <a class="el" href="classConstraintMatrix.html#ab97f0436882283ec56368f4b8a9bf85e">add_lines()</a>. The entries in this line are pairs of the form (<em>j</em>,<em>a<sub>ij</sub></em>), which are added by <a class="el" href="classConstraintMatrix.html#a4cd323a407cb379510a68c26e842304e">add_entry()</a> or <a class="el" href="classConstraintMatrix.html#a5c906810edcc1917729cdca50d76c021">add_entries()</a>. The organization is essentially a <a class="el" href="classSparsityPattern.html">SparsityPattern</a>, but with only a few lines containing nonzero elements, and therefore no data wasted on the others. For each line, which has been added by the mechanism above, an elimination of the constrained degree of freedom of the form </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ x_i = \sum_j a_{ij} x_j + b_i \]" src="form_362.png"/>
</p>
<p> is performed, where <em>b<sub>i</sub></em> is optional and set by <a class="el" href="classConstraintMatrix.html#a2121ba9d256cbab8e6b8390fb89dda74">set_inhomogeneity()</a>. Thus, if a constraint is formulated for instance as a zero mean value of several degrees of freedom, one of the degrees has to be chosen to be eliminated.</p>
<p>Note that the constraints are linear in the <em>x<sub>i</sub></em>, and that there might be a constant (non-homogeneous) term in the constraint. This is exactly the form we need for hanging node constraints, where we need to constrain one degree of freedom in terms of others. There are other conditions of this form possible, for example for implementing mean value conditions as is done in the <a class="el" href="step_11.html">step-11</a> tutorial program. The name of the class stems from the fact that these constraints can be represented in matrix form as <b>X</b> <em>x</em> = <em>b</em>, and this object then describes the matrix <b>X</b> (and the vector <em>b</em>; originally, the <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> class was only meant to handle homogenous constraints where <em>b</em>=0, thus the name). The most frequent way to create/fill objects of this type is using the <a class="el" href="group__constraints.html#gabe9d21d4bb33ce556a6e6e80c2bf4b41">DoFTools::make_hanging_node_constraints()</a> function. The use of these objects is first explained in <a class="el" href="step_6.html">step-6</a>.</p>
<p>Objects of the present type are organized in lines (rows), but only those lines are stored where constraints are present. New constraints are added by adding new lines using the <a class="el" href="classConstraintMatrix.html#a24eb022f65797389badbb6d21da5b708">add_line()</a> function, and then populating it using the <a class="el" href="classConstraintMatrix.html#a4cd323a407cb379510a68c26e842304e">add_entry()</a> function to a given line, or <a class="el" href="classConstraintMatrix.html#a5c906810edcc1917729cdca50d76c021">add_entries()</a> to add more than one entry at a time. The right hand side element, if nonzero, can be set using the <a class="el" href="classConstraintMatrix.html#a2121ba9d256cbab8e6b8390fb89dda74">set_inhomogeneity()</a> function. After all constraints have been added, you need to call <a class="el" href="classConstraintMatrix.html#a8056d07faa2a7ed3f158c1b42d56abc8">close()</a>, which compresses the storage format and sorts the entries.</p>
<dl class="section note"><dt>Note</dt><dd>Many of the algorithms this class implements are discussed in the <a class="el" href="DEALGlossary.html#hp_paper">hp_paper</a> . The algorithms are also related to those shown in <em>M. S. Shephard: Linear multipoint constraints applied via transformation as part of a direct stiffness assembly process. Int. J. Numer. Meth. Engrg., vol. 20 (1984), pp. 2107-2112.</em>, with the difference that the algorithms shown there completely eliminated constrained degrees of freedom, whereas we usually keep them as part of the linear system.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Wolfgang Bangerth, Martin Kronbichler, 1998, 2004, 2008, 2009 </dd></dl>

<p>Definition at line <a class="el" href="constraint__matrix_8h_source.html#l00145">145</a> of file <a class="el" href="constraint__matrix_8h_source.html">constraint_matrix.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a71b13eb29cd43c9e87abebf2bf78b2a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">ConstraintMatrix::size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare the type for container size. </p>

<p>Definition at line <a class="el" href="constraint__matrix_8h_source.html#l00151">151</a> of file <a class="el" href="constraint__matrix_8h_source.html">constraint_matrix.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="a13384243a9580fd6540f0b5bc9ab2e12"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classConstraintMatrix.html#a13384243a9580fd6540f0b5bc9ab2e12">ConstraintMatrix::MergeConflictBehavior</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An enum that describes what should happen if the two <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> objects involved in a call to the <a class="el" href="classConstraintMatrix.html#a08b5378ad8b23e5fb86c71a2c66bff13">merge()</a> function happen to have constraints on the same degrees of freedom. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a13384243a9580fd6540f0b5bc9ab2e12acbfe858c120a4048128ed22a4b7d6d3c"></a>no_conflicts_allowed&#160;</td><td class="fielddoc">
<p>Throw an exception if the two objects concerned have conflicting constraints on the same degree of freedom. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a13384243a9580fd6540f0b5bc9ab2e12a9a973f6cdef8bfbb583f05d520940bd9"></a>left_object_wins&#160;</td><td class="fielddoc">
<p>In an operation <code>cm1.merge(cm2)</code>, if <code>cm1</code> and <code>cm2</code> have constraints on the same degree of freedom, take the one from <code>cm1</code>. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a13384243a9580fd6540f0b5bc9ab2e12a77ea16e7d833659a57b4cc7ef2aa83ff"></a>right_object_wins&#160;</td><td class="fielddoc">
<p>In an operation <code>cm1.merge(cm2)</code>, if <code>cm1</code> and <code>cm2</code> have constraints on the same degree of freedom, take the one from <code>cm2</code>. </p>
</td></tr>
</table>

<p>Definition at line <a class="el" href="constraint__matrix_8h_source.html#l00158">158</a> of file <a class="el" href="constraint__matrix_8h_source.html">constraint_matrix.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ab0441dd6e2b4ac88a06ec8a74842aa67"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ConstraintMatrix::ConstraintMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>local_constraints</em> = <code><a class="el" href="classIndexSet.html">IndexSet</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor. The supplied <a class="el" href="classIndexSet.html">IndexSet</a> defines which indices might be constrained inside this <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a>. In a calculation with a parallel::distributed::DoFHandler one should use locally_relevant_dofs. The <a class="el" href="classIndexSet.html">IndexSet</a> allows the <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> to safe memory. Otherwise internal data structures for all possible indices will be created. </p>

<p>Definition at line <a class="el" href="constraint__matrix_8h_source.html#l01401">1401</a> of file <a class="el" href="constraint__matrix_8h_source.html">constraint_matrix.h</a>.</p>

</div>
</div>
<a class="anchor" id="acd9abe681db430ed7493b8f86034d2bf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ConstraintMatrix::ConstraintMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraint_matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy constructor </p>

<p>Definition at line <a class="el" href="constraint__matrix_8h_source.html#l01416">1416</a> of file <a class="el" href="constraint__matrix_8h_source.html">constraint_matrix.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ac2726821354883ac97fe7e6181de9792"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>local_constraints</em> = <code><a class="el" href="classIndexSet.html">IndexSet</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reinit the <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> object and supply an <a class="el" href="classIndexSet.html">IndexSet</a> with lines that may be constrained. This function is only relevant in the distributed case to supply a different <a class="el" href="classIndexSet.html">IndexSet</a>. Otherwise this routine is equivalent to calling <a class="el" href="classConstraintMatrix.html#a24120d0331183f9a63cbe41493a19f6b">clear()</a>. See the constructor for details. </p>

</div>
</div>
<a class="anchor" id="a5b8fcc9dc467d8dda86b192405587ba9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ConstraintMatrix::can_store_line </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a>&#160;</td>
          <td class="paramname"><em>line_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determines if we can store a constraint for the given <code>line_index</code>. This routine only matters in the distributed case and checks if the <a class="el" href="classIndexSet.html">IndexSet</a> allows storage of this line. Always returns true if not in the distributed case. </p>

<p>Definition at line <a class="el" href="constraint__matrix_8h_source.html#l01597">1597</a> of file <a class="el" href="constraint__matrix_8h_source.html">constraint_matrix.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3a9fbd08cdb7508f948fb2cccb2ce096"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp; ConstraintMatrix::get_local_lines </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the index set describing locally relevant lines if any are present. Note that if no local lines were given, this represents an empty <a class="el" href="classIndexSet.html">IndexSet</a>, whereas otherwise it contains the global problem size and the local range. </p>

<p>Definition at line <a class="el" href="constraint__matrix_8h_source.html#l01606">1606</a> of file <a class="el" href="constraint__matrix_8h_source.html">constraint_matrix.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa133ef470eff7de0d26a28610a047753"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::add_selected_constraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function copies the content of <code>constraints_in</code> with DoFs that are element of the <a class="el" href="classIndexSet.html">IndexSet</a> <code>filter</code>. Elements that are not present in the <a class="el" href="classIndexSet.html">IndexSet</a> are ignored. All DoFs will be transformed to local index space of the filter, both the constrained DoFs and the other DoFs these entries are constrained to. The local index space of the filter is a contiguous numbering of all (global) DoFs that are elements in the filter.</p>
<p>If, for example, the filter represents the range <code>[10,20)</code>, and the constraint matrix <code>constraints_in</code> includes the global indices <code>{7,13,14}</code>, the indices <code>{3,4}</code> are added to the calling constraint matrix (since 13 and 14 are elements in the filter and element 13 is the fourth element in the index, and 14 is the fifth).</p>
<p>This function provides an easy way to create a <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> for certain vector components in a vector-valued problem from a full <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a>, i.e. extracting a diagonal subblock from a larger <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a>. The block is specified by the <a class="el" href="classIndexSet.html">IndexSet</a> argument. </p>

</div>
</div>
<a class="anchor" id="a24eb022f65797389badbb6d21da5b708"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::add_line </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a>&#160;</td>
          <td class="paramname"><em>line</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add a new line to the matrix. If the line already exists, then the function simply returns without doing anything. </p>

<p>Definition at line <a class="el" href="constraint__matrix_8h_source.html#l01428">1428</a> of file <a class="el" href="constraint__matrix_8h_source.html">constraint_matrix.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab97f0436882283ec56368f4b8a9bf85e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::add_lines </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>lines</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call the first <a class="el" href="classConstraintMatrix.html#a24eb022f65797389badbb6d21da5b708">add_line()</a> function for every index <code>i</code> for which <code>lines[i]</code> is true.</p>
<p>This function essentially exists to allow adding several constraints of the form <em>x<sub>i</sub></em>=0 all at once, where the set of indices <em>i</em> for which these constraints should be added are given by the argument of this function. On the other hand, just as if the single-argument <a class="el" href="classConstraintMatrix.html#a24eb022f65797389badbb6d21da5b708">add_line()</a> function were called repeatedly, the constraints can later be modified to include linear dependencies using the <a class="el" href="classConstraintMatrix.html#a4cd323a407cb379510a68c26e842304e">add_entry()</a> function as well as inhomogeneities using <a class="el" href="classConstraintMatrix.html#a2121ba9d256cbab8e6b8390fb89dda74">set_inhomogeneity()</a>. </p>

</div>
</div>
<a class="anchor" id="a3c11118d7fc3117aea42de57062ee6c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::add_lines </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>lines</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call the first <a class="el" href="classConstraintMatrix.html#a24eb022f65797389badbb6d21da5b708">add_line()</a> function for every index <code>i</code> that appears in the argument.</p>
<p>This function essentially exists to allow adding several constraints of the form <em>x<sub>i</sub></em>=0 all at once, where the set of indices <em>i</em> for which these constraints should be added are given by the argument of this function. On the other hand, just as if the single-argument <a class="el" href="classConstraintMatrix.html#a24eb022f65797389badbb6d21da5b708">add_line()</a> function were called repeatedly, the constraints can later be modified to include linear dependencies using the <a class="el" href="classConstraintMatrix.html#a4cd323a407cb379510a68c26e842304e">add_entry()</a> function as well as inhomogeneities using <a class="el" href="classConstraintMatrix.html#a2121ba9d256cbab8e6b8390fb89dda74">set_inhomogeneity()</a>. </p>

</div>
</div>
<a class="anchor" id="a9d5e306f3db7f2e2a7256af61626c445"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::add_lines </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>lines</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call the first <a class="el" href="classConstraintMatrix.html#a24eb022f65797389badbb6d21da5b708">add_line()</a> function for every index <code>i</code> that appears in the argument.</p>
<p>This function essentially exists to allow adding several constraints of the form <em>x<sub>i</sub></em>=0 all at once, where the set of indices <em>i</em> for which these constraints should be added are given by the argument of this function. On the other hand, just as if the single-argument <a class="el" href="classConstraintMatrix.html#a24eb022f65797389badbb6d21da5b708">add_line()</a> function were called repeatedly, the constraints can later be modified to include linear dependencies using the <a class="el" href="classConstraintMatrix.html#a4cd323a407cb379510a68c26e842304e">add_entry()</a> function as well as inhomogeneities using <a class="el" href="classConstraintMatrix.html#a2121ba9d256cbab8e6b8390fb89dda74">set_inhomogeneity()</a>. </p>

</div>
</div>
<a class="anchor" id="a4cd323a407cb379510a68c26e842304e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::add_entry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a>&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a>&#160;</td>
          <td class="paramname"><em>column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add an entry to a given line. The list of lines is searched from the back to the front, so clever programming would add a new line (which is pushed to the back) and immediately afterwards fill the entries of that line. This way, no expensive searching is needed.</p>
<p>If an entry with the same indices as the one this function call denotes already exists, then this function simply returns provided that the value of the entry is the same. Thus, it does no harm to enter a constraint twice. </p>

<p>Definition at line <a class="el" href="constraint__matrix_8h_source.html#l01461">1461</a> of file <a class="el" href="constraint__matrix_8h_source.html">constraint_matrix.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5c906810edcc1917729cdca50d76c021"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::add_entries </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a>&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a>, <a class="el" href="classdouble.html">double</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_val_pairs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a whole series of entries, denoted by pairs of column indices and values, to a line of constraints. This function is equivalent to calling the preceding function several times, but is faster. </p>

</div>
</div>
<a class="anchor" id="a2121ba9d256cbab8e6b8390fb89dda74"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::set_inhomogeneity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a>&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set an imhomogeneity to the constraint line <em>i</em>, according to the discussion in the general class description.</p>
<dl class="section note"><dt>Note</dt><dd>the line needs to be added with one of the <a class="el" href="classConstraintMatrix.html#a24eb022f65797389badbb6d21da5b708">add_line()</a> calls first. </dd></dl>

<p>Definition at line <a class="el" href="constraint__matrix_8h_source.html#l01495">1495</a> of file <a class="el" href="constraint__matrix_8h_source.html">constraint_matrix.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8056d07faa2a7ed3f158c1b42d56abc8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Close the filling of entries. Since the lines of a matrix of this type are usually filled in an arbitrary order and since we do not want to use associative constainers to store the lines, we need to sort the lines and within the lines the columns before usage of the matrix. This is done through this function.</p>
<p>Also, zero entries are discarded, since they are not needed.</p>
<p>After closing, no more entries are accepted. If the object was already closed, then this function returns immediately.</p>
<p>This function also resolves chains of constraints. For example, degree of freedom 13 may be constrained to <img class="formulaInl" alt="$u_{13} = \frac{u_3}{2} + \frac{u_7}{2}$" src="form_363.png"/> while degree of freedom 7 is itself constrained as <img class="formulaInl" alt="$u_{7} = \frac{u_2}{2} + \frac{u_4}{2}$" src="form_364.png"/>. Then, the resolution will be that <img class="formulaInl" alt="$u_{13} = \frac{u_3}{2} + \frac{u_2}{4} + \frac{u_4}{4}$" src="form_365.png"/>. Note, however, that cycles in this graph of constraints are not allowed, i.e. for example <img class="formulaInl" alt="$u_4$" src="form_366.png"/> may not be constrained, directly or indirectly, to <img class="formulaInl" alt="$u_{13}$" src="form_367.png"/> again. </p>

</div>
</div>
<a class="anchor" id="a08b5378ad8b23e5fb86c71a2c66bff13"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::merge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>other_constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html#a13384243a9580fd6540f0b5bc9ab2e12">MergeConflictBehavior</a>&#160;</td>
          <td class="paramname"><em>merge_conflict_behavior</em> = <code><a class="el" href="classConstraintMatrix.html#a13384243a9580fd6540f0b5bc9ab2e12acbfe858c120a4048128ed22a4b7d6d3c">no_conflicts_allowed</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Merge the constraints represented by the object given as argument into the constraints represented by this object. Both objects may or may not be closed (by having their function <a class="el" href="classConstraintMatrix.html#a8056d07faa2a7ed3f158c1b42d56abc8">close()</a> called before). If this object was closed before, then it will be closed afterwards as well. Note, however, that if the other argument is closed, then merging may be significantly faster.</p>
<p>Using the default value of the second arguments, the constraints in each of the two objects (the old one represented by this object and the argument) may not refer to the same degree of freedom, i.e. a degree of freedom that is constrained in one object may not be constrained in the second. If this is nevertheless the case, an exception is thrown. However, this behavior can be changed by providing a different value for the second argument. </p>

</div>
</div>
<a class="anchor" id="ad971fb29f0a15bf8d30704d2a5ab445e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::shift </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a>&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shift all entries of this matrix down <code>offset</code> rows and over <code>offset</code> columns.</p>
<p>This function is useful if you are building block matrices, where all blocks are built by the same <a class="el" href="classDoFHandler.html">DoFHandler</a> object, i.e. the matrix size is larger than the number of degrees of freedom. Since several matrix rows and columns correspond to the same degrees of freedom, you'd generate several constraint objects, then shift them, and finally <a class="el" href="classConstraintMatrix.html#a08b5378ad8b23e5fb86c71a2c66bff13">merge()</a> them together again. </p>

</div>
</div>
<a class="anchor" id="a24120d0331183f9a63cbe41493a19f6b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear all entries of this matrix. Reset the flag determining whether new entries are accepted or not.</p>
<p>This function may be called also on objects which are empty or already cleared. </p>

</div>
</div>
<a class="anchor" id="a92cbfbc16e70c7ba4f93ed6d548d87cb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> ConstraintMatrix::n_constraints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return number of constraints stored in this matrix. </p>

<p>Definition at line <a class="el" href="constraint__matrix_8h_source.html#l01511">1511</a> of file <a class="el" href="constraint__matrix_8h_source.html">constraint_matrix.h</a>.</p>

</div>
</div>
<a class="anchor" id="aac0dd11d56f41826d958ade7faa0cfe4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ConstraintMatrix::is_constrained </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return whether the degree of freedom with number <code>index</code> is a constrained one.</p>
<p>Note that if <a class="el" href="classConstraintMatrix.html#a8056d07faa2a7ed3f158c1b42d56abc8">close()</a> was called before, then this function is significantly faster, since then the constrained degrees of freedom are sorted and we can do a binary search, while before <a class="el" href="classConstraintMatrix.html#a8056d07faa2a7ed3f158c1b42d56abc8">close()</a> was called, we have to perform a linear search through all entries. </p>

<p>Definition at line <a class="el" href="constraint__matrix_8h_source.html#l01520">1520</a> of file <a class="el" href="constraint__matrix_8h_source.html">constraint_matrix.h</a>.</p>

</div>
</div>
<a class="anchor" id="a91ee07099e4385280b6cd0770151c1f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ConstraintMatrix::is_identity_constrained </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether the dof is constrained, and whether it is constrained to only one other degree of freedom with weight one. The function therefore returns whether the degree of freedom would simply be eliminated in favor of exactly one other degree of freedom.</p>
<p>The function returns <code>false</code> if either the degree of freedom is not constrained at all, or if it is constrained to more than one other degree of freedom, or if it is constrained to only one degree of freedom but with a weight different from one. </p>

</div>
</div>
<a class="anchor" id="a21b954badf7ee5cf04e0295a32e89b5b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ConstraintMatrix::are_identity_constrained </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a>&#160;</td>
          <td class="paramname"><em>index1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a>&#160;</td>
          <td class="paramname"><em>index2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether the two given degrees of freedom are linked by an equality constraint that either constrains index1 to be so that <code>index1=index2</code> or constrains index2 so that <code>index2=index1</code>. </p>

</div>
</div>
<a class="anchor" id="a5f2373f9f16c2dc2ec3a145c08f8ff79"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> ConstraintMatrix::max_constraint_indirections </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the maximum number of other dofs that one dof is constrained to. For example, in 2d a hanging node is constrained only to its two neighbors, so the returned value would be 2. However, for higher order elements and/or higher dimensions, or other types of constraints, this number is no more obvious.</p>
<p>The name indicates that within the system matrix, references to a constrained node are indirected to the nodes it is constrained to. </p>

</div>
</div>
<a class="anchor" id="ae181e7b571ed96cefdbd187a4970a16e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ConstraintMatrix::is_inhomogeneously_constrained </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <code>true</code> in case the dof is constrained and there is a non-trivial inhomogeneous valeus set to the dof. </p>

<p>Definition at line <a class="el" href="constraint__matrix_8h_source.html#l01532">1532</a> of file <a class="el" href="constraint__matrix_8h_source.html">constraint_matrix.h</a>.</p>

</div>
</div>
<a class="anchor" id="accb6279d07885d6061bd915e3a9283ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ConstraintMatrix::has_inhomogeneities </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns <code>false</code> if all constraints in the <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> are homogeneous ones, and <code>true</code> if there is at least one inhomogeneity. </p>

</div>
</div>
<a class="anchor" id="a96b20c2f6162fdde6bafcea825f1cb31"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; std::pair&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>, <a class="el" href="classdouble.html">double</a> &gt; &gt; * ConstraintMatrix::get_constraint_entries </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a>&#160;</td>
          <td class="paramname"><em>line</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a pointer to the the vector of entries if a line is constrained, and a zero pointer in case the dof is not constrained. </p>

<p>Definition at line <a class="el" href="constraint__matrix_8h_source.html#l01551">1551</a> of file <a class="el" href="constraint__matrix_8h_source.html">constraint_matrix.h</a>.</p>

</div>
</div>
<a class="anchor" id="a78917c8bd905889c623092af2e54f7fb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> ConstraintMatrix::get_inhomogeneity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a>&#160;</td>
          <td class="paramname"><em>line</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the value of the inhomogeneity stored in the constrained dof <code>line</code>. Unconstrained dofs also return a zero value. </p>

<p>Definition at line <a class="el" href="constraint__matrix_8h_source.html#l01567">1567</a> of file <a class="el" href="constraint__matrix_8h_source.html">constraint_matrix.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3206ee452631ab10fd028b24c26aa550"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print the constraint lines. Mainly for debugging purposes.</p>
<p>This function writes out all entries in the constraint matrix lines with their value in the form <code>row col : value</code>. Unconstrained lines containing only one identity entry are not stored in this object and are not printed. </p>

</div>
</div>
<a class="anchor" id="a614435ed3d892aa3ac599feda8db6c25"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::write_dot </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write the graph of constraints in 'dot' format. 'dot' is a program that can take a list of nodes and produce a graphical representation of the graph of constrained degrees of freedom and the degrees of freedom they are constrained to.</p>
<p>The output of this function can be used as input to the 'dot' program that can convert the graph into a graphical representation in postscript, png, xfig, and a number of other formats.</p>
<p>This function exists mostly for debugging purposes. </p>

</div>
</div>
<a class="anchor" id="ab70d342fa999cccd064567b98100ceaa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t ConstraintMatrix::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine an estimate for the memory consumption (in bytes) of this object. </p>

</div>
</div>
<a class="anchor" id="a04812585b8ebd156ea680aacc32f5d98"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::resolve_indices </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add the constraint indices associated to the indices in the given vector. After a call to this function, the indices vector contains the initial elements and all the associated constrained indices. This function sorts the elements and suppresses duplicates. </p>

</div>
</div>
<a class="anchor" id="a66337316e8fbbc786c9f0383d085ab01"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::condense </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>uncondensed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>condensed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Condense a given sparsity pattern. This function assumes the uncondensed matrix struct to be compressed and the one to be filled to be empty. The condensed structure is compressed afterwards.</p>
<p>The constraint matrix object must be closed to call this function.</p>
<dl class="section note"><dt>Note</dt><dd>The hanging nodes are completely eliminated from the linear system referring to <code>condensed</code>. Therefore, the dimension of <code>condensed</code> is the dimension of <code>uncondensed</code> minus the number of constrained degrees of freedom. </dd></dl>

</div>
</div>
<a class="anchor" id="a4c543aa9c09a2eeb1f6c89fcd6e67f0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::condense </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>sparsity</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function does much the same as the above one, except that it condenses the matrix struct 'in-place'. It does not remove nonzero entries from the matrix but adds those needed for the process of distribution of the constrained degrees of freedom.</p>
<p>Since this function adds new nonzero entries to the sparsity pattern, the argument must not be compressed. However the constraint matrix must be closed. The matrix struct is compressed at the end of the function. </p>

</div>
</div>
<a class="anchor" id="a89592e12d5b3fd3f49d334abd2aec7e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::condense </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBlockSparsityPattern.html">BlockSparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>sparsity</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same function as above, but condenses square block sparsity patterns. </p>

</div>
</div>
<a class="anchor" id="a5045dd1c16712362047a09f8a7fdab57"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::condense </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCompressedSparsityPattern.html">CompressedSparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>sparsity</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same function as above, but condenses square compressed sparsity patterns.</p>
<p>Given the data structure used by <a class="el" href="classCompressedSparsityPattern.html">CompressedSparsityPattern</a>, this function becomes quadratic in the number of degrees of freedom for large problems and can dominate setting up linear systems when several hundred thousand or millions of unknowns are involved and for problems with many nonzero elements per row (for example for vector-valued problems or hp finite elements). In this case, it is advisable to use the <a class="el" href="classCompressedSetSparsityPattern.html">CompressedSetSparsityPattern</a> class instead, see for example <a class="el" href="step_27.html">step-27</a>, or to use the <a class="el" href="classCompressedSimpleSparsityPattern.html">CompressedSimpleSparsityPattern</a> class, see for example <a class="el" href="step_31.html">step-31</a>. </p>

</div>
</div>
<a class="anchor" id="a251937c07785568939cd594f70927a54"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::condense </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCompressedSetSparsityPattern.html">CompressedSetSparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>sparsity</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same function as above, but condenses compressed sparsity patterns, which are based on the std::set container. </p>

</div>
</div>
<a class="anchor" id="a02bd8832964dab7141ba308b4807013b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::condense </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCompressedSimpleSparsityPattern.html">CompressedSimpleSparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>sparsity</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same function as above, but condenses compressed sparsity patterns, which are based on the ''simple'' aproach. </p>

</div>
</div>
<a class="anchor" id="a9358dc591e0e20d9c436ff681ded0f81"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::condense </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBlockCompressedSparsityPattern.html">BlockCompressedSparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>sparsity</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same function as above, but condenses square compressed sparsity patterns.</p>
<p>Given the data structure used by <a class="el" href="classBlockCompressedSparsityPattern.html">BlockCompressedSparsityPattern</a>, this function becomes quadratic in the number of degrees of freedom for large problems and can dominate setting up linear systems when several hundred thousand or millions of unknowns are involved and for problems with many nonzero elements per row (for example for vector-valued problems or hp finite elements). In this case, it is advisable to use the <a class="el" href="classBlockCompressedSetSparsityPattern.html">BlockCompressedSetSparsityPattern</a> class instead, see for example <a class="el" href="step_27.html">step-27</a> and <a class="el" href="step_31.html">step-31</a>. </p>

</div>
</div>
<a class="anchor" id="a6c9a7553ea7692b9cca16261f101a817"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::condense </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBlockCompressedSetSparsityPattern.html">BlockCompressedSetSparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>sparsity</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same function as above, but condenses square compressed sparsity patterns. </p>

</div>
</div>
<a class="anchor" id="a367e25c757851dd2bb841045c6b017f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::condense </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBlockCompressedSimpleSparsityPattern.html">BlockCompressedSimpleSparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>sparsity</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same function as above, but condenses square compressed sparsity patterns. </p>

</div>
</div>
<a class="anchor" id="a03eb1cae2b287fd730ade4b03435cf5b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::condense </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>uncondensed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>condensed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Condense a given matrix. The associated matrix struct should be condensed and compressed. It is the user's responsibility to guarantee that all entries in the <code>condensed</code> matrix be zero!</p>
<p>The constraint matrix object must be closed to call this function.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000081">Deprecated:</a></b></dt><dd>The functions converting an uncondensed matrix into its condensed form are deprecated. Use the functions doing the in-place condensation leaving the size of the linear system unchanged. </dd></dl>

</div>
</div>
<a class="anchor" id="acbed1c1ffab4cccd72f29d9e32434d8b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::condense </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function does much the same as the above one, except that it condenses the matrix 'in-place'. See the general documentation of this class for more detailed information. </p>

<p>Definition at line <a class="el" href="constraint__matrix_8templates_8h_source.html#l00056">56</a> of file <a class="el" href="constraint__matrix_8templates_8h_source.html">constraint_matrix.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4f2277dc3def8132b5fa14d7424020fc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::condense </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same function as above, but condenses square block sparse matrices. </p>

<p>Definition at line <a class="el" href="constraint__matrix_8templates_8h_source.html#l00066">66</a> of file <a class="el" href="constraint__matrix_8templates_8h_source.html">constraint_matrix.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8185bee0894c938b9511c669f42b9291"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::condense </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>uncondensed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>condensed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Condense the given vector <code>uncondensed</code> into <code>condensed</code>. It is the user's responsibility to guarantee that all entries of <code>condensed</code> be zero. Note that this function does not take any inhomogeneity into account and throws an exception in case there are any inhomogeneities. Use the function using both a matrix and vector for that case.</p>
<p>The <code>VectorType</code> may be a Vector&lt;float&gt;, <a class="el" href="classVector.html">Vector&lt;double&gt;</a>, <a class="el" href="classBlockVector.html">BlockVector</a><code>&lt;...&gt;</code>, a PETSc or Trilinos vector wrapper class, or any other type having the same interface.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000082">Deprecated:</a></b></dt><dd>The functions converting an uncondensed matrix into its condensed form are deprecated. Use the functions doing the in-place condensation leaving the size of the linear system unchanged. </dd></dl>

<p>Definition at line <a class="el" href="constraint__matrix_8templates_8h_source.html#l00076">76</a> of file <a class="el" href="constraint__matrix_8templates_8h_source.html">constraint_matrix.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="acabb2a68508f976262ea6286f655de71"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::condense </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Condense the given vector in-place. The <code>VectorType</code> may be a Vector&lt;float&gt;, <a class="el" href="classVector.html">Vector&lt;double&gt;</a>, <a class="el" href="classBlockVector.html">BlockVector</a><code>&lt;...&gt;</code>, a PETSc or Trilinos vector wrapper class, or any other type having the same interface. Note that this function does not take any inhomogeneity into account and throws an exception in case there are any inhomogeneities. Use the function using both a matrix and vector for that case. </p>

<p>Definition at line <a class="el" href="constraint__matrix_8templates_8h_source.html#l00149">149</a> of file <a class="el" href="constraint__matrix_8templates_8h_source.html">constraint_matrix.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3da0b58d91a1806351fa4ab83d0c52de"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number , class VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::condense </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>uncondensed_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>uncondensed_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>condensed_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>condensed_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Condense a given matrix and a given vector. The associated matrix struct should be condensed and compressed. It is the user's responsibility to guarantee that all entries in the <code>condensed</code> matrix and vector be zero! This function is the appropriate choice for applying inhomogeneous constraints.</p>
<p>The constraint matrix object must be closed to call this function.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000083">Deprecated:</a></b></dt><dd>The functions converting an uncondensed matrix into its condensed form are deprecated. Use the functions doing the in-place condensation leaving the size of the linear system unchanged. </dd></dl>

<p>Definition at line <a class="el" href="constraint__matrix_8templates_8h_source.html#l00193">193</a> of file <a class="el" href="constraint__matrix_8templates_8h_source.html">constraint_matrix.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4eb1a5d5d17e58f9c9cdc6eb551e075a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number , class VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::condense </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function does much the same as the above one, except that it condenses matrix and vector 'in-place'. See the general documentation of this class for more detailed information. </p>

<p>Definition at line <a class="el" href="constraint__matrix_8templates_8h_source.html#l00365">365</a> of file <a class="el" href="constraint__matrix_8templates_8h_source.html">constraint_matrix.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6e138156c4216abed3277232b86ebcb8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number , class BlockVectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::condense </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BlockVectorType &amp;&#160;</td>
          <td class="paramname"><em>vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same function as above, but condenses square block sparse matrices and vectors. </p>

<p>Definition at line <a class="el" href="constraint__matrix_8templates_8h_source.html#l00530">530</a> of file <a class="el" href="constraint__matrix_8templates_8h_source.html">constraint_matrix.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0a3e683ed07b7811be4522fc187d811e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::set_zero </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the values of all constrained DoFs in a vector to zero. The <code>VectorType</code> may be a Vector&lt;float&gt;, <a class="el" href="classVector.html">Vector&lt;double&gt;</a>, <a class="el" href="classBlockVector.html">BlockVector</a><code>&lt;...&gt;</code>, a PETSc or Trilinos vector wrapper class, or any other type having the same interface. </p>

<p>Definition at line <a class="el" href="constraint__matrix_8templates_8h_source.html#l00836">836</a> of file <a class="el" href="constraint__matrix_8templates_8h_source.html">constraint_matrix.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa9f3612a8fc51eafa34252bb436e8ae4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InVector , class OutVector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::distribute_local_to_global </td>
          <td>(</td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>local_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>global_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function takes a vector of local contributions (<code>local_vector</code>) corresponding to the degrees of freedom indices given in <code>local_dof_indices</code> and distributes them to the global vector. In most cases, these local contributions will be the result of an integration over a cell or face of a cell. However, as long as <code>local_vector</code> and <code>local_dof_indices</code> have the same number of elements, this function is happy with whatever it is given.</p>
<p>In contrast to the similar function in the <a class="el" href="classDoFAccessor.html">DoFAccessor</a> class, this function also takes care of constraints, i.e. if one of the elements of <code>local_dof_indices</code> belongs to a constrained node, then rather than writing the corresponding element of <code>local_vector</code> into <code>global_vector</code>, the element is distributed to the entries in the global vector to which this particular degree of freedom is constrained.</p>
<p>Thus, by using this function to distribute local contributions to the global object, one saves the call to the condense function after the vectors and matrices are fully assembled. On the other hand, by consequence, the function does not only write into the entries enumerated by the <code>local_dof_indices</code> array, but also (possibly) others as necessary.</p>
<p>Note that this function will apply all constraints as if they were homogeneous. For correctly setting inhomogeneous constraints, use the similar function with a matrix argument or the function with both matrix and vector arguments.</p>
<dl class="section note"><dt>Note</dt><dd>This function in itself is thread-safe, i.e., it works properly also when several threads call it simultaneously. However, the function call is only thread-safe if the underlying global vector allows for simultaneous access and the access is not to rows with the same global index at the same time. This needs to be made sure from the caller's site. There is no locking mechanism inside this method to prevent data races. </dd></dl>

<p>Definition at line <a class="el" href="constraint__matrix_8h_source.html#l01665">1665</a> of file <a class="el" href="constraint__matrix_8h_source.html">constraint_matrix.h</a>.</p>

</div>
</div>
<a class="anchor" id="a65c9b3a10880e101757d0b4ffabbd38c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::distribute_local_to_global </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>global_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function takes a vector of local contributions (<code>local_vector</code>) corresponding to the degrees of freedom indices given in <code>local_dof_indices</code> and distributes them to the global vector. In most cases, these local contributions will be the result of an integration over a cell or face of a cell. However, as long as <code>local_vector</code> and <code>local_dof_indices</code> have the same number of elements, this function is happy with whatever it is given.</p>
<p>In contrast to the similar function in the <a class="el" href="classDoFAccessor.html">DoFAccessor</a> class, this function also takes care of constraints, i.e. if one of the elements of <code>local_dof_indices</code> belongs to a constrained node, then rather than writing the corresponding element of <code>local_vector</code> into <code>global_vector</code>, the element is distributed to the entries in the global vector to which this particular degree of freedom is constrained.</p>
<p>Thus, by using this function to distribute local contributions to the global object, one saves the call to the condense function after the vectors and matrices are fully assembled. On the other hand, by consequence, the function does not only write into the entries enumerated by the <code>local_dof_indices</code> array, but also (possibly) others as necessary. This includes writing into diagonal elements of the matrix if the corresponding degree of freedom is constrained.</p>
<p>The fourth argument <code>local_matrix</code> is intended to be used in case one wants to apply inhomogeneous constraints on the vector only. Such a situation could be where one wants to assemble of a right hand side vector on a problem with inhomogeneous constraints, but the global matrix has been assembled previously. A typical example of this is a time stepping algorithm where the stiffness matrix is assembled once, and the right hand side updated every time step. Note that, however, the entries in the columns of the local matrix have to be exactly the same as those that have been written into the global matrix. Otherwise, this function will not be able to correctly handle inhomogeneities.</p>
<dl class="section note"><dt>Note</dt><dd>This function in itself is thread-safe, i.e., it works properly also when several threads call it simultaneously. However, the function call is only thread-safe if the underlying global vector allows for simultaneous access and the access is not to rows with the same global index at the same time. This needs to be made sure from the caller's site. There is no locking mechanism inside this method to prevent data races. </dd></dl>

<p>Definition at line <a class="el" href="constraint__matrix_8templates_8h_source.html#l00852">852</a> of file <a class="el" href="constraint__matrix_8templates_8h_source.html">constraint_matrix.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab6b9fca14b899361ed2862574a099a6d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::distribute_local_to_global </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>global_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Enter a single value into a result vector, obeying constraints. </p>

<p>Definition at line <a class="el" href="constraint__matrix_8h_source.html#l01615">1615</a> of file <a class="el" href="constraint__matrix_8h_source.html">constraint_matrix.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1032d59cc816d071812febd5fd3c1fd5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIteratorVec , typename ForwardIteratorInd , class VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::distribute_local_to_global </td>
          <td>(</td>
          <td class="paramtype">ForwardIteratorVec&#160;</td>
          <td class="paramname"><em>local_vector_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIteratorVec&#160;</td>
          <td class="paramname"><em>local_vector_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIteratorInd&#160;</td>
          <td class="paramname"><em>local_indices_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>global_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function takes a pointer to a vector of local contributions (<code>local_vector</code>) corresponding to the degrees of freedom indices given in <code>local_dof_indices</code> and distributes them to the global vector. In most cases, these local contributions will be the result of an integration over a cell or face of a cell. However, as long as the entries in <code>local_dof_indices</code> indicate reasonable global vector entries, this function is happy with whatever it is given.</p>
<p>If one of the elements of <code>local_dof_indices</code> belongs to a constrained node, then rather than writing the corresponding element of <code>local_vector</code> into <code>global_vector</code>, the element is distributed to the entries in the global vector to which this particular degree of freedom is constrained.</p>
<p>Thus, by using this function to distribute local contributions to the global object, one saves the call to the condense function after the vectors and matrices are fully assembled. Note that this function completely ignores inhomogeneous constraints.</p>
<dl class="section note"><dt>Note</dt><dd>This function in itself is thread-safe, i.e., it works properly also when several threads call it simultaneously. However, the function call is only thread-safe if the underlying global vector allows for simultaneous access and the access is not to rows with the same global index at the same time. This needs to be made sure from the caller's site. There is no locking mechanism inside this method to prevent data races. </dd></dl>

<p>Definition at line <a class="el" href="constraint__matrix_8h_source.html#l01638">1638</a> of file <a class="el" href="constraint__matrix_8h_source.html">constraint_matrix.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0edca3cf6c2c649850b590bc62452c45"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::distribute_local_to_global </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>global_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function takes a matrix of local contributions (<code>local_matrix</code>) corresponding to the degrees of freedom indices given in <code>local_dof_indices</code> and distributes them to the global matrix. In most cases, these local contributions will be the result of an integration over a cell or face of a cell. However, as long as <code>local_matrix</code> and <code>local_dof_indices</code> have the same number of elements, this function is happy with whatever it is given.</p>
<p>In contrast to the similar function in the <a class="el" href="classDoFAccessor.html">DoFAccessor</a> class, this function also takes care of constraints, i.e. if one of the elements of <code>local_dof_indices</code> belongs to a constrained node, then rather than writing the corresponding element of <code>local_matrix</code> into <code>global_matrix</code>, the element is distributed to the entries in the global matrix to which this particular degree of freedom is constrained.</p>
<p>With this scheme, we never write into rows or columns of constrained degrees of freedom. In order to make sure that the resulting matrix can still be inverted, we need to do something with the diagonal elements corresponding to constrained nodes. Thus, if a degree of freedom in <code>local_dof_indices</code> is constrained, we distribute the corresponding entries in the matrix, but also add the absolute value of the diagonal entry of the local matrix to the corresponding entry in the global matrix. Since the exact value of the diagonal element is not important (the value of the respective degree of freedom will be overwritten by the <a class="el" href="classConstraintMatrix.html#a7cf6b84c47aa32408f412ae769085bd6">distribute()</a> call later on anyway), this guarantees that the diagonal entry is always non-zero, positive, and of the same order of magnitude as the other entries of the matrix.</p>
<p>Thus, by using this function to distribute local contributions to the global object, one saves the call to the condense function after the vectors and matrices are fully assembled.</p>
<dl class="section note"><dt>Note</dt><dd>This function in itself is thread-safe, i.e., it works properly also when several threads call it simultaneously. However, the function call is only thread-safe if the underlying global matrix allows for simultaneous access and the access is not to rows with the same global index at the same time. This needs to be made sure from the caller's site. There is no locking mechanism inside this method to prevent data races. </dd></dl>

<p>Definition at line <a class="el" href="constraint__matrix_8h_source.html#l01711">1711</a> of file <a class="el" href="constraint__matrix_8h_source.html">constraint_matrix.h</a>.</p>

</div>
</div>
<a class="anchor" id="a67f9bee1c3e3b1c7a49ddf113385bf6c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::distribute_local_to_global </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>global_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Does the same as the function above but can treat non quadratic matrices. </p>

<p>Definition at line <a class="el" href="constraint__matrix_8templates_8h_source.html#l02589">2589</a> of file <a class="el" href="constraint__matrix_8templates_8h_source.html">constraint_matrix.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a355fc5c0b4d237f1ae335f82c8de1332"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , typename VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::distribute_local_to_global </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>global_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>global_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>use_inhomogeneities_for_rhs</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function simultaneously writes elements into matrix and vector, according to the constraints specified by the calling <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a>. This function can correctly handle inhomogeneous constraints as well. For the parameter use_inhomogeneities_for_rhs see the documentation in <a class="el" href="group__constraints.html">Constraints on degrees of freedom</a> module.</p>
<dl class="section note"><dt>Note</dt><dd>This function in itself is thread-safe, i.e., it works properly also when several threads call it simultaneously. However, the function call is only thread-safe if the underlying global matrix and vector allow for simultaneous access and the access is not to rows with the same global index at the same time. This needs to be made sure from the caller's site. There is no locking mechanism inside this method to prevent data races. </dd></dl>

<p>Definition at line <a class="el" href="constraint__matrix_8h_source.html#l01729">1729</a> of file <a class="el" href="constraint__matrix_8h_source.html">constraint_matrix.h</a>.</p>

</div>
</div>
<a class="anchor" id="a646ac6aabbc957e439971b8a14d0add8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparsityType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::add_entries_local_to_global </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SparsityType &amp;&#160;</td>
          <td class="paramname"><em>sparsity_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>keep_constrained_entries</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_mask</em> = <code><a class="el" href="classConstraintMatrix.html#a8d93601283d9e32df2192c3ca362ebf5">default_empty_table</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Do a similar operation as the <a class="el" href="classConstraintMatrix.html#aa9f3612a8fc51eafa34252bb436e8ae4">distribute_local_to_global()</a> function that distributes writing entries into a matrix for constrained degrees of freedom, except that here we don't write into a matrix but only allocate sparsity pattern entries.</p>
<p>As explained in the <a class="el" href="DEALGlossary.html#hp_paper">hp paper</a> and in <a class="el" href="step_27.html">step-27</a>, first allocating a sparsity pattern and later coming back and allocating additional entries for those matrix entries that will be written to due to the elimination of constrained degrees of freedom (using <a class="el" href="classConstraintMatrix.html#a66337316e8fbbc786c9f0383d085ab01">ConstraintMatrix::condense()</a> ), can be a very expensive procedure. It is cheaper to allocate these entries right away without having to do a second pass over the sparsity pattern object. This function does exactly that.</p>
<p>Because the function only allocates entries in a sparsity pattern, all it needs to know are the degrees of freedom that couple to each other. Unlike the previous function, no actual values are written, so the second input argument is not necessary here.</p>
<p>The third argument to this function, keep_constrained_entries determines whether the function shall allocate entries in the sparsity pattern at all for entries that will later be set to zero upon condensation of the matrix. These entries are necessary if the matrix is built unconstrained, and only later condensed. They are not necessary if the matrix is built using the <a class="el" href="classConstraintMatrix.html#aa9f3612a8fc51eafa34252bb436e8ae4">distribute_local_to_global()</a> function of this class which distributes entries right away when copying a local matrix into a global object. The default of this argument is true, meaning to allocate the few entries that may later be set to zero.</p>
<p>By default, the function adds entries for all pairs of indices given in the first argument to the sparsity pattern (unless keep_constrained_entries is false). However, sometimes one would like to only add a subset of all of these pairs. In that case, the last argument can be used which specifies a boolean mask which of the pairs of indices should be considered. If the mask is false for a pair of indices, then no entry will be added to the sparsity pattern for this pair, irrespective of whether one or both of the indices correspond to constrained degrees of freedom.</p>
<p>This function is not typically called from user code, but is used in the <a class="el" href="group__constraints.html#gab627b1d4845c9526521dbd1be83469dc">DoFTools::make_sparsity_pattern()</a> function when passed a constraint matrix object.</p>
<dl class="section note"><dt>Note</dt><dd>This function in itself is thread-safe, i.e., it works properly also when several threads call it simultaneously. However, the function call is only thread-safe if the underlying global sparsity pattern allows for simultaneous access and the access is not to rows with the same global index at the same time. This needs to be made sure from the caller's site. There is no locking mechanism inside this method to prevent data races. </dd></dl>

<p>Definition at line <a class="el" href="constraint__matrix_8h_source.html#l01749">1749</a> of file <a class="el" href="constraint__matrix_8h_source.html">constraint_matrix.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8560e315f45648df1a6c1d2b093e68d3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparsityType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::add_entries_local_to_global </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SparsityType &amp;&#160;</td>
          <td class="paramname"><em>sparsity_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>keep_constrained_entries</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_mask</em> = <code><a class="el" href="classConstraintMatrix.html#a8d93601283d9e32df2192c3ca362ebf5">default_empty_table</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Similar to the other function, but for non-quadratic sparsity patterns. </p>

<p>Definition at line <a class="el" href="constraint__matrix_8templates_8h_source.html#l02860">2860</a> of file <a class="el" href="constraint__matrix_8templates_8h_source.html">constraint_matrix.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0e087ffed00c38027211757dffd8ea9b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIteratorVec , typename ForwardIteratorInd , class VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::get_dof_values </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>global_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIteratorInd&#160;</td>
          <td class="paramname"><em>local_indices_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIteratorVec&#160;</td>
          <td class="paramname"><em>local_vector_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIteratorVec&#160;</td>
          <td class="paramname"><em>local_vector_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function imports values from a global vector (<code>global_vector</code>) by applying the constraints to a vector of local values, expressed in iterator format. In most cases, the local values will be identified by the local dof values on a cell. However, as long as the entries in <code>local_dof_indices</code> indicate reasonable global vector entries, this function is happy with whatever it is given.</p>
<p>If one of the elements of <code>local_dof_indices</code> belongs to a constrained node, then rather than writing the corresponding element of <code>global_vector</code> into <code>local_vector</code>, the constraints are resolved as the respective distribute function does, i.e., the local entry is constructed from the global entries to which this particular degree of freedom is constrained.</p>
<p>In contrast to the similar function get_dof_values in the <a class="el" href="classDoFAccessor.html">DoFAccessor</a> class, this function does not need the constrained values to be correctly set (i.e., distribute to be called). </p>

<p>Definition at line <a class="el" href="constraint__matrix_8h_source.html#l01681">1681</a> of file <a class="el" href="constraint__matrix_8h_source.html">constraint_matrix.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7cf6b84c47aa32408f412ae769085bd6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::distribute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>condensed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>uncondensed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Re-distribute the elements of the vector <code>condensed</code> to <code>uncondensed</code>. It is the user's responsibility to guarantee that all entries of <code>uncondensed</code> be zero!</p>
<p>This function undoes the action of <code>condense</code> somehow, but it should be noted that it is not the inverse of <code>condense</code>.</p>
<p>The <code>VectorType</code> may be a Vector&lt;float&gt;, <a class="el" href="classVector.html">Vector&lt;double&gt;</a>, <a class="el" href="classBlockVector.html">BlockVector</a><code>&lt;...&gt;</code>, a PETSc or Trilinos vector wrapper class, or any other type having the same interface. </p>

<p>Definition at line <a class="el" href="constraint__matrix_8templates_8h_source.html#l00931">931</a> of file <a class="el" href="constraint__matrix_8templates_8h_source.html">constraint_matrix.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1676b89d3936a007bb48a9d5210e6f07"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::distribute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Re-distribute the elements of the vector in-place. The <code>VectorType</code> may be a Vector&lt;float&gt;, <a class="el" href="classVector.html">Vector&lt;double&gt;</a>, <a class="el" href="classBlockVector.html">BlockVector</a><code>&lt;...&gt;</code>, a PETSc or Trilinos vector wrapper class, or any other type having the same interface.</p>
<p>Note that if called with a <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> it may not contain ghost elements. </p>

<p>Definition at line <a class="el" href="constraint__matrix_8templates_8h_source.html#l01108">1108</a> of file <a class="el" href="constraint__matrix_8templates_8h_source.html">constraint_matrix.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4cee40b1b2797c8c42cc7b5a0c707517"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> ConstraintMatrix::calculate_line_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a>&#160;</td>
          <td class="paramname"><em>line</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Internal function to calculate the index of line <code>line</code> in the vector lines_cache using local_lines. </p>

<p>Definition at line <a class="el" href="constraint__matrix_8h_source.html#l01582">1582</a> of file <a class="el" href="constraint__matrix_8h_source.html">constraint_matrix.h</a>.</p>

</div>
</div>
<a class="anchor" id="a454dc961e571b2890a0046051ae32248"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbool.html">bool</a> ConstraintMatrix::check_zero_weight </td>
          <td>(</td>
          <td class="paramtype">const std::pair&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a>, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return <code>true</code> if the weight of an entry (the second element of the pair) equals zero. This function is used to delete entries with zero weight. </p>

</div>
</div>
<a class="anchor" id="a9ee730e1973c0676bfc174a3d12d9248"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , typename VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::distribute_local_to_global </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>global_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>global_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>use_inhomogeneities_for_rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinternal_1_1bool2type.html">internal::bool2type</a>&lt; false &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function actually implements the local_to_global function for standard (non-block) matrices. </p>

<p>Definition at line <a class="el" href="constraint__matrix_8templates_8h_source.html#l02482">2482</a> of file <a class="el" href="constraint__matrix_8templates_8h_source.html">constraint_matrix.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="af173ddd46331a28bb82d21d522b04d61"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , typename VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::distribute_local_to_global </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>global_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>global_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>use_inhomogeneities_for_rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinternal_1_1bool2type.html">internal::bool2type</a>&lt; true &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function actually implements the local_to_global function for block matrices. </p>

<p>Definition at line <a class="el" href="constraint__matrix_8templates_8h_source.html#l02646">2646</a> of file <a class="el" href="constraint__matrix_8templates_8h_source.html">constraint_matrix.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="ace822e43c8e8167af16d946d7b0cab64"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparsityType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::add_entries_local_to_global </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SparsityType &amp;&#160;</td>
          <td class="paramname"><em>sparsity_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>keep_constrained_entries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinternal_1_1bool2type.html">internal::bool2type</a>&lt; false &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function actually implements the local_to_global function for standard (non-block) sparsity types. </p>

<p>Definition at line <a class="el" href="constraint__matrix_8templates_8h_source.html#l02766">2766</a> of file <a class="el" href="constraint__matrix_8templates_8h_source.html">constraint_matrix.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0bf32d1ffa681bc4072aa34875d37894"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparsityType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::add_entries_local_to_global </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SparsityType &amp;&#160;</td>
          <td class="paramname"><em>sparsity_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>keep_constrained_entries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinternal_1_1bool2type.html">internal::bool2type</a>&lt; true &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function actually implements the local_to_global function for block sparsity types. </p>

<p>Definition at line <a class="el" href="constraint__matrix_8templates_8h_source.html#l02919">2919</a> of file <a class="el" href="constraint__matrix_8templates_8h_source.html">constraint_matrix.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="abd032ea43b4ddd6eae2d2ed3b0d45ffd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::make_sorted_row_list </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classinternals_1_1GlobalRowsFromLocal.html">internals::GlobalRowsFromLocal</a> &amp;&#160;</td>
          <td class="paramname"><em>global_rows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Internal helper function for distribute_local_to_global function.</p>
<p>Creates a list of affected global rows for distribution, including the local rows where the entries come from. The list is sorted according to the global row indices. </p>

<p>Definition at line <a class="el" href="constraint__matrix_8templates_8h_source.html#l02320">2320</a> of file <a class="el" href="constraint__matrix_8templates_8h_source.html">constraint_matrix.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a21f5134bab744c1ec293eb83d1d0664e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::make_sorted_row_list </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>active_dofs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Internal helper function for add_entries_local_to_global function.</p>
<p>Creates a list of affected rows for distribution without any additional information, otherwise similar to the other <a class="el" href="classConstraintMatrix.html#abd032ea43b4ddd6eae2d2ed3b0d45ffd">make_sorted_row_list()</a> function. </p>

<p>Definition at line <a class="el" href="constraint__matrix_8templates_8h_source.html#l02385">2385</a> of file <a class="el" href="constraint__matrix_8templates_8h_source.html">constraint_matrix.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a957d1a559a898d9f06ce3ee8eedbb04f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> ConstraintMatrix::resolve_vector_entry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classinternals_1_1GlobalRowsFromLocal.html">internals::GlobalRowsFromLocal</a> &amp;&#160;</td>
          <td class="paramname"><em>global_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Internal helper function for distribute_local_to_global function. </p>

<p>Definition at line <a class="el" href="constraint__matrix_8templates_8h_source.html#l02439">2439</a> of file <a class="el" href="constraint__matrix_8templates_8h_source.html">constraint_matrix.templates.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a0f3b653958a9f500be62c61791e42dd0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structConstraintMatrix_1_1ConstraintLine.html">ConstraintLine</a>&gt; ConstraintMatrix::lines</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Store the lines of the matrix. Entries are usually appended in an arbitrary order and insertion into a vector is done best at the end, so the order is unspecified after all entries are inserted. Sorting of the entries takes place when calling the <code><a class="el" href="classConstraintMatrix.html#a8056d07faa2a7ed3f158c1b42d56abc8">close()</a></code> function.</p>
<p>We could, instead of using a vector, use an associative array, like a map to store the lines. This, however, would mean a much more fractioned heap since it allocates many small objects, and would additionally make usage of this matrix much slower. </p>

<p>Definition at line <a class="el" href="constraint__matrix_8h_source.html#l01245">1245</a> of file <a class="el" href="constraint__matrix_8h_source.html">constraint_matrix.h</a>.</p>

</div>
</div>
<a class="anchor" id="a25db0740488705b778ab6eedeec9c1fb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a>&gt; ConstraintMatrix::lines_cache</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A list of size_type that contains the position of the <a class="el" href="structConstraintMatrix_1_1ConstraintLine.html">ConstraintLine</a> of a constrained degree of freedom, or <a class="el" href="namespacenumbers.html#aed814969c852ea1a9aa050cf02b73b80">numbers::invalid_size_type</a> if the degree of freedom is not constrained. The <a class="el" href="namespacenumbers.html#aed814969c852ea1a9aa050cf02b73b80">numbers::invalid_size_type</a> return value returns thus whether there is a constraint line for a given degree of freedom index. Note that this class has no notion of how many degrees of freedom there really are, so if we check whether there is a constraint line for a given degree of freedom, then this vector may actually be shorter than the index of the DoF we check for.</p>
<p>This field exists since when adding a new constraint line we have to figure out whether it already exists. Previously, we would simply walk the unsorted list of constraint lines until we either hit the end or found it. This algorithm is O(N) if N is the number of constraints, which makes it O(N^2) when inserting all constraints. For large problems with many constraints, this could easily take 5-10 per cent of the total run time. With this field, we can save this time since we find any constraint in O(1) time or get to know that it a certain degree of freedom is not constrained.</p>
<p>To make things worse, traversing the list of existing constraints requires reads from many different places in memory. Thus, in large 3d applications, the <a class="el" href="classConstraintMatrix.html#a24eb022f65797389badbb6d21da5b708">add_line()</a> function showed up very prominently in the overall compute time, mainly because it generated a lot of cache misses. This should also be fixed by using the O(1) algorithm to access the fields of this array.</p>
<p>The field is useful in a number of other contexts as well, e.g. when one needs random access to the constraints as in all the functions that apply constraints on the fly while add cell contributions into vectors and matrices. </p>

<p>Definition at line <a class="el" href="constraint__matrix_8h_source.html#l01279">1279</a> of file <a class="el" href="constraint__matrix_8h_source.html">constraint_matrix.h</a>.</p>

</div>
</div>
<a class="anchor" id="a58dd31bd6fceeb6b67fe54017e0750b5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexSet.html">IndexSet</a> ConstraintMatrix::local_lines</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This <a class="el" href="classIndexSet.html">IndexSet</a> is used to limit the lines to save in the <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> to a subset. This is necessary, because the lines_cache vector would become too big in a distributed calculation. </p>

<p>Definition at line <a class="el" href="constraint__matrix_8h_source.html#l01286">1286</a> of file <a class="el" href="constraint__matrix_8h_source.html">constraint_matrix.h</a>.</p>

</div>
</div>
<a class="anchor" id="ada29d922494c2b645e418cc311ec872d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ConstraintMatrix::sorted</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Store whether the arrays are sorted. If so, no new entries can be added. </p>

<p>Definition at line <a class="el" href="constraint__matrix_8h_source.html#l01291">1291</a> of file <a class="el" href="constraint__matrix_8h_source.html">constraint_matrix.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8d93601283d9e32df2192c3ca362ebf5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTable.html">Table</a>&lt;2,<a class="el" href="classbool.html">bool</a>&gt; ConstraintMatrix::default_empty_table</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Dummy table that serves as default argument for function <code><a class="el" href="classConstraintMatrix.html#a646ac6aabbc957e439971b8a14d0add8">add_entries_local_to_global()</a></code>. </p>

<p>Definition at line <a class="el" href="constraint__matrix_8h_source.html#l01309">1309</a> of file <a class="el" href="constraint__matrix_8h_source.html">constraint_matrix.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/deal.II/lac/<a class="el" href="constraint__matrix_8h_source.html">constraint_matrix.h</a></li>
<li>include/deal.II/lac/<a class="el" href="constraint__matrix_8templates_8h_source.html">constraint_matrix.templates.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jan 27 2014 15:27:17 for The deal.II Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
