<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>The deal.II Library: TrilinosWrappers::SparsityPattern Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="http://www.dealii.org/deal.ico"></link>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2014 by the deal.II authors"></meta>
<meta name="deal.II-version" content="8.1.0"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 8.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceTrilinosWrappers.html">TrilinosWrappers</a></li><li class="navelem"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html">SparsityPattern</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classTrilinosWrappers_1_1SparsityPattern-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">TrilinosWrappers::SparsityPattern Class Reference<div class="ingroups"><a class="el" href="group__TrilinosWrappers.html">TrilinosWrappers</a> &#124; <a class="el" href="group__Sparsity.html">Sparsity patterns</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="trilinos__sparsity__pattern_8h_source.html">trilinos_sparsity_pattern.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for TrilinosWrappers::SparsityPattern:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classTrilinosWrappers_1_1SparsityPattern__inherit__graph.svg" width="187" height="136"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a542f2dcccaf8d7ae0f54fa9b7a2ce445"><td class="memItemLeft" align="right" valign="top">typedef ::<a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a></td></tr>
<tr class="separator:a542f2dcccaf8d7ae0f54fa9b7a2ce445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb98ca501c1a85dcd1ef7e3800d5a0f5"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="classTrilinosWrappers_1_1SparsityPatternIterators_1_1Iterator.html">SparsityPatternIterators::Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#adb98ca501c1a85dcd1ef7e3800d5a0f5">const_iterator</a></td></tr>
<tr class="separator:adb98ca501c1a85dcd1ef7e3800d5a0f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ga82c2717328fbda71e2a9359917a52e80"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga82c2717328fbda71e2a9359917a52e80">DeclException1</a> (ExcTrilinosError, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;An error with error number &quot;&lt;&lt; arg1&lt;&lt; &quot; occurred while calling a Trilinos function&quot;)</td></tr>
<tr class="separator:ga82c2717328fbda71e2a9359917a52e80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0efe127811d16cf6858a14cda5a2a9dc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga0efe127811d16cf6858a14cda5a2a9dc">DeclException2</a> (ExcInvalidIndex, <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a>, <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a>,&lt;&lt; &quot;The entry with index &lt;&quot;&lt;&lt; arg1&lt;&lt;  ','&lt;&lt; arg2&lt;&lt; &quot;&gt; does not exist.&quot;)</td></tr>
<tr class="separator:ga0efe127811d16cf6858a14cda5a2a9dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0af73c664be44fc029d9d95dc2465020"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga0af73c664be44fc029d9d95dc2465020">DeclException0</a> (ExcSourceEqualsDestination)</td></tr>
<tr class="separator:ga0af73c664be44fc029d9d95dc2465020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66384e4ca94b2cc611ca4cc0350b779d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga66384e4ca94b2cc611ca4cc0350b779d">DeclException4</a> (ExcAccessToNonLocalElement, <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a>, <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a>, <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a>, <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a>,&lt;&lt; &quot;You tried to access element (&quot;&lt;&lt; arg1&lt;&lt; &quot;/&quot;&lt;&lt; arg2&lt;&lt; &quot;)&quot;&lt;&lt; &quot; of a distributed matrix, but only rows &quot;&lt;&lt; arg3&lt;&lt; &quot; through &quot;&lt;&lt; arg4&lt;&lt; &quot; are stored locally and can be accessed.&quot;)</td></tr>
<tr class="separator:ga66384e4ca94b2cc611ca4cc0350b779d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9afbd2c36f9712ec95cb5f3bbfc8857"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf9afbd2c36f9712ec95cb5f3bbfc8857">DeclException2</a> (ExcAccessToNonPresentElement, <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a>, <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a>,&lt;&lt; &quot;You tried to access element (&quot;&lt;&lt; arg1&lt;&lt; &quot;/&quot;&lt;&lt; arg2&lt;&lt; &quot;)&quot;&lt;&lt; &quot; of a sparse matrix, but it appears to not&quot;&lt;&lt; &quot; exist in the Trilinos sparsity pattern.&quot;)</td></tr>
<tr class="separator:gaf9afbd2c36f9712ec95cb5f3bbfc8857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Basic constructors and initalization.</div></td></tr>
<tr class="memitem:a6f9b583b6dd2ed58958ecc54c4344420"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a6f9b583b6dd2ed58958ecc54c4344420">SparsityPattern</a> ()</td></tr>
<tr class="separator:a6f9b583b6dd2ed58958ecc54c4344420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c9f08ac331cd547973e99a8ec3783ad"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a9c9f08ac331cd547973e99a8ec3783ad">SparsityPattern</a> (const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> m, const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> n, const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> n_entries_per_row=0)</td></tr>
<tr class="separator:a9c9f08ac331cd547973e99a8ec3783ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a055d61c918012a7fc026b0aee8aac9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a6a055d61c918012a7fc026b0aee8aac9">SparsityPattern</a> (const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> m, const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> n, const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> &gt; &amp;n_entries_per_row)</td></tr>
<tr class="separator:a6a055d61c918012a7fc026b0aee8aac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9857b8210d194d18541042c864f47ead"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a9857b8210d194d18541042c864f47ead">SparsityPattern</a> (const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html">SparsityPattern</a> &amp;input_sparsity_pattern)</td></tr>
<tr class="separator:a9857b8210d194d18541042c864f47ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d34185dfa0d3cf50f0d9c87100d1bf7"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a4d34185dfa0d3cf50f0d9c87100d1bf7">~SparsityPattern</a> ()</td></tr>
<tr class="separator:a4d34185dfa0d3cf50f0d9c87100d1bf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35df9ba1ea9645293f1df7dd4f952fe8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a35df9ba1ea9645293f1df7dd4f952fe8">reinit</a> (const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> m, const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> n, const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> n_entries_per_row=0)</td></tr>
<tr class="separator:a35df9ba1ea9645293f1df7dd4f952fe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bcbf0cf47ddac3bc4a3ee6e0b22aedd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a2bcbf0cf47ddac3bc4a3ee6e0b22aedd">reinit</a> (const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> m, const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> n, const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> &gt; &amp;n_entries_per_row)</td></tr>
<tr class="separator:a2bcbf0cf47ddac3bc4a3ee6e0b22aedd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a852f4ac014717dda54daca42e8c0309d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a852f4ac014717dda54daca42e8c0309d">copy_from</a> (const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html">SparsityPattern</a> &amp;input_sparsity_pattern)</td></tr>
<tr class="separator:a852f4ac014717dda54daca42e8c0309d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab58dd6c800ca13d3edd161933e75f923"><td class="memTemplParams" colspan="2">template&lt;typename SparsityType &gt; </td></tr>
<tr class="memitem:ab58dd6c800ca13d3edd161933e75f923"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#ab58dd6c800ca13d3edd161933e75f923">copy_from</a> (const SparsityType &amp;nontrilinos_sparsity_pattern)</td></tr>
<tr class="separator:ab58dd6c800ca13d3edd161933e75f923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5070af6229463ec4873a66e69be7c1f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html">SparsityPattern</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a5070af6229463ec4873a66e69be7c1f8">operator=</a> (const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html">SparsityPattern</a> &amp;input_sparsity_pattern)</td></tr>
<tr class="separator:a5070af6229463ec4873a66e69be7c1f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53f5bd094b1fb38b701412759180e2a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a53f5bd094b1fb38b701412759180e2a7">clear</a> ()</td></tr>
<tr class="separator:a53f5bd094b1fb38b701412759180e2a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a497f24cbf7f49e9ab752268bedef05a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a497f24cbf7f49e9ab752268bedef05a2">compress</a> ()</td></tr>
<tr class="separator:a497f24cbf7f49e9ab752268bedef05a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors and initialization using an Epetra_Map description</div></td></tr>
<tr class="memitem:a0b1cf374dc78b70d02ab8fe4b89d4995"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a0b1cf374dc78b70d02ab8fe4b89d4995">SparsityPattern</a> (const Epetra_Map &amp;parallel_partitioning, const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> n_entries_per_row=0)</td></tr>
<tr class="separator:a0b1cf374dc78b70d02ab8fe4b89d4995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af924ee89effc417974c0652e542f049a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#af924ee89effc417974c0652e542f049a">SparsityPattern</a> (const Epetra_Map &amp;parallel_partitioning, const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> &gt; &amp;n_entries_per_row)</td></tr>
<tr class="separator:af924ee89effc417974c0652e542f049a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9434904823485bed58a518992fc49935"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a9434904823485bed58a518992fc49935">SparsityPattern</a> (const Epetra_Map &amp;row_parallel_partitioning, const Epetra_Map &amp;col_parallel_partitioning, const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> n_entries_per_row=0)</td></tr>
<tr class="separator:a9434904823485bed58a518992fc49935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87d1d2faf95dcc105f0210a4a0673be0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a87d1d2faf95dcc105f0210a4a0673be0">SparsityPattern</a> (const Epetra_Map &amp;row_parallel_partitioning, const Epetra_Map &amp;col_parallel_partitioning, const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> &gt; &amp;n_entries_per_row)</td></tr>
<tr class="separator:a87d1d2faf95dcc105f0210a4a0673be0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a891811bd7b9ed083ed33e7ef8d36c069"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a891811bd7b9ed083ed33e7ef8d36c069">reinit</a> (const Epetra_Map &amp;parallel_partitioning, const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> n_entries_per_row=0)</td></tr>
<tr class="separator:a891811bd7b9ed083ed33e7ef8d36c069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55bc5d749841ede277c20dc8991529dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a55bc5d749841ede277c20dc8991529dc">reinit</a> (const Epetra_Map &amp;parallel_partitioning, const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> &gt; &amp;n_entries_per_row)</td></tr>
<tr class="separator:a55bc5d749841ede277c20dc8991529dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ddfe6ccaac1ec5c077e633fc02505be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a2ddfe6ccaac1ec5c077e633fc02505be">reinit</a> (const Epetra_Map &amp;row_parallel_partitioning, const Epetra_Map &amp;col_parallel_partitioning, const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> n_entries_per_row=0)</td></tr>
<tr class="separator:a2ddfe6ccaac1ec5c077e633fc02505be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bc2681538101f9906c53feb7045795c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a8bc2681538101f9906c53feb7045795c">reinit</a> (const Epetra_Map &amp;row_parallel_partitioning, const Epetra_Map &amp;col_parallel_partitioning, const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> &gt; &amp;n_entries_per_row)</td></tr>
<tr class="separator:a8bc2681538101f9906c53feb7045795c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f8d7a9cd270633f987f08031f02c299"><td class="memTemplParams" colspan="2">template&lt;typename SparsityType &gt; </td></tr>
<tr class="memitem:a9f8d7a9cd270633f987f08031f02c299"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a9f8d7a9cd270633f987f08031f02c299">reinit</a> (const Epetra_Map &amp;row_parallel_partitioning, const Epetra_Map &amp;col_parallel_partitioning, const SparsityType &amp;nontrilinos_sparsity_pattern, const <a class="el" href="classbool.html">bool</a> exchange_data=false)</td></tr>
<tr class="separator:a9f8d7a9cd270633f987f08031f02c299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89ff675d743220fc1dc55db34b010764"><td class="memTemplParams" colspan="2">template&lt;typename SparsityType &gt; </td></tr>
<tr class="memitem:a89ff675d743220fc1dc55db34b010764"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a89ff675d743220fc1dc55db34b010764">reinit</a> (const Epetra_Map &amp;parallel_partitioning, const SparsityType &amp;nontrilinos_sparsity_pattern, const <a class="el" href="classbool.html">bool</a> exchange_data=false)</td></tr>
<tr class="separator:a89ff675d743220fc1dc55db34b010764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors and initialization using an IndexSet description</div></td></tr>
<tr class="memitem:a332b7796669a8501613e0dcf09cd7eb2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a332b7796669a8501613e0dcf09cd7eb2">SparsityPattern</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;parallel_partitioning, const MPI_Comm &amp;communicator=MPI_COMM_WORLD, const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> n_entries_per_row=0)</td></tr>
<tr class="separator:a332b7796669a8501613e0dcf09cd7eb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55b0c1296dbc63bdb65038974f40fd08"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a55b0c1296dbc63bdb65038974f40fd08">SparsityPattern</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;parallel_partitioning, const MPI_Comm &amp;communicator, const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> &gt; &amp;n_entries_per_row)</td></tr>
<tr class="separator:a55b0c1296dbc63bdb65038974f40fd08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab342e99825bb5ca20d83f7f4014c5465"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#ab342e99825bb5ca20d83f7f4014c5465">SparsityPattern</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;row_parallel_partitioning, const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;col_parallel_partitioning, const MPI_Comm &amp;communicator=MPI_COMM_WORLD, const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> n_entries_per_row=0)</td></tr>
<tr class="separator:ab342e99825bb5ca20d83f7f4014c5465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a882f09fe514d5c81f1a72ebf38f9023b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a882f09fe514d5c81f1a72ebf38f9023b">SparsityPattern</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;row_parallel_partitioning, const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;col_parallel_partitioning, const MPI_Comm &amp;communicator, const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> &gt; &amp;n_entries_per_row)</td></tr>
<tr class="separator:a882f09fe514d5c81f1a72ebf38f9023b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae49b1221034cfc8563066be053a36f78"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#ae49b1221034cfc8563066be053a36f78">reinit</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;parallel_partitioning, const MPI_Comm &amp;communicator=MPI_COMM_WORLD, const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> n_entries_per_row=0)</td></tr>
<tr class="separator:ae49b1221034cfc8563066be053a36f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46f9b0cb75823908f59dc25204494641"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a46f9b0cb75823908f59dc25204494641">reinit</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;parallel_partitioning, const MPI_Comm &amp;communicator, const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> &gt; &amp;n_entries_per_row)</td></tr>
<tr class="separator:a46f9b0cb75823908f59dc25204494641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32bbc13333cc2977e6370e8cc6917003"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a32bbc13333cc2977e6370e8cc6917003">reinit</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;row_parallel_partitioning, const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;col_parallel_partitioning, const MPI_Comm &amp;communicator=MPI_COMM_WORLD, const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> n_entries_per_row=0)</td></tr>
<tr class="separator:a32bbc13333cc2977e6370e8cc6917003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31d8ab0dbb6508a4482efc6593e7477a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a31d8ab0dbb6508a4482efc6593e7477a">reinit</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;row_parallel_partitioning, const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;col_parallel_partitioning, const MPI_Comm &amp;communicator, const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> &gt; &amp;n_entries_per_row)</td></tr>
<tr class="separator:a31d8ab0dbb6508a4482efc6593e7477a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70de039bb673a33d87515597c0a75e5a"><td class="memTemplParams" colspan="2">template&lt;typename SparsityType &gt; </td></tr>
<tr class="memitem:a70de039bb673a33d87515597c0a75e5a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a70de039bb673a33d87515597c0a75e5a">reinit</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;row_parallel_partitioning, const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;col_parallel_partitioning, const SparsityType &amp;nontrilinos_sparsity_pattern, const MPI_Comm &amp;communicator=MPI_COMM_WORLD, const <a class="el" href="classbool.html">bool</a> exchange_data=false)</td></tr>
<tr class="separator:a70de039bb673a33d87515597c0a75e5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add63d29cd82d0299709b4919856fb8e7"><td class="memTemplParams" colspan="2">template&lt;typename SparsityType &gt; </td></tr>
<tr class="memitem:add63d29cd82d0299709b4919856fb8e7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#add63d29cd82d0299709b4919856fb8e7">reinit</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;parallel_partitioning, const SparsityType &amp;nontrilinos_sparsity_pattern, const MPI_Comm &amp;communicator=MPI_COMM_WORLD, const <a class="el" href="classbool.html">bool</a> exchange_data=false)</td></tr>
<tr class="separator:add63d29cd82d0299709b4919856fb8e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Information on the sparsity pattern</div></td></tr>
<tr class="memitem:a551a8dd4edff03422f4e6d70692000ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a551a8dd4edff03422f4e6d70692000ed">is_compressed</a> () const </td></tr>
<tr class="separator:a551a8dd4edff03422f4e6d70692000ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30a73d895cde35d2685f8055d2963cec"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a30a73d895cde35d2685f8055d2963cec">max_entries_per_row</a> () const </td></tr>
<tr class="separator:a30a73d895cde35d2685f8055d2963cec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe6bb434a032bfea9a983ad0c45ba714"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#abe6bb434a032bfea9a983ad0c45ba714">n_rows</a> () const </td></tr>
<tr class="separator:abe6bb434a032bfea9a983ad0c45ba714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eddd7bc08a03db06bf5ffca090a747b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a1eddd7bc08a03db06bf5ffca090a747b">n_cols</a> () const </td></tr>
<tr class="separator:a1eddd7bc08a03db06bf5ffca090a747b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae16f84f633fbeb077d3a5a5c3ffd78a6"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#ae16f84f633fbeb077d3a5a5c3ffd78a6">local_size</a> () const </td></tr>
<tr class="separator:ae16f84f633fbeb077d3a5a5c3ffd78a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76fe15cc375f8a93e96db09c81f71d1c"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a>, <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a76fe15cc375f8a93e96db09c81f71d1c">local_range</a> () const </td></tr>
<tr class="separator:a76fe15cc375f8a93e96db09c81f71d1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69ddc7d08424178c9dc8b4a5d0efb21b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a69ddc7d08424178c9dc8b4a5d0efb21b">in_local_range</a> (const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> index) const </td></tr>
<tr class="separator:a69ddc7d08424178c9dc8b4a5d0efb21b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb770b36027af2f5a8b07cd038177b22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#acb770b36027af2f5a8b07cd038177b22">n_nonzero_elements</a> () const </td></tr>
<tr class="separator:acb770b36027af2f5a8b07cd038177b22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2f96e3dc7ff5784160fad9477065ef0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#ad2f96e3dc7ff5784160fad9477065ef0">row_length</a> (const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> row) const </td></tr>
<tr class="separator:ad2f96e3dc7ff5784160fad9477065ef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8836761542de689f1f6729462671d6cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a8836761542de689f1f6729462671d6cf">bandwidth</a> () const </td></tr>
<tr class="separator:a8836761542de689f1f6729462671d6cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a01937aab4e8b5de14d013338df9cd9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a2a01937aab4e8b5de14d013338df9cd9">empty</a> () const </td></tr>
<tr class="separator:a2a01937aab4e8b5de14d013338df9cd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dade6bd81cd50b01b7322e88b955d08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a7dade6bd81cd50b01b7322e88b955d08">exists</a> (const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> i, const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> j) const </td></tr>
<tr class="separator:a7dade6bd81cd50b01b7322e88b955d08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dfd4db7ddb59b54c76af50424e29ded"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a5dfd4db7ddb59b54c76af50424e29ded">memory_consumption</a> () const </td></tr>
<tr class="separator:a5dfd4db7ddb59b54c76af50424e29ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Adding entries</div></td></tr>
<tr class="memitem:a4a411ae74d053f5ab1b85e885d637cd2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a4a411ae74d053f5ab1b85e885d637cd2">add</a> (const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> i, const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> j)</td></tr>
<tr class="separator:a4a411ae74d053f5ab1b85e885d637cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90cfaf7a56fb9c2c012e0cf692f57e41"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator &gt; </td></tr>
<tr class="memitem:a90cfaf7a56fb9c2c012e0cf692f57e41"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a90cfaf7a56fb9c2c012e0cf692f57e41">add_entries</a> (const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> row, ForwardIterator <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a7e861c6b2f6334e81c591cd26e65cb08">begin</a>, ForwardIterator <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a7821606ff1d02ab37feee30d0c585787">end</a>, const <a class="el" href="classbool.html">bool</a> indices_are_sorted=false)</td></tr>
<tr class="separator:a90cfaf7a56fb9c2c012e0cf692f57e41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Access of underlying Trilinos data</div></td></tr>
<tr class="memitem:a50860d216f9a5da1ff2e5db603251c76"><td class="memItemLeft" align="right" valign="top">const Epetra_FECrsGraph &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a50860d216f9a5da1ff2e5db603251c76">trilinos_sparsity_pattern</a> () const </td></tr>
<tr class="separator:a50860d216f9a5da1ff2e5db603251c76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48e4fb17dc1aedfc2404fa42d94abebf"><td class="memItemLeft" align="right" valign="top">const Epetra_Map &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a48e4fb17dc1aedfc2404fa42d94abebf">domain_partitioner</a> () const </td></tr>
<tr class="separator:a48e4fb17dc1aedfc2404fa42d94abebf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85290c88f4247602395c88bfb7f08636"><td class="memItemLeft" align="right" valign="top">const Epetra_Map &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a85290c88f4247602395c88bfb7f08636">range_partitioner</a> () const </td></tr>
<tr class="separator:a85290c88f4247602395c88bfb7f08636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ccac53455c9f9beaf0c69e6dbed176a"><td class="memItemLeft" align="right" valign="top">const Epetra_Map &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a7ccac53455c9f9beaf0c69e6dbed176a">row_partitioner</a> () const </td></tr>
<tr class="separator:a7ccac53455c9f9beaf0c69e6dbed176a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f636377e22ce742005b535c9894460c"><td class="memItemLeft" align="right" valign="top">const Epetra_Map &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a3f636377e22ce742005b535c9894460c">col_partitioner</a> () const </td></tr>
<tr class="separator:a3f636377e22ce742005b535c9894460c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a852b2cb7e4ba3f5f3b3307bac1680943"><td class="memItemLeft" align="right" valign="top">const Epetra_Comm &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a852b2cb7e4ba3f5f3b3307bac1680943">trilinos_communicator</a> () const </td></tr>
<tr class="separator:a852b2cb7e4ba3f5f3b3307bac1680943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Iterators</div></td></tr>
<tr class="memitem:a7e861c6b2f6334e81c591cd26e65cb08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#adb98ca501c1a85dcd1ef7e3800d5a0f5">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a7e861c6b2f6334e81c591cd26e65cb08">begin</a> () const </td></tr>
<tr class="separator:a7e861c6b2f6334e81c591cd26e65cb08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7821606ff1d02ab37feee30d0c585787"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#adb98ca501c1a85dcd1ef7e3800d5a0f5">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a7821606ff1d02ab37feee30d0c585787">end</a> () const </td></tr>
<tr class="separator:a7821606ff1d02ab37feee30d0c585787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8ad8ef4058e7c10335623322d2bcfde"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#adb98ca501c1a85dcd1ef7e3800d5a0f5">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#ae8ad8ef4058e7c10335623322d2bcfde">begin</a> (const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> r) const </td></tr>
<tr class="separator:ae8ad8ef4058e7c10335623322d2bcfde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1256a34d21375322fb2d544e1af5e13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#adb98ca501c1a85dcd1ef7e3800d5a0f5">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#ac1256a34d21375322fb2d544e1af5e13">end</a> (const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> r) const </td></tr>
<tr class="separator:ac1256a34d21375322fb2d544e1af5e13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Input/Output</div></td></tr>
<tr class="memitem:a33da0a09d950e994818cd200ec8a8e17"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a33da0a09d950e994818cd200ec8a8e17">write_ascii</a> ()</td></tr>
<tr class="separator:a33da0a09d950e994818cd200ec8a8e17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7174ed02db9bc420630f83a51c911692"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a7174ed02db9bc420630f83a51c911692">print</a> (std::ostream &amp;out, const <a class="el" href="classbool.html">bool</a> write_extended_trilinos_info=false) const </td></tr>
<tr class="separator:a7174ed02db9bc420630f83a51c911692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ee2e9d7d1066c53d9f93ed424503472"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a7ee2e9d7d1066c53d9f93ed424503472">print_gnuplot</a> (std::ostream &amp;out) const </td></tr>
<tr class="separator:a7ee2e9d7d1066c53d9f93ed424503472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSubscriptor"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSubscriptor')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSubscriptor.html">Subscriptor</a></td></tr>
<tr class="memitem:ae5541017c0966b0af345db75895106f2 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#ae5541017c0966b0af345db75895106f2">Subscriptor</a> ()</td></tr>
<tr class="separator:ae5541017c0966b0af345db75895106f2 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367fce3122075f05f168d14f114b4c65 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a367fce3122075f05f168d14f114b4c65">Subscriptor</a> (const <a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;)</td></tr>
<tr class="separator:a367fce3122075f05f168d14f114b4c65 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c6c557e06110d2127fa6459119e94af inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a6c6c557e06110d2127fa6459119e94af">~Subscriptor</a> ()</td></tr>
<tr class="separator:a6c6c557e06110d2127fa6459119e94af inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24ee69d4b3cf9690d1208b2443cbbb80 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a24ee69d4b3cf9690d1208b2443cbbb80">operator=</a> (const <a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;)</td></tr>
<tr class="separator:a24ee69d4b3cf9690d1208b2443cbbb80 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3422499827ecd52f1d12d65eb6cc3125 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a3422499827ecd52f1d12d65eb6cc3125">subscribe</a> (const char *identifier=0) const </td></tr>
<tr class="separator:a3422499827ecd52f1d12d65eb6cc3125 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b4839b1cffc18781144ede1744b35ea inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a2b4839b1cffc18781144ede1744b35ea">unsubscribe</a> (const char *identifier=0) const </td></tr>
<tr class="separator:a2b4839b1cffc18781144ede1744b35ea inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b45274c8e1936bff024df01d618e86f inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a7b45274c8e1936bff024df01d618e86f">n_subscriptions</a> () const </td></tr>
<tr class="separator:a7b45274c8e1936bff024df01d618e86f inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbbc5f845063b1f23223b7ac96e89e13 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#adbbc5f845063b1f23223b7ac96e89e13">list_subscribers</a> () const </td></tr>
<tr class="separator:adbbc5f845063b1f23223b7ac96e89e13 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2f0251d20c6a5295024de3b2e9b4359 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac2f0251d20c6a5295024de3b2e9b4359">DeclException3</a> (ExcInUse, <a class="el" href="classint.html">int</a>, char *, std::string &amp;,&lt;&lt; &quot;Object of class &quot;&lt;&lt; arg2&lt;&lt; &quot; is still used by &quot;&lt;&lt; arg1&lt;&lt; &quot; other objects.\n&quot;&lt;&lt; &quot;(Additional information: &quot;&lt;&lt; arg3&lt;&lt; &quot;)\n&quot;&lt;&lt; &quot;Note the entry in the Frequently Asked Questions of &quot;&lt;&lt; &quot;deal.II (linked to from http://www.dealii.org/) for &quot;&lt;&lt; &quot;more information on what this error means.&quot;)</td></tr>
<tr class="separator:gac2f0251d20c6a5295024de3b2e9b4359 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e000d9ce953da6afe4bbbaca4397344 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga9e000d9ce953da6afe4bbbaca4397344">DeclException2</a> (ExcNoSubscriber, char *, char *,&lt;&lt; &quot;No subscriber with identifier \&quot;&quot;&lt;&lt; arg2&lt;&lt; &quot;\&quot; did <a class="el" href="classSubscriptor.html#a3422499827ecd52f1d12d65eb6cc3125">subscribe</a> to this object of class &quot;&lt;&lt; arg1)</td></tr>
<tr class="separator:ga9e000d9ce953da6afe4bbbaca4397344 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38 inherit pub_methods_classSubscriptor"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38 inherit pub_methods_classSubscriptor"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:a68efd17a8330ab676d9cd711029b0f38 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a0737dae63dbbef3edbf7257882eb8bee"><td class="memItemLeft" align="right" valign="top">std_cxx1x::shared_ptr&lt; Epetra_Map &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a0737dae63dbbef3edbf7257882eb8bee">column_space_map</a></td></tr>
<tr class="separator:a0737dae63dbbef3edbf7257882eb8bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc1a1a146684fb40952addddf2de191c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#adc1a1a146684fb40952addddf2de191c">compressed</a></td></tr>
<tr class="separator:adc1a1a146684fb40952addddf2de191c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9ab2184b1d3c1044ca9ca4766c3f418"><td class="memItemLeft" align="right" valign="top">std_cxx1x::shared_ptr<br class="typebreak"/>
&lt; Epetra_FECrsGraph &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#ab9ab2184b1d3c1044ca9ca4766c3f418">graph</a></td></tr>
<tr class="separator:ab9ab2184b1d3c1044ca9ca4766c3f418"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ab1f9cdd2797ea0f1ebbec7878d2cd1be"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab1f9cdd2797ea0f1ebbec7878d2cd1be"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>SparsityPatternIterators::Accessor</b></td></tr>
<tr class="separator:ab1f9cdd2797ea0f1ebbec7878d2cd1be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a788687eb290f58f6accdff6098d5f492"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a788687eb290f58f6accdff6098d5f492"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>SparsityPatternIterators::Iterator</b></td></tr>
<tr class="separator:a788687eb290f58f6accdff6098d5f492"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class implements a wrapper class to use the Trilinos distributed sparsity pattern class Epetra_FECrsGraph. This class is designed to be used for construction of parallel Trilinos matrices. The functionality of this class is modeled after the existing sparsity pattern classes, with the difference that this class can work fully in parallel according to a partitioning of the sparsity pattern rows.</p>
<p>This class has many similarities to the compressed sparsity pattern classes of deal.II (i.e., the classes <a class="el" href="classCompressedSparsityPattern.html">CompressedSparsityPattern</a>, <a class="el" href="classCompressedSetSparsityPattern.html">CompressedSetSparsityPattern</a>, and <a class="el" href="classCompressedSimpleSparsityPattern.html">CompressedSimpleSparsityPattern</a>), since it can dynamically add elements to the pattern without any memory being previously reserved for it. However, it also has a method <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a497f24cbf7f49e9ab752268bedef05a2">SparsityPattern::compress()</a>, that finalizes the pattern and enables its use with Trilinos sparse matrices.</p>
<dl class="section author"><dt>Author</dt><dd>Martin Kronbichler, 2008 </dd></dl>

<p>Definition at line <a class="el" href="trilinos__sparsity__pattern_8h_source.html#l00300">300</a> of file <a class="el" href="trilinos__sparsity__pattern_8h_source.html">trilinos_sparsity_pattern.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a542f2dcccaf8d7ae0f54fa9b7a2ce445"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef ::<a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">TrilinosWrappers::SparsityPattern::size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare type for container size. </p>

<p>Definition at line <a class="el" href="trilinos__sparsity__pattern_8h_source.html#l00307">307</a> of file <a class="el" href="trilinos__sparsity__pattern_8h_source.html">trilinos_sparsity_pattern.h</a>.</p>

</div>
</div>
<a class="anchor" id="adb98ca501c1a85dcd1ef7e3800d5a0f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classTrilinosWrappers_1_1SparsityPatternIterators_1_1Iterator.html">SparsityPatternIterators::Iterator</a> <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#adb98ca501c1a85dcd1ef7e3800d5a0f5">TrilinosWrappers::SparsityPattern::const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare a typedef for the iterator class. </p>

<p>Definition at line <a class="el" href="trilinos__sparsity__pattern_8h_source.html#l00313">313</a> of file <a class="el" href="trilinos__sparsity__pattern_8h_source.html">trilinos_sparsity_pattern.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a6f9b583b6dd2ed58958ecc54c4344420"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TrilinosWrappers::SparsityPattern::SparsityPattern </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default constructor. Generates an empty (zero-size) sparsity pattern. </p>

</div>
</div>
<a class="anchor" id="a9c9f08ac331cd547973e99a8ec3783ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TrilinosWrappers::SparsityPattern::SparsityPattern </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a>&#160;</td>
          <td class="paramname"><em>n_entries_per_row</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate a sparsity pattern that is completely stored locally, having <img class="formulaInl" alt="$m$" src="form_272.png"/> rows and <img class="formulaInl" alt="$n$" src="form_156.png"/> columns. The resulting matrix will be completely stored locally, too.</p>
<p>It is possible to specify the number of columns entries per row using the optional <code>n_entries_per_row</code> argument. However, this value does not need to be accurate or even given at all, since one does usually not have this kind of information before building the sparsity pattern (the usual case when the function <a class="el" href="group__constraints.html#gab627b1d4845c9526521dbd1be83469dc">DoFTools::make_sparsity_pattern()</a> is called). The entries are allocated dynamically in a similar manner as for the deal.II <a class="el" href="classCompressedSparsityPattern.html">CompressedSparsityPattern</a> classes. However, a good estimate will reduce the setup time of the sparsity pattern. </p>

</div>
</div>
<a class="anchor" id="a6a055d61c918012a7fc026b0aee8aac9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TrilinosWrappers::SparsityPattern::SparsityPattern </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>n_entries_per_row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate a sparsity pattern that is completely stored locally, having <img class="formulaInl" alt="$m$" src="form_272.png"/> rows and <img class="formulaInl" alt="$n$" src="form_156.png"/> columns. The resulting matrix will be completely stored locally, too.</p>
<p>The vector <code>n_entries_per_row</code> specifies the number of entries in each row (an information usually not available, though). </p>

</div>
</div>
<a class="anchor" id="a9857b8210d194d18541042c864f47ead"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TrilinosWrappers::SparsityPattern::SparsityPattern </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html">SparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>input_sparsity_pattern</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy constructor. Sets the calling sparsity pattern to be the same as the input sparsity pattern. </p>

</div>
</div>
<a class="anchor" id="a4d34185dfa0d3cf50f0d9c87100d1bf7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual TrilinosWrappers::SparsityPattern::~SparsityPattern </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor. Made virtual so that one can use pointers to this class. </p>

</div>
</div>
<a class="anchor" id="a0b1cf374dc78b70d02ab8fe4b89d4995"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TrilinosWrappers::SparsityPattern::SparsityPattern </td>
          <td>(</td>
          <td class="paramtype">const Epetra_Map &amp;&#160;</td>
          <td class="paramname"><em>parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a>&#160;</td>
          <td class="paramname"><em>n_entries_per_row</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor for a square sparsity pattern using an Epetra_map for the description of the parallel partitioning. Moreover, the number of nonzero entries in the rows of the sparsity pattern can be specified. Note that this number does not need to be exact, and it is allowed that the actual sparsity structure has more nonzero entries than specified in the constructor (the usual case when the function <a class="el" href="group__constraints.html#gab627b1d4845c9526521dbd1be83469dc">DoFTools::make_sparsity_pattern()</a> is called). However it is still advantageous to provide good estimates here since a good value will avoid repeated allocation of memory, which considerably increases the performance when creating the sparsity pattern. </p>

</div>
</div>
<a class="anchor" id="af924ee89effc417974c0652e542f049a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TrilinosWrappers::SparsityPattern::SparsityPattern </td>
          <td>(</td>
          <td class="paramtype">const Epetra_Map &amp;&#160;</td>
          <td class="paramname"><em>parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>n_entries_per_row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as before, but now use the exact number of nonzeros in each m row. Since we know the number of elements in the sparsity pattern exactly in this case, we can already allocate the right amount of memory, which makes the creation process by the respective <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a35df9ba1ea9645293f1df7dd4f952fe8">SparsityPattern::reinit</a> call considerably faster. However, this is a rather unusual situation, since knowing the number of entries in each row is usually connected to knowing the indices of nonzero entries, which the sparsity pattern is designed to describe. </p>

</div>
</div>
<a class="anchor" id="a9434904823485bed58a518992fc49935"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TrilinosWrappers::SparsityPattern::SparsityPattern </td>
          <td>(</td>
          <td class="paramtype">const Epetra_Map &amp;&#160;</td>
          <td class="paramname"><em>row_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Epetra_Map &amp;&#160;</td>
          <td class="paramname"><em>col_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a>&#160;</td>
          <td class="paramname"><em>n_entries_per_row</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This constructor is similar to the one above, but it now takes two different Epetra maps for rows and columns. This interface is meant to be used for generating rectangular sparsity pattern, where one map describes the parallel partitioning of the dofs associated with the sparsity pattern rows and the other one of the sparsity pattern columns. Note that there is no real parallelism along the columns &ndash; the processor that owns a certain row always owns all the column elements, no matter how far they might be spread out. The second Epetra_Map is only used to specify the number of columns and for specifying the correct domain space when performing matrix-vector products with vectors based on the same column map.</p>
<p>The number of columns entries per row is specified as the maximum number of entries argument. </p>

</div>
</div>
<a class="anchor" id="a87d1d2faf95dcc105f0210a4a0673be0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TrilinosWrappers::SparsityPattern::SparsityPattern </td>
          <td>(</td>
          <td class="paramtype">const Epetra_Map &amp;&#160;</td>
          <td class="paramname"><em>row_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Epetra_Map &amp;&#160;</td>
          <td class="paramname"><em>col_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>n_entries_per_row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This constructor is similar to the one above, but it now takes two different Epetra maps for rows and columns. This interface is meant to be used for generating rectangular matrices, where one map specifies the parallel distribution of rows and the second one specifies the distribution of degrees of freedom associated with matrix columns. This second map is however not used for the distribution of the columns themselves &ndash; rather, all column elements of a row are stored on the same processor. The vector <code>n_entries_per_row</code> specifies the number of entries in each row of the newly generated matrix. </p>

</div>
</div>
<a class="anchor" id="a332b7796669a8501613e0dcf09cd7eb2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TrilinosWrappers::SparsityPattern::SparsityPattern </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>communicator</em> = <code>MPI_COMM_WORLD</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a>&#160;</td>
          <td class="paramname"><em>n_entries_per_row</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor for a square sparsity pattern using an <a class="el" href="classIndexSet.html">IndexSet</a> and an <a class="el" href="namespaceTrilinosWrappers_1_1MPI.html">MPI</a> communicator for the description of the parallel partitioning. Moreover, the number of nonzero entries in the rows of the sparsity pattern can be specified. Note that this number does not need to be exact, and it is even allowed that the actual sparsity structure has more nonzero entries than specified in the constructor. However it is still advantageous to provide good estimates here since a good value will avoid repeated allocation of memory, which considerably increases the performance when creating the sparsity pattern. </p>

</div>
</div>
<a class="anchor" id="a55b0c1296dbc63bdb65038974f40fd08"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TrilinosWrappers::SparsityPattern::SparsityPattern </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>communicator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>n_entries_per_row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as before, but now use the exact number of nonzeros in each m row. Since we know the number of elements in the sparsity pattern exactly in this case, we can already allocate the right amount of memory, which makes the creation process by the respective <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a35df9ba1ea9645293f1df7dd4f952fe8">SparsityPattern::reinit</a> call considerably faster. However, this is a rather unusual situation, since knowing the number of entries in each row is usually connected to knowing the indices of nonzero entries, which the sparsity pattern is designed to describe. </p>

</div>
</div>
<a class="anchor" id="ab342e99825bb5ca20d83f7f4014c5465"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TrilinosWrappers::SparsityPattern::SparsityPattern </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>row_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>col_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>communicator</em> = <code>MPI_COMM_WORLD</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a>&#160;</td>
          <td class="paramname"><em>n_entries_per_row</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This constructor is similar to the one above, but it now takes two different index sets to describe the parallel partitioning of rows and columns. This interface is meant to be used for generating rectangular sparsity pattern. Note that there is no real parallelism along the columns &ndash; the processor that owns a certain row always owns all the column elements, no matter how far they might be spread out. The second Epetra_Map is only used to specify the number of columns and for internal arragements when doing matrix-vector products with vectors based on that column map.</p>
<p>The number of columns entries per row is specified as the maximum number of entries argument. </p>

</div>
</div>
<a class="anchor" id="a882f09fe514d5c81f1a72ebf38f9023b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TrilinosWrappers::SparsityPattern::SparsityPattern </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>row_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>col_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>communicator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>n_entries_per_row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This constructor is similar to the one above, but it now takes two different index sets for rows and columns. This interface is meant to be used for generating rectangular matrices, where one map specifies the parallel distribution of rows and the second one specifies the distribution of degrees of freedom associated with matrix columns. This second map is however not used for the distribution of the columns themselves &ndash; rather, all column elements of a row are stored on the same processor. The vector <code>n_entries_per_row</code> specifies the number of entries in each row of the newly generated matrix. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a35df9ba1ea9645293f1df7dd4f952fe8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparsityPattern::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a>&#160;</td>
          <td class="paramname"><em>n_entries_per_row</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize a sparsity pattern that is completely stored locally, having <img class="formulaInl" alt="$m$" src="form_272.png"/> rows and <img class="formulaInl" alt="$n$" src="form_156.png"/> columns. The resulting matrix will be completely stored locally.</p>
<p>The number of columns entries per row is specified as the maximum number of entries argument. This does not need to be an accurate number since the entries are allocated dynamically in a similar manner as for the deal.II <a class="el" href="classCompressedSparsityPattern.html">CompressedSparsityPattern</a> classes, but a good estimate will reduce the setup time of the sparsity pattern. </p>

</div>
</div>
<a class="anchor" id="a2bcbf0cf47ddac3bc4a3ee6e0b22aedd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparsityPattern::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>n_entries_per_row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize a sparsity pattern that is completely stored locally, having <img class="formulaInl" alt="$m$" src="form_272.png"/> rows and <img class="formulaInl" alt="$n$" src="form_156.png"/> columns. The resulting matrix will be completely stored locally.</p>
<p>The vector <code>n_entries_per_row</code> specifies the number of entries in each row. </p>

</div>
</div>
<a class="anchor" id="a852f4ac014717dda54daca42e8c0309d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparsityPattern::copy_from </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html">SparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>input_sparsity_pattern</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy function. Sets the calling sparsity pattern to be the same as the input sparsity pattern. </p>

</div>
</div>
<a class="anchor" id="ab58dd6c800ca13d3edd161933e75f923"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparsityType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparsityPattern::copy_from </td>
          <td>(</td>
          <td class="paramtype">const SparsityType &amp;&#160;</td>
          <td class="paramname"><em>nontrilinos_sparsity_pattern</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy function from one of the deal.II sparsity patterns. If used in parallel, this function uses an ad-hoc partitioning of the rows and columns. </p>

</div>
</div>
<a class="anchor" id="a5070af6229463ec4873a66e69be7c1f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html">SparsityPattern</a>&amp; TrilinosWrappers::SparsityPattern::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html">SparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>input_sparsity_pattern</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy operator. This operation is only allowed for empty objects, to avoid potentially very costly operations automatically synthesized by the compiler. Use <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a852f4ac014717dda54daca42e8c0309d">copy_from()</a> instead if you know that you really want to copy a sparsity pattern with non-trivial content. </p>

</div>
</div>
<a class="anchor" id="a53f5bd094b1fb38b701412759180e2a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparsityPattern::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Release all memory and return to a state just like after having called the default constructor.</p>
<p>This is a collective operation that needs to be called on all processors in order to avoid a dead lock. </p>

</div>
</div>
<a class="anchor" id="a497f24cbf7f49e9ab752268bedef05a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparsityPattern::compress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>In analogy to our own <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html">SparsityPattern</a> class, this function compresses the sparsity pattern and allows the resulting pattern to be used for actually generating a (Trilinos-based) matrix. This function also exchanges non-local data that might have accumulated during the addition of new elements. This function must therefore be called once the structure is fixed. This is a collective operation, i.e., it needs to be run on all processors when used in parallel. </p>

</div>
</div>
<a class="anchor" id="a891811bd7b9ed083ed33e7ef8d36c069"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparsityPattern::reinit </td>
          <td>(</td>
          <td class="paramtype">const Epetra_Map &amp;&#160;</td>
          <td class="paramname"><em>parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a>&#160;</td>
          <td class="paramname"><em>n_entries_per_row</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reinitialization function for generating a square sparsity pattern using an Epetra_Map for the description of the parallel partitioning and the number of nonzero entries in the rows of the sparsity pattern. Note that this number does not need to be exact, and it is even allowed that the actual sparsity structure has more nonzero entries than specified in the constructor. However it is still advantageous to provide good estimates here since this will considerably increase the performance when creating the sparsity pattern.</p>
<p>This function does not create any entries by itself, but provides the correct data structures that can be used by the respective <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a4a411ae74d053f5ab1b85e885d637cd2">add()</a> function. </p>

</div>
</div>
<a class="anchor" id="a55bc5d749841ede277c20dc8991529dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparsityPattern::reinit </td>
          <td>(</td>
          <td class="paramtype">const Epetra_Map &amp;&#160;</td>
          <td class="paramname"><em>parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>n_entries_per_row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as before, but now use the exact number of nonzeros in each m row. Since we know the number of elements in the sparsity pattern exactly in this case, we can already allocate the right amount of memory, which makes process of adding entries to the sparsity pattern considerably faster. However, this is a rather unusual situation, since knowing the number of entries in each row is usually connected to knowing the indices of nonzero entries, which the sparsity pattern is designed to describe. </p>

</div>
</div>
<a class="anchor" id="a2ddfe6ccaac1ec5c077e633fc02505be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparsityPattern::reinit </td>
          <td>(</td>
          <td class="paramtype">const Epetra_Map &amp;&#160;</td>
          <td class="paramname"><em>row_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Epetra_Map &amp;&#160;</td>
          <td class="paramname"><em>col_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a>&#160;</td>
          <td class="paramname"><em>n_entries_per_row</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This reinit function is similar to the one above, but it now takes two different Epetra maps for rows and columns. This interface is meant to be used for generating rectangular sparsity pattern, where one map describes the parallel partitioning of the dofs associated with the sparsity pattern rows and the other one of the sparsity pattern columns. Note that there is no real parallelism along the columns &ndash; the processor that owns a certain row always owns all the column elements, no matter how far they might be spread out. The second Epetra_Map is only used to specify the number of columns and for internal arragements when doing matrix-vector products with vectors based on that column map.</p>
<p>The number of columns entries per row is specified by the argument <code>n_entries_per_row</code>. </p>

</div>
</div>
<a class="anchor" id="a8bc2681538101f9906c53feb7045795c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparsityPattern::reinit </td>
          <td>(</td>
          <td class="paramtype">const Epetra_Map &amp;&#160;</td>
          <td class="paramname"><em>row_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Epetra_Map &amp;&#160;</td>
          <td class="paramname"><em>col_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>n_entries_per_row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This reinit function is similar to the one above, but it now takes two different Epetra maps for rows and columns. This interface is meant to be used for generating rectangular matrices, where one map specifies the parallel distribution of rows and the second one specifies the distribution of degrees of freedom associated with matrix columns. This second map is however not used for the distribution of the columns themselves &ndash; rather, all column elements of a row are stored on the same processor. The vector <code>n_entries_per_row</code> specifies the number of entries in each row of the newly generated matrix. </p>

</div>
</div>
<a class="anchor" id="a9f8d7a9cd270633f987f08031f02c299"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparsityType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparsityPattern::reinit </td>
          <td>(</td>
          <td class="paramtype">const Epetra_Map &amp;&#160;</td>
          <td class="paramname"><em>row_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Epetra_Map &amp;&#160;</td>
          <td class="paramname"><em>col_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SparsityType &amp;&#160;</td>
          <td class="paramname"><em>nontrilinos_sparsity_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>exchange_data</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reinit function. Takes one of the deal.II sparsity patterns and a parallel partitioning of the rows and columns for initializing the current Trilinos sparsity pattern. The optional argument <code>exchange_data</code> can be used for reinitialization with a sparsity pattern that is not fully constructed. This feature is only implemented for input sparsity patterns of type <a class="el" href="classCompressedSimpleSparsityPattern.html">CompressedSimpleSparsityPattern</a>. </p>

</div>
</div>
<a class="anchor" id="a89ff675d743220fc1dc55db34b010764"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparsityType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparsityPattern::reinit </td>
          <td>(</td>
          <td class="paramtype">const Epetra_Map &amp;&#160;</td>
          <td class="paramname"><em>parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SparsityType &amp;&#160;</td>
          <td class="paramname"><em>nontrilinos_sparsity_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>exchange_data</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reinit function. Takes one of the deal.II sparsity patterns and a parallel partitioning of the rows and columns for initializing the current Trilinos sparsity pattern. The optional argument <code>exchange_data</code> can be used for reinitialization with a sparsity pattern that is not fully constructed. This feature is only implemented for input sparsity patterns of type <a class="el" href="classCompressedSimpleSparsityPattern.html">CompressedSimpleSparsityPattern</a>. </p>

</div>
</div>
<a class="anchor" id="ae49b1221034cfc8563066be053a36f78"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparsityPattern::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>communicator</em> = <code>MPI_COMM_WORLD</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a>&#160;</td>
          <td class="paramname"><em>n_entries_per_row</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reinitialization function for generating a square sparsity pattern using an <a class="el" href="classIndexSet.html">IndexSet</a> and an <a class="el" href="namespaceTrilinosWrappers_1_1MPI.html">MPI</a> communicator for the description of the parallel partitioning and the number of nonzero entries in the rows of the sparsity pattern. Note that this number does not need to be exact, and it is even allowed that the actual sparsity structure has more nonzero entries than specified in the constructor. However it is still advantageous to provide good estimates here since this will considerably increase the performance when creating the sparsity pattern.</p>
<p>This function does not create any entries by itself, but provides the correct data structures that can be used by the respective <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a4a411ae74d053f5ab1b85e885d637cd2">add()</a> function. </p>

</div>
</div>
<a class="anchor" id="a46f9b0cb75823908f59dc25204494641"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparsityPattern::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>communicator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>n_entries_per_row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as before, but now use the exact number of nonzeros in each m row. Since we know the number of elements in the sparsity pattern exactly in this case, we can already allocate the right amount of memory, which makes process of adding entries to the sparsity pattern considerably faster. However, this is a rather unusual situation, since knowing the number of entries in each row is usually connected to knowing the indices of nonzero entries, which the sparsity pattern is designed to describe. </p>

</div>
</div>
<a class="anchor" id="a32bbc13333cc2977e6370e8cc6917003"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparsityPattern::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>row_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>col_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>communicator</em> = <code>MPI_COMM_WORLD</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a>&#160;</td>
          <td class="paramname"><em>n_entries_per_row</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This reinit function is similar to the one above, but it now takes two different index sets for rows and columns. This interface is meant to be used for generating rectangular sparsity pattern, where one index set describes the parallel partitioning of the dofs associated with the sparsity pattern rows and the other one of the sparsity pattern columns. Note that there is no real parallelism along the columns &ndash; the processor that owns a certain row always owns all the column elements, no matter how far they might be spread out. The second <a class="el" href="classIndexSet.html">IndexSet</a> is only used to specify the number of columns and for internal arragements when doing matrix-vector products with vectors based on an EpetraMap based on that <a class="el" href="classIndexSet.html">IndexSet</a>.</p>
<p>The number of columns entries per row is specified by the argument <code>n_entries_per_row</code>. </p>

</div>
</div>
<a class="anchor" id="a31d8ab0dbb6508a4482efc6593e7477a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparsityPattern::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>row_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>col_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>communicator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>n_entries_per_row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as before, but now using a vector <code>n_entries_per_row</code> for specifying the number of entries in each row of the sparsity pattern. </p>

</div>
</div>
<a class="anchor" id="a70de039bb673a33d87515597c0a75e5a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparsityType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparsityPattern::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>row_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>col_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SparsityType &amp;&#160;</td>
          <td class="paramname"><em>nontrilinos_sparsity_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>communicator</em> = <code>MPI_COMM_WORLD</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>exchange_data</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reinit function. Takes one of the deal.II sparsity patterns and the parallel partitioning of the rows and columns specified by two index sets and a parallel communicator for initializing the current Trilinos sparsity pattern. The optional argument <code>exchange_data</code> can be used for reinitialization with a sparsity pattern that is not fully constructed. This feature is only implemented for input sparsity patterns of type <a class="el" href="classCompressedSimpleSparsityPattern.html">CompressedSimpleSparsityPattern</a>. </p>

</div>
</div>
<a class="anchor" id="add63d29cd82d0299709b4919856fb8e7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparsityType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparsityPattern::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SparsityType &amp;&#160;</td>
          <td class="paramname"><em>nontrilinos_sparsity_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>communicator</em> = <code>MPI_COMM_WORLD</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>exchange_data</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reinit function. Takes one of the deal.II sparsity patterns and a parallel partitioning of the rows and columns for initializing the current Trilinos sparsity pattern. The optional argument <code>exchange_data</code> can be used for reinitialization with a sparsity pattern that is not fully constructed. This feature is only implemented for input sparsity patterns of type <a class="el" href="classCompressedSimpleSparsityPattern.html">CompressedSimpleSparsityPattern</a>. </p>

</div>
</div>
<a class="anchor" id="a551a8dd4edff03422f4e6d70692000ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TrilinosWrappers::SparsityPattern::is_compressed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the state of the sparsity pattern, i.e., whether <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a497f24cbf7f49e9ab752268bedef05a2">compress()</a> needs to be called after an operation requiring data exchange. </p>

</div>
</div>
<a class="anchor" id="a30a73d895cde35d2685f8055d2963cec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> TrilinosWrappers::SparsityPattern::max_entries_per_row </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gives the maximum number of entries per row on the current processor. </p>

</div>
</div>
<a class="anchor" id="abe6bb434a032bfea9a983ad0c45ba714"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> TrilinosWrappers::SparsityPattern::n_rows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of rows in this sparsity pattern. </p>

</div>
</div>
<a class="anchor" id="a1eddd7bc08a03db06bf5ffca090a747b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> TrilinosWrappers::SparsityPattern::n_cols </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of columns in this sparsity pattern. </p>

</div>
</div>
<a class="anchor" id="ae16f84f633fbeb077d3a5a5c3ffd78a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> TrilinosWrappers::SparsityPattern::local_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the local dimension of the sparsity pattern, i.e. the number of rows stored on the present <a class="el" href="namespaceTrilinosWrappers_1_1MPI.html">MPI</a> process. In the sequential case, this number is the same as <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#abe6bb434a032bfea9a983ad0c45ba714">n_rows()</a>, but for parallel matrices it may be smaller.</p>
<p>To figure out which elements exactly are stored locally, use <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a76fe15cc375f8a93e96db09c81f71d1c">local_range()</a>. </p>

</div>
</div>
<a class="anchor" id="a76fe15cc375f8a93e96db09c81f71d1c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a>, <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a>&gt; TrilinosWrappers::SparsityPattern::local_range </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a pair of indices indicating which rows of this sparsity pattern are stored locally. The first number is the index of the first row stored, the second the index of the one past the last one that is stored locally. If this is a sequential matrix, then the result will be the pair (0,<a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#abe6bb434a032bfea9a983ad0c45ba714">n_rows()</a>), otherwise it will be a pair (i,i+n), where <code>n=<a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#ae16f84f633fbeb077d3a5a5c3ffd78a6">local_size()</a></code>. </p>

</div>
</div>
<a class="anchor" id="a69ddc7d08424178c9dc8b4a5d0efb21b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TrilinosWrappers::SparsityPattern::in_local_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether <code>index</code> is in the local range or not, see also <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a76fe15cc375f8a93e96db09c81f71d1c">local_range()</a>. </p>

</div>
</div>
<a class="anchor" id="acb770b36027af2f5a8b07cd038177b22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> TrilinosWrappers::SparsityPattern::n_nonzero_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of nonzero elements of this sparsity pattern. </p>

</div>
</div>
<a class="anchor" id="ad2f96e3dc7ff5784160fad9477065ef0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> TrilinosWrappers::SparsityPattern::row_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of entries in a specific row. </p>

</div>
</div>
<a class="anchor" id="a8836761542de689f1f6729462671d6cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> TrilinosWrappers::SparsityPattern::bandwidth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the bandwidth of the matrix represented by this structure. The bandwidth is the maximum of <img class="formulaInl" alt="$|i-j|$" src="form_302.png"/> for which the index pair <img class="formulaInl" alt="$(i,j)$" src="form_209.png"/> represents a nonzero entry of the matrix. Consequently, the maximum bandwidth a <img class="formulaInl" alt="$n\times m$" src="form_303.png"/> matrix can have is <img class="formulaInl" alt="$\max\{n-1,m-1\}$" src="form_304.png"/>. </p>

</div>
</div>
<a class="anchor" id="a2a01937aab4e8b5de14d013338df9cd9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TrilinosWrappers::SparsityPattern::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether the object is empty. It is empty if no memory is allocated, which is the same as when both dimensions are zero. </p>

</div>
</div>
<a class="anchor" id="a7dade6bd81cd50b01b7322e88b955d08"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TrilinosWrappers::SparsityPattern::exists </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether the index (<em>i,j</em>) exists in the sparsity pattern (i.e., it may be non-zero) or not. </p>

</div>
</div>
<a class="anchor" id="a5dfd4db7ddb59b54c76af50424e29ded"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t TrilinosWrappers::SparsityPattern::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine an estimate for the memory consumption (in bytes) of this object. Currently not implemented for this class. </p>

</div>
</div>
<a class="anchor" id="a4a411ae74d053f5ab1b85e885d637cd2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparsityPattern::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add the element (<em>i,j</em>) to the sparsity pattern. </p>

</div>
</div>
<a class="anchor" id="a90cfaf7a56fb9c2c012e0cf692f57e41"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparsityPattern::add_entries </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>indices_are_sorted</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add several elements in one row to the sparsity pattern. </p>

</div>
</div>
<a class="anchor" id="a50860d216f9a5da1ff2e5db603251c76"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Epetra_FECrsGraph&amp; TrilinosWrappers::SparsityPattern::trilinos_sparsity_pattern </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a const reference to the underlying Trilinos Epetra_CrsGraph data that stores the sparsity pattern. </p>

</div>
</div>
<a class="anchor" id="a48e4fb17dc1aedfc2404fa42d94abebf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Epetra_Map&amp; TrilinosWrappers::SparsityPattern::domain_partitioner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a const reference to the underlying Trilinos Epetra_Map that sets the parallel partitioning of the domain space of this sparsity pattern, i.e., the partitioning of the vectors matrices based on this sparsity pattern are multiplied with. </p>

</div>
</div>
<a class="anchor" id="a85290c88f4247602395c88bfb7f08636"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Epetra_Map&amp; TrilinosWrappers::SparsityPattern::range_partitioner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a const reference to the underlying Trilinos Epetra_Map that sets the partitioning of the range space of this sparsity pattern, i.e., the partitioning of the vectors that are result from matrix-vector products. </p>

</div>
</div>
<a class="anchor" id="a7ccac53455c9f9beaf0c69e6dbed176a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Epetra_Map&amp; TrilinosWrappers::SparsityPattern::row_partitioner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a const reference to the underlying Trilinos Epetra_Map that sets the partitioning of the sparsity pattern rows. Equal to the partitioning of the range. </p>

</div>
</div>
<a class="anchor" id="a3f636377e22ce742005b535c9894460c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Epetra_Map&amp; TrilinosWrappers::SparsityPattern::col_partitioner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a const reference to the underlying Trilinos Epetra_Map that sets the partitioning of the sparsity pattern columns. This is in general not equal to the partitioner Epetra_Map for the domain because of overlap in the matrix. </p>

</div>
</div>
<a class="anchor" id="a852b2cb7e4ba3f5f3b3307bac1680943"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Epetra_Comm&amp; TrilinosWrappers::SparsityPattern::trilinos_communicator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a const reference to the communicator used for this object. </p>

</div>
</div>
<a class="anchor" id="a7e861c6b2f6334e81c591cd26e65cb08"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#adb98ca501c1a85dcd1ef7e3800d5a0f5">const_iterator</a> TrilinosWrappers::SparsityPattern::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>STL-like iterator with the first entry. </p>

</div>
</div>
<a class="anchor" id="a7821606ff1d02ab37feee30d0c585787"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#adb98ca501c1a85dcd1ef7e3800d5a0f5">const_iterator</a> TrilinosWrappers::SparsityPattern::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Final iterator. </p>

</div>
</div>
<a class="anchor" id="ae8ad8ef4058e7c10335623322d2bcfde"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#adb98ca501c1a85dcd1ef7e3800d5a0f5">const_iterator</a> TrilinosWrappers::SparsityPattern::begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a>&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>STL-like iterator with the first entry of row <code>r</code>.</p>
<p>Note that if the given row is empty, i.e. does not contain any nonzero entries, then the iterator returned by this function equals <code>end(r)</code>. Note also that the iterator may not be dereferencable in that case. </p>

</div>
</div>
<a class="anchor" id="ac1256a34d21375322fb2d544e1af5e13"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#adb98ca501c1a85dcd1ef7e3800d5a0f5">const_iterator</a> TrilinosWrappers::SparsityPattern::end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a>&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Final iterator of row <code>r</code>. It points to the first element past the end of line <code>r</code>, or past the end of the entire sparsity pattern.</p>
<p>Note that the end iterator is not necessarily dereferencable. This is in particular the case if it is the end iterator for the last row of a matrix. </p>

</div>
</div>
<a class="anchor" id="a33da0a09d950e994818cd200ec8a8e17"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparsityPattern::write_ascii </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Abstract Trilinos object that helps view in ASCII other Trilinos objects. Currently this function is not implemented. TODO: Not implemented. </p>

</div>
</div>
<a class="anchor" id="a7174ed02db9bc420630f83a51c911692"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparsityPattern::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>write_extended_trilinos_info</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print (the locally owned part of) the sparsity pattern to the given stream, using the format <code>(line,col)</code>. The optional flag outputs the sparsity pattern in Trilinos style, where even the according processor number is printed to the stream, as well as a summary before actually writing the entries. </p>

</div>
</div>
<a class="anchor" id="a7ee2e9d7d1066c53d9f93ed424503472"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparsityPattern::print_gnuplot </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print the sparsity of the matrix in a format that <code>gnuplot</code> understands and which can be used to plot the sparsity pattern in a graphical way. The format consists of pairs <code>i j</code> of nonzero elements, each representing one entry of this matrix, one per line of the output file. Indices are counted from zero on, as usual. Since sparsity patterns are printed in the same way as matrices are displayed, we print the negative of the column index, which means that the <code>(0,0)</code> element is in the top left rather than in the bottom left corner.</p>
<p>Print the sparsity pattern in gnuplot by setting the data style to dots or points and use the <code>plot</code> command. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a0737dae63dbbef3edbf7257882eb8bee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std_cxx1x::shared_ptr&lt;Epetra_Map&gt; TrilinosWrappers::SparsityPattern::column_space_map</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pointer to the user-supplied Epetra Trilinos mapping of the matrix columns that assigns parts of the matrix to the individual processes. </p>

<p>Definition at line <a class="el" href="trilinos__sparsity__pattern_8h_source.html#l01380">1380</a> of file <a class="el" href="trilinos__sparsity__pattern_8h_source.html">trilinos_sparsity_pattern.h</a>.</p>

</div>
</div>
<a class="anchor" id="adc1a1a146684fb40952addddf2de191c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TrilinosWrappers::SparsityPattern::compressed</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A boolean variable to hold information on whether the vector is compressed or not. </p>

<p>Definition at line <a class="el" href="trilinos__sparsity__pattern_8h_source.html#l01387">1387</a> of file <a class="el" href="trilinos__sparsity__pattern_8h_source.html">trilinos_sparsity_pattern.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab9ab2184b1d3c1044ca9ca4766c3f418"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std_cxx1x::shared_ptr&lt;Epetra_FECrsGraph&gt; TrilinosWrappers::SparsityPattern::graph</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A sparsity pattern object in Trilinos to be used for finite element based problems which allows for adding non-local elements to the pattern. </p>

<p>Definition at line <a class="el" href="trilinos__sparsity__pattern_8h_source.html#l01396">1396</a> of file <a class="el" href="trilinos__sparsity__pattern_8h_source.html">trilinos_sparsity_pattern.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/deal.II/lac/<a class="el" href="trilinos__sparsity__pattern_8h_source.html">trilinos_sparsity_pattern.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jan 27 2014 15:27:26 for The deal.II Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
