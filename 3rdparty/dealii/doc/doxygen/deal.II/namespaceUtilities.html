<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>The deal.II Library: Utilities Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="http://www.dealii.org/deal.ico"></link>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2014 by the deal.II authors"></meta>
<meta name="deal.II-version" content="8.1.0"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 8.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Utilities Namespace Reference<div class="ingroups"><a class="el" href="group__utilities.html">Utility functions and classes</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceUtilities_1_1System"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities_1_1System.html">System</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceUtilities_1_1Trilinos"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities_1_1Trilinos.html">Trilinos</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceUtilities_1_1MPI"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities_1_1MPI.html">MPI</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structUtilities_1_1fixed__int__power.html">fixed_int_power</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structUtilities_1_1fixed__int__power_3_01a_00_010_01_4.html">fixed_int_power&lt; a, 0 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a136deeb1b4b93a151e5e4c46c6a777d5"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a136deeb1b4b93a151e5e4c46c6a777d5">int_to_string</a> (const unsigned <a class="el" href="classint.html">int</a> i, const unsigned <a class="el" href="classint.html">int</a> digits=<a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>)</td></tr>
<tr class="separator:a136deeb1b4b93a151e5e4c46c6a777d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c75f3b2b9de645e7432eba26e59499b"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a9c75f3b2b9de645e7432eba26e59499b">needed_digits</a> (const unsigned <a class="el" href="classint.html">int</a> max_number)</td></tr>
<tr class="separator:a9c75f3b2b9de645e7432eba26e59499b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7e8ff146c677d8a2408b88e4936f57d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#af7e8ff146c677d8a2408b88e4936f57d">string_to_int</a> (const std::string &amp;s)</td></tr>
<tr class="separator:af7e8ff146c677d8a2408b88e4936f57d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03ac6ff405ca62464f4bd81ff75558a5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a03ac6ff405ca62464f4bd81ff75558a5">string_to_int</a> (const std::vector&lt; std::string &gt; &amp;s)</td></tr>
<tr class="separator:a03ac6ff405ca62464f4bd81ff75558a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3177021843ad87857e6f8c5d98d29a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#ab3177021843ad87857e6f8c5d98d29a5">string_to_double</a> (const std::string &amp;s)</td></tr>
<tr class="separator:ab3177021843ad87857e6f8c5d98d29a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6db1821e0c89ae283417b52b0d900c4"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#aa6db1821e0c89ae283417b52b0d900c4">string_to_double</a> (const std::vector&lt; std::string &gt; &amp;s)</td></tr>
<tr class="separator:aa6db1821e0c89ae283417b52b0d900c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a457f15e44db227b3c38daccb9b7ff40a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a457f15e44db227b3c38daccb9b7ff40a">split_string_list</a> (const std::string &amp;s, const char delimiter= ',')</td></tr>
<tr class="separator:a457f15e44db227b3c38daccb9b7ff40a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e9339cb098898e0c1ca0c961a7993da"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a1e9339cb098898e0c1ca0c961a7993da">break_text_into_lines</a> (const std::string &amp;original_text, const unsigned <a class="el" href="classint.html">int</a> width, const char delimiter= ' ')</td></tr>
<tr class="separator:a1e9339cb098898e0c1ca0c961a7993da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b37ad8cfa930cb1ff91d68562553fec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a6b37ad8cfa930cb1ff91d68562553fec">match_at_string_start</a> (const std::string &amp;name, const std::string &amp;pattern)</td></tr>
<tr class="separator:a6b37ad8cfa930cb1ff91d68562553fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae04f6c8886763183ed224e38bd181710"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#ae04f6c8886763183ed224e38bd181710">get_integer_at_position</a> (const std::string &amp;name, const unsigned <a class="el" href="classint.html">int</a> position)</td></tr>
<tr class="separator:ae04f6c8886763183ed224e38bd181710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc6aef87ce08208501a4b524563836db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#acc6aef87ce08208501a4b524563836db">generate_normal_random_number</a> (const <a class="el" href="classdouble.html">double</a> a, const <a class="el" href="classdouble.html">double</a> sigma)</td></tr>
<tr class="separator:acc6aef87ce08208501a4b524563836db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a834c6b595ada6f8e73c78d9bbd8ec551"><td class="memTemplParams" colspan="2">template&lt;int N, typename T &gt; </td></tr>
<tr class="memitem:a834c6b595ada6f8e73c78d9bbd8ec551"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a834c6b595ada6f8e73c78d9bbd8ec551">fixed_power</a> (const T t)</td></tr>
<tr class="separator:a834c6b595ada6f8e73c78d9bbd8ec551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa0f9cd449850bf25160131cc4bc5668"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename T &gt; </td></tr>
<tr class="memitem:aaa0f9cd449850bf25160131cc4bc5668"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#aaa0f9cd449850bf25160131cc4bc5668">lower_bound</a> (Iterator first, Iterator last, const T &amp;val)</td></tr>
<tr class="separator:aaa0f9cd449850bf25160131cc4bc5668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c612c5ab6f6fe3937de5f82861d7533"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename T , typename Comp &gt; </td></tr>
<tr class="memitem:a3c612c5ab6f6fe3937de5f82861d7533"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a3c612c5ab6f6fe3937de5f82861d7533">lower_bound</a> (Iterator first, Iterator last, const T &amp;val, const Comp comp)</td></tr>
<tr class="separator:a3c612c5ab6f6fe3937de5f82861d7533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae40823ad3d8d78682eec8b7250bf9444"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#ae40823ad3d8d78682eec8b7250bf9444">reverse_permutation</a> (const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;permutation)</td></tr>
<tr class="separator:ae40823ad3d8d78682eec8b7250bf9444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9abe63bb9673ddd22e1b255d264235a4"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a9abe63bb9673ddd22e1b255d264235a4">invert_permutation</a> (const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;permutation)</td></tr>
<tr class="separator:a9abe63bb9673ddd22e1b255d264235a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb0840adc9ae3515ea38b5d18741d058"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned long <br class="typebreak"/>
long <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#afb0840adc9ae3515ea38b5d18741d058">reverse_permutation</a> (const std::vector&lt; unsigned long long <a class="el" href="classint.html">int</a> &gt; &amp;permutation)</td></tr>
<tr class="separator:afb0840adc9ae3515ea38b5d18741d058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75e1076a84284c48e7cae56caee0c22f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned long <br class="typebreak"/>
long <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a75e1076a84284c48e7cae56caee0c22f">invert_permutation</a> (const std::vector&lt; unsigned long long <a class="el" href="classint.html">int</a> &gt; &amp;permutation)</td></tr>
<tr class="separator:a75e1076a84284c48e7cae56caee0c22f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A namespace for utility functions that are not particularly specific to finite element computing or numerical programs, but nevertheless are needed in various contexts when writing applications.</p>
<dl class="section author"><dt>Author</dt><dd>Wolfgang Bangerth, 2005 </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a136deeb1b4b93a151e5e4c46c6a777d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Utilities::int_to_string </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>digits</em> = <code><a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert a number <code>i</code> to a string, with as many digits as given to fill with leading zeros.</p>
<p>If the second parameter is left at its default value, the number is not padded with leading zeros. The result is then the same as of the standard C function <code>itoa()</code> had been called. </p>

</div>
</div>
<a class="anchor" id="a9c75f3b2b9de645e7432eba26e59499b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> Utilities::needed_digits </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>max_number</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine how many digits are needed to represent numbers at most as large as the given number. </p>

</div>
</div>
<a class="anchor" id="af7e8ff146c677d8a2408b88e4936f57d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> Utilities::string_to_int </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a string, convert it to an integer. Throw an assertion if that is not possible. </p>

</div>
</div>
<a class="anchor" id="a03ac6ff405ca62464f4bd81ff75558a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classint.html">int</a>&gt; Utilities::string_to_int </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a list of strings, convert it to a list of integers. Throw an assertion if that is not possible. </p>

</div>
</div>
<a class="anchor" id="ab3177021843ad87857e6f8c5d98d29a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> Utilities::string_to_double </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a string, convert it to an double. Throw an assertion if that is not possible. </p>

</div>
</div>
<a class="anchor" id="aa6db1821e0c89ae283417b52b0d900c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classdouble.html">double</a>&gt; Utilities::string_to_double </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a list of strings, convert it to a list of doubles. Throw an assertion if that is not possible. </p>

</div>
</div>
<a class="anchor" id="a457f15e44db227b3c38daccb9b7ff40a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; Utilities::split_string_list </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>delimiter</em> = <code>','</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a string that contains text separated by a <code>delimiter</code>, split it into its components; for each component, remove leading and trailing spaces.</p>
<p>The default value of the delimiter is a comma, so that the function splits comma separated lists of strings. </p>

</div>
</div>
<a class="anchor" id="a1e9339cb098898e0c1ca0c961a7993da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; Utilities::break_text_into_lines </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>original_text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>delimiter</em> = <code>'&#160;'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Take a text, usually a documentation or something, and try to break it into individual lines of text at most <code>width</code> characters wide, by breaking at positions marked by <code>delimiter</code> in the text. If this is not possible, return the shortest lines that are longer than <code>width</code>. The default value of the delimiter is a space character. If original_text contains newline characters (<br/>
), the string is split at these locations, too. </p>

</div>
</div>
<a class="anchor" id="a6b37ad8cfa930cb1ff91d68562553fec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> Utilities::match_at_string_start </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return true if the given pattern string appears in the first position of the string. </p>

</div>
</div>
<a class="anchor" id="ae04f6c8886763183ed224e38bd181710"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>&gt; Utilities::get_integer_at_position </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a (signed) integer starting at the position in <code>name</code> indicated by the second argument, and retun this integer as a pair together with how many characters it takes up in the string.</p>
<p>If no integer can be read at the indicated position, return (-1,<a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>) </p>

</div>
</div>
<a class="anchor" id="acc6aef87ce08208501a4b524563836db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> Utilities::generate_normal_random_number </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate a random number from a normalized Gaussian probability distribution centered around <code>a</code> and with standard deviation <code>sigma</code>.</p>
<p>This function is reentrant, i.e., it can safely be called from multiple threads at the same time. However, if so done, then there is no guarantee that each thread will get the same sequence of numbers every time. Rather, the produced sequence of random numbers will be apportioned to the different threads in non-deterministic ways. If this is a problem, for example for exactly reproducibility, then you need to use separate random number facilities for separate threads, rather than this global function. For example, the C++11 standard offers such objects, as does BOOST.</p>
<dl class="section note"><dt>Note</dt><dd>Like the system function rand(), this function produces the same sequence of random numbers every time a program is started. This is an important property for debugging codes, but it makes it impossible to really verify statistics properties of a code. For rand(), you can call srand() to "seed" the random number generator to get different sequences of random numbers every time a program is called. However, this function does not allow seeding the random number generator. If you need this, as above, use one of the C++ or BOOST facilities. </dd></dl>

</div>
</div>
<a class="anchor" id="a834c6b595ada6f8e73c78d9bbd8ec551"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Utilities::fixed_power </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculate a fixed power, provided as a template argument, of a number.</p>
<p>This function provides an efficient way to calculate things like <code>t^N</code> where <code>N</code> is a known number at compile time.</p>
<p>Use this function as in <code>fixed_power&lt;dim&gt; (n)</code>. </p>

<p>Definition at line <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html#l00705">705</a> of file <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a class="anchor" id="aaa0f9cd449850bf25160131cc4bc5668"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Iterator Utilities::lower_bound </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Optimized replacement for <code>std::lower_bound</code> for searching within the range of column indices. Slashes execution time by approximately one half for the present application, partly because because the binary search is replaced by a linear search for small loop lengths.</p>
<p>Another reason for this function is rather obscure: when using the GCC libstdc++ function std::lower_bound, complexity is O(log(N)) as required. However, when using the debug version of the GCC libstdc++ as we do when running the testsuite, then std::lower_bound tests whether the sequence is in fact partitioned with respect to the pivot 'value' (i.e. in essence that the sequence is sorted as required for binary search to work). However, verifying this means that the complexity of std::lower_bound jumps to O(N); we call this function O(N) times below, making the overall complexity O(N**2). The consequence is that a few tests with big meshes completely run off the wall time limit for tests and fail with the libstdc++ debug mode</p>
<p>This function simply makes the assumption that the sequence is sorted, and we simply don't do the additional check. </p>

<p>Definition at line <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html#l00731">731</a> of file <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3c612c5ab6f6fe3937de5f82861d7533"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator , typename T , typename Comp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Iterator Utilities::lower_bound </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Comp&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The same function as above, but taking an argument that is used to compare individual elements of the sequence of objects pointed to by the iterators. </p>

<p>Definition at line <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html#l00744">744</a> of file <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae40823ad3d8d78682eec8b7250bf9444"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;unsigned <a class="el" href="classint.html">int</a>&gt; Utilities::reverse_permutation </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>permutation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a permutation vector (i.e. a vector <img class="formulaInl" alt="$p_0\ldots p_{N-1}$" src="form_440.png"/> where each <img class="formulaInl" alt="$p_i\in [0,N)$" src="form_441.png"/> and <img class="formulaInl" alt="$p_i\neq p_j$" src="form_442.png"/> for <img class="formulaInl" alt="$i\neq j$" src="form_443.png"/>), produce the reverse permutation <img class="formulaInl" alt="$q_i=N-1-p_i$" src="form_444.png"/>. </p>

</div>
</div>
<a class="anchor" id="a9abe63bb9673ddd22e1b255d264235a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;unsigned <a class="el" href="classint.html">int</a>&gt; Utilities::invert_permutation </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>permutation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a permutation vector (i.e. a vector <img class="formulaInl" alt="$p_0\ldots p_{N-1}$" src="form_440.png"/> where each <img class="formulaInl" alt="$p_i\in [0,N)$" src="form_441.png"/> and <img class="formulaInl" alt="$p_i\neq p_j$" src="form_442.png"/> for <img class="formulaInl" alt="$i\neq j$" src="form_443.png"/>), produce the inverse permutation <img class="formulaInl" alt="$q_0\ldots q_{N-1}$" src="form_445.png"/> so that <img class="formulaInl" alt="$q_{p_i}=p_{q_i}=i$" src="form_446.png"/>. </p>

</div>
</div>
<a class="anchor" id="afb0840adc9ae3515ea38b5d18741d058"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;unsigned long long <a class="el" href="classint.html">int</a>&gt; Utilities::reverse_permutation </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned long long <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>permutation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a permutation vector (i.e. a vector <img class="formulaInl" alt="$p_0\ldots p_{N-1}$" src="form_440.png"/> where each <img class="formulaInl" alt="$p_i\in [0,N)$" src="form_441.png"/> and <img class="formulaInl" alt="$p_i\neq p_j$" src="form_442.png"/> for <img class="formulaInl" alt="$i\neq j$" src="form_443.png"/>), produce the reverse permutation <img class="formulaInl" alt="$q_i=N-1-p_i$" src="form_444.png"/>. </p>

</div>
</div>
<a class="anchor" id="a75e1076a84284c48e7cae56caee0c22f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;unsigned long long <a class="el" href="classint.html">int</a>&gt; Utilities::invert_permutation </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned long long <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>permutation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a permutation vector (i.e. a vector <img class="formulaInl" alt="$p_0\ldots p_{N-1}$" src="form_440.png"/> where each <img class="formulaInl" alt="$p_i\in [0,N)$" src="form_441.png"/> and <img class="formulaInl" alt="$p_i\neq p_j$" src="form_442.png"/> for <img class="formulaInl" alt="$i\neq j$" src="form_443.png"/>), produce the inverse permutation <img class="formulaInl" alt="$q_0\ldots q_{N-1}$" src="form_445.png"/> so that <img class="formulaInl" alt="$q_{p_i}=p_{q_i}=i$" src="form_446.png"/>. </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jan 27 2014 15:27:26 for The deal.II Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
