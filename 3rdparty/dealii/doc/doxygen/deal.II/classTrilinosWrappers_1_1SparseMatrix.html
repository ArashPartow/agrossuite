<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>The deal.II Library: TrilinosWrappers::SparseMatrix Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="http://www.dealii.org/deal.ico"></link>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2014 by the deal.II authors"></meta>
<meta name="deal.II-version" content="8.1.0"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 8.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceTrilinosWrappers.html">TrilinosWrappers</a></li><li class="navelem"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classTrilinosWrappers_1_1SparseMatrix-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">TrilinosWrappers::SparseMatrix Class Reference<div class="ingroups"><a class="el" href="group__TrilinosWrappers.html">TrilinosWrappers</a> &#124; <a class="el" href="group__Matrix1.html">Basic matrices</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="trilinos__sparse__matrix_8h_source.html">trilinos_sparse_matrix.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for TrilinosWrappers::SparseMatrix:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classTrilinosWrappers_1_1SparseMatrix__inherit__graph.svg" width="179" height="136"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTrilinosWrappers_1_1SparseMatrix_1_1Traits.html">Traits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:afe482aa470fc1e948eabce22fbe0bad6"><td class="memItemLeft" align="right" valign="top">typedef ::<a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a></td></tr>
<tr class="separator:afe482aa470fc1e948eabce22fbe0bad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2bbbe25812a885629f61c0adb78161d"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="classTrilinosWrappers_1_1SparseMatrixIterators_1_1Iterator.html">SparseMatrixIterators::Iterator</a><br class="typebreak"/>
&lt; false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#af2bbbe25812a885629f61c0adb78161d">iterator</a></td></tr>
<tr class="separator:af2bbbe25812a885629f61c0adb78161d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b7cd05f0a29cf3725d7323c961938e5"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="classTrilinosWrappers_1_1SparseMatrixIterators_1_1Iterator.html">SparseMatrixIterators::Iterator</a><br class="typebreak"/>
&lt; true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a2b7cd05f0a29cf3725d7323c961938e5">const_iterator</a></td></tr>
<tr class="separator:a2b7cd05f0a29cf3725d7323c961938e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2b0bc8a994f8441b1089b01d1eb2b1f"><td class="memItemLeft" align="right" valign="top">typedef TrilinosScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ae2b0bc8a994f8441b1089b01d1eb2b1f">value_type</a></td></tr>
<tr class="separator:ae2b0bc8a994f8441b1089b01d1eb2b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:gaaa91c2a8575019cbaf8a9217fd0f5d02"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaaa91c2a8575019cbaf8a9217fd0f5d02">DeclException1</a> (ExcTrilinosError, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;An error with error number &quot;&lt;&lt; arg1&lt;&lt; &quot; occurred while calling a Trilinos function&quot;)</td></tr>
<tr class="separator:gaaa91c2a8575019cbaf8a9217fd0f5d02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4c07a4183bbc5953b1b9a79dfdc4cd9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gad4c07a4183bbc5953b1b9a79dfdc4cd9">DeclException2</a> (ExcInvalidIndex, <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a>, <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a>,&lt;&lt; &quot;The entry with index &lt;&quot;&lt;&lt; arg1&lt;&lt;  ','&lt;&lt; arg2&lt;&lt; &quot;&gt; does not exist.&quot;)</td></tr>
<tr class="separator:gad4c07a4183bbc5953b1b9a79dfdc4cd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d8906fd76a1653d2cfa16d23548c604"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga9d8906fd76a1653d2cfa16d23548c604">DeclException0</a> (ExcSourceEqualsDestination)</td></tr>
<tr class="separator:ga9d8906fd76a1653d2cfa16d23548c604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7426cdb9e8078ac7cd442857a786545c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga7426cdb9e8078ac7cd442857a786545c">DeclException0</a> (ExcMatrixNotCompressed)</td></tr>
<tr class="separator:ga7426cdb9e8078ac7cd442857a786545c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30d32b81159474d8c73662d482895749"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga30d32b81159474d8c73662d482895749">DeclException4</a> (ExcAccessToNonLocalElement, <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a>, <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a>, <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a>, <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a>,&lt;&lt; &quot;You tried to access element (&quot;&lt;&lt; arg1&lt;&lt; &quot;/&quot;&lt;&lt; arg2&lt;&lt; &quot;)&quot;&lt;&lt; &quot; of a distributed <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a72eb041778036fdf9fd412957532a5af">matrix</a>, but only rows &quot;&lt;&lt; arg3&lt;&lt; &quot; through &quot;&lt;&lt; arg4&lt;&lt; &quot; are stored locally and can be accessed.&quot;)</td></tr>
<tr class="separator:ga30d32b81159474d8c73662d482895749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb9160e213bcaf3e98adb55bb34f9089"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gabb9160e213bcaf3e98adb55bb34f9089">DeclException2</a> (ExcAccessToNonPresentElement, <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a>, <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a>,&lt;&lt; &quot;You tried to access element (&quot;&lt;&lt; arg1&lt;&lt; &quot;/&quot;&lt;&lt; arg2&lt;&lt; &quot;)&quot;&lt;&lt; &quot; of a sparse <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a72eb041778036fdf9fd412957532a5af">matrix</a>, but it appears to not&quot;&lt;&lt; &quot; exist in the Trilinos sparsity pattern.&quot;)</td></tr>
<tr class="separator:gabb9160e213bcaf3e98adb55bb34f9089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors and initialization.</div></td></tr>
<tr class="memitem:a695b68c019a28d002bc7718305602a75"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a695b68c019a28d002bc7718305602a75">SparseMatrix</a> ()</td></tr>
<tr class="separator:a695b68c019a28d002bc7718305602a75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a828eb275869a13640556404903217553"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a828eb275869a13640556404903217553">SparseMatrix</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#af05c6bcc588b4f1ebbe5afd6a57d99fe">m</a>, const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a8c617389fd7bf1804bd8c8ccf92b64f1">n</a>, const unsigned <a class="el" href="classint.html">int</a> n_max_entries_per_row)</td></tr>
<tr class="separator:a828eb275869a13640556404903217553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c7e65d465d23132ef43140abfb57eee"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a9c7e65d465d23132ef43140abfb57eee">SparseMatrix</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#af05c6bcc588b4f1ebbe5afd6a57d99fe">m</a>, const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a8c617389fd7bf1804bd8c8ccf92b64f1">n</a>, const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;n_entries_per_row)</td></tr>
<tr class="separator:a9c7e65d465d23132ef43140abfb57eee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecc2129752c012c425c93ba1c6e83a7f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#aecc2129752c012c425c93ba1c6e83a7f">SparseMatrix</a> (const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html">SparsityPattern</a> &amp;InputSparsityPattern)</td></tr>
<tr class="separator:aecc2129752c012c425c93ba1c6e83a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acda9913af5e2465c8f3e168c1eb9eaf0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#acda9913af5e2465c8f3e168c1eb9eaf0">SparseMatrix</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;InputMatrix)</td></tr>
<tr class="separator:acda9913af5e2465c8f3e168c1eb9eaf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa34b73144d475bbeb494c3d4bf802716"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#aa34b73144d475bbeb494c3d4bf802716">~SparseMatrix</a> ()</td></tr>
<tr class="separator:aa34b73144d475bbeb494c3d4bf802716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc3814dc954a89899b9f2e6a8270f920"><td class="memTemplParams" colspan="2">template&lt;typename SparsityType &gt; </td></tr>
<tr class="memitem:afc3814dc954a89899b9f2e6a8270f920"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afc3814dc954a89899b9f2e6a8270f920">reinit</a> (const SparsityType &amp;sparsity_pattern)</td></tr>
<tr class="separator:afc3814dc954a89899b9f2e6a8270f920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad829e2420bae04c4d008404c6f71f286"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ad829e2420bae04c4d008404c6f71f286">reinit</a> (const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html">SparsityPattern</a> &amp;sparsity_pattern)</td></tr>
<tr class="separator:ad829e2420bae04c4d008404c6f71f286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ea0137289d95679e8ed5224474b5d93"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a5ea0137289d95679e8ed5224474b5d93">reinit</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;sparse_matrix)</td></tr>
<tr class="separator:a5ea0137289d95679e8ed5224474b5d93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad74c6dd1164be6ed6e70553406114d27"><td class="memTemplParams" colspan="2">template&lt;typename number &gt; </td></tr>
<tr class="memitem:ad74c6dd1164be6ed6e70553406114d27"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ad74c6dd1164be6ed6e70553406114d27">reinit</a> (const ::<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;dealii_sparse_matrix, const <a class="el" href="classdouble.html">double</a> drop_tolerance=1e-13, const bool copy_values=true, const ::SparsityPattern *use_this_sparsity=0)</td></tr>
<tr class="separator:ad74c6dd1164be6ed6e70553406114d27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15dbd350662ba08393592756ea5baa98"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a15dbd350662ba08393592756ea5baa98">reinit</a> (const Epetra_CrsMatrix &amp;input_matrix, const <a class="el" href="classbool.html">bool</a> copy_values=true)</td></tr>
<tr class="separator:a15dbd350662ba08393592756ea5baa98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors and initialization using an Epetra_Map description</div></td></tr>
<tr class="memitem:abb8565f87089782c731a56f072585531"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#abb8565f87089782c731a56f072585531">SparseMatrix</a> (const Epetra_Map &amp;parallel_partitioning, const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> n_max_entries_per_row=0)</td></tr>
<tr class="separator:abb8565f87089782c731a56f072585531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a770646993ec73e678c79171629a38bd2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a770646993ec73e678c79171629a38bd2">SparseMatrix</a> (const Epetra_Map &amp;parallel_partitioning, const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;n_entries_per_row)</td></tr>
<tr class="separator:a770646993ec73e678c79171629a38bd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a425fd5b7d0730eb1a8487f0ad400daec"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a425fd5b7d0730eb1a8487f0ad400daec">SparseMatrix</a> (const Epetra_Map &amp;row_parallel_partitioning, const Epetra_Map &amp;col_parallel_partitioning, const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> n_max_entries_per_row=0)</td></tr>
<tr class="separator:a425fd5b7d0730eb1a8487f0ad400daec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d4abaa99ca5c30ab61d75e01360469e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a3d4abaa99ca5c30ab61d75e01360469e">SparseMatrix</a> (const Epetra_Map &amp;row_parallel_partitioning, const Epetra_Map &amp;col_parallel_partitioning, const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;n_entries_per_row)</td></tr>
<tr class="separator:a3d4abaa99ca5c30ab61d75e01360469e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6e0f0e37ef52e0efeb1c4f5771f7578"><td class="memTemplParams" colspan="2">template&lt;typename SparsityType &gt; </td></tr>
<tr class="memitem:ae6e0f0e37ef52e0efeb1c4f5771f7578"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ae6e0f0e37ef52e0efeb1c4f5771f7578">reinit</a> (const Epetra_Map &amp;parallel_partitioning, const SparsityType &amp;sparsity_pattern, const <a class="el" href="classbool.html">bool</a> exchange_data=false)</td></tr>
<tr class="separator:ae6e0f0e37ef52e0efeb1c4f5771f7578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53307fe407dd69f4f27a5b6d0f8fee1c"><td class="memTemplParams" colspan="2">template&lt;typename SparsityType &gt; </td></tr>
<tr class="memitem:a53307fe407dd69f4f27a5b6d0f8fee1c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a53307fe407dd69f4f27a5b6d0f8fee1c">reinit</a> (const Epetra_Map &amp;row_parallel_partitioning, const Epetra_Map &amp;col_parallel_partitioning, const SparsityType &amp;sparsity_pattern, const <a class="el" href="classbool.html">bool</a> exchange_data=false)</td></tr>
<tr class="separator:a53307fe407dd69f4f27a5b6d0f8fee1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa5819232c87da0d9ace3c6188072f69"><td class="memTemplParams" colspan="2">template&lt;typename number &gt; </td></tr>
<tr class="memitem:aaa5819232c87da0d9ace3c6188072f69"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#aaa5819232c87da0d9ace3c6188072f69">reinit</a> (const Epetra_Map &amp;parallel_partitioning, const ::<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;dealii_sparse_matrix, const <a class="el" href="classdouble.html">double</a> drop_tolerance=1e-13, const bool copy_values=true, const ::SparsityPattern *use_this_sparsity=0)</td></tr>
<tr class="separator:aaa5819232c87da0d9ace3c6188072f69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7388b16391c62ceb32ac4370cb714d11"><td class="memTemplParams" colspan="2">template&lt;typename number &gt; </td></tr>
<tr class="memitem:a7388b16391c62ceb32ac4370cb714d11"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a7388b16391c62ceb32ac4370cb714d11">reinit</a> (const Epetra_Map &amp;row_parallel_partitioning, const Epetra_Map &amp;col_parallel_partitioning, const ::<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;dealii_sparse_matrix, const <a class="el" href="classdouble.html">double</a> drop_tolerance=1e-13, const bool copy_values=true, const ::SparsityPattern *use_this_sparsity=0)</td></tr>
<tr class="separator:a7388b16391c62ceb32ac4370cb714d11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors and initialization using an IndexSet description</div></td></tr>
<tr class="memitem:a8969757d00994c8baf19f0e846811400"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a8969757d00994c8baf19f0e846811400">SparseMatrix</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;parallel_partitioning, const MPI_Comm &amp;communicator=MPI_COMM_WORLD, const unsigned <a class="el" href="classint.html">int</a> n_max_entries_per_row=0)</td></tr>
<tr class="separator:a8969757d00994c8baf19f0e846811400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04b563fc63829f5b826ae156c17b5fa0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a04b563fc63829f5b826ae156c17b5fa0">SparseMatrix</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;parallel_partitioning, const MPI_Comm &amp;communicator, const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;n_entries_per_row)</td></tr>
<tr class="separator:a04b563fc63829f5b826ae156c17b5fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6088d3e02d77cea043b0192c01c8da1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ac6088d3e02d77cea043b0192c01c8da1">SparseMatrix</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;row_parallel_partitioning, const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;col_parallel_partitioning, const MPI_Comm &amp;communicator=MPI_COMM_WORLD, const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> n_max_entries_per_row=0)</td></tr>
<tr class="separator:ac6088d3e02d77cea043b0192c01c8da1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f60ffcc45751260d198141c1131f5ad"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a5f60ffcc45751260d198141c1131f5ad">SparseMatrix</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;row_parallel_partitioning, const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;col_parallel_partitioning, const MPI_Comm &amp;communicator, const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;n_entries_per_row)</td></tr>
<tr class="separator:a5f60ffcc45751260d198141c1131f5ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a9fb14e959d817db52de2109e28014d"><td class="memTemplParams" colspan="2">template&lt;typename SparsityType &gt; </td></tr>
<tr class="memitem:a8a9fb14e959d817db52de2109e28014d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a8a9fb14e959d817db52de2109e28014d">reinit</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;parallel_partitioning, const SparsityType &amp;sparsity_pattern, const MPI_Comm &amp;communicator=MPI_COMM_WORLD, const <a class="el" href="classbool.html">bool</a> exchange_data=false)</td></tr>
<tr class="separator:a8a9fb14e959d817db52de2109e28014d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27570b2ca6b34715093eec18c98f695e"><td class="memTemplParams" colspan="2">template&lt;typename SparsityType &gt; </td></tr>
<tr class="memitem:a27570b2ca6b34715093eec18c98f695e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a27570b2ca6b34715093eec18c98f695e">reinit</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;row_parallel_partitioning, const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;col_parallel_partitioning, const SparsityType &amp;sparsity_pattern, const MPI_Comm &amp;communicator=MPI_COMM_WORLD, const <a class="el" href="classbool.html">bool</a> exchange_data=false)</td></tr>
<tr class="separator:a27570b2ca6b34715093eec18c98f695e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf43eb7111fe543871742185dea9dabc"><td class="memTemplParams" colspan="2">template&lt;typename number &gt; </td></tr>
<tr class="memitem:acf43eb7111fe543871742185dea9dabc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#acf43eb7111fe543871742185dea9dabc">reinit</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;parallel_partitioning, const ::<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;dealii_sparse_matrix, const MPI_Comm &amp;communicator=MPI_COMM_WORLD, const <a class="el" href="classdouble.html">double</a> drop_tolerance=1e-13, const bool copy_values=true, const ::SparsityPattern *use_this_sparsity=0)</td></tr>
<tr class="separator:acf43eb7111fe543871742185dea9dabc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99bf74cc14f0f53bde1ea75d4c4b8dbe"><td class="memTemplParams" colspan="2">template&lt;typename number &gt; </td></tr>
<tr class="memitem:a99bf74cc14f0f53bde1ea75d4c4b8dbe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a99bf74cc14f0f53bde1ea75d4c4b8dbe">reinit</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;row_parallel_partitioning, const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;col_parallel_partitioning, const ::<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;dealii_sparse_matrix, const MPI_Comm &amp;communicator=MPI_COMM_WORLD, const <a class="el" href="classdouble.html">double</a> drop_tolerance=1e-13, const bool copy_values=true, const ::SparsityPattern *use_this_sparsity=0)</td></tr>
<tr class="separator:a99bf74cc14f0f53bde1ea75d4c4b8dbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Information on the matrix</div></td></tr>
<tr class="memitem:af05c6bcc588b4f1ebbe5afd6a57d99fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#af05c6bcc588b4f1ebbe5afd6a57d99fe">m</a> () const </td></tr>
<tr class="separator:af05c6bcc588b4f1ebbe5afd6a57d99fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c617389fd7bf1804bd8c8ccf92b64f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a8c617389fd7bf1804bd8c8ccf92b64f1">n</a> () const </td></tr>
<tr class="separator:a8c617389fd7bf1804bd8c8ccf92b64f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a501c654bf426f648d850e2135b54f6ed"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a501c654bf426f648d850e2135b54f6ed">local_size</a> () const </td></tr>
<tr class="separator:a501c654bf426f648d850e2135b54f6ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abebd63f5b539b295bae5fefa165e17ba"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a>, <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#abebd63f5b539b295bae5fefa165e17ba">local_range</a> () const </td></tr>
<tr class="separator:abebd63f5b539b295bae5fefa165e17ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24eadbb1da68aed99eade133a32b3f13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a24eadbb1da68aed99eade133a32b3f13">in_local_range</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> index) const </td></tr>
<tr class="separator:a24eadbb1da68aed99eade133a32b3f13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a516da0ce017436f6933dccb119de1ea1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a516da0ce017436f6933dccb119de1ea1">n_nonzero_elements</a> () const </td></tr>
<tr class="separator:a516da0ce017436f6933dccb119de1ea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b34c18bf127d2805637aae34dcc6a7a"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a1b34c18bf127d2805637aae34dcc6a7a">row_length</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> row) const </td></tr>
<tr class="separator:a1b34c18bf127d2805637aae34dcc6a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af95b702a8ce3d743ec558be105441b2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#af95b702a8ce3d743ec558be105441b2d">is_compressed</a> () const </td></tr>
<tr class="separator:af95b702a8ce3d743ec558be105441b2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc88d1cb914403191d3827fe2a063975"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afc88d1cb914403191d3827fe2a063975">memory_consumption</a> () const </td></tr>
<tr class="separator:afc88d1cb914403191d3827fe2a063975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Modifying entries</div></td></tr>
<tr class="memitem:a121825a4fd7785ac73f946f28b856c07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a121825a4fd7785ac73f946f28b856c07">operator=</a> (const <a class="el" href="classdouble.html">double</a> d)</td></tr>
<tr class="separator:a121825a4fd7785ac73f946f28b856c07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf652b70cdf396c5ab2e060a66eedaff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#aaf652b70cdf396c5ab2e060a66eedaff">clear</a> ()</td></tr>
<tr class="separator:aaf652b70cdf396c5ab2e060a66eedaff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affc572fd17d90d65a78dc23c6e89e9d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#affc572fd17d90d65a78dc23c6e89e9d2">compress</a> (::VectorOperation::values operation)</td></tr>
<tr class="separator:affc572fd17d90d65a78dc23c6e89e9d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc390e218faf682f0ae27f25568d787f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afc390e218faf682f0ae27f25568d787f">compress</a> () <a class="el" href="group__Sparsity.html#ga0849dabf81f46d4d964e251c286784dd">DEAL_II_DEPRECATED</a></td></tr>
<tr class="separator:afc390e218faf682f0ae27f25568d787f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0279858faded0f95d78c901b4e655317"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a0279858faded0f95d78c901b4e655317">set</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> i, const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> j, const TrilinosScalar value)</td></tr>
<tr class="separator:a0279858faded0f95d78c901b4e655317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4eb1ed3db64694a143ff796028ed36f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ae4eb1ed3db64694a143ff796028ed36f">set</a> (const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> &gt; &amp;indices, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; TrilinosScalar &gt; &amp;full_matrix, const <a class="el" href="classbool.html">bool</a> elide_zero_values=false)</td></tr>
<tr class="separator:ae4eb1ed3db64694a143ff796028ed36f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb388935f308125487ed25dadba89aca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afb388935f308125487ed25dadba89aca">set</a> (const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> &gt; &amp;row_indices, const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> &gt; &amp;col_indices, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; TrilinosScalar &gt; &amp;full_matrix, const <a class="el" href="classbool.html">bool</a> elide_zero_values=false)</td></tr>
<tr class="separator:afb388935f308125487ed25dadba89aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8467fa0334a3f86071d7a4e6bb6c7ca5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a8467fa0334a3f86071d7a4e6bb6c7ca5">set</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> row, const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> &gt; &amp;col_indices, const std::vector&lt; TrilinosScalar &gt; &amp;values, const <a class="el" href="classbool.html">bool</a> elide_zero_values=false)</td></tr>
<tr class="separator:a8467fa0334a3f86071d7a4e6bb6c7ca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7254cca1389a426c3a613aa0cc8dd3f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a7254cca1389a426c3a613aa0cc8dd3f1">set</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> row, const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> n_cols, const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> *col_indices, const TrilinosScalar *values, const <a class="el" href="classbool.html">bool</a> elide_zero_values=false)</td></tr>
<tr class="separator:a7254cca1389a426c3a613aa0cc8dd3f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2822f0aed012ede4516df69f53d0d13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ac2822f0aed012ede4516df69f53d0d13">add</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> i, const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> j, const TrilinosScalar value)</td></tr>
<tr class="separator:ac2822f0aed012ede4516df69f53d0d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab72246118eba4d13eb0ffac201a92dd3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ab72246118eba4d13eb0ffac201a92dd3">add</a> (const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> &gt; &amp;indices, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; TrilinosScalar &gt; &amp;full_matrix, const <a class="el" href="classbool.html">bool</a> elide_zero_values=true)</td></tr>
<tr class="separator:ab72246118eba4d13eb0ffac201a92dd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91803703c567906bfe15c38d26835a16"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a91803703c567906bfe15c38d26835a16">add</a> (const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> &gt; &amp;row_indices, const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> &gt; &amp;col_indices, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; TrilinosScalar &gt; &amp;full_matrix, const <a class="el" href="classbool.html">bool</a> elide_zero_values=true)</td></tr>
<tr class="separator:a91803703c567906bfe15c38d26835a16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbd01cdfc38771a1a58c3413f1b698a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#adbd01cdfc38771a1a58c3413f1b698a7">add</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> row, const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> &gt; &amp;col_indices, const std::vector&lt; TrilinosScalar &gt; &amp;values, const <a class="el" href="classbool.html">bool</a> elide_zero_values=true)</td></tr>
<tr class="separator:adbd01cdfc38771a1a58c3413f1b698a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11fe941933ae32cac616f01c6d2aa619"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a11fe941933ae32cac616f01c6d2aa619">add</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> row, const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> n_cols, const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> *col_indices, const TrilinosScalar *values, const <a class="el" href="classbool.html">bool</a> elide_zero_values=true, const <a class="el" href="classbool.html">bool</a> col_indices_are_sorted=false)</td></tr>
<tr class="separator:a11fe941933ae32cac616f01c6d2aa619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba03a21f0322adbb4e3162aef801aa5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#aba03a21f0322adbb4e3162aef801aa5d">operator*=</a> (const TrilinosScalar factor)</td></tr>
<tr class="separator:aba03a21f0322adbb4e3162aef801aa5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0178b8d2ce2f4ef10f9ef1d43edb57fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a0178b8d2ce2f4ef10f9ef1d43edb57fc">operator/=</a> (const TrilinosScalar factor)</td></tr>
<tr class="separator:a0178b8d2ce2f4ef10f9ef1d43edb57fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15b4dcaddb689f81c5d4160e9ac93efa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a15b4dcaddb689f81c5d4160e9ac93efa">copy_from</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;source)</td></tr>
<tr class="separator:a15b4dcaddb689f81c5d4160e9ac93efa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a791d1d6a8e7f78f32c276350ee44fa6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a791d1d6a8e7f78f32c276350ee44fa6c">add</a> (const TrilinosScalar factor, const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a72eb041778036fdf9fd412957532a5af">matrix</a>)</td></tr>
<tr class="separator:a791d1d6a8e7f78f32c276350ee44fa6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50486b99c6f00c1b0fc86e22d12eeb0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a50486b99c6f00c1b0fc86e22d12eeb0c">clear_row</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> row, const TrilinosScalar new_diag_value=0)</td></tr>
<tr class="separator:a50486b99c6f00c1b0fc86e22d12eeb0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08949474521622478ec9ab6ed0a78ad5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a08949474521622478ec9ab6ed0a78ad5">clear_rows</a> (const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> &gt; &amp;rows, const TrilinosScalar new_diag_value=0)</td></tr>
<tr class="separator:a08949474521622478ec9ab6ed0a78ad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcce713dadd3680b2193c17602512075"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#adcce713dadd3680b2193c17602512075">transpose</a> ()</td></tr>
<tr class="separator:adcce713dadd3680b2193c17602512075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Entry Access</div></td></tr>
<tr class="memitem:a95c02569488234115abe66ce0ec573d2"><td class="memItemLeft" align="right" valign="top">TrilinosScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a95c02569488234115abe66ce0ec573d2">operator()</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> i, const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> j) const </td></tr>
<tr class="separator:a95c02569488234115abe66ce0ec573d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c8916b75d10efad38abeff8ae6507b1"><td class="memItemLeft" align="right" valign="top">TrilinosScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a6c8916b75d10efad38abeff8ae6507b1">el</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> i, const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> j) const </td></tr>
<tr class="separator:a6c8916b75d10efad38abeff8ae6507b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa64686b2ff138d8c87ac63d1b44d5d12"><td class="memItemLeft" align="right" valign="top">TrilinosScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#aa64686b2ff138d8c87ac63d1b44d5d12">diag_element</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> i) const </td></tr>
<tr class="separator:aa64686b2ff138d8c87ac63d1b44d5d12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Multiplications</div></td></tr>
<tr class="memitem:a879071ca77fba383732d97cb129144fa"><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr class="memitem:a879071ca77fba383732d97cb129144fa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a879071ca77fba383732d97cb129144fa">vmult</a> (<a class="el" href="classVectorType.html">VectorType</a> &amp;dst, const <a class="el" href="classVectorType.html">VectorType</a> &amp;src) const </td></tr>
<tr class="separator:a879071ca77fba383732d97cb129144fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bbf722460779bceccb75cba590c8578"><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr class="memitem:a3bbf722460779bceccb75cba590c8578"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a3bbf722460779bceccb75cba590c8578">Tvmult</a> (<a class="el" href="classVectorType.html">VectorType</a> &amp;dst, const <a class="el" href="classVectorType.html">VectorType</a> &amp;src) const </td></tr>
<tr class="separator:a3bbf722460779bceccb75cba590c8578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d33254e1330b47886fdafd0e183aa8e"><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr class="memitem:a6d33254e1330b47886fdafd0e183aa8e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a6d33254e1330b47886fdafd0e183aa8e">vmult_add</a> (<a class="el" href="classVectorType.html">VectorType</a> &amp;dst, const <a class="el" href="classVectorType.html">VectorType</a> &amp;src) const </td></tr>
<tr class="separator:a6d33254e1330b47886fdafd0e183aa8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a466767795de31bf048e3503b5aed1a83"><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr class="memitem:a466767795de31bf048e3503b5aed1a83"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a466767795de31bf048e3503b5aed1a83">Tvmult_add</a> (<a class="el" href="classVectorType.html">VectorType</a> &amp;dst, const <a class="el" href="classVectorType.html">VectorType</a> &amp;src) const </td></tr>
<tr class="separator:a466767795de31bf048e3503b5aed1a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42eef53a67e221141fbde3ca37313093"><td class="memItemLeft" align="right" valign="top">TrilinosScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a42eef53a67e221141fbde3ca37313093">matrix_norm_square</a> (const <a class="el" href="classTrilinosWrappers_1_1VectorBase.html">VectorBase</a> &amp;v) const </td></tr>
<tr class="separator:a42eef53a67e221141fbde3ca37313093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb72c69e9f33bd7215f65fd0a6c6bdcb"><td class="memItemLeft" align="right" valign="top">TrilinosScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#adb72c69e9f33bd7215f65fd0a6c6bdcb">matrix_scalar_product</a> (const <a class="el" href="classTrilinosWrappers_1_1VectorBase.html">VectorBase</a> &amp;u, const <a class="el" href="classTrilinosWrappers_1_1VectorBase.html">VectorBase</a> &amp;v) const </td></tr>
<tr class="separator:adb72c69e9f33bd7215f65fd0a6c6bdcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94d3717d7dee92675a65428120f49d34"><td class="memItemLeft" align="right" valign="top">TrilinosScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a94d3717d7dee92675a65428120f49d34">residual</a> (<a class="el" href="classTrilinosWrappers_1_1VectorBase.html">VectorBase</a> &amp;dst, const <a class="el" href="classTrilinosWrappers_1_1VectorBase.html">VectorBase</a> &amp;x, const <a class="el" href="classTrilinosWrappers_1_1VectorBase.html">VectorBase</a> &amp;b) const </td></tr>
<tr class="separator:a94d3717d7dee92675a65428120f49d34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e26fb7017e11f69f941097f33bcf9cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a4e26fb7017e11f69f941097f33bcf9cd">mmult</a> (<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;C, const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;B, const <a class="el" href="classTrilinosWrappers_1_1VectorBase.html">VectorBase</a> &amp;V=<a class="el" href="classTrilinosWrappers_1_1VectorBase.html">VectorBase</a>()) const </td></tr>
<tr class="separator:a4e26fb7017e11f69f941097f33bcf9cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f65fb7da30eb5ef0582b179be6bb73b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a9f65fb7da30eb5ef0582b179be6bb73b">Tmmult</a> (<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;C, const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;B, const <a class="el" href="classTrilinosWrappers_1_1VectorBase.html">VectorBase</a> &amp;V=<a class="el" href="classTrilinosWrappers_1_1VectorBase.html">VectorBase</a>()) const </td></tr>
<tr class="separator:a9f65fb7da30eb5ef0582b179be6bb73b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Matrix norms</div></td></tr>
<tr class="memitem:aba093d109bf6dcfd8f9496fd0fa32f8f"><td class="memItemLeft" align="right" valign="top">TrilinosScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#aba093d109bf6dcfd8f9496fd0fa32f8f">l1_norm</a> () const </td></tr>
<tr class="separator:aba093d109bf6dcfd8f9496fd0fa32f8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5024906b2bc60ff3c60e962cc9c56b1c"><td class="memItemLeft" align="right" valign="top">TrilinosScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a5024906b2bc60ff3c60e962cc9c56b1c">linfty_norm</a> () const </td></tr>
<tr class="separator:a5024906b2bc60ff3c60e962cc9c56b1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0154efe67b553f4d0eee23e854838143"><td class="memItemLeft" align="right" valign="top">TrilinosScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a0154efe67b553f4d0eee23e854838143">frobenius_norm</a> () const </td></tr>
<tr class="separator:a0154efe67b553f4d0eee23e854838143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Access to underlying Trilinos data</div></td></tr>
<tr class="memitem:ae66f65bf1a75519bd147320c73435bcb"><td class="memItemLeft" align="right" valign="top">const Epetra_CrsMatrix &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ae66f65bf1a75519bd147320c73435bcb">trilinos_matrix</a> () const </td></tr>
<tr class="separator:ae66f65bf1a75519bd147320c73435bcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e4d5fd181e58c5fe32059ac8a388291"><td class="memItemLeft" align="right" valign="top">const Epetra_CrsGraph &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a0e4d5fd181e58c5fe32059ac8a388291">trilinos_sparsity_pattern</a> () const </td></tr>
<tr class="separator:a0e4d5fd181e58c5fe32059ac8a388291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0ca401b20191acff4796e1be3c93ec2"><td class="memItemLeft" align="right" valign="top">const Epetra_Map &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ad0ca401b20191acff4796e1be3c93ec2">domain_partitioner</a> () const </td></tr>
<tr class="separator:ad0ca401b20191acff4796e1be3c93ec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e85c59b194f0621e832f760bf547947"><td class="memItemLeft" align="right" valign="top">const Epetra_Map &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a5e85c59b194f0621e832f760bf547947">range_partitioner</a> () const </td></tr>
<tr class="separator:a5e85c59b194f0621e832f760bf547947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d8d378ae2d232533aa6ce5804918f16"><td class="memItemLeft" align="right" valign="top">const Epetra_Map &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a2d8d378ae2d232533aa6ce5804918f16">row_partitioner</a> () const </td></tr>
<tr class="separator:a2d8d378ae2d232533aa6ce5804918f16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e2bd73313e31ec9d28db3e45efe0137"><td class="memItemLeft" align="right" valign="top">const Epetra_Map &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a8e2bd73313e31ec9d28db3e45efe0137">col_partitioner</a> () const </td></tr>
<tr class="separator:a8e2bd73313e31ec9d28db3e45efe0137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Iterators</div></td></tr>
<tr class="memitem:a2a9cf77a3345048adc28fad33bdb1548"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a2b7cd05f0a29cf3725d7323c961938e5">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a2a9cf77a3345048adc28fad33bdb1548">begin</a> () const </td></tr>
<tr class="separator:a2a9cf77a3345048adc28fad33bdb1548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9e8fbb957d4f10f5123515779fa96ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a2b7cd05f0a29cf3725d7323c961938e5">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ac9e8fbb957d4f10f5123515779fa96ae">end</a> () const </td></tr>
<tr class="separator:ac9e8fbb957d4f10f5123515779fa96ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7fa7748ecbb2cbb7c09a5f176dc980d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a2b7cd05f0a29cf3725d7323c961938e5">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#aa7fa7748ecbb2cbb7c09a5f176dc980d">begin</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> r) const </td></tr>
<tr class="separator:aa7fa7748ecbb2cbb7c09a5f176dc980d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad863c5a72b9109989231f9f1096cebbe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a2b7cd05f0a29cf3725d7323c961938e5">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ad863c5a72b9109989231f9f1096cebbe">end</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> r) const </td></tr>
<tr class="separator:ad863c5a72b9109989231f9f1096cebbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a432dd81dc9b1c3446d2b35dd902af016"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#af2bbbe25812a885629f61c0adb78161d">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a432dd81dc9b1c3446d2b35dd902af016">begin</a> ()</td></tr>
<tr class="separator:a432dd81dc9b1c3446d2b35dd902af016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a818f02479da77b15b295090b8d379bb5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#af2bbbe25812a885629f61c0adb78161d">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a818f02479da77b15b295090b8d379bb5">end</a> ()</td></tr>
<tr class="separator:a818f02479da77b15b295090b8d379bb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac801a93ef57d40f3fbe36ca10909e47f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#af2bbbe25812a885629f61c0adb78161d">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ac801a93ef57d40f3fbe36ca10909e47f">begin</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> r)</td></tr>
<tr class="separator:ac801a93ef57d40f3fbe36ca10909e47f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba4773e90eb187a3432dd2b69fe28273"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#af2bbbe25812a885629f61c0adb78161d">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#aba4773e90eb187a3432dd2b69fe28273">end</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> r)</td></tr>
<tr class="separator:aba4773e90eb187a3432dd2b69fe28273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Input/Output</div></td></tr>
<tr class="memitem:ad1ca55b69b500064092c37d2bca0145f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ad1ca55b69b500064092c37d2bca0145f">write_ascii</a> ()</td></tr>
<tr class="separator:ad1ca55b69b500064092c37d2bca0145f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a191b64cb5ca360258c0389ac778079b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a191b64cb5ca360258c0389ac778079b3">print</a> (std::ostream &amp;out, const <a class="el" href="classbool.html">bool</a> write_extended_trilinos_info=false) const </td></tr>
<tr class="separator:a191b64cb5ca360258c0389ac778079b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSubscriptor"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSubscriptor')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSubscriptor.html">Subscriptor</a></td></tr>
<tr class="memitem:ae5541017c0966b0af345db75895106f2 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#ae5541017c0966b0af345db75895106f2">Subscriptor</a> ()</td></tr>
<tr class="separator:ae5541017c0966b0af345db75895106f2 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367fce3122075f05f168d14f114b4c65 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a367fce3122075f05f168d14f114b4c65">Subscriptor</a> (const <a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;)</td></tr>
<tr class="separator:a367fce3122075f05f168d14f114b4c65 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c6c557e06110d2127fa6459119e94af inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a6c6c557e06110d2127fa6459119e94af">~Subscriptor</a> ()</td></tr>
<tr class="separator:a6c6c557e06110d2127fa6459119e94af inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24ee69d4b3cf9690d1208b2443cbbb80 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a24ee69d4b3cf9690d1208b2443cbbb80">operator=</a> (const <a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;)</td></tr>
<tr class="separator:a24ee69d4b3cf9690d1208b2443cbbb80 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3422499827ecd52f1d12d65eb6cc3125 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a3422499827ecd52f1d12d65eb6cc3125">subscribe</a> (const char *identifier=0) const </td></tr>
<tr class="separator:a3422499827ecd52f1d12d65eb6cc3125 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b4839b1cffc18781144ede1744b35ea inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a2b4839b1cffc18781144ede1744b35ea">unsubscribe</a> (const char *identifier=0) const </td></tr>
<tr class="separator:a2b4839b1cffc18781144ede1744b35ea inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b45274c8e1936bff024df01d618e86f inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a7b45274c8e1936bff024df01d618e86f">n_subscriptions</a> () const </td></tr>
<tr class="separator:a7b45274c8e1936bff024df01d618e86f inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbbc5f845063b1f23223b7ac96e89e13 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#adbbc5f845063b1f23223b7ac96e89e13">list_subscribers</a> () const </td></tr>
<tr class="separator:adbbc5f845063b1f23223b7ac96e89e13 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2f0251d20c6a5295024de3b2e9b4359 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac2f0251d20c6a5295024de3b2e9b4359">DeclException3</a> (ExcInUse, <a class="el" href="classint.html">int</a>, char *, std::string &amp;,&lt;&lt; &quot;Object of class &quot;&lt;&lt; arg2&lt;&lt; &quot; is still used by &quot;&lt;&lt; arg1&lt;&lt; &quot; other objects.\n&quot;&lt;&lt; &quot;(Additional information: &quot;&lt;&lt; arg3&lt;&lt; &quot;)\n&quot;&lt;&lt; &quot;Note the entry in the Frequently Asked Questions of &quot;&lt;&lt; &quot;deal.II (linked to from http://www.dealii.org/) for &quot;&lt;&lt; &quot;more information on what this error means.&quot;)</td></tr>
<tr class="separator:gac2f0251d20c6a5295024de3b2e9b4359 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e000d9ce953da6afe4bbbaca4397344 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga9e000d9ce953da6afe4bbbaca4397344">DeclException2</a> (ExcNoSubscriber, char *, char *,&lt;&lt; &quot;No subscriber with identifier \&quot;&quot;&lt;&lt; arg2&lt;&lt; &quot;\&quot; did <a class="el" href="classSubscriptor.html#a3422499827ecd52f1d12d65eb6cc3125">subscribe</a> to this object of class &quot;&lt;&lt; arg1)</td></tr>
<tr class="separator:ga9e000d9ce953da6afe4bbbaca4397344 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38 inherit pub_methods_classSubscriptor"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38 inherit pub_methods_classSubscriptor"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:a68efd17a8330ab676d9cd711029b0f38 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a536e7d727e8394586b4c2dde99b39ba3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a536e7d727e8394586b4c2dde99b39ba3">prepare_add</a> ()</td></tr>
<tr class="separator:a536e7d727e8394586b4c2dde99b39ba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68a6620012e379b4c660fb4431d817fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a68a6620012e379b4c660fb4431d817fb">prepare_set</a> ()</td></tr>
<tr class="separator:a68a6620012e379b4c660fb4431d817fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a664a863fb861b74913054988f12818df"><td class="memItemLeft" align="right" valign="top">std_cxx1x::shared_ptr&lt; Epetra_Map &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a664a863fb861b74913054988f12818df">column_space_map</a></td></tr>
<tr class="separator:a664a863fb861b74913054988f12818df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72eb041778036fdf9fd412957532a5af"><td class="memItemLeft" align="right" valign="top">std_cxx1x::shared_ptr<br class="typebreak"/>
&lt; Epetra_FECrsMatrix &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a72eb041778036fdf9fd412957532a5af">matrix</a></td></tr>
<tr class="separator:a72eb041778036fdf9fd412957532a5af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c1d6236f2215737135912c25cc993b0"><td class="memItemLeft" align="right" valign="top">Epetra_CombineMode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a3c1d6236f2215737135912c25cc993b0">last_action</a></td></tr>
<tr class="separator:a3c1d6236f2215737135912c25cc993b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a896761c5d6156507d191a404ca7dc8c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a896761c5d6156507d191a404ca7dc8c3">compressed</a></td></tr>
<tr class="separator:a896761c5d6156507d191a404ca7dc8c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a0eb72d666c41a0ac3c16def795c0c99b"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a0eb72d666c41a0ac3c16def795c0c99b">BlockMatrixBase&lt; SparseMatrix &gt;</a></td></tr>
<tr class="separator:a0eb72d666c41a0ac3c16def795c0c99b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class implements a wrapper to use the Trilinos distributed sparse matrix class Epetra_FECrsMatrix. This is precisely the kind of matrix we deal with all the time - we most likely get it from some assembly process, where also entries not locally owned might need to be written and hence need to be forwarded to the owner process. This class is designed to be used in a distributed memory architecture with an <a class="el" href="namespaceTrilinosWrappers_1_1MPI.html">MPI</a> compiler on the bottom, but works equally well also for serial processes. The only requirement for this class to work is that Trilinos has been installed with the same compiler as is used for generating deal.II.</p>
<p>The interface of this class is modeled after the existing <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> class in deal.II. It has almost the same member functions, and is often exchangable. However, since Trilinos only supports a single scalar type (double), it is not templated, and only works with doubles.</p>
<p>Note that Trilinos only guarantees that operations do what you expect if the functions <code>GlobalAssemble</code> has been called after matrix assembly. Therefore, you need to call <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afc390e218faf682f0ae27f25568d787f">SparseMatrix::compress()</a> before you actually use the matrix. This also calls <code>FillComplete</code> that compresses the storage format for sparse matrices by discarding unused elements. Trilinos allows to continue with assembling the matrix after calls to these functions, though.</p>
<dl class="section author"><dt>Author</dt><dd>Martin Kronbichler, Wolfgang Bangerth, 2008, 2009 </dd></dl>

<p>Definition at line <a class="el" href="trilinos__sparse__matrix_8h_source.html#l00515">515</a> of file <a class="el" href="trilinos__sparse__matrix_8h_source.html">trilinos_sparse_matrix.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="afe482aa470fc1e948eabce22fbe0bad6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef ::<a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">TrilinosWrappers::SparseMatrix::size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare the type for container size. </p>

<p>Definition at line <a class="el" href="trilinos__sparse__matrix_8h_source.html#l00521">521</a> of file <a class="el" href="trilinos__sparse__matrix_8h_source.html">trilinos_sparse_matrix.h</a>.</p>

</div>
</div>
<a class="anchor" id="af2bbbe25812a885629f61c0adb78161d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classTrilinosWrappers_1_1SparseMatrixIterators_1_1Iterator.html">SparseMatrixIterators::Iterator</a>&lt;false&gt; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#af2bbbe25812a885629f61c0adb78161d">TrilinosWrappers::SparseMatrix::iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare a typedef for the iterator class. </p>

<p>Definition at line <a class="el" href="trilinos__sparse__matrix_8h_source.html#l00549">549</a> of file <a class="el" href="trilinos__sparse__matrix_8h_source.html">trilinos_sparse_matrix.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2b7cd05f0a29cf3725d7323c961938e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classTrilinosWrappers_1_1SparseMatrixIterators_1_1Iterator.html">SparseMatrixIterators::Iterator</a>&lt;true&gt; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a2b7cd05f0a29cf3725d7323c961938e5">TrilinosWrappers::SparseMatrix::const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare a typedef for the const iterator class. </p>

<p>Definition at line <a class="el" href="trilinos__sparse__matrix_8h_source.html#l00555">555</a> of file <a class="el" href="trilinos__sparse__matrix_8h_source.html">trilinos_sparse_matrix.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae2b0bc8a994f8441b1089b01d1eb2b1f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef TrilinosScalar <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ae2b0bc8a994f8441b1089b01d1eb2b1f">TrilinosWrappers::SparseMatrix::value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare a typedef in analogy to all the other container classes. </p>

<p>Definition at line <a class="el" href="trilinos__sparse__matrix_8h_source.html#l00562">562</a> of file <a class="el" href="trilinos__sparse__matrix_8h_source.html">trilinos_sparse_matrix.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a695b68c019a28d002bc7718305602a75"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TrilinosWrappers::SparseMatrix::SparseMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default constructor. Generates an empty (zero-size) matrix. </p>

</div>
</div>
<a class="anchor" id="a828eb275869a13640556404903217553"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TrilinosWrappers::SparseMatrix::SparseMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_max_entries_per_row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate a matrix that is completely stored locally, having <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#af05c6bcc588b4f1ebbe5afd6a57d99fe">m</a> rows and <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a8c617389fd7bf1804bd8c8ccf92b64f1">n</a> columns.</p>
<p>The number of columns entries per row is specified as the maximum number of entries argument. </p>

</div>
</div>
<a class="anchor" id="a9c7e65d465d23132ef43140abfb57eee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TrilinosWrappers::SparseMatrix::SparseMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>n_entries_per_row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate a matrix that is completely stored locally, having <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#af05c6bcc588b4f1ebbe5afd6a57d99fe">m</a> rows and <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a8c617389fd7bf1804bd8c8ccf92b64f1">n</a> columns.</p>
<p>The vector <code>n_entries_per_row</code> specifies the number of entries in each row. </p>

</div>
</div>
<a class="anchor" id="aecc2129752c012c425c93ba1c6e83a7f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TrilinosWrappers::SparseMatrix::SparseMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html">SparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>InputSparsityPattern</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate a matrix from a Trilinos sparsity pattern object. </p>

</div>
</div>
<a class="anchor" id="acda9913af5e2465c8f3e168c1eb9eaf0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TrilinosWrappers::SparseMatrix::SparseMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>InputMatrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy constructor. Sets the calling matrix to be the same as the input matrix, i.e., using the same sparsity pattern and entries. </p>

</div>
</div>
<a class="anchor" id="aa34b73144d475bbeb494c3d4bf802716"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual TrilinosWrappers::SparseMatrix::~SparseMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor. Made virtual so that one can use pointers to this class. </p>

</div>
</div>
<a class="anchor" id="abb8565f87089782c731a56f072585531"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TrilinosWrappers::SparseMatrix::SparseMatrix </td>
          <td>(</td>
          <td class="paramtype">const Epetra_Map &amp;&#160;</td>
          <td class="paramname"><em>parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a>&#160;</td>
          <td class="paramname"><em>n_max_entries_per_row</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor using an Epetra_Map to describe the parallel partitioning. The parameter <code>n_max_entries_per_row</code> sets the number of nonzero entries in each row that will be allocated. Note that this number does not need to be exact, and it is even allowed that the actual matrix structure has more nonzero entries than specified in the constructor. However it is still advantageous to provide good estimates here since this will considerably increase the performance of the matrix setup. However, there is no effect in the performance of matrix-vector products, since Trilinos reorganizes the matrix memory prior to use (in the <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afc390e218faf682f0ae27f25568d787f">compress()</a> step). </p>

</div>
</div>
<a class="anchor" id="a770646993ec73e678c79171629a38bd2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TrilinosWrappers::SparseMatrix::SparseMatrix </td>
          <td>(</td>
          <td class="paramtype">const Epetra_Map &amp;&#160;</td>
          <td class="paramname"><em>parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>n_entries_per_row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as before, but now set a value of nonzeros for each matrix row. Since we know the number of elements in the matrix exactly in this case, we can already allocate the right amount of memory, which makes the creation process including the insertion of nonzero elements by the respective <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afc3814dc954a89899b9f2e6a8270f920">SparseMatrix::reinit</a> call considerably faster. </p>

</div>
</div>
<a class="anchor" id="a425fd5b7d0730eb1a8487f0ad400daec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TrilinosWrappers::SparseMatrix::SparseMatrix </td>
          <td>(</td>
          <td class="paramtype">const Epetra_Map &amp;&#160;</td>
          <td class="paramname"><em>row_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Epetra_Map &amp;&#160;</td>
          <td class="paramname"><em>col_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a>&#160;</td>
          <td class="paramname"><em>n_max_entries_per_row</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This constructor is similar to the one above, but it now takes two different Epetra maps for rows and columns. This interface is meant to be used for generating rectangular matrices, where one map describes the parallel partitioning of the dofs associated with the matrix rows and the other one the partitioning of dofs in the matrix columns. Note that there is no real parallelism along the columns &ndash; the processor that owns a certain row always owns all the column elements, no matter how far they might be spread out. The second Epetra_Map is only used to specify the number of columns and for internal arrangements when doing matrix-vector products with vectors based on that column map.</p>
<p>The integer input <code>n_max_entries_per_row</code> defines the number of columns entries per row that will be allocated. </p>

</div>
</div>
<a class="anchor" id="a3d4abaa99ca5c30ab61d75e01360469e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TrilinosWrappers::SparseMatrix::SparseMatrix </td>
          <td>(</td>
          <td class="paramtype">const Epetra_Map &amp;&#160;</td>
          <td class="paramname"><em>row_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Epetra_Map &amp;&#160;</td>
          <td class="paramname"><em>col_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>n_entries_per_row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This constructor is similar to the one above, but it now takes two different Epetra maps for rows and columns. This interface is meant to be used for generating rectangular matrices, where one map specifies the parallel distribution of degrees of freedom associated with matrix rows and the second one specifies the parallel distribution the dofs associated with columns in the matrix. The second map also provides information for the internal arrangement in matrix vector products (i.e., the distribution of vector this matrix is to be multiplied with), but is not used for the distribution of the columns &ndash; rather, all column elements of a row are stored on the same processor in any case. The vector <code>n_entries_per_row</code> specifies the number of entries in each row of the newly generated matrix. </p>

</div>
</div>
<a class="anchor" id="a8969757d00994c8baf19f0e846811400"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TrilinosWrappers::SparseMatrix::SparseMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>communicator</em> = <code>MPI_COMM_WORLD</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_max_entries_per_row</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor using an <a class="el" href="classIndexSet.html">IndexSet</a> and an <a class="el" href="namespaceTrilinosWrappers_1_1MPI.html">MPI</a> communicator to describe the parallel partitioning. The parameter <code>n_max_entries_per_row</code> sets the number of nonzero entries in each row that will be allocated. Note that this number does not need to be exact, and it is even allowed that the actual matrix structure has more nonzero entries than specified in the constructor. However it is still advantageous to provide good estimates here since this will considerably increase the performance of the matrix setup. However, there is no effect in the performance of matrix-vector products, since Trilinos reorganizes the matrix memory prior to use (in the <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afc390e218faf682f0ae27f25568d787f">compress()</a> step). </p>

</div>
</div>
<a class="anchor" id="a04b563fc63829f5b826ae156c17b5fa0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TrilinosWrappers::SparseMatrix::SparseMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>communicator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>n_entries_per_row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as before, but now set the number of nonzeros in each matrix row separately. Since we know the number of elements in the matrix exactly in this case, we can already allocate the right amount of memory, which makes the creation process including the insertion of nonzero elements by the respective <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afc3814dc954a89899b9f2e6a8270f920">SparseMatrix::reinit</a> call considerably faster. </p>

</div>
</div>
<a class="anchor" id="ac6088d3e02d77cea043b0192c01c8da1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TrilinosWrappers::SparseMatrix::SparseMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>row_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>col_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>communicator</em> = <code>MPI_COMM_WORLD</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a>&#160;</td>
          <td class="paramname"><em>n_max_entries_per_row</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This constructor is similar to the one above, but it now takes two different <a class="el" href="classIndexSet.html">IndexSet</a> partitions for row and columns. This interface is meant to be used for generating rectangular matrices, where the first index set describes the parallel partitioning of the degrees of freedom associated with the matrix rows and the second one the partitioning of the matrix columns. The second index set specifies the partitioning of the vectors this matrix is to be multiplied with, not the distribution of the elements that actually appear in the matrix.</p>
<p>The parameter <code>n_max_entries_per_row</code> defines how much memory will be allocated for each row. This number does not need to be accurate, as the structure is reorganized in the <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afc390e218faf682f0ae27f25568d787f">compress()</a> call. </p>

</div>
</div>
<a class="anchor" id="a5f60ffcc45751260d198141c1131f5ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TrilinosWrappers::SparseMatrix::SparseMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>row_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>col_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>communicator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>n_entries_per_row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This constructor is similar to the one above, but it now takes two different Epetra maps for rows and columns. This interface is meant to be used for generating rectangular matrices, where one map specifies the parallel distribution of degrees of freedom associated with matrix rows and the second one specifies the parallel distribution the dofs associated with columns in the matrix. The second map also provides information for the internal arrangement in matrix vector products (i.e., the distribution of vector this matrix is to be multiplied with), but is not used for the distribution of the columns &ndash; rather, all column elements of a row are stored on the same processor in any case. The vector <code>n_entries_per_row</code> specifies the number of entries in each row of the newly generated matrix. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="afc3814dc954a89899b9f2e6a8270f920"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparsityType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparseMatrix::reinit </td>
          <td>(</td>
          <td class="paramtype">const SparsityType &amp;&#160;</td>
          <td class="paramname"><em>sparsity_pattern</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function initializes the Trilinos matrix with a deal.II sparsity pattern, i.e. it makes the Trilinos Epetra matrix know the position of nonzero entries according to the sparsity pattern. This function is meant for use in serial programs, where there is no need to specify how the matrix is going to be distributed among different processors. This function works in parallel, too, but it is recommended to manually specify the parallel partioning of the matrix using an Epetra_Map. When run in parallel, it is currently necessary that each processor holds the sparsity_pattern structure because each processor sets its rows.</p>
<p>This is a collective operation that needs to be called on all processors in order to avoid a dead lock. </p>

</div>
</div>
<a class="anchor" id="ad829e2420bae04c4d008404c6f71f286"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparseMatrix::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html">SparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>sparsity_pattern</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function reinitializes the Trilinos sparse matrix from a (possibly distributed) Trilinos sparsity pattern.</p>
<p>This is a collective operation that needs to be called on all processors in order to avoid a dead lock. </p>

</div>
</div>
<a class="anchor" id="a5ea0137289d95679e8ed5224474b5d93"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparseMatrix::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>sparse_matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function copies the content in <code>sparse_matrix</code> to the calling matrix.</p>
<p>This is a collective operation that needs to be called on all processors in order to avoid a dead lock. </p>

</div>
</div>
<a class="anchor" id="ad74c6dd1164be6ed6e70553406114d27"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparseMatrix::reinit </td>
          <td>(</td>
          <td class="paramtype">const ::<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>dealii_sparse_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>drop_tolerance</em> = <code>1e-13</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>copy_values</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html">SparsityPattern</a> *&#160;</td>
          <td class="paramname"><em>use_this_sparsity</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function initializes the Trilinos matrix using the deal.II sparse matrix and the entries stored therein. It uses a threshold to copy only elements with modulus larger than the threshold (so zeros in the deal.II matrix can be filtered away).</p>
<p>The optional parameter <code>copy_values</code> decides whether only the sparsity structure of the input matrix should be used or the matrix entries should be copied, too.</p>
<p>This is a collective operation that needs to be called on all processors in order to avoid a deadlock.</p>
<dl class="section note"><dt>Note</dt><dd>If a different sparsity pattern is given in the last argument (i.e., one that differs from the one used in the sparse matrix given in the first argument), then the resulting Trilinos matrix will have the sparsity pattern so given. This of course also means that all entries in the given matrix that are not part of this separate sparsity pattern will in fact be dropped. </dd></dl>

</div>
</div>
<a class="anchor" id="a15dbd350662ba08393592756ea5baa98"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparseMatrix::reinit </td>
          <td>(</td>
          <td class="paramtype">const Epetra_CrsMatrix &amp;&#160;</td>
          <td class="paramname"><em>input_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>copy_values</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This reinit function takes as input a Trilinos Epetra_CrsMatrix and copies its sparsity pattern. If so requested, even the content (values) will be copied. </p>

</div>
</div>
<a class="anchor" id="ae6e0f0e37ef52e0efeb1c4f5771f7578"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparsityType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparseMatrix::reinit </td>
          <td>(</td>
          <td class="paramtype">const Epetra_Map &amp;&#160;</td>
          <td class="paramname"><em>parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SparsityType &amp;&#160;</td>
          <td class="paramname"><em>sparsity_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>exchange_data</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is initializes the Trilinos Epetra matrix according to the specified sparsity_pattern, and also reassigns the matrix rows to different processes according to a user-supplied Epetra map. In programs following the style of the tutorial programs, this function (and the respective call for a rectangular matrix) are the natural way to initialize the matrix size, its distribution among the <a class="el" href="namespaceTrilinosWrappers_1_1MPI.html">MPI</a> processes (if run in parallel) as well as the locatoin of non-zero elements. Trilinos stores the sparsity pattern internally, so it won't be needed any more after this call, in contrast to the deal.II own object. The optional argument <code>exchange_data</code> can be used for reinitialization with a sparsity pattern that is not fully constructed. This feature is only implemented for input sparsity patterns of type <a class="el" href="classCompressedSimpleSparsityPattern.html">CompressedSimpleSparsityPattern</a>. If the flag is not set, each processor just sets the elements in the sparsity pattern that belong to its rows.</p>
<p>This is a collective operation that needs to be called on all processors in order to avoid a dead lock. </p>

</div>
</div>
<a class="anchor" id="a53307fe407dd69f4f27a5b6d0f8fee1c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparsityType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparseMatrix::reinit </td>
          <td>(</td>
          <td class="paramtype">const Epetra_Map &amp;&#160;</td>
          <td class="paramname"><em>row_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Epetra_Map &amp;&#160;</td>
          <td class="paramname"><em>col_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SparsityType &amp;&#160;</td>
          <td class="paramname"><em>sparsity_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>exchange_data</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is similar to the other initialization function above, but now also reassigns the matrix rows and columns according to two user-supplied Epetra maps. To be used for rectangular matrices. The optional argument <code>exchange_data</code> can be used for reinitialization with a sparsity pattern that is not fully constructed. This feature is only implemented for input sparsity patterns of type <a class="el" href="classCompressedSimpleSparsityPattern.html">CompressedSimpleSparsityPattern</a>.</p>
<p>This is a collective operation that needs to be called on all processors in order to avoid a dead lock. </p>

</div>
</div>
<a class="anchor" id="aaa5819232c87da0d9ace3c6188072f69"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparseMatrix::reinit </td>
          <td>(</td>
          <td class="paramtype">const Epetra_Map &amp;&#160;</td>
          <td class="paramname"><em>parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>dealii_sparse_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>drop_tolerance</em> = <code>1e-13</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>copy_values</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html">SparsityPattern</a> *&#160;</td>
          <td class="paramname"><em>use_this_sparsity</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function initializes the Trilinos matrix using the deal.II sparse matrix and the entries stored therein. It uses a threshold to copy only elements with modulus larger than the threshold (so zeros in the deal.II matrix can be filtered away). In contrast to the other reinit function with deal.II sparse matrix argument, this function takes a parallel partitioning specified by the user instead of internally generating it.</p>
<p>The optional parameter <code>copy_values</code> decides whether only the sparsity structure of the input matrix should be used or the matrix entries should be copied, too.</p>
<p>This is a collective operation that needs to be called on all processors in order to avoid a dead lock. </p>

</div>
</div>
<a class="anchor" id="a7388b16391c62ceb32ac4370cb714d11"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparseMatrix::reinit </td>
          <td>(</td>
          <td class="paramtype">const Epetra_Map &amp;&#160;</td>
          <td class="paramname"><em>row_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Epetra_Map &amp;&#160;</td>
          <td class="paramname"><em>col_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>dealii_sparse_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>drop_tolerance</em> = <code>1e-13</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>copy_values</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html">SparsityPattern</a> *&#160;</td>
          <td class="paramname"><em>use_this_sparsity</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is similar to the other initialization function with deal.II sparse matrix input above, but now takes Epetra maps for both the rows and the columns of the matrix. Chosen for rectangular matrices.</p>
<p>The optional parameter <code>copy_values</code> decides whether only the sparsity structure of the input matrix should be used or the matrix entries should be copied, too.</p>
<p>This is a collective operation that needs to be called on all processors in order to avoid a dead lock. </p>

</div>
</div>
<a class="anchor" id="a8a9fb14e959d817db52de2109e28014d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparsityType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparseMatrix::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SparsityType &amp;&#160;</td>
          <td class="paramname"><em>sparsity_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>communicator</em> = <code>MPI_COMM_WORLD</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>exchange_data</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is initializes the Trilinos Epetra matrix according to the specified sparsity_pattern, and also reassigns the matrix rows to different processes according to a user-supplied index set and parallel communicator. In programs following the style of the tutorial programs, this function (and the respective call for a rectangular matrix) are the natural way to initialize the matrix size, its distribution among the <a class="el" href="namespaceTrilinosWrappers_1_1MPI.html">MPI</a> processes (if run in parallel) as well as the locatoin of non-zero elements. Trilinos stores the sparsity pattern internally, so it won't be needed any more after this call, in contrast to the deal.II own object. The optional argument <code>exchange_data</code> can be used for reinitialization with a sparsity pattern that is not fully constructed. This feature is only implemented for input sparsity patterns of type <a class="el" href="classCompressedSimpleSparsityPattern.html">CompressedSimpleSparsityPattern</a>. If the flag is not set, each processor just sets the elements in the sparsity pattern that belong to its rows.</p>
<p>This is a collective operation that needs to be called on all processors in order to avoid a dead lock. </p>

</div>
</div>
<a class="anchor" id="a27570b2ca6b34715093eec18c98f695e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparsityType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparseMatrix::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>row_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>col_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SparsityType &amp;&#160;</td>
          <td class="paramname"><em>sparsity_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>communicator</em> = <code>MPI_COMM_WORLD</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>exchange_data</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is similar to the other initialization function above, but now also reassigns the matrix rows and columns according to two user-supplied index sets. To be used for rectangular matrices. The optional argument <code>exchange_data</code> can be used for reinitialization with a sparsity pattern that is not fully constructed. This feature is only implemented for input sparsity patterns of type <a class="el" href="classCompressedSimpleSparsityPattern.html">CompressedSimpleSparsityPattern</a>.</p>
<p>This is a collective operation that needs to be called on all processors in order to avoid a dead lock. </p>

</div>
</div>
<a class="anchor" id="acf43eb7111fe543871742185dea9dabc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparseMatrix::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>dealii_sparse_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>communicator</em> = <code>MPI_COMM_WORLD</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>drop_tolerance</em> = <code>1e-13</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>copy_values</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html">SparsityPattern</a> *&#160;</td>
          <td class="paramname"><em>use_this_sparsity</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function initializes the Trilinos matrix using the deal.II sparse matrix and the entries stored therein. It uses a threshold to copy only elements with modulus larger than the threshold (so zeros in the deal.II matrix can be filtered away). In contrast to the other reinit function with deal.II sparse matrix argument, this function takes a parallel partitioning specified by the user instead of internally generating it.</p>
<p>The optional parameter <code>copy_values</code> decides whether only the sparsity structure of the input matrix should be used or the matrix entries should be copied, too.</p>
<p>This is a collective operation that needs to be called on all processors in order to avoid a dead lock. </p>

</div>
</div>
<a class="anchor" id="a99bf74cc14f0f53bde1ea75d4c4b8dbe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparseMatrix::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>row_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>col_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>dealii_sparse_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>communicator</em> = <code>MPI_COMM_WORLD</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>drop_tolerance</em> = <code>1e-13</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>copy_values</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html">SparsityPattern</a> *&#160;</td>
          <td class="paramname"><em>use_this_sparsity</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is similar to the other initialization function with deal.II sparse matrix input above, but now takes index sets for both the rows and the columns of the matrix. Chosen for rectangular matrices.</p>
<p>The optional parameter <code>copy_values</code> decides whether only the sparsity structure of the input matrix should be used or the matrix entries should be copied, too.</p>
<p>This is a collective operation that needs to be called on all processors in order to avoid a dead lock. </p>

</div>
</div>
<a class="anchor" id="af05c6bcc588b4f1ebbe5afd6a57d99fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> TrilinosWrappers::SparseMatrix::m </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of rows in this matrix. </p>

</div>
</div>
<a class="anchor" id="a8c617389fd7bf1804bd8c8ccf92b64f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> TrilinosWrappers::SparseMatrix::n </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of columns in this matrix. </p>

</div>
</div>
<a class="anchor" id="a501c654bf426f648d850e2135b54f6ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> TrilinosWrappers::SparseMatrix::local_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the local dimension of the matrix, i.e. the number of rows stored on the present <a class="el" href="namespaceTrilinosWrappers_1_1MPI.html">MPI</a> process. For sequential matrices, this number is the same as <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#af05c6bcc588b4f1ebbe5afd6a57d99fe">m()</a>, but for parallel matrices it may be smaller.</p>
<p>To figure out which elements exactly are stored locally, use <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#abebd63f5b539b295bae5fefa165e17ba">local_range()</a>. </p>

</div>
</div>
<a class="anchor" id="abebd63f5b539b295bae5fefa165e17ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a>, <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a>&gt; TrilinosWrappers::SparseMatrix::local_range </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a pair of indices indicating which rows of this matrix are stored locally. The first number is the index of the first row stored, the second the index of the one past the last one that is stored locally. If this is a sequential matrix, then the result will be the pair (0,<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#af05c6bcc588b4f1ebbe5afd6a57d99fe">m()</a>), otherwise it will be a pair (i,i+n), where <code>n=<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a501c654bf426f648d850e2135b54f6ed">local_size()</a></code>. </p>

</div>
</div>
<a class="anchor" id="a24eadbb1da68aed99eade133a32b3f13"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TrilinosWrappers::SparseMatrix::in_local_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether <code>index</code> is in the local range or not, see also <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#abebd63f5b539b295bae5fefa165e17ba">local_range()</a>. </p>

</div>
</div>
<a class="anchor" id="a516da0ce017436f6933dccb119de1ea1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> TrilinosWrappers::SparseMatrix::n_nonzero_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of nonzero elements of this matrix. </p>

</div>
</div>
<a class="anchor" id="a1b34c18bf127d2805637aae34dcc6a7a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> TrilinosWrappers::SparseMatrix::row_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of entries in a specific row. </p>

</div>
</div>
<a class="anchor" id="af95b702a8ce3d743ec558be105441b2d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TrilinosWrappers::SparseMatrix::is_compressed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the state of the matrix, i.e., whether <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afc390e218faf682f0ae27f25568d787f">compress()</a> needs to be called after an operation requiring data exchange. A call to <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afc390e218faf682f0ae27f25568d787f">compress()</a> is also needed when the method <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a0279858faded0f95d78c901b4e655317">set()</a> has been called (even when working in serial). </p>

</div>
</div>
<a class="anchor" id="afc88d1cb914403191d3827fe2a063975"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> TrilinosWrappers::SparseMatrix::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine an estimate for the memory consumption (in bytes) of this object. Note that only the memory reserved on the current processor is returned in case this is called in an MPI-based program. </p>

</div>
</div>
<a class="anchor" id="a121825a4fd7785ac73f946f28b856c07"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&amp; TrilinosWrappers::SparseMatrix::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This operator assigns a scalar to a matrix. Since this does usually not make much sense (should we set all matrix entries to this value? Only the nonzero entries of the sparsity pattern?), this operation is only allowed if the actual value to be assigned is zero. This operator only exists to allow for the obvious notation <code>matrix=0</code>, which sets all elements of the matrix to zero, but keeps the sparsity pattern previously used. </p>

</div>
</div>
<a class="anchor" id="aaf652b70cdf396c5ab2e060a66eedaff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparseMatrix::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Release all memory and return to a state just like after having called the default constructor.</p>
<p>This is a collective operation that needs to be called on all processors in order to avoid a dead lock. </p>

</div>
</div>
<a class="anchor" id="affc572fd17d90d65a78dc23c6e89e9d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparseMatrix::compress </td>
          <td>(</td>
          <td class="paramtype">::VectorOperation::values&#160;</td>
          <td class="paramname"><em>operation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This command does two things: </p>
<ul>
<li>
If the matrix was initialized without a sparsity pattern, elements have been added manually using the <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a0279858faded0f95d78c901b4e655317">set()</a> command. When this process is completed, a call to <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afc390e218faf682f0ae27f25568d787f">compress()</a> reorganizes the internal data structures (aparsity pattern) so that a fast access to data is possible in matrix-vector products. </li>
<li>
If the matrix structure has already been fixed (either by initialization with a sparsity pattern or by calling <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afc390e218faf682f0ae27f25568d787f">compress()</a> during the setup phase), this command does the parallel exchange of data. This is necessary when we perform assembly on more than one (<a class="el" href="namespaceTrilinosWrappers_1_1MPI.html">MPI</a>) process, because then some non-local row data will accumulate on nodes that belong to the current's processor element, but are actually held by another. This command is usually called after all elements have been traversed. </li>
</ul>
<p>In both cases, this function compresses the data structures and allows the resulting matrix to be used in all other operations like matrix-vector products. This is a collective operation, i.e., it needs to be run on all processors when used in parallel.</p>
<p>See <a class="el" href="DEALGlossary.html#GlossCompress">Compressing distributed objects</a> for more information. </p>

</div>
</div>
<a class="anchor" id="afc390e218faf682f0ae27f25568d787f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparseMatrix::compress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000031">Deprecated:</a></b></dt><dd>: use <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afc390e218faf682f0ae27f25568d787f">compress()</a> with <a class="el" href="structVectorOperation.html">VectorOperation</a> instead. </dd></dl>

</div>
</div>
<a class="anchor" id="a0279858faded0f95d78c901b4e655317"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparseMatrix::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TrilinosScalar&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the element (<em>i,j</em>) to <code>value</code>.</p>
<p>This function is able to insert new elements into the matrix as long as <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afc390e218faf682f0ae27f25568d787f">compress()</a> has not been called, so the sparsity pattern will be extended. When <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afc390e218faf682f0ae27f25568d787f">compress()</a> is called for the first time, then this is no longer possible and an insertion of elements at positions which have not been initialized will throw an exception. Note that in case elements need to be inserted, it is mandatory that elements are inserted only once. Otherwise, the elements will actually be added in the end (since it is not possible to efficiently find values to the same entry before <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afc390e218faf682f0ae27f25568d787f">compress()</a> has been called). In the case that an element is set more than once, initialize the matrix with a sparsity pattern first. </p>

</div>
</div>
<a class="anchor" id="ae4eb1ed3db64694a143ff796028ed36f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparseMatrix::set </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; TrilinosScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>full_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set all elements given in a <a class="el" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> into the sparse matrix locations given by <code>indices</code>. In other words, this function writes the elements in <code>full_matrix</code> into the calling matrix, using the local-to-global indexing specified by <code>indices</code> for both the rows and the columns of the matrix. This function assumes a quadratic sparse matrix and a quadratic full_matrix, the usual situation in FE calculations.</p>
<p>This function is able to insert new elements into the matrix as long as <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afc390e218faf682f0ae27f25568d787f">compress()</a> has not been called, so the sparsity pattern will be extended. When <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afc390e218faf682f0ae27f25568d787f">compress()</a> is called for the first time, then this is no longer possible and an insertion of elements at positions which have not been initialized will throw an exception.</p>
<p>The optional parameter <code>elide_zero_values</code> can be used to specify whether zero values should be inserted anyway or they should be filtered away. The default value is <code>false</code>, i.e., even zero values are inserted/replaced. </p>

</div>
</div>
<a class="anchor" id="afb388935f308125487ed25dadba89aca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparseMatrix::set </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; TrilinosScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>full_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same function as before, but now including the possibility to use rectangular full_matrices and different local-to-global indexing on rows and columns, respectively. </p>

</div>
</div>
<a class="anchor" id="a8467fa0334a3f86071d7a4e6bb6c7ca5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparseMatrix::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; TrilinosScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set several elements in the specified row of the matrix with column indices as given by <code>col_indices</code> to the respective value.</p>
<p>This function is able to insert new elements into the matrix as long as <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afc390e218faf682f0ae27f25568d787f">compress()</a> has not been called, so the sparsity pattern will be extended. When <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afc390e218faf682f0ae27f25568d787f">compress()</a> is called for the first time, then this is no longer possible and an insertion of elements at positions which have not been initialized will throw an exception.</p>
<p>The optional parameter <code>elide_zero_values</code> can be used to specify whether zero values should be inserted anyway or they should be filtered away. The default value is <code>false</code>, i.e., even zero values are inserted/replaced. </p>

</div>
</div>
<a class="anchor" id="a7254cca1389a426c3a613aa0cc8dd3f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparseMatrix::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a>&#160;</td>
          <td class="paramname"><em>n_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> *&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TrilinosScalar *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set several elements to values given by <code>values</code> in a given row in columns given by col_indices into the sparse matrix.</p>
<p>This function is able to insert new elements into the matrix as long as <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afc390e218faf682f0ae27f25568d787f">compress()</a> has not been called, so the sparsity pattern will be extended. When <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afc390e218faf682f0ae27f25568d787f">compress()</a> is called for the first time, then this is no longer possible and an insertion of elements at positions which have not been initialized will throw an exception.</p>
<p>The optional parameter <code>elide_zero_values</code> can be used to specify whether zero values should be inserted anyway or they should be filtered away. The default value is <code>false</code>, i.e., even zero values are inserted/replaced. </p>

</div>
</div>
<a class="anchor" id="ac2822f0aed012ede4516df69f53d0d13"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparseMatrix::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TrilinosScalar&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add <code>value</code> to the element (<em>i,j</em>).</p>
<p>Just as the respective call in deal.II SparseMatrix&lt;Number&gt; class (but in contrast to the situation for PETSc based matrices), this function throws an exception if an entry does not exist in the sparsity pattern. Moreover, if <code>value</code> is not a finite number an exception is thrown. </p>

</div>
</div>
<a class="anchor" id="ab72246118eba4d13eb0ffac201a92dd3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparseMatrix::add </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; TrilinosScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>full_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add all elements given in a <a class="el" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> into sparse matrix locations given by <code>indices</code>. In other words, this function adds the elements in <code>full_matrix</code> to the respective entries in calling matrix, using the local-to-global indexing specified by <code>indices</code> for both the rows and the columns of the matrix. This function assumes a quadratic sparse matrix and a quadratic full_matrix, the usual situation in FE calculations.</p>
<p>Just as the respective call in deal.II SparseMatrix&lt;Number&gt; class (but in contrast to the situation for PETSc based matrices), this function throws an exception if an entry does not exist in the sparsity pattern.</p>
<p>The optional parameter <code>elide_zero_values</code> can be used to specify whether zero values should be added anyway or these should be filtered away and only non-zero data is added. The default value is <code>true</code>, i.e., zero values won't be added into the matrix. </p>

</div>
</div>
<a class="anchor" id="a91803703c567906bfe15c38d26835a16"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparseMatrix::add </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; TrilinosScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>full_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same function as before, but now including the possibility to use rectangular full_matrices and different local-to-global indexing on rows and columns, respectively. </p>

</div>
</div>
<a class="anchor" id="adbd01cdfc38771a1a58c3413f1b698a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparseMatrix::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; TrilinosScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set several elements in the specified row of the matrix with column indices as given by <code>col_indices</code> to the respective value.</p>
<p>Just as the respective call in deal.II SparseMatrix&lt;Number&gt; class (but in contrast to the situation for PETSc based matrices), this function throws an exception if an entry does not exist in the sparsity pattern.</p>
<p>The optional parameter <code>elide_zero_values</code> can be used to specify whether zero values should be added anyway or these should be filtered away and only non-zero data is added. The default value is <code>true</code>, i.e., zero values won't be added into the matrix. </p>

</div>
</div>
<a class="anchor" id="a11fe941933ae32cac616f01c6d2aa619"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparseMatrix::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a>&#160;</td>
          <td class="paramname"><em>n_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> *&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TrilinosScalar *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>col_indices_are_sorted</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add an array of values given by <code>values</code> in the given global matrix row at columns specified by col_indices in the sparse matrix.</p>
<p>Just as the respective call in deal.II SparseMatrix&lt;Number&gt; class (but in contrast to the situation for PETSc based matrices), this function throws an exception if an entry does not exist in the sparsity pattern.</p>
<p>The optional parameter <code>elide_zero_values</code> can be used to specify whether zero values should be added anyway or these should be filtered away and only non-zero data is added. The default value is <code>true</code>, i.e., zero values won't be added into the matrix. </p>

</div>
</div>
<a class="anchor" id="aba03a21f0322adbb4e3162aef801aa5d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&amp; TrilinosWrappers::SparseMatrix::operator*= </td>
          <td>(</td>
          <td class="paramtype">const TrilinosScalar&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiply the entire matrix by a fixed factor. </p>

</div>
</div>
<a class="anchor" id="a0178b8d2ce2f4ef10f9ef1d43edb57fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&amp; TrilinosWrappers::SparseMatrix::operator/= </td>
          <td>(</td>
          <td class="paramtype">const TrilinosScalar&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Divide the entire matrix by a fixed factor. </p>

</div>
</div>
<a class="anchor" id="a15b4dcaddb689f81c5d4160e9ac93efa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparseMatrix::copy_from </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy the given (Trilinos) matrix (sparsity pattern and entries). </p>

</div>
</div>
<a class="anchor" id="a791d1d6a8e7f78f32c276350ee44fa6c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparseMatrix::add </td>
          <td>(</td>
          <td class="paramtype">const TrilinosScalar&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add <code>matrix</code> scaled by <code>factor</code> to this matrix, i.e. the matrix <code>factor*matrix</code> is added to <code>this</code>. If the sparsity pattern of the calling matrix does not contain all the elements in the sparsity pattern of the input matrix, this function will throw an exception. </p>

</div>
</div>
<a class="anchor" id="a50486b99c6f00c1b0fc86e22d12eeb0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparseMatrix::clear_row </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TrilinosScalar&#160;</td>
          <td class="paramname"><em>new_diag_value</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove all elements from this <code>row</code> by setting them to zero. The function does not modify the number of allocated nonzero entries, it only sets some entries to zero. It may drop them from the sparsity pattern, though (but retains the allocated memory in case new entries are again added later). Note that this is a global operation, so this needs to be done on all <a class="el" href="namespaceTrilinosWrappers_1_1MPI.html">MPI</a> processes.</p>
<p>This operation is used in eliminating constraints (e.g. due to hanging nodes) and makes sure that we can write this modification to the matrix without having to read entries (such as the locations of non-zero elements) from it &mdash; without this operation, removing constraints on parallel matrices is a rather complicated procedure.</p>
<p>The second parameter can be used to set the diagonal entry of this row to a value different from zero. The default is to set it to zero. </p>

</div>
</div>
<a class="anchor" id="a08949474521622478ec9ab6ed0a78ad5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparseMatrix::clear_rows </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TrilinosScalar&#160;</td>
          <td class="paramname"><em>new_diag_value</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a50486b99c6f00c1b0fc86e22d12eeb0c">clear_row()</a>, except that it works on a number of rows at once.</p>
<p>The second parameter can be used to set the diagonal entries of all cleared rows to something different from zero. Note that all of these diagonal entries get the same value &ndash; if you want different values for the diagonal entries, you have to set them by hand. </p>

</div>
</div>
<a class="anchor" id="adcce713dadd3680b2193c17602512075"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparseMatrix::transpose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make an in-place transpose of a matrix. </p>

</div>
</div>
<a class="anchor" id="a95c02569488234115abe66ce0ec573d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TrilinosScalar TrilinosWrappers::SparseMatrix::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the value of the entry (<em>i,j</em>). This may be an expensive operation and you should always take care where to call this function. As in the deal.II sparse matrix class, we throw an exception if the respective entry doesn't exist in the sparsity pattern of this class, which is requested from Trilinos. Moreover, an exception will be thrown when the requested element is not saved on the calling process. </p>

</div>
</div>
<a class="anchor" id="a6c8916b75d10efad38abeff8ae6507b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TrilinosScalar TrilinosWrappers::SparseMatrix::el </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the value of the matrix entry (<em>i,j</em>). If this entry does not exist in the sparsity pattern, then zero is returned. While this may be convenient in some cases, note that it is simple to write algorithms that are slow compared to an optimal solution, since the sparsity of the matrix is not used. On the other hand, if you want to be sure the entry exists, you should use operator() instead.</p>
<p>The lack of error checking in this function can also yield surprising results if you have a parallel matrix. In that case, just because you get a zero result from this function does not mean that either the entry does not exist in the sparsity pattern or that it does but has a value of zero. Rather, it could also be that it simply isn't stored on the current processor; in that case, it may be stored on a different processor, and possibly so with a nonzero value. </p>

</div>
</div>
<a class="anchor" id="aa64686b2ff138d8c87ac63d1b44d5d12"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TrilinosScalar TrilinosWrappers::SparseMatrix::diag_element </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the main diagonal element in the <em>i</em>th row. This function throws an error if the matrix is not quadratic and it also throws an error if <em>(i,i)</em> is not element of the local matrix. See also the comment in trilinos_sparse_matrix.cc. </p>

</div>
</div>
<a class="anchor" id="a879071ca77fba383732d97cb129144fa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparseMatrix::vmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Matrix-vector multiplication: let <em>dst = M*src</em> with <em>M</em> being this matrix.</p>
<p>Source and destination must not be the same vector.</p>
<p>This function can be called with several different vector objects, namely <a class="el" href="classTrilinosWrappers_1_1Vector.html">TrilinosWrappers::Vector</a>, <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> as well as deal.II's own vector classes <a class="el" href="classVector.html">Vector&lt;double&gt;</a> and parallel::distributed::Vector&lt;double&gt;.</p>
<p>Note that both vectors have to be distributed vectors generated using the same Map as was used for the matrix in case you work on a distributed memory architecture, using the interface in the <a class="el" href="classTrilinosWrappers_1_1VectorBase.html">TrilinosWrappers::VectorBase</a> class (or one of the two derived classes <a class="el" href="classTrilinosWrappers_1_1Vector.html">Vector</a> and <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">MPI::Vector</a>).</p>
<p>In case of a localized <a class="el" href="classTrilinosWrappers_1_1Vector.html">Vector</a>, this function will only work when running on one processor, since the matrix object is inherently distributed. Otherwise, and exception will be thrown. </p>

</div>
</div>
<a class="anchor" id="a3bbf722460779bceccb75cba590c8578"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparseMatrix::Tvmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Matrix-vector multiplication: let <em>dst = M<sup>T</sup>*src</em> with <em>M</em> being this matrix. This function does the same as <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a879071ca77fba383732d97cb129144fa">vmult()</a> but takes the transposed matrix.</p>
<p>Source and destination must not be the same vector.</p>
<p>This function can be called with several different vector objects, namely <a class="el" href="classTrilinosWrappers_1_1Vector.html">TrilinosWrappers::Vector</a>, <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> as well as deal.II's own vector classes <a class="el" href="classVector.html">Vector&lt;double&gt;</a> and parallel::distributed::Vector&lt;double&gt;.</p>
<p>Note that both vectors have to be distributed vectors generated using the same Map as was used for the matrix in case you work on a distributed memory architecture, using the interface in the <a class="el" href="classTrilinosWrappers_1_1VectorBase.html">TrilinosWrappers::VectorBase</a> class (or one of the two derived classes <a class="el" href="classTrilinosWrappers_1_1Vector.html">Vector</a> and <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">MPI::Vector</a>).</p>
<p>In case of a localized <a class="el" href="classTrilinosWrappers_1_1Vector.html">Vector</a>, this function will only work when running on one processor, since the matrix object is inherently distributed. Otherwise, and exception will be thrown. </p>

</div>
</div>
<a class="anchor" id="a6d33254e1330b47886fdafd0e183aa8e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparseMatrix::vmult_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adding matrix-vector multiplication. Add <em>M*src</em> on <em>dst</em> with <em>M</em> being this matrix.</p>
<p>Source and destination must not be the same vector.</p>
<p>This function can be called with several different vector objects, namely <a class="el" href="classTrilinosWrappers_1_1Vector.html">TrilinosWrappers::Vector</a>, <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> as well as deal.II's own vector classes <a class="el" href="classVector.html">Vector&lt;double&gt;</a> and parallel::distributed::Vector&lt;double&gt;.</p>
<p>When using a vector of type <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a>, both vectors have to be distributed vectors generated using the same Map as was used for the matrix rows and columns in case you work on a distributed memory architecture, using the interface in the <a class="el" href="classTrilinosWrappers_1_1VectorBase.html">TrilinosWrappers::VectorBase</a> class.</p>
<p>In case of a localized <a class="el" href="classTrilinosWrappers_1_1Vector.html">Vector</a> (i.e., <a class="el" href="classTrilinosWrappers_1_1Vector.html">TrilinosWrappers::Vector</a> or <a class="el" href="classVector.html">Vector&lt;double&gt;</a>), this function will only work when running on one processor, since the matrix object is inherently distributed. Otherwise, and exception will be thrown. </p>

</div>
</div>
<a class="anchor" id="a466767795de31bf048e3503b5aed1a83"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparseMatrix::Tvmult_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adding matrix-vector multiplication. Add <em>M<sup>T</sup>*src</em> to <em>dst</em> with <em>M</em> being this matrix. This function does the same as <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a6d33254e1330b47886fdafd0e183aa8e">vmult_add()</a> but takes the transposed matrix.</p>
<p>Source and destination must not be the same vector.</p>
<p>This function can be called with several different vector objects, namely <a class="el" href="classTrilinosWrappers_1_1Vector.html">TrilinosWrappers::Vector</a>, <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> as well as deal.II's own vector classes <a class="el" href="classVector.html">Vector&lt;double&gt;</a> and parallel::distributed::Vector&lt;double&gt;.</p>
<p>When using a vector of type <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a>, both vectors have to be distributed vectors generated using the same Map as was used for the matrix rows and columns in case you work on a distributed memory architecture, using the interface in the <a class="el" href="classTrilinosWrappers_1_1VectorBase.html">TrilinosWrappers::VectorBase</a> class.</p>
<p>In case of a localized <a class="el" href="classTrilinosWrappers_1_1Vector.html">Vector</a> (i.e., <a class="el" href="classTrilinosWrappers_1_1Vector.html">TrilinosWrappers::Vector</a> or <a class="el" href="classVector.html">Vector&lt;double&gt;</a>), this function will only work when running on one processor, since the matrix object is inherently distributed. Otherwise, and exception will be thrown. </p>

</div>
</div>
<a class="anchor" id="a42eef53a67e221141fbde3ca37313093"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TrilinosScalar TrilinosWrappers::SparseMatrix::matrix_norm_square </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the square of the norm of the vector <img class="formulaInl" alt="$v$" src="form_292.png"/> with respect to the norm induced by this matrix, i.e., <img class="formulaInl" alt="$\left(v,Mv\right)$" src="form_293.png"/>. This is useful, e.g. in the finite element context, where the <img class="formulaInl" alt="$L_2$" src="form_294.png"/> norm of a function equals the matrix norm with respect to the mass matrix of the vector representing the nodal values of the finite element function.</p>
<p>Obviously, the matrix needs to be quadratic for this operation.</p>
<p>The implementation of this function is not as efficient as the one in the <code><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a></code> class used in deal.II (i.e. the original one, not the Trilinos wrapper class) since Trilinos doesn't support this operation and needs a temporary vector.</p>
<p>Note that both vectors have to be distributed vectors generated using the same Map as was used for the matrix in case you work on a distributed memory architecture, using the interface in the <a class="el" href="classTrilinosWrappers_1_1VectorBase.html">TrilinosWrappers::VectorBase</a> class (or one of the two derived classes <a class="el" href="classTrilinosWrappers_1_1Vector.html">Vector</a> and <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">MPI::Vector</a>).</p>
<p>In case of a localized <a class="el" href="classTrilinosWrappers_1_1Vector.html">Vector</a>, this function will only work when running on one processor, since the matrix object is inherently distributed. Otherwise, and exception will be thrown. </p>

</div>
</div>
<a class="anchor" id="adb72c69e9f33bd7215f65fd0a6c6bdcb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TrilinosScalar TrilinosWrappers::SparseMatrix::matrix_scalar_product </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the matrix scalar product <img class="formulaInl" alt="$\left(u,Mv\right)$" src="form_295.png"/>.</p>
<p>The implementation of this function is not as efficient as the one in the <code><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a></code> class used in deal.II (i.e. the original one, not the Trilinos wrapper class) since Trilinos doesn't support this operation and needs a temporary vector.</p>
<p>Note that both vectors have to be distributed vectors generated using the same Map as was used for the matrix in case you work on a distributed memory architecture, using the interface in the <a class="el" href="classTrilinosWrappers_1_1VectorBase.html">TrilinosWrappers::VectorBase</a> class (or one of the two derived classes <a class="el" href="classTrilinosWrappers_1_1Vector.html">Vector</a> and <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">MPI::Vector</a>).</p>
<p>In case of a localized <a class="el" href="classTrilinosWrappers_1_1Vector.html">Vector</a>, this function will only work when running on one processor, since the matrix object is inherently distributed. Otherwise, and exception will be thrown. </p>

</div>
</div>
<a class="anchor" id="a94d3717d7dee92675a65428120f49d34"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TrilinosScalar TrilinosWrappers::SparseMatrix::residual </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTrilinosWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the residual of an equation <em>Mx=b</em>, where the residual is defined to be <em>r=b-Mx</em>. Write the residual into <code>dst</code>. The <em>l<sub>2</sub></em> norm of the residual vector is returned.</p>
<p>Source <em>x</em> and destination <em>dst</em> must not be the same vector.</p>
<p>Note that both vectors have to be distributed vectors generated using the same Map as was used for the matrix in case you work on a distributed memory architecture, using the interface in the <a class="el" href="classTrilinosWrappers_1_1VectorBase.html">TrilinosWrappers::VectorBase</a> class (or one of the two derived classes <a class="el" href="classTrilinosWrappers_1_1Vector.html">Vector</a> and <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">MPI::Vector</a>).</p>
<p>In case of a localized <a class="el" href="classTrilinosWrappers_1_1Vector.html">Vector</a>, this function will only work when running on one processor, since the matrix object is inherently distributed. Otherwise, and exception will be thrown. </p>

</div>
</div>
<a class="anchor" id="a4e26fb7017e11f69f941097f33bcf9cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparseMatrix::mmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em> = <code><a class="el" href="classTrilinosWrappers_1_1VectorBase.html">VectorBase</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform the matrix-matrix multiplication <code>C = A * B</code>, or, if an optional vector argument is given, <code>C = A * diag(V) * B</code>, where <code>diag(V)</code> defines a diagonal matrix with the vector entries.</p>
<p>This function assumes that the calling matrix <code>A</code> and <code>B</code> have compatible sizes. The size of <code>C</code> will be set within this function.</p>
<p>The content as well as the sparsity pattern of the matrix C will be changed by this function, so make sure that the sparsity pattern is not used somewhere else in your program. This is an expensive operation, so think twice before you use this function. </p>

</div>
</div>
<a class="anchor" id="a9f65fb7da30eb5ef0582b179be6bb73b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparseMatrix::Tmmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em> = <code><a class="el" href="classTrilinosWrappers_1_1VectorBase.html">VectorBase</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform the matrix-matrix multiplication with the transpose of <code>this</code>, i.e., <code>C = A<sup>T</sup> * B</code>, or, if an optional vector argument is given, <code>C = A<sup>T</sup> * diag(V) * B</code>, where <code>diag(V)</code> defines a diagonal matrix with the vector entries.</p>
<p>This function assumes that the calling matrix <code>A</code> and <code>B</code> have compatible sizes. The size of <code>C</code> will be set within this function.</p>
<p>The content as well as the sparsity pattern of the matrix C will be changed by this function, so make sure that the sparsity pattern is not used somewhere else in your program. This is an expensive operation, so think twice before you use this function. </p>

</div>
</div>
<a class="anchor" id="aba093d109bf6dcfd8f9496fd0fa32f8f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TrilinosScalar TrilinosWrappers::SparseMatrix::l1_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the <em>l</em><sub>1</sub>-norm of the matrix, that is <img class="formulaInl" alt="$|M|_1= \max_{\mathrm{all\ columns\ } j} \sum_{\mathrm{all\ rows\ } i} |M_{ij}|$" src="form_296.png"/>, (max. sum of columns). This is the natural matrix norm that is compatible to the l1-norm for vectors, i.e. <img class="formulaInl" alt="$|Mv|_1 \leq |M|_1 |v|_1$" src="form_297.png"/>. (cf. Haemmerlin-Hoffmann: Numerische Mathematik) </p>

</div>
</div>
<a class="anchor" id="a5024906b2bc60ff3c60e962cc9c56b1c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TrilinosScalar TrilinosWrappers::SparseMatrix::linfty_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the linfty-norm of the matrix, that is <img class="formulaInl" alt="$|M|_\infty=\max_{\mathrm{all\ rows\ } i}\sum_{\mathrm{all\ columns\ } j} |M_{ij}|$" src="form_298.png"/>, (max. sum of rows). This is the natural matrix norm that is compatible to the linfty-norm of vectors, i.e. <img class="formulaInl" alt="$|Mv|_\infty \leq |M|_\infty |v|_\infty$" src="form_299.png"/>. (cf. Haemmerlin-Hoffmann: Numerische Mathematik) </p>

</div>
</div>
<a class="anchor" id="a0154efe67b553f4d0eee23e854838143"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TrilinosScalar TrilinosWrappers::SparseMatrix::frobenius_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the frobenius norm of the matrix, i.e. the square root of the sum of squares of all entries in the matrix. </p>

</div>
</div>
<a class="anchor" id="ae66f65bf1a75519bd147320c73435bcb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Epetra_CrsMatrix&amp; TrilinosWrappers::SparseMatrix::trilinos_matrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a const reference to the underlying Trilinos Epetra_CrsMatrix data. </p>

</div>
</div>
<a class="anchor" id="a0e4d5fd181e58c5fe32059ac8a388291"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Epetra_CrsGraph&amp; TrilinosWrappers::SparseMatrix::trilinos_sparsity_pattern </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a const reference to the underlying Trilinos Epetra_CrsGraph data that stores the sparsity pattern of the matrix. </p>

</div>
</div>
<a class="anchor" id="ad0ca401b20191acff4796e1be3c93ec2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Epetra_Map&amp; TrilinosWrappers::SparseMatrix::domain_partitioner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a const reference to the underlying Trilinos Epetra_Map that sets the partitioning of the domain space of this matrix, i.e., the partitioning of the vectors this matrix has to be multiplied with. </p>

</div>
</div>
<a class="anchor" id="a5e85c59b194f0621e832f760bf547947"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Epetra_Map&amp; TrilinosWrappers::SparseMatrix::range_partitioner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a const reference to the underlying Trilinos Epetra_Map that sets the partitioning of the range space of this matrix, i.e., the partitioning of the vectors that are result from matrix-vector products. </p>

</div>
</div>
<a class="anchor" id="a2d8d378ae2d232533aa6ce5804918f16"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Epetra_Map&amp; TrilinosWrappers::SparseMatrix::row_partitioner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a const reference to the underlying Trilinos Epetra_Map that sets the partitioning of the matrix rows. Equal to the partitioning of the range. </p>

</div>
</div>
<a class="anchor" id="a8e2bd73313e31ec9d28db3e45efe0137"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Epetra_Map&amp; TrilinosWrappers::SparseMatrix::col_partitioner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a const reference to the underlying Trilinos Epetra_Map that sets the partitioning of the matrix columns. This is in general not equal to the partitioner Epetra_Map for the domain because of overlap in the matrix. </p>

</div>
</div>
<a class="anchor" id="a2a9cf77a3345048adc28fad33bdb1548"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a2b7cd05f0a29cf3725d7323c961938e5">const_iterator</a> TrilinosWrappers::SparseMatrix::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>STL-like iterator with the first entry. </p>

</div>
</div>
<a class="anchor" id="ac9e8fbb957d4f10f5123515779fa96ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a2b7cd05f0a29cf3725d7323c961938e5">const_iterator</a> TrilinosWrappers::SparseMatrix::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Final iterator. </p>

</div>
</div>
<a class="anchor" id="aa7fa7748ecbb2cbb7c09a5f176dc980d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a2b7cd05f0a29cf3725d7323c961938e5">const_iterator</a> TrilinosWrappers::SparseMatrix::begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a>&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>STL-like iterator with the first entry of row <code>r</code>.</p>
<p>Note that if the given row is empty, i.e. does not contain any nonzero entries, then the iterator returned by this function equals <code>end(r)</code>. Note also that the iterator may not be dereferencable in that case. </p>

</div>
</div>
<a class="anchor" id="ad863c5a72b9109989231f9f1096cebbe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a2b7cd05f0a29cf3725d7323c961938e5">const_iterator</a> TrilinosWrappers::SparseMatrix::end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a>&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Final iterator of row <code>r</code>. It points to the first element past the end of line <code>r</code>, or past the end of the entire sparsity pattern.</p>
<p>Note that the end iterator is not necessarily dereferencable. This is in particular the case if it is the end iterator for the last row of a matrix. </p>

</div>
</div>
<a class="anchor" id="a432dd81dc9b1c3446d2b35dd902af016"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#af2bbbe25812a885629f61c0adb78161d">iterator</a> TrilinosWrappers::SparseMatrix::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>STL-like iterator with the first entry. </p>

</div>
</div>
<a class="anchor" id="a818f02479da77b15b295090b8d379bb5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#af2bbbe25812a885629f61c0adb78161d">iterator</a> TrilinosWrappers::SparseMatrix::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Final iterator. </p>

</div>
</div>
<a class="anchor" id="ac801a93ef57d40f3fbe36ca10909e47f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#af2bbbe25812a885629f61c0adb78161d">iterator</a> TrilinosWrappers::SparseMatrix::begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a>&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>STL-like iterator with the first entry of row <code>r</code>.</p>
<p>Note that if the given row is empty, i.e. does not contain any nonzero entries, then the iterator returned by this function equals <code>end(r)</code>. Note also that the iterator may not be dereferencable in that case. </p>

</div>
</div>
<a class="anchor" id="aba4773e90eb187a3432dd2b69fe28273"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#af2bbbe25812a885629f61c0adb78161d">iterator</a> TrilinosWrappers::SparseMatrix::end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a>&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Final iterator of row <code>r</code>. It points to the first element past the end of line <code>r</code>, or past the end of the entire sparsity pattern.</p>
<p>Note that the end iterator is not necessarily dereferencable. This is in particular the case if it is the end iterator for the last row of a matrix. </p>

</div>
</div>
<a class="anchor" id="ad1ca55b69b500064092c37d2bca0145f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparseMatrix::write_ascii </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Abstract Trilinos object that helps view in ASCII other Trilinos objects. Currently this function is not implemented. TODO: Not implemented. </p>

</div>
</div>
<a class="anchor" id="a191b64cb5ca360258c0389ac778079b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparseMatrix::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>write_extended_trilinos_info</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print the matrix to the given stream, using the format <code>(line,col) value</code>, i.e. one nonzero entry of the matrix per line. The optional flag outputs the sparsity pattern in Trilinos style, where the data is sorted according to the processor number when printed to the stream, as well as a summary of the matrix like the global size. </p>

</div>
</div>
<a class="anchor" id="a536e7d727e8394586b4c2dde99b39ba3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparseMatrix::prepare_add </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For some matrix storage formats, in particular for the PETSc distributed blockmatrices, set and add operations on individual elements can not be freely mixed. Rather, one has to synchronize operations when one wants to switch from setting elements to adding to elements. <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a> automatically synchronizes the access by calling this helper function for each block. This function ensures that the matrix is in a state that allows adding elements; if it previously already was in this state, the function does nothing. </p>

</div>
</div>
<a class="anchor" id="a68a6620012e379b4c660fb4431d817fb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparseMatrix::prepare_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a536e7d727e8394586b4c2dde99b39ba3">prepare_add()</a> but prepare the matrix for setting elements if the representation of elements in this class requires such an operation. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="a0eb72d666c41a0ac3c16def795c0c99b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>To allow calling protected <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a536e7d727e8394586b4c2dde99b39ba3">prepare_add()</a> and <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a68a6620012e379b4c660fb4431d817fb">prepare_set()</a>. </p>

<p>Definition at line <a class="el" href="trilinos__sparse__matrix_8h_source.html#l02550">2550</a> of file <a class="el" href="trilinos__sparse__matrix_8h_source.html">trilinos_sparse_matrix.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a664a863fb861b74913054988f12818df"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std_cxx1x::shared_ptr&lt;Epetra_Map&gt; TrilinosWrappers::SparseMatrix::column_space_map</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pointer to the user-supplied Epetra Trilinos mapping of the matrix columns that assigns parts of the matrix to the individual processes. </p>

<p>Definition at line <a class="el" href="trilinos__sparse__matrix_8h_source.html#l02501">2501</a> of file <a class="el" href="trilinos__sparse__matrix_8h_source.html">trilinos_sparse_matrix.h</a>.</p>

</div>
</div>
<a class="anchor" id="a72eb041778036fdf9fd412957532a5af"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std_cxx1x::shared_ptr&lt;Epetra_FECrsMatrix&gt; TrilinosWrappers::SparseMatrix::matrix</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A sparse matrix object in Trilinos to be used for finite element based problems which allows for assembling into non-local elements. The actual type, a sparse matrix, is set in the constructor. </p>

<p>Definition at line <a class="el" href="trilinos__sparse__matrix_8h_source.html#l02513">2513</a> of file <a class="el" href="trilinos__sparse__matrix_8h_source.html">trilinos_sparse_matrix.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3c1d6236f2215737135912c25cc993b0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Epetra_CombineMode TrilinosWrappers::SparseMatrix::last_action</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Trilinos doesn't allow to mix additions to matrix entries and overwriting them (to make synchronisation of parallel computations simpler). The way we do it is to, for each access operation, store whether it is an insertion or an addition. If the previous one was of different type, then we first have to flush the Trilinos buffers; otherwise, we can simply go on. Luckily, Trilinos has an object for this which does already all the parallel communications in such a case, so we simply use their model, which stores whether the last operation was an addition or an insertion. </p>

<p>Definition at line <a class="el" href="trilinos__sparse__matrix_8h_source.html#l02536">2536</a> of file <a class="el" href="trilinos__sparse__matrix_8h_source.html">trilinos_sparse_matrix.h</a>.</p>

</div>
</div>
<a class="anchor" id="a896761c5d6156507d191a404ca7dc8c3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TrilinosWrappers::SparseMatrix::compressed</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A boolean variable to hold information on whether the vector is compressed or not. </p>

<p>Definition at line <a class="el" href="trilinos__sparse__matrix_8h_source.html#l02543">2543</a> of file <a class="el" href="trilinos__sparse__matrix_8h_source.html">trilinos_sparse_matrix.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/deal.II/lac/<a class="el" href="trilinos__sparse__matrix_8h_source.html">trilinos_sparse_matrix.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jan 27 2014 15:27:26 for The deal.II Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
