<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>The deal.II Library: SolutionTransfer&lt; dim, VECTOR, DH &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="http://www.dealii.org/deal.ico"></link>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2014 by the deal.II authors"></meta>
<meta name="deal.II-version" content="8.1.0"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 8.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classSolutionTransfer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SolutionTransfer&lt; dim, VECTOR, DH &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__numerics.html">Numerical algorithms</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="numerics_2solution__transfer_8h_source.html">solution_transfer.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSolutionTransfer_1_1Pointerstruct.html">Pointerstruct</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a43a458c46a0cb74ba8439b87828cf140"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolutionTransfer.html#a43a458c46a0cb74ba8439b87828cf140">SolutionTransfer</a> (const DH &amp;dof)</td></tr>
<tr class="separator:a43a458c46a0cb74ba8439b87828cf140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acec4e48da94c77310d4ed8509ebd6958"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolutionTransfer.html#acec4e48da94c77310d4ed8509ebd6958">~SolutionTransfer</a> ()</td></tr>
<tr class="separator:acec4e48da94c77310d4ed8509ebd6958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a624673452cbb65fd6872b2d853551599"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolutionTransfer.html#a624673452cbb65fd6872b2d853551599">clear</a> ()</td></tr>
<tr class="separator:a624673452cbb65fd6872b2d853551599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00f91378647b9b75112db929749f49b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolutionTransfer.html#a00f91378647b9b75112db929749f49b0">prepare_for_pure_refinement</a> ()</td></tr>
<tr class="separator:a00f91378647b9b75112db929749f49b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8965f94a35be07bb187ca4a28fb3833b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolutionTransfer.html#a8965f94a35be07bb187ca4a28fb3833b">prepare_for_coarsening_and_refinement</a> (const std::vector&lt; VECTOR &gt; &amp;all_in)</td></tr>
<tr class="separator:a8965f94a35be07bb187ca4a28fb3833b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5992c56d6084b4073b38af04ebf62e50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolutionTransfer.html#a5992c56d6084b4073b38af04ebf62e50">prepare_for_coarsening_and_refinement</a> (const VECTOR &amp;in)</td></tr>
<tr class="separator:a5992c56d6084b4073b38af04ebf62e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2719944d34080ab8a0a219a0bf56303"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolutionTransfer.html#af2719944d34080ab8a0a219a0bf56303">refine_interpolate</a> (const VECTOR &amp;in, VECTOR &amp;out) const </td></tr>
<tr class="separator:af2719944d34080ab8a0a219a0bf56303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac74c38d3237ff7eee950e59ea001aeb9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolutionTransfer.html#ac74c38d3237ff7eee950e59ea001aeb9">interpolate</a> (const std::vector&lt; VECTOR &gt; &amp;all_in, std::vector&lt; VECTOR &gt; &amp;all_out) const </td></tr>
<tr class="separator:ac74c38d3237ff7eee950e59ea001aeb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98ae4d8a6174b72518474098856c42b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolutionTransfer.html#a98ae4d8a6174b72518474098856c42b9">interpolate</a> (const VECTOR &amp;in, VECTOR &amp;out) const </td></tr>
<tr class="separator:a98ae4d8a6174b72518474098856c42b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a547bf583d0fd3d01c6b4bf729c706e"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolutionTransfer.html#a0a547bf583d0fd3d01c6b4bf729c706e">memory_consumption</a> () const </td></tr>
<tr class="separator:a0a547bf583d0fd3d01c6b4bf729c706e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab57f3b985423e2540373553481845034"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolutionTransfer.html#ab57f3b985423e2540373553481845034">DeclException0</a> (ExcNotPrepared)</td></tr>
<tr class="separator:ab57f3b985423e2540373553481845034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef4cad8f0bcbd21ed73c36f2da48c379"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolutionTransfer.html#aef4cad8f0bcbd21ed73c36f2da48c379">DeclException0</a> (ExcAlreadyPrepForRef)</td></tr>
<tr class="separator:aef4cad8f0bcbd21ed73c36f2da48c379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb9973083375d509658582e06d465b9c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolutionTransfer.html#adb9973083375d509658582e06d465b9c">DeclException0</a> (ExcAlreadyPrepForCoarseAndRef)</td></tr>
<tr class="separator:adb9973083375d509658582e06d465b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab96c183943c9cf85e4fd201df3dcd96"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolutionTransfer.html#aab96c183943c9cf85e4fd201df3dcd96">DeclException0</a> (ExcTriaPrepCoarseningNotCalledBefore)</td></tr>
<tr class="separator:aab96c183943c9cf85e4fd201df3dcd96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64b5ef2606ff1b505d94e95a790601b2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolutionTransfer.html#a64b5ef2606ff1b505d94e95a790601b2">DeclException0</a> (ExcNoInVectorsGiven)</td></tr>
<tr class="separator:a64b5ef2606ff1b505d94e95a790601b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a805d5673cb2b8d0f33c142f2dffdedd6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolutionTransfer.html#a805d5673cb2b8d0f33c142f2dffdedd6">DeclException0</a> (ExcVectorsDifferFromInVectors)</td></tr>
<tr class="separator:a805d5673cb2b8d0f33c142f2dffdedd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1119f5912c2e00e0932b5c19a2882e23"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolutionTransfer.html#a1119f5912c2e00e0932b5c19a2882e23">DeclException0</a> (ExcNumberOfDoFsPerCellHasChanged)</td></tr>
<tr class="separator:a1119f5912c2e00e0932b5c19a2882e23"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:ad03cb34b1ace26f6cc38e9ecaa5eab46"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolutionTransfer.html#ad03cb34b1ace26f6cc38e9ecaa5eab46">PreparationState</a> { <b>none</b>, 
<b>pure_refinement</b>, 
<b>coarsening_and_refinement</b>
 }</td></tr>
<tr class="separator:ad03cb34b1ace26f6cc38e9ecaa5eab46"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a4e07acadd5ea119aa7d07710146a9189"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSmartPointer.html">SmartPointer</a>&lt; const DH, <br class="typebreak"/>
<a class="el" href="classSolutionTransfer.html">SolutionTransfer</a>&lt; dim, VECTOR, <br class="typebreak"/>
DH &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolutionTransfer.html#a4e07acadd5ea119aa7d07710146a9189">dof_handler</a></td></tr>
<tr class="separator:a4e07acadd5ea119aa7d07710146a9189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a908c9c59caf3c02e05ea265d1f112e3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolutionTransfer.html#a908c9c59caf3c02e05ea265d1f112e3d">n_dofs_old</a></td></tr>
<tr class="separator:a908c9c59caf3c02e05ea265d1f112e3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d964fbe6490c9dea754a5c0b13c2dc0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSolutionTransfer.html#ad03cb34b1ace26f6cc38e9ecaa5eab46">PreparationState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolutionTransfer.html#a4d964fbe6490c9dea754a5c0b13c2dc0">prepared_for</a></td></tr>
<tr class="separator:a4d964fbe6490c9dea754a5c0b13c2dc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6021a90fcf7c90ef2698de488e51d79c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector<br class="typebreak"/>
&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolutionTransfer.html#a6021a90fcf7c90ef2698de488e51d79c">indices_on_cell</a></td></tr>
<tr class="separator:a6021a90fcf7c90ef2698de488e51d79c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3074688b798cf78b200f78bf230baa0f"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::pair&lt; unsigned <br class="typebreak"/>
<a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;<br class="typebreak"/>
, <a class="el" href="structSolutionTransfer_1_1Pointerstruct.html">Pointerstruct</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolutionTransfer.html#a3074688b798cf78b200f78bf230baa0f">cell_map</a></td></tr>
<tr class="separator:a3074688b798cf78b200f78bf230baa0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab002b15566e73d59fbc0eb04847221a7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector<br class="typebreak"/>
&lt; <a class="el" href="classVector.html">Vector</a>&lt; typename <br class="typebreak"/>
VECTOR::value_type &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolutionTransfer.html#ab002b15566e73d59fbc0eb04847221a7">dof_values_on_cell</a></td></tr>
<tr class="separator:ab002b15566e73d59fbc0eb04847221a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int dim, typename VECTOR = Vector&lt;double&gt;, class DH = DoFHandler&lt;dim&gt;&gt;<br/>
class SolutionTransfer&lt; dim, VECTOR, DH &gt;</h3>

<p>This class implements the transfer of a discrete FE function (e.g. a solution vector) from one mesh to another that is obtained by the first by a single refinement and/or coarsening step. During interpolation the vector is reinitialized to the new size and filled with the interpolated values. This class is used in the <a class="el" href="step_15.html">step-15</a>, <a class="el" href="step_31.html">step-31</a>, and <a class="el" href="step_33.html">step-33</a> tutorial programs.</p>
<h3>Usage</h3>
<p>This class implements the algorithms in two different ways:</p>
<ul>
<li>
<p class="startli">If the grid will only be refined (i.e. no cells are coarsened) then use <code><a class="el" href="classSolutionTransfer.html">SolutionTransfer</a></code> as follows: </p>
<div class="fragment"><div class="line"><a class="code" href="classSolutionTransfer.html">SolutionTransfer&lt;dim, double&gt;</a> soltrans(*<a class="code" href="classSolutionTransfer.html#a4e07acadd5ea119aa7d07710146a9189">dof_handler</a>);</div>
<div class="line">                                    <span class="comment">// flag some cells for refinement, e.g.</span></div>
<div class="line"><a class="code" href="namespaceGridRefinement.html#a2c366e520528adc37e14649ee713156e">GridRefinement::refine_and_coarsen_fixed_fraction</a>(</div>
<div class="line">  *tria, error_indicators, 0.3, 0);</div>
<div class="line">                                    <span class="comment">// prepare the triangulation</span></div>
<div class="line">                                    <span class="comment">// for refinement,</span></div>
<div class="line">tria-&gt;prepare_coarsening_and_refinement();</div>
<div class="line">                                    <span class="comment">// tell the SolutionTransfer object</span></div>
<div class="line">                                    <span class="comment">// that we intend to do pure refinement,</span></div>
<div class="line">soltrans.prepare_for_pure_refinement();</div>
<div class="line">                                    <span class="comment">// actually execute the refinement,</span></div>
<div class="line">tria-&gt;execute_coarsening_and_refinement();</div>
<div class="line">                                    <span class="comment">// and redistribute dofs.</span></div>
<div class="line"><a class="code" href="classSolutionTransfer.html#a4e07acadd5ea119aa7d07710146a9189">dof_handler</a>-&gt;distribute_dofs (fe);</div>
</div><!-- fragment --><p>Then to proceed do </p>
<div class="fragment"><div class="line">                                    <span class="comment">// take a copy of the solution vector</span></div>
<div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a> solution_old(solution);</div>
<div class="line">                                    <span class="comment">// resize solution vector to the correct</span></div>
<div class="line">                                    <span class="comment">// size, as the @p refine_interpolate</span></div>
<div class="line">                                    <span class="comment">// function requires the vectors to be</span></div>
<div class="line">                                    <span class="comment">// of right sizes</span></div>
<div class="line">solution.reinit(<a class="code" href="classSolutionTransfer.html#a4e07acadd5ea119aa7d07710146a9189">dof_handler</a>-&gt;n_dofs());</div>
<div class="line">                                    <span class="comment">// and finally interpolate</span></div>
<div class="line">soltrans.refine_interpolate(solution_old, solution);</div>
</div><!-- fragment --><p>Although the <code>refine_interpolate</code> functions are allowed to be called multiple times, e.g. for interpolating several solution vectors, there is following possibility of interpolating several functions simultaneously. </p>
<div class="fragment"><div class="line">vector&lt;Vector&lt;double&gt; &gt; solutions_old(n_vectors, <a class="code" href="classVector.html">Vector&lt;double&gt;</a> (n));</div>
<div class="line">...</div>
<div class="line">vector&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &gt; solutions(n_vectors, <a class="code" href="classVector.html">Vector&lt;double&gt;</a> (n));</div>
<div class="line">soltrans.refine_interpolate(solutions_old, solutions);</div>
</div><!-- fragment --><p> This is used in several of the tutorial programs, for example <a class="el" href="step_31.html">step-31</a>.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">If the grid has cells that will be coarsened, then use <code><a class="el" href="classSolutionTransfer.html">SolutionTransfer</a></code> as follows: </p>
<div class="fragment"><div class="line"><a class="code" href="classSolutionTransfer.html">SolutionTransfer&lt;dim, Vector&lt;double&gt;</a> &gt; soltrans(*<a class="code" href="classSolutionTransfer.html#a4e07acadd5ea119aa7d07710146a9189">dof_handler</a>);</div>
<div class="line">                                    <span class="comment">// flag some cells for refinement</span></div>
<div class="line">                                    <span class="comment">// and coarsening, e.g.</span></div>
<div class="line"><a class="code" href="namespaceGridRefinement.html#a2c366e520528adc37e14649ee713156e">GridRefinement::refine_and_coarsen_fixed_fraction</a>(</div>
<div class="line">  *tria, error_indicators, 0.3, 0.05);</div>
<div class="line">                                    <span class="comment">// prepare the triangulation,</span></div>
<div class="line">tria-&gt;prepare_coarsening_and_refinement();</div>
<div class="line">                                    <span class="comment">// prepare the SolutionTransfer object</span></div>
<div class="line">                                    <span class="comment">// for coarsening and refinement and give</span></div>
<div class="line">                                    <span class="comment">// the solution vector that we intend to</span></div>
<div class="line">                                    <span class="comment">// interpolate later,</span></div>
<div class="line">soltrans.prepare_for_coarsening_and_refinement(solution);</div>
<div class="line">                                    <span class="comment">// actually execute the refinement,</span></div>
<div class="line">tria-&gt;execute_coarsening_and_refinement ();</div>
<div class="line">                                    <span class="comment">// redistribute dofs,</span></div>
<div class="line"><a class="code" href="classSolutionTransfer.html#a4e07acadd5ea119aa7d07710146a9189">dof_handler</a>-&gt;distribute_dofs (fe);</div>
<div class="line">                                    <span class="comment">// and interpolate the solution</span></div>
<div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a> interpolate_solution(<a class="code" href="classSolutionTransfer.html#a4e07acadd5ea119aa7d07710146a9189">dof_handler</a>-&gt;n_dofs());</div>
<div class="line">soltrans.interpolate(solution, interpolated_solution);</div>
</div><!-- fragment --><p class="endli">Multiple calls to the function <code>interpolate (const <a class="el" href="classVector.html">Vector&lt;number&gt;</a> &amp;in, <a class="el" href="classVector.html">Vector&lt;number&gt;</a> &amp;out)</code> are NOT allowed. Interpolating several functions can be performed in one step by using <code>void interpolate (const vector&lt;<a class="el" href="classVector.html">Vector&lt;number&gt;</a> &gt;&amp;all_in, vector&lt;<a class="el" href="classVector.html">Vector&lt;number&gt;</a> &gt;&amp;all_out) const</code>, and using the respective <code>prepare_for_coarsening_and_refinement</code> function taking several vectors as input before actually refining and coarsening the triangulation (see there). </p>
</li>
</ul>
<p>For deleting all stored data in <code><a class="el" href="classSolutionTransfer.html">SolutionTransfer</a></code> and reinitializing it use the <code><a class="el" href="classSolutionTransfer.html#a624673452cbb65fd6872b2d853551599">clear()</a></code> function.</p>
<p>The template argument <code>number</code> denotes the data type of the vectors you want to transfer.</p>
<h3>Implementation</h3>
<ul>
<li>
<p class="startli">Solution transfer with only refinement. Assume that we have got a solution vector on the current (original) grid. Each entry of this vector belongs to one of the DoFs of the discretisation. If we now refine the grid then the calling of <a class="el" href="classDoFHandler.html#afcfcc3b473f444f50d206ae62dfe3694">DoFHandler::distribute_dofs()</a> will change at least some of the DoF indices. Hence we need to store the DoF indices of all active cells before the refinement. A pointer for each active cell is used to point to the vector of these DoF indices of that cell. This is done by <a class="el" href="classSolutionTransfer.html#a00f91378647b9b75112db929749f49b0">prepare_for_pure_refinement()</a>.</p>
<p>In the function <code>refine_interpolate(in,out)</code> and on each cell where the pointer is set (i.e. the cells that were active in the original grid) we can now access the local values of the solution vector <code>in</code> on that cell by using the stored DoF indices. These local values are interpolated and set into the vector <code>out</code> that is at the end the discrete function <code>in</code> interpolated on the refined mesh.</p>
<p>The <code>refine_interpolate(in,out)</code> function can be called multiple times for arbitrary many discrete functions (solution vectors) on the original grid.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Solution transfer with coarsening and refinement. After calling <a class="el" href="classTriangulation.html#ab9fa3177e0e43ab0cf243215d284a35a">Triangulation::prepare_coarsening_and_refinement</a> the coarsen flags of either all or none of the children of a (father-)cell are set. While coarsening (<a class="el" href="classTriangulation.html#aaedd900205c1879d8d9ef6ffe7d1a554">Triangulation::execute_coarsening_and_refinement</a>) the cells that are not needed any more will be deleted from the <a class="el" href="classTriangulation.html">Triangulation</a>.</p>
<p>For the interpolation from the (to be coarsenend) children to their father the children cells are needed. Hence this interpolation and the storing of the interpolated values of each of the discrete functions that we want to interpolate needs to take place before these children cells are coarsened (and deleted!!). Again a pointers for the relevant cells is set to point to these values (see below). Additionally the DoF indices of the cells that will not be coarsened need to be stored according to the solution transfer while pure refinement (cf there). All this is performed by <code>prepare_for_coarsening_and_refinement(all_in)</code> where the <code>vector&lt;<a class="el" href="classVector.html">Vector&lt;number&gt;</a> &gt;vector all_in</code> includes all discrete functions to be interpolated onto the new grid.</p>
<p>As we need two different kinds of pointers (<code>vector&lt;unsigned int&gt; *</code> for the Dof indices and <code>vector&lt;<a class="el" href="classVector.html">Vector&lt;number&gt;</a> &gt; *</code> for the interpolated DoF values) we use the <code><a class="el" href="structSolutionTransfer_1_1Pointerstruct.html">Pointerstruct</a></code> that includes both of these pointers and the pointer for each cell points to these <code>Pointerstructs</code>. On each cell only one of the two different pointers is used at one time hence we could use a <code>void * pointer</code> as <code>vector&lt;unsigned int&gt; *</code> at one time and as <code>vector&lt;<a class="el" href="classVector.html">Vector&lt;number&gt;</a> &gt; *</code> at the other but using this <code><a class="el" href="structSolutionTransfer_1_1Pointerstruct.html">Pointerstruct</a></code> in between makes the use of these pointers more safe and gives better possibility to expand their usage.</p>
<p class="endli">In <code>interpolate(all_in, all_out)</code> the refined cells are treated according to the solution transfer while pure refinement. Additionally, on each cell that is coarsened (hence previously was a father cell), the values of the discrete functions in <code>all_out</code> are set to the stored local interpolated values that are accessible due to the 'vector&lt;<a class="el" href="classVector.html">Vector&lt;number&gt;</a> &gt; *' pointer in <code><a class="el" href="structSolutionTransfer_1_1Pointerstruct.html">Pointerstruct</a></code> that is pointed to by the pointer of that cell. It is clear that <code>interpolate(all_in, all_out)</code> only can be called with the <code>vector&lt;<a class="el" href="classVector.html">Vector&lt;number&gt;</a> &gt; all_in</code> that previously was the parameter of the <code>prepare_for_coarsening_and_refinement(all_in)</code> function. Hence <code>interpolate(all_in, all_out)</code> can (in contrast to <code>refine_interpolate(in, out)</code>) only be called once. </p>
</li>
</ul>
<dl class="section author"><dt>Author</dt><dd>Ralf Hartmann, 1999 </dd></dl>

<p>Definition at line <a class="el" href="numerics_2solution__transfer_8h_source.html#l00205">205</a> of file <a class="el" href="numerics_2solution__transfer_8h_source.html">solution_transfer.h</a>.</p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="ad03cb34b1ace26f6cc38e9ecaa5eab46"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VECTOR = Vector&lt;double&gt;, class DH  = DoFHandler&lt;dim&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classSolutionTransfer.html#ad03cb34b1ace26f6cc38e9ecaa5eab46">SolutionTransfer::PreparationState</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Declaration of <code>PreparationState</code> that denotes the three possible states of the <code><a class="el" href="classSolutionTransfer.html">SolutionTransfer</a>:</code> being prepared for 'pure refinement', prepared for 'coarsening and refinement' or not prepared. </p>

<p>Definition at line <a class="el" href="numerics_2solution__transfer_8h_source.html#l00398">398</a> of file <a class="el" href="numerics_2solution__transfer_8h_source.html">solution_transfer.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a43a458c46a0cb74ba8439b87828cf140"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VECTOR = Vector&lt;double&gt;, class DH  = DoFHandler&lt;dim&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSolutionTransfer.html">SolutionTransfer</a>&lt; dim, VECTOR, DH &gt;::<a class="el" href="classSolutionTransfer.html">SolutionTransfer</a> </td>
          <td>(</td>
          <td class="paramtype">const DH &amp;&#160;</td>
          <td class="paramname"><em>dof</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor, takes the current <a class="el" href="classDoFHandler.html">DoFHandler</a> as argument. </p>

</div>
</div>
<a class="anchor" id="acec4e48da94c77310d4ed8509ebd6958"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VECTOR = Vector&lt;double&gt;, class DH  = DoFHandler&lt;dim&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSolutionTransfer.html">SolutionTransfer</a>&lt; dim, VECTOR, DH &gt;::~<a class="el" href="classSolutionTransfer.html">SolutionTransfer</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destructor </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a624673452cbb65fd6872b2d853551599"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VECTOR = Vector&lt;double&gt;, class DH  = DoFHandler&lt;dim&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSolutionTransfer.html">SolutionTransfer</a>&lt; dim, VECTOR, DH &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reinit this class to the state that it has directly after calling the Constructor </p>

</div>
</div>
<a class="anchor" id="a00f91378647b9b75112db929749f49b0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VECTOR = Vector&lt;double&gt;, class DH  = DoFHandler&lt;dim&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSolutionTransfer.html">SolutionTransfer</a>&lt; dim, VECTOR, DH &gt;::prepare_for_pure_refinement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prepares the <code><a class="el" href="classSolutionTransfer.html">SolutionTransfer</a></code> for pure refinement. It stores the dof indices of each cell. After calling this function only calling the <code>refine_interpolate</code> functions is allowed. </p>

</div>
</div>
<a class="anchor" id="a8965f94a35be07bb187ca4a28fb3833b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VECTOR = Vector&lt;double&gt;, class DH  = DoFHandler&lt;dim&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSolutionTransfer.html">SolutionTransfer</a>&lt; dim, VECTOR, DH &gt;::prepare_for_coarsening_and_refinement </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; VECTOR &gt; &amp;&#160;</td>
          <td class="paramname"><em>all_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prepares the <code><a class="el" href="classSolutionTransfer.html">SolutionTransfer</a></code> for coarsening and refinement. It stores the dof indices of each cell and stores the dof values of the vectors in <code>all_in</code> in each cell that'll be coarsened. <code>all_in</code> includes all vectors that are to be interpolated onto the new (refined and/or coarsenend) grid. </p>

</div>
</div>
<a class="anchor" id="a5992c56d6084b4073b38af04ebf62e50"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VECTOR = Vector&lt;double&gt;, class DH  = DoFHandler&lt;dim&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSolutionTransfer.html">SolutionTransfer</a>&lt; dim, VECTOR, DH &gt;::prepare_for_coarsening_and_refinement </td>
          <td>(</td>
          <td class="paramtype">const VECTOR &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as previous function but for only one discrete function to be interpolated. </p>

</div>
</div>
<a class="anchor" id="af2719944d34080ab8a0a219a0bf56303"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VECTOR = Vector&lt;double&gt;, class DH  = DoFHandler&lt;dim&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSolutionTransfer.html">SolutionTransfer</a>&lt; dim, VECTOR, DH &gt;::refine_interpolate </td>
          <td>(</td>
          <td class="paramtype">const VECTOR &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VECTOR &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function interpolates the discrete function <code>in</code>, which is a vector on the grid before the refinement, to the function <code>out</code> which then is a vector on the refined grid. It assumes the vectors having the right sizes (i.e. <code>in.size()==n_dofs_old</code>, <code>out.size()==n_dofs_refined</code>)</p>
<p>Calling this function is allowed only if <code>prepare_for_pure_refinement</code> is called and the refinement is executed before. Multiple calling of this function is allowed. e.g. for interpolating several functions. </p>

</div>
</div>
<a class="anchor" id="ac74c38d3237ff7eee950e59ea001aeb9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VECTOR = Vector&lt;double&gt;, class DH  = DoFHandler&lt;dim&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSolutionTransfer.html">SolutionTransfer</a>&lt; dim, VECTOR, DH &gt;::interpolate </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; VECTOR &gt; &amp;&#160;</td>
          <td class="paramname"><em>all_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; VECTOR &gt; &amp;&#160;</td>
          <td class="paramname"><em>all_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function interpolates the discrete functions that are stored in <code>all_in</code> onto the refined and/or coarsenend grid. It assumes the vectors in <code>all_in</code> denote the same vectors as in <code>all_in</code> as parameter of <code>prepare_for_refinement_and_coarsening(all_in)</code>. However, there is no way of verifying this internally, so be careful here.</p>
<p>Calling this function is allowed only if first <a class="el" href="classTriangulation.html#ab9fa3177e0e43ab0cf243215d284a35a">Triangulation::prepare_coarsening_and_refinement</a>, second <code><a class="el" href="classSolutionTransfer.html#a8965f94a35be07bb187ca4a28fb3833b">SolutionTransfer::prepare_for_coarsening_and_refinement</a></code>, an then third <a class="el" href="classTriangulation.html#aaedd900205c1879d8d9ef6ffe7d1a554">Triangulation::execute_coarsening_and_refinement</a> are called before. Multiple calling of this function is NOT allowed. Interpolating several functions can be performed in one step.</p>
<p>The number of output vectors is assumed to be the same as the number of input vectors. Also, the sizes of the output vectors are assumed to be of the right size (<code>n_dofs_refined</code>). Otherwise an assertion will be thrown. </p>

</div>
</div>
<a class="anchor" id="a98ae4d8a6174b72518474098856c42b9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VECTOR = Vector&lt;double&gt;, class DH  = DoFHandler&lt;dim&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSolutionTransfer.html">SolutionTransfer</a>&lt; dim, VECTOR, DH &gt;::interpolate </td>
          <td>(</td>
          <td class="paramtype">const VECTOR &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VECTOR &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as the previous function. It interpolates only one function. It assumes the vectors having the right sizes (i.e. <code>in.size()==n_dofs_old</code>, <code>out.size()==n_dofs_refined</code>)</p>
<p>Multiple calling of this function is NOT allowed. Interpolating several functions can be performed in one step by using <code>interpolate (all_in, all_out)</code> </p>

</div>
</div>
<a class="anchor" id="a0a547bf583d0fd3d01c6b4bf729c706e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VECTOR = Vector&lt;double&gt;, class DH  = DoFHandler&lt;dim&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classSolutionTransfer.html">SolutionTransfer</a>&lt; dim, VECTOR, DH &gt;::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine an estimate for the memory consumption (in bytes) of this object. </p>

</div>
</div>
<a class="anchor" id="ab57f3b985423e2540373553481845034"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VECTOR = Vector&lt;double&gt;, class DH  = DoFHandler&lt;dim&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSolutionTransfer.html">SolutionTransfer</a>&lt; dim, VECTOR, DH &gt;::DeclException0 </td>
          <td>(</td>
          <td class="paramtype">ExcNotPrepared&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exception </p>

</div>
</div>
<a class="anchor" id="aef4cad8f0bcbd21ed73c36f2da48c379"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VECTOR = Vector&lt;double&gt;, class DH  = DoFHandler&lt;dim&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSolutionTransfer.html">SolutionTransfer</a>&lt; dim, VECTOR, DH &gt;::DeclException0 </td>
          <td>(</td>
          <td class="paramtype">ExcAlreadyPrepForRef&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exception </p>

</div>
</div>
<a class="anchor" id="adb9973083375d509658582e06d465b9c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VECTOR = Vector&lt;double&gt;, class DH  = DoFHandler&lt;dim&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSolutionTransfer.html">SolutionTransfer</a>&lt; dim, VECTOR, DH &gt;::DeclException0 </td>
          <td>(</td>
          <td class="paramtype">ExcAlreadyPrepForCoarseAndRef&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exception </p>

</div>
</div>
<a class="anchor" id="aab96c183943c9cf85e4fd201df3dcd96"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VECTOR = Vector&lt;double&gt;, class DH  = DoFHandler&lt;dim&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSolutionTransfer.html">SolutionTransfer</a>&lt; dim, VECTOR, DH &gt;::DeclException0 </td>
          <td>(</td>
          <td class="paramtype">ExcTriaPrepCoarseningNotCalledBefore&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exception </p>

</div>
</div>
<a class="anchor" id="a64b5ef2606ff1b505d94e95a790601b2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VECTOR = Vector&lt;double&gt;, class DH  = DoFHandler&lt;dim&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSolutionTransfer.html">SolutionTransfer</a>&lt; dim, VECTOR, DH &gt;::DeclException0 </td>
          <td>(</td>
          <td class="paramtype">ExcNoInVectorsGiven&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exception </p>

</div>
</div>
<a class="anchor" id="a805d5673cb2b8d0f33c142f2dffdedd6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VECTOR = Vector&lt;double&gt;, class DH  = DoFHandler&lt;dim&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSolutionTransfer.html">SolutionTransfer</a>&lt; dim, VECTOR, DH &gt;::DeclException0 </td>
          <td>(</td>
          <td class="paramtype">ExcVectorsDifferFromInVectors&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exception </p>

</div>
</div>
<a class="anchor" id="a1119f5912c2e00e0932b5c19a2882e23"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VECTOR = Vector&lt;double&gt;, class DH  = DoFHandler&lt;dim&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSolutionTransfer.html">SolutionTransfer</a>&lt; dim, VECTOR, DH &gt;::DeclException0 </td>
          <td>(</td>
          <td class="paramtype">ExcNumberOfDoFsPerCellHasChanged&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exception </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a4e07acadd5ea119aa7d07710146a9189"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VECTOR = Vector&lt;double&gt;, class DH  = DoFHandler&lt;dim&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSmartPointer.html">SmartPointer</a>&lt;const DH,<a class="el" href="classSolutionTransfer.html">SolutionTransfer</a>&lt;dim,VECTOR,DH&gt; &gt; <a class="el" href="classSolutionTransfer.html">SolutionTransfer</a>&lt; dim, VECTOR, DH &gt;::dof_handler</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pointer to the degree of freedom handler to work with. </p>

<p>Definition at line <a class="el" href="numerics_2solution__transfer_8h_source.html#l00379">379</a> of file <a class="el" href="numerics_2solution__transfer_8h_source.html">solution_transfer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a908c9c59caf3c02e05ea265d1f112e3d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VECTOR = Vector&lt;double&gt;, class DH  = DoFHandler&lt;dim&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> <a class="el" href="classSolutionTransfer.html">SolutionTransfer</a>&lt; dim, VECTOR, DH &gt;::n_dofs_old</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stores the number of DoFs before the refinement and/or coarsening. </p>

<p>Definition at line <a class="el" href="numerics_2solution__transfer_8h_source.html#l00385">385</a> of file <a class="el" href="numerics_2solution__transfer_8h_source.html">solution_transfer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4d964fbe6490c9dea754a5c0b13c2dc0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VECTOR = Vector&lt;double&gt;, class DH  = DoFHandler&lt;dim&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSolutionTransfer.html#ad03cb34b1ace26f6cc38e9ecaa5eab46">PreparationState</a> <a class="el" href="classSolutionTransfer.html">SolutionTransfer</a>&lt; dim, VECTOR, DH &gt;::prepared_for</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Definition of the respective variable. </p>

<p>Definition at line <a class="el" href="numerics_2solution__transfer_8h_source.html#l00406">406</a> of file <a class="el" href="numerics_2solution__transfer_8h_source.html">solution_transfer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6021a90fcf7c90ef2698de488e51d79c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VECTOR = Vector&lt;double&gt;, class DH  = DoFHandler&lt;dim&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;<a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>&gt; &gt; <a class="el" href="classSolutionTransfer.html">SolutionTransfer</a>&lt; dim, VECTOR, DH &gt;::indices_on_cell</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Is used for <code>prepare_for_refining</code> (of course also for <code>repare_for_refining_and_coarsening</code>) and stores all dof indices of the cells that'll be refined </p>

<p>Definition at line <a class="el" href="numerics_2solution__transfer_8h_source.html#l00416">416</a> of file <a class="el" href="numerics_2solution__transfer_8h_source.html">solution_transfer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3074688b798cf78b200f78bf230baa0f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VECTOR = Vector&lt;double&gt;, class DH  = DoFHandler&lt;dim&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::pair&lt;unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>&gt;, <a class="el" href="structSolutionTransfer_1_1Pointerstruct.html">Pointerstruct</a>&gt; <a class="el" href="classSolutionTransfer.html">SolutionTransfer</a>&lt; dim, VECTOR, DH &gt;::cell_map</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Map mapping from level and index of cell to the <code>Pointerstructs</code> (cf. there). This map makes it possible to keep all the information needed to transfer the solution inside this object rather than using user pointers of the <a class="el" href="classTriangulation.html">Triangulation</a> for this purpose. </p>

<p>Definition at line <a class="el" href="numerics_2solution__transfer_8h_source.html#l00467">467</a> of file <a class="el" href="numerics_2solution__transfer_8h_source.html">solution_transfer.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab002b15566e73d59fbc0eb04847221a7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VECTOR = Vector&lt;double&gt;, class DH  = DoFHandler&lt;dim&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;<a class="el" href="classVector.html">Vector</a>&lt;typename VECTOR::value_type&gt; &gt; &gt; <a class="el" href="classSolutionTransfer.html">SolutionTransfer</a>&lt; dim, VECTOR, DH &gt;::dof_values_on_cell</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Is used for <code>prepare_for_refining_and_coarsening</code> The interpolated dof values of all cells that'll be coarsened will be stored in this vector. </p>

<p>Definition at line <a class="el" href="numerics_2solution__transfer_8h_source.html#l00476">476</a> of file <a class="el" href="numerics_2solution__transfer_8h_source.html">solution_transfer.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/deal.II/numerics/<a class="el" href="numerics_2solution__transfer_8h_source.html">solution_transfer.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jan 27 2014 15:27:21 for The deal.II Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
