<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>The deal.II Library: TableHandler Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="http://www.dealii.org/deal.ico"></link>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2014 by the deal.II authors"></meta>
<meta name="deal.II-version" content="8.1.0"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 8.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classTableHandler-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">TableHandler Class Reference<div class="ingroups"><a class="el" href="group__textoutput.html">Textual output</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="table__handler_8h_source.html">table_handler.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for TableHandler:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classTableHandler__inherit__graph.svg" width="142" height="118"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTableHandler_1_1Column.html">Column</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a84255fd53f3c75dcbdc4706079d56d8a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableHandler.html#a84255fd53f3c75dcbdc4706079d56d8a">TextOutputFormat</a> { <b>table_with_headers</b>, 
<b>table_with_separate_column_description</b>, 
<b>simple_table_with_separate_column_description</b>, 
<b>org_mode_table</b>
 }</td></tr>
<tr class="separator:a84255fd53f3c75dcbdc4706079d56d8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7824771057567647419de994788c1b52"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableHandler.html#a7824771057567647419de994788c1b52">TableHandler</a> ()</td></tr>
<tr class="separator:a7824771057567647419de994788c1b52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5484a9516db419a90540a40aba4c6d84"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5484a9516db419a90540a40aba4c6d84"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTableHandler.html#a5484a9516db419a90540a40aba4c6d84">add_value</a> (const std::string &amp;key, const T value)</td></tr>
<tr class="separator:a5484a9516db419a90540a40aba4c6d84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cb7335fc1afcc338b6d57e43be39116"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableHandler.html#a4cb7335fc1afcc338b6d57e43be39116">set_auto_fill_mode</a> (const <a class="el" href="classbool.html">bool</a> state)</td></tr>
<tr class="separator:a4cb7335fc1afcc338b6d57e43be39116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3cd640c9e3a2736dfe5c345ebe652d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableHandler.html#ab3cd640c9e3a2736dfe5c345ebe652d1">add_column_to_supercolumn</a> (const std::string &amp;key, const std::string &amp;superkey)</td></tr>
<tr class="separator:ab3cd640c9e3a2736dfe5c345ebe652d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab83b34eb9cbd403bf2cff04d162ebccc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableHandler.html#ab83b34eb9cbd403bf2cff04d162ebccc">set_column_order</a> (const std::vector&lt; std::string &gt; &amp;new_order)</td></tr>
<tr class="separator:ab83b34eb9cbd403bf2cff04d162ebccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4766582d0900d3095fc2efad21ae83e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableHandler.html#af4766582d0900d3095fc2efad21ae83e">set_precision</a> (const std::string &amp;key, const unsigned <a class="el" href="classint.html">int</a> precision)</td></tr>
<tr class="separator:af4766582d0900d3095fc2efad21ae83e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aded59db14d0341e6ea6cc27165fa918d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableHandler.html#aded59db14d0341e6ea6cc27165fa918d">set_scientific</a> (const std::string &amp;key, const <a class="el" href="classbool.html">bool</a> scientific)</td></tr>
<tr class="separator:aded59db14d0341e6ea6cc27165fa918d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac85c292764a506f0691507a0d29b10ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableHandler.html#ac85c292764a506f0691507a0d29b10ff">set_tex_caption</a> (const std::string &amp;key, const std::string &amp;tex_caption)</td></tr>
<tr class="separator:ac85c292764a506f0691507a0d29b10ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36ab3fd473ea2f8a21d0bb914db59342"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableHandler.html#a36ab3fd473ea2f8a21d0bb914db59342">set_tex_table_caption</a> (const std::string &amp;table_caption)</td></tr>
<tr class="separator:a36ab3fd473ea2f8a21d0bb914db59342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed20f49e64bfc90d0ab72e6fad5376ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableHandler.html#aed20f49e64bfc90d0ab72e6fad5376ef">set_tex_table_label</a> (const std::string &amp;table_label)</td></tr>
<tr class="separator:aed20f49e64bfc90d0ab72e6fad5376ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3896a239cd72d9839f8a55db563f0f57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableHandler.html#a3896a239cd72d9839f8a55db563f0f57">set_tex_supercaption</a> (const std::string &amp;superkey, const std::string &amp;tex_supercaption)</td></tr>
<tr class="separator:a3896a239cd72d9839f8a55db563f0f57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11013123ef4b3e44e4ee22e40be21b67"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableHandler.html#a11013123ef4b3e44e4ee22e40be21b67">set_tex_format</a> (const std::string &amp;key, const std::string &amp;format=&quot;c&quot;)</td></tr>
<tr class="separator:a11013123ef4b3e44e4ee22e40be21b67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ede7ec19cb71266e90d378a9ffbbe39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableHandler.html#a9ede7ec19cb71266e90d378a9ffbbe39">write_text</a> (std::ostream &amp;out, const <a class="el" href="classTableHandler.html#a84255fd53f3c75dcbdc4706079d56d8a">TextOutputFormat</a> format=table_with_headers) const </td></tr>
<tr class="separator:a9ede7ec19cb71266e90d378a9ffbbe39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94498b8065fb16b372d267f3b2bdccf8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableHandler.html#a94498b8065fb16b372d267f3b2bdccf8">write_tex</a> (std::ostream &amp;file, const <a class="el" href="classbool.html">bool</a> with_header=true) const </td></tr>
<tr class="separator:a94498b8065fb16b372d267f3b2bdccf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3896c62fe9aeb1830446d9d1c27b1fdb"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a3896c62fe9aeb1830446d9d1c27b1fdb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTableHandler.html#a3896c62fe9aeb1830446d9d1c27b1fdb">serialize</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:a3896c62fe9aeb1830446d9d1c27b1fdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd64f7f124c25ccf2e02d5a9199ef77c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gadd64f7f124c25ccf2e02d5a9199ef77c">DeclException1</a> (ExcColumnNotExistent, std::string,&lt;&lt; &quot;Column &lt;&quot;&lt;&lt; arg1&lt;&lt; &quot;&gt; does not exist.&quot;)</td></tr>
<tr class="separator:gadd64f7f124c25ccf2e02d5a9199ef77c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27a206cfa10e3526f162154b3e3b7947"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga27a206cfa10e3526f162154b3e3b7947">DeclException1</a> (ExcSuperColumnNotExistent, std::string,&lt;&lt; &quot;Supercolumn &lt;&quot;&lt;&lt; arg1&lt;&lt; &quot;&gt; does not exist.&quot;)</td></tr>
<tr class="separator:ga27a206cfa10e3526f162154b3e3b7947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44bee5e917561abc21f11ffafc904589"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga44bee5e917561abc21f11ffafc904589">DeclException1</a> (ExcColumnOrSuperColumnNotExistent, std::string,&lt;&lt; &quot;Column or supercolumn &lt;&quot;&lt;&lt; arg1&lt;&lt; &quot;&gt; does not exist.&quot;)</td></tr>
<tr class="separator:ga44bee5e917561abc21f11ffafc904589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bb5743e959aa95111819585fae4c8bb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga2bb5743e959aa95111819585fae4c8bb">DeclException4</a> (ExcWrongNumberOfDataEntries, std::string, <a class="el" href="classint.html">int</a>, std::string, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;Column &lt;&quot;&lt;&lt; arg1&lt;&lt; &quot;&gt; has got &quot;&lt;&lt; arg2&lt;&lt; &quot; rows, but <a class="el" href="structTableHandler_1_1Column.html">Column</a> &lt;&quot;&lt;&lt; arg3&lt;&lt; &quot;&gt; has got &quot;&lt;&lt; arg4&lt;&lt; &quot;.&quot;)</td></tr>
<tr class="separator:ga2bb5743e959aa95111819585fae4c8bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6eb217eca389cc46ed040d829b86d717"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga6eb217eca389cc46ed040d829b86d717">DeclException1</a> (ExcUndefinedTexFormat, std::string,&lt;&lt; &quot;&lt;&quot;&lt;&lt; arg1&lt;&lt; &quot;&gt; is not a tex column format. Use l,c,r.&quot;)</td></tr>
<tr class="separator:ga6eb217eca389cc46ed040d829b86d717"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a06c8e231df6ef643358c2d4d30b842bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableHandler.html#a06c8e231df6ef643358c2d4d30b842bd">get_selected_columns</a> (std::vector&lt; std::string &gt; &amp;sel_columns) const </td></tr>
<tr class="separator:a06c8e231df6ef643358c2d4d30b842bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5bfe4e1abab2642b0a93b6179b4b72f"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableHandler.html#ac5bfe4e1abab2642b0a93b6179b4b72f">n_rows</a> () const </td></tr>
<tr class="separator:ac5bfe4e1abab2642b0a93b6179b4b72f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ae9eadbc232f49cf4a39b9eea5318b0c7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableHandler.html#ae9eadbc232f49cf4a39b9eea5318b0c7">column_order</a></td></tr>
<tr class="separator:ae9eadbc232f49cf4a39b9eea5318b0c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95732f88563631faaece286f842c0979"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="structTableHandler_1_1Column.html">Column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableHandler.html#a95732f88563631faaece286f842c0979">columns</a></td></tr>
<tr class="separator:a95732f88563631faaece286f842c0979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d8ccfeb4f8cb5df5ab21a8e1d53c3b3"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <br class="typebreak"/>
std::vector&lt; std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableHandler.html#a7d8ccfeb4f8cb5df5ab21a8e1d53c3b3">supercolumns</a></td></tr>
<tr class="separator:a7d8ccfeb4f8cb5df5ab21a8e1d53c3b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fadd66861022772b9901ee96b5b6004"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <br class="typebreak"/>
std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableHandler.html#a8fadd66861022772b9901ee96b5b6004">tex_supercaptions</a></td></tr>
<tr class="separator:a8fadd66861022772b9901ee96b5b6004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0920e405beec2a978f2921ccf88ea1d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableHandler.html#aa0920e405beec2a978f2921ccf88ea1d">tex_table_caption</a></td></tr>
<tr class="separator:aa0920e405beec2a978f2921ccf88ea1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98ba6a6cc6f4b5c170bdfc9bc0313e26"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableHandler.html#a98ba6a6cc6f4b5c170bdfc9bc0313e26">tex_table_label</a></td></tr>
<tr class="separator:a98ba6a6cc6f4b5c170bdfc9bc0313e26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a825579ea69b3eb16e52f1ec2673b6dec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableHandler.html#a825579ea69b3eb16e52f1ec2673b6dec">auto_fill_mode</a></td></tr>
<tr class="separator:a825579ea69b3eb16e52f1ec2673b6dec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="classTableHandler.html">TableHandler</a> stores TableEntries of arbitrary value type and writes the table as text or in tex format to an output stream. The value type actually may vary from column to column and from row to row.</p>
<h3>Usage</h3>
<p>The most important function is the templatized function <code><a class="el" href="classTableHandler.html#a5484a9516db419a90540a40aba4c6d84">add_value(const std::string &amp;key, const T value)</a></code> that adds a column with the name <code>key</code> to the table if this column does not yet exist and adds the given value of type <code>T</code> (which must be one of <code>int</code>, <code>unsigned int</code>, <code>double</code>, <code>std::string</code>) to this column. After the table is complete there are different possibilities of output, e.g., into a latex file with <a class="el" href="classTableHandler.html#a94498b8065fb16b372d267f3b2bdccf8">write_tex()</a> or as text with <a class="el" href="classTableHandler.html#a9ede7ec19cb71266e90d378a9ffbbe39">write_text()</a>.</p>
<p>Two (or more) columns may be merged into a "supercolumn" by twice (or multiple) calling <a class="el" href="classTableHandler.html#ab3cd640c9e3a2736dfe5c345ebe652d1">add_column_to_supercolumn()</a>, see there. Additionally there is a function to set for each column the precision of the output of numbers, and there are several functions to prescribe the format and the captions the columns are written with in tex mode.</p>
<p>A detailed explanation of this class is also given in the <a class="el" href="step_13.html">step-13</a> tutorial program.</p>
<h3>Example</h3>
<p>This is a simple example demonstrating the usage of this class. The first column includes the numbers <code>i=1..n</code>, the second <img class="formulaInl" alt="$1^2$" src="form_544.png"/>... <img class="formulaInl" alt="$n^2$" src="form_545.png"/>, the third <img class="formulaInl" alt="$sqrt(1)...sqrt(n)$" src="form_546.png"/>, where the second and third columns are merged into one supercolumn with the superkey <code>squares and roots</code>. Additionally the first column is aligned to the right (the default was <code>centered</code>) and the precision of the square roots are set to be 6 (instead of 4 as default).</p>
<div class="fragment"><div class="line"><a class="code" href="classTableHandler.html">TableHandler</a> table;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=1; i&lt;=n; ++i)</div>
<div class="line">  {</div>
<div class="line">    table.<a class="code" href="classTableHandler.html#a5484a9516db419a90540a40aba4c6d84">add_value</a>(<span class="stringliteral">&quot;numbers&quot;</span>, i);</div>
<div class="line">    table.<a class="code" href="classTableHandler.html#a5484a9516db419a90540a40aba4c6d84">add_value</a>(<span class="stringliteral">&quot;squares&quot;</span>, i*i);</div>
<div class="line">    table.<a class="code" href="classTableHandler.html#a5484a9516db419a90540a40aba4c6d84">add_value</a>(<span class="stringliteral">&quot;square roots&quot;</span>, sqrt(i));</div>
<div class="line">  }</div>
<div class="line">                                 <span class="comment">// merge the second and third column</span></div>
<div class="line">table.<a class="code" href="classTableHandler.html#ab3cd640c9e3a2736dfe5c345ebe652d1">add_column_to_supercolumn</a>(<span class="stringliteral">&quot;squares&quot;</span>, <span class="stringliteral">&quot;squares and roots&quot;</span>);</div>
<div class="line">table.<a class="code" href="classTableHandler.html#ab3cd640c9e3a2736dfe5c345ebe652d1">add_column_to_supercolumn</a>(<span class="stringliteral">&quot;square roots&quot;</span>, <span class="stringliteral">&quot;squares and roots&quot;</span>);</div>
<div class="line"></div>
<div class="line">                                 <span class="comment">// additional settings</span></div>
<div class="line">table.<a class="code" href="classTableHandler.html#a11013123ef4b3e44e4ee22e40be21b67">set_tex_format</a>(<span class="stringliteral">&quot;numbers&quot;</span>, <span class="stringliteral">&quot;r&quot;</span>);</div>
<div class="line">table.<a class="code" href="classTableHandler.html#af4766582d0900d3095fc2efad21ae83e">set_precision</a>(<span class="stringliteral">&quot;square roots&quot;</span>, 6);</div>
<div class="line"></div>
<div class="line">                                 <span class="comment">// output</span></div>
<div class="line">std::ofstream out_file(<span class="stringliteral">&quot;number_table.tex&quot;</span>);</div>
<div class="line">table.<a class="code" href="classTableHandler.html#a94498b8065fb16b372d267f3b2bdccf8">write_tex</a>(out_file);</div>
<div class="line">out_file.close();</div>
</div><!-- fragment --><h3>Dealing with sparse data: auto-fill mode</h3>
<p>When generating output, <a class="el" href="classTableHandler.html">TableHandler</a> expects that all columns have the exact same number of elements in it so that the result is in fact a table. This assumes that in each of the iterations (time steps, nonlinear iterations, etc) you fill every single column. On the other hand, this may not always be what you want to do. For example, it could be that the function that computes the nonlinear residual is only called every few time steps; or, a function computing statistics of the mesh is only called whenever the mesh is in fact refined. In these cases, the <a class="el" href="classTableHandler.html#a5484a9516db419a90540a40aba4c6d84">add_value()</a> function will be called less often for some columns and the column would therefore have fewer elements; furthermore, these elements would not be aligned with the rows that contain the other data elements that were produced during this iteration. An entirely different scenario is that the table is filled and at a later time we use the data in there to compute the elements of other rows; the <a class="el" href="classConvergenceTable.html">ConvergenceTable</a> class does something like this.</p>
<p>To support both scenarios, the <a class="el" href="classTableHandler.html">TableHandler</a> class has a property called <em>auto-fill mode</em>. By default, auto-fill mode is off, but it can be enabled by calling <a class="el" href="classTableHandler.html#a4cb7335fc1afcc338b6d57e43be39116">set_auto_fill_mode()</a>. If auto-fill mode is enabled we use the following algorithm:</p>
<ul>
<li>When calling <code>add_value(key, value)</code>, we count the number of elements in the column corresponding to <code>key</code>. Let's call this number <img class="formulaInl" alt="$m$" src="form_272.png"/>.</li>
<li>We also determine the maximal number of elements in the other columns; call it <img class="formulaInl" alt="$n$" src="form_156.png"/>.</li>
<li>If <img class="formulaInl" alt="$m < n-1$" src="form_547.png"/> then we add <img class="formulaInl" alt="$n-m-1$" src="form_548.png"/> copies of the object <code>T()</code> to this column. Here, <code>T</code> is the data type of the given <code>value</code>. For example, if <code>T</code> is a numeric type, then <code>T()</code> is the number zero; if <code>T</code> is <code>std::string</code>, then <code>T()</code> is the empty string <code>""</code>.</li>
<li>Add the given value to this column.</li>
</ul>
<p>Padding the column with default elements makes sure that after the addition the column has as many entries as the longest other column. In other words, if we have skipped previous invokations of <a class="el" href="classTableHandler.html#a5484a9516db419a90540a40aba4c6d84">add_value()</a> for a given key, then the padding will enter default values into this column.</p>
<p>The algorithm as described will fail if you try to skip adding values for a key if adding an element for this key is the first thing you want to do for a given iteration or time step, since we would then pad to the length of the longest column of the <em>previous</em> iteration or time step. You may have to re-order adding to this column to a different spot in your program, after adding to a column that will always be added to; or, you may want to start every iteration by adding the number of the iteration to the table, for example in column 1.</p>
<p>In the case above, we have always padded columns <b>above</b> the element that is being added to a column. However, there is also a case where we have to pad <b>below</b>. Namely, if a previous row has been completely filled using <a class="el" href="classTableHandler.html#a5484a9516db419a90540a40aba4c6d84">TableHandler::add_value()</a>, subsequent rows have been filled partially, and we then ask for output via <a class="el" href="classTableHandler.html#a9ede7ec19cb71266e90d378a9ffbbe39">write_text()</a> or <a class="el" href="classTableHandler.html#a94498b8065fb16b372d267f3b2bdccf8">write_tex()</a>. In that case, the last few rows that have been filled only partially need to be padded below the last element that has been added to them. As before, we do that by using default constructed objects of the same type as the last element of that column.</p>
<dl class="section author"><dt>Author</dt><dd>Ralf Hartmann, 1999; Wolfgang Bangerth, 2011 </dd></dl>

<p>Definition at line <a class="el" href="table__handler_8h_source.html#l00264">264</a> of file <a class="el" href="table__handler_8h_source.html">table_handler.h</a>.</p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="a84255fd53f3c75dcbdc4706079d56d8a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classTableHandler.html#a84255fd53f3c75dcbdc4706079d56d8a">TableHandler::TextOutputFormat</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set of options how a table should be formatted when output with the <a class="el" href="classTableHandler.html#a9ede7ec19cb71266e90d378a9ffbbe39">write_text()</a> function. The following possibilities exist:</p>
<ul>
<li><code>table_with_headers</code>: The table is formatted in such a way that the contents are aligned under the key of each column, i.e. the key sits atop each column. This is suitable for tables with few columns where the entire table can be displayed on the screen. Output looks like this: <div class="fragment"><div class="line">key1 key2 key3</div>
<div class="line">0    0    <span class="stringliteral">&quot;&quot;</span></div>
<div class="line">1    0    <span class="stringliteral">&quot;&quot;</span></div>
<div class="line">2    13   a</div>
<div class="line">1    0    <span class="stringliteral">&quot;&quot;</span></div>
</div><!-- fragment --></li>
<li><code>table_with_separate_column_description</code>: This is a better format when there are many columns and the table as a whole can not be displayed on the screen. Here, the column keys are first listed one-by-one on lines of their own, and are numbered for better readability. In addition, each of these description lines are prefixed by '#' to mark these lines as comments for programs that want to read the following table as data and should ignore these descriptive lines. GNUPLOT is one such program that will automatically ignore lines so prefixed. Output with this option looks like this: <div class="fragment"><div class="line"><span class="preprocessor"># 1: key1</span></div>
<div class="line"><span class="preprocessor"># 2: key2</span></div>
<div class="line"><span class="preprocessor"># 3: key3</span></div>
<div class="line">0 0  <span class="stringliteral">&quot;&quot;</span></div>
<div class="line">1 0  <span class="stringliteral">&quot;&quot;</span></div>
<div class="line">2 13 a</div>
<div class="line">1 0  <span class="stringliteral">&quot;&quot;</span></div>
</div><!-- fragment --></li>
<li><code>simple_table_with_separate_column_description</code>: This format is very similar to <code>table_with_separate_column_description</code>, but it skips aligning the columns with additional white space. This increases the performance o fwrite_text() for large tables. Example output: <div class="fragment"><div class="line"><span class="preprocessor"># 1: key1</span></div>
<div class="line"><span class="preprocessor"># 2: key2</span></div>
<div class="line"><span class="preprocessor"># 3: key3</span></div>
<div class="line">0 0 <span class="stringliteral">&quot;&quot;</span></div>
<div class="line">1 0 <span class="stringliteral">&quot;&quot;</span></div>
<div class="line">2 13 a</div>
<div class="line">1 0 <span class="stringliteral">&quot;&quot;</span></div>
</div><!-- fragment --></li>
<li><code>org_mode_table</code>: Outputs to org-mode (<a href="http://orgmode.org/">http://orgmode.org/</a>) table format. It is easy to convert org-mode tables to HTML/LaTeX/csv. Example output: <div class="fragment"><div class="line">| key1 | key2 | key3 |</div>
<div class="line">| 0    | 0    | <span class="stringliteral">&quot;&quot;</span>   |</div>
<div class="line">| 1    | 0    | <span class="stringliteral">&quot;&quot;</span>   |</div>
<div class="line">| 2    | 13   | a    |</div>
<div class="line">| 1    | 0    | <span class="stringliteral">&quot;&quot;</span>   |</div>
</div><!-- fragment --> </li>
</ul>

<p>Definition at line <a class="el" href="table__handler_8h_source.html#l00325">325</a> of file <a class="el" href="table__handler_8h_source.html">table_handler.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a7824771057567647419de994788c1b52"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TableHandler::TableHandler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a5484a9516db419a90540a40aba4c6d84"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TableHandler::add_value </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a column (if not yet existent) with the key <code>key</code> and adds the value of type <code>T</code> to the column. Values of type <code>T</code> must be convertible to one of <code>int, unsigned int, double, std::string</code> or a compiler error will result. </p>

<p>Definition at line <a class="el" href="table__handler_8h_source.html#l00884">884</a> of file <a class="el" href="table__handler_8h_source.html">table_handler.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4cb7335fc1afcc338b6d57e43be39116"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TableHandler::set_auto_fill_mode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Switch auto-fill mode on or off. See the general documentation of this class for a description of what auto-fill mode does. </p>

</div>
</div>
<a class="anchor" id="ab3cd640c9e3a2736dfe5c345ebe652d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TableHandler::add_column_to_supercolumn </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>superkey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a supercolumn (if not yet existent) and includes column to it. The keys of the column and the supercolumn are <code>key</code> and <code>superkey</code>, respectively. To merge two columns <code>c1</code> and <code>c2</code> to a supercolumn <code>sc</code> hence call <code>add_column_to_supercolumn(c1,sc)</code> and <code>add_column_to_supercolumn(c2,sc)</code>.</p>
<p>Concerning the order of the columns, the supercolumn replaces the first column that is added to the supercolumn. Within the supercolumn the order of output follows the order the columns are added to the supercolumn. </p>

</div>
</div>
<a class="anchor" id="ab83b34eb9cbd403bf2cff04d162ebccc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TableHandler::set_column_order </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_order</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change the order of columns and supercolumns in the table.</p>
<p><code>new_order</code> includes the keys and superkeys of the columns and supercolumns in the order the user like to. If a superkey is included the keys of the subcolumns need not to be additionally mentioned in this vector. The order of subcolumns within a supercolumn is not changeable and keeps the order in which the columns are added to the supercolumn.</p>
<p>This function may also be used to break big tables with too many columns into smaller ones. Call this function with the first e.g. five columns and then <code>write_*</code>. Afterwards call this function with the next e.g. five columns and again <code>write_*</code>, and so on. </p>

</div>
</div>
<a class="anchor" id="af4766582d0900d3095fc2efad21ae83e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TableHandler::set_precision </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>precision</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the <code>precision</code> e.g. double or float variables are written with. <code>precision</code> is the same as in calling <code>out&lt;&lt;setprecision(precision)</code>. </p>

</div>
</div>
<a class="anchor" id="aded59db14d0341e6ea6cc27165fa918d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TableHandler::set_scientific </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>scientific</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the <code>scientific_flag</code>. True means scientific, false means fixed point notation. </p>

</div>
</div>
<a class="anchor" id="ac85c292764a506f0691507a0d29b10ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TableHandler::set_tex_caption </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tex_caption</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the caption of the column <code>key</code> for tex output. You may want to chose this different from <code>key</code>, if it contains formulas or similar constructs. </p>

</div>
</div>
<a class="anchor" id="a36ab3fd473ea2f8a21d0bb914db59342"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TableHandler::set_tex_table_caption </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>table_caption</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the tex caption of the entire <code>table</code> for tex output. </p>

</div>
</div>
<a class="anchor" id="aed20f49e64bfc90d0ab72e6fad5376ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TableHandler::set_tex_table_label </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>table_label</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the label of this <code>table</code> for tex output. </p>

</div>
</div>
<a class="anchor" id="a3896a239cd72d9839f8a55db563f0f57"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TableHandler::set_tex_supercaption </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>superkey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tex_supercaption</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the caption the the supercolumn <code>superkey</code> for tex output. You may want to chose this different from <code>superkey</code>, if it contains formulas or similar constructs. </p>

</div>
</div>
<a class="anchor" id="a11013123ef4b3e44e4ee22e40be21b67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TableHandler::set_tex_format </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>format</em> = <code>&quot;c&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the tex output format of a column, e.g. <code>c</code>, <code>r</code>, <code>l</code>, or <code>p{3cm}</code>. The default is <code>c</code>. Also if this function is not called for a column, the default is preset to be <code>c</code>. </p>

</div>
</div>
<a class="anchor" id="a9ede7ec19cb71266e90d378a9ffbbe39"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TableHandler::write_text </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTableHandler.html#a84255fd53f3c75dcbdc4706079d56d8a">TextOutputFormat</a>&#160;</td>
          <td class="paramname"><em>format</em> = <code>table_with_headers</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write table as formatted text to the given stream. The text is formatted in such as way that it represents data as formatted columns of text. To avoid problems when reading these tables automatically, for example for postprocessing, if an entry in a cell of this table is empty (i.e. it has been created by calling the <a class="el" href="classTableHandler.html#a5484a9516db419a90540a40aba4c6d84">add_value()</a> function with an empty string), then the entry of the table is printed as <code>""</code>.</p>
<p>The second argument indicates how column keys are to be displayed. See the description of TextOutputFormat for more information </p>

</div>
</div>
<a class="anchor" id="a94498b8065fb16b372d267f3b2bdccf8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TableHandler::write_tex </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>with_header</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write table as a tex file. If with_header is set to false (it is true by default), then no "\documentclass{...}", "\begin{document}" and "\end{document}" are used. In this way the file can be included into an existing tex file using a command like "\input{table_file}". </p>

</div>
</div>
<a class="anchor" id="a3896c62fe9aeb1830446d9d1c27b1fdb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TableHandler::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read or write the data of this object to or from a stream for the purpose of serialization. </p>

<p>Definition at line <a class="el" href="table__handler_8h_source.html#l00946">946</a> of file <a class="el" href="table__handler_8h_source.html">table_handler.h</a>.</p>

</div>
</div>
<a class="anchor" id="a06c8e231df6ef643358c2d4d30b842bd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TableHandler::get_selected_columns </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>sel_columns</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Help function that gives a vector of the keys of all columns that are mentioned in <code>column_order</code>, where each supercolumn key is replaced by its subcolumn keys.</p>
<p>This function implicitly checks the consistency of the data. The result is returned in <code>sel_columns</code>. </p>

</div>
</div>
<a class="anchor" id="ac5bfe4e1abab2642b0a93b6179b4b72f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> TableHandler::n_rows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Builtin function, that gives the number of rows in the table and that checks if the number of rows is equal in every column. This function is e.g. called before writing output. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="ae9eadbc232f49cf4a39b9eea5318b0c7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; TableHandler::column_order</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stores the column and supercolumn keys in the order desired by the user. By default this is the order of adding the columns. This order may be changed by <code>set_column_order(...)</code>. </p>

<p>Definition at line <a class="el" href="table__handler_8h_source.html#l00711">711</a> of file <a class="el" href="table__handler_8h_source.html">table_handler.h</a>.</p>

</div>
</div>
<a class="anchor" id="a95732f88563631faaece286f842c0979"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string,<a class="el" href="structTableHandler_1_1Column.html">Column</a>&gt; TableHandler::columns</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Maps the column keys to the columns (not supercolumns).</p>
<p>The field is declared mutable so that the <a class="el" href="classTableHandler.html#a9ede7ec19cb71266e90d378a9ffbbe39">write_text()</a> and <a class="el" href="classTableHandler.html#a94498b8065fb16b372d267f3b2bdccf8">write_tex()</a> functions can be const, even though they may pad columns below if auto_fill_mode is on. </p>

<p>Definition at line <a class="el" href="table__handler_8h_source.html#l00723">723</a> of file <a class="el" href="table__handler_8h_source.html">table_handler.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7d8ccfeb4f8cb5df5ab21a8e1d53c3b3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, std::vector&lt;std::string&gt; &gt; TableHandler::supercolumns</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Maps each supercolumn key to the the keys of its subcolumns in the right order. It is allowed that a supercolumn has got the same key as a column.</p>
<p>Note that we do not use a <code>multimap</code> here since the order of column keys for each supercolumn key is relevant. </p>

<p>Definition at line <a class="el" href="table__handler_8h_source.html#l00737">737</a> of file <a class="el" href="table__handler_8h_source.html">table_handler.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8fadd66861022772b9901ee96b5b6004"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, std::string&gt; TableHandler::tex_supercaptions</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Maps the supercolumn keys to the captions of the supercolumns that are used in tex output.</p>
<p>By default these are just the supercolumn keys but they may be changed by <code>set_tex_supercaptions(...)</code>. </p>

<p>Definition at line <a class="el" href="table__handler_8h_source.html#l00750">750</a> of file <a class="el" href="table__handler_8h_source.html">table_handler.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa0920e405beec2a978f2921ccf88ea1d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string TableHandler::tex_table_caption</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The caption of the table itself. </p>

<p>Definition at line <a class="el" href="table__handler_8h_source.html#l00755">755</a> of file <a class="el" href="table__handler_8h_source.html">table_handler.h</a>.</p>

</div>
</div>
<a class="anchor" id="a98ba6a6cc6f4b5c170bdfc9bc0313e26"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string TableHandler::tex_table_label</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The label of the table. </p>

<p>Definition at line <a class="el" href="table__handler_8h_source.html#l00759">759</a> of file <a class="el" href="table__handler_8h_source.html">table_handler.h</a>.</p>

</div>
</div>
<a class="anchor" id="a825579ea69b3eb16e52f1ec2673b6dec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TableHandler::auto_fill_mode</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Flag indicating whether auto-fill mode should be used. </p>

<p>Definition at line <a class="el" href="table__handler_8h_source.html#l00764">764</a> of file <a class="el" href="table__handler_8h_source.html">table_handler.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/deal.II/base/<a class="el" href="table__handler_8h_source.html">table_handler.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jan 27 2014 15:27:22 for The deal.II Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
