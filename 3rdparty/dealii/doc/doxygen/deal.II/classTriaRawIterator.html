<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>The deal.II Library: TriaRawIterator&lt; Accessor &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="http://www.dealii.org/deal.ico"></link>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2014 by the deal.II authors"></meta>
<meta name="deal.II-version" content="8.1.0"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 8.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classTriaRawIterator-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">TriaRawIterator&lt; Accessor &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__grid.html">Grid classes</a> &#124; <a class="el" href="group__Iterators.html">Iterators on mesh-like containers</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="tria__iterator_8h_source.html">tria_iterator.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for TriaRawIterator&lt; Accessor &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classTriaRawIterator__inherit__graph.svg" width="200" height="326"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a728126c49d7d94b760616f9e88ab974d"><td class="memItemLeft" align="right" valign="top">typedef Accessor&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaRawIterator.html#a728126c49d7d94b760616f9e88ab974d">AccessorType</a></td></tr>
<tr class="separator:a728126c49d7d94b760616f9e88ab974d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4de292acbb26dc040c0d54320d052856"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaRawIterator.html#a4de292acbb26dc040c0d54320d052856">TriaRawIterator</a> ()</td></tr>
<tr class="separator:a4de292acbb26dc040c0d54320d052856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e972bae8d2540f2aa3ec1c6ade88cd9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaRawIterator.html#a4e972bae8d2540f2aa3ec1c6ade88cd9">TriaRawIterator</a> (const <a class="el" href="classTriaRawIterator.html">TriaRawIterator</a> &amp;)</td></tr>
<tr class="separator:a4e972bae8d2540f2aa3ec1c6ade88cd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a972118d0712cd84d2b7a4fb60d40d3df"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaRawIterator.html#a972118d0712cd84d2b7a4fb60d40d3df">TriaRawIterator</a> (const Accessor &amp;a)</td></tr>
<tr class="separator:a972118d0712cd84d2b7a4fb60d40d3df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a915d1e6e745a614dc18f103bd52e7906"><td class="memTemplParams" colspan="2">template&lt;typename OtherAccessor &gt; </td></tr>
<tr class="memitem:a915d1e6e745a614dc18f103bd52e7906"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTriaRawIterator.html#a915d1e6e745a614dc18f103bd52e7906">TriaRawIterator</a> (const OtherAccessor &amp;a)</td></tr>
<tr class="separator:a915d1e6e745a614dc18f103bd52e7906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19ae51088651b23b165a6d28fb0e8c4e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaRawIterator.html#a19ae51088651b23b165a6d28fb0e8c4e">TriaRawIterator</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; Accessor::dimension, Accessor::space_dimension &gt; *parent, const <a class="el" href="classint.html">int</a> level, const <a class="el" href="classint.html">int</a> index, const typename AccessorType::AccessorData *local_data=0)</td></tr>
<tr class="separator:a19ae51088651b23b165a6d28fb0e8c4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8808d63d54fc5404489bcab6bf15573"><td class="memTemplParams" colspan="2">template&lt;typename OtherAccessor &gt; </td></tr>
<tr class="memitem:ac8808d63d54fc5404489bcab6bf15573"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTriaRawIterator.html#ac8808d63d54fc5404489bcab6bf15573">TriaRawIterator</a> (const <a class="el" href="classTriaRawIterator.html">TriaRawIterator</a>&lt; OtherAccessor &gt; &amp;i)</td></tr>
<tr class="separator:ac8808d63d54fc5404489bcab6bf15573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dae776615895759d9406f7546c7d17f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaRawIterator.html#a2dae776615895759d9406f7546c7d17f">TriaRawIterator</a> (const <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; Accessor::structure_dimension, Accessor::dimension, Accessor::space_dimension &gt; &amp;tria_accessor, const typename Accessor::AccessorData *local_data)</td></tr>
<tr class="separator:a2dae776615895759d9406f7546c7d17f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42b552e4dcb90b2f969b1f8db2fe8432"><td class="memTemplParams" colspan="2">template&lt;typename OtherAccessor &gt; </td></tr>
<tr class="memitem:a42b552e4dcb90b2f969b1f8db2fe8432"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTriaRawIterator.html#a42b552e4dcb90b2f969b1f8db2fe8432">TriaRawIterator</a> (const <a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; OtherAccessor &gt; &amp;i)</td></tr>
<tr class="separator:a42b552e4dcb90b2f969b1f8db2fe8432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5e759cf552f254d87dc6c895bf17d71"><td class="memTemplParams" colspan="2">template&lt;typename OtherAccessor &gt; </td></tr>
<tr class="memitem:af5e759cf552f254d87dc6c895bf17d71"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTriaRawIterator.html#af5e759cf552f254d87dc6c895bf17d71">TriaRawIterator</a> (const <a class="el" href="classTriaActiveIterator.html">TriaActiveIterator</a>&lt; OtherAccessor &gt; &amp;i)</td></tr>
<tr class="separator:af5e759cf552f254d87dc6c895bf17d71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5865fe8e6c47667aa614f5e53da7821"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriaRawIterator.html">TriaRawIterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaRawIterator.html#aa5865fe8e6c47667aa614f5e53da7821">operator=</a> (const <a class="el" href="classTriaRawIterator.html">TriaRawIterator</a> &amp;)</td></tr>
<tr class="separator:aa5865fe8e6c47667aa614f5e53da7821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8573a202f9646fcc22de540846d99fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaRawIterator.html#ad8573a202f9646fcc22de540846d99fb">operator==</a> (const <a class="el" href="classTriaRawIterator.html">TriaRawIterator</a> &amp;) const </td></tr>
<tr class="separator:ad8573a202f9646fcc22de540846d99fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af11bdfe301df8da60c40dd4a1f40f997"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaRawIterator.html#af11bdfe301df8da60c40dd4a1f40f997">operator!=</a> (const <a class="el" href="classTriaRawIterator.html">TriaRawIterator</a> &amp;) const </td></tr>
<tr class="separator:af11bdfe301df8da60c40dd4a1f40f997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac29fa141caa5674a96dc2942524c19ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaRawIterator.html#ac29fa141caa5674a96dc2942524c19ce">operator&lt;</a> (const <a class="el" href="classTriaRawIterator.html">TriaRawIterator</a> &amp;) const </td></tr>
<tr class="separator:ac29fa141caa5674a96dc2942524c19ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a450ed05f19c04c787215b18883a34fd6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceIteratorState.html#a4e92f4a9d339ff987cc3eb5b0a1ac507">IteratorState::IteratorStates</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaRawIterator.html#a450ed05f19c04c787215b18883a34fd6">state</a> () const </td></tr>
<tr class="separator:a450ed05f19c04c787215b18883a34fd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6088c7a91d8dca52679338f964e7bef2"><td class="memTemplParams" colspan="2">template&lt;class STREAM &gt; </td></tr>
<tr class="memitem:a6088c7a91d8dca52679338f964e7bef2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTriaRawIterator.html#a6088c7a91d8dca52679338f964e7bef2">print</a> (STREAM &amp;out) const </td></tr>
<tr class="separator:a6088c7a91d8dca52679338f964e7bef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5106c071e81a13748fa73eafb5780773"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaRawIterator.html#a5106c071e81a13748fa73eafb5780773">memory_consumption</a> () const </td></tr>
<tr class="separator:a5106c071e81a13748fa73eafb5780773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac578b1f5021e51f7668d5e49fb013454"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac578b1f5021e51f7668d5e49fb013454"></a>
template&lt;typename Accessor &gt; </td></tr>
<tr class="memitem:ac578b1f5021e51f7668d5e49fb013454"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>TriaRawIterator</b> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; Accessor::dimension, Accessor::space_dimension &gt; *parent, const <a class="el" href="classint.html">int</a> level, const <a class="el" href="classint.html">int</a> index, const typename Accessor::AccessorData *local_data)</td></tr>
<tr class="separator:ac578b1f5021e51f7668d5e49fb013454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Dereferencing</div></td></tr>
<tr class="memitem:a8985bbac6cc60ae1d9966e51ccad7744"><td class="memItemLeft" align="right" valign="top">const Accessor &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaRawIterator.html#a8985bbac6cc60ae1d9966e51ccad7744">operator*</a> () const </td></tr>
<tr class="separator:a8985bbac6cc60ae1d9966e51ccad7744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2af7c49cabff9d77c271206440075219"><td class="memItemLeft" align="right" valign="top">Accessor &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaRawIterator.html#a2af7c49cabff9d77c271206440075219">operator*</a> ()</td></tr>
<tr class="separator:a2af7c49cabff9d77c271206440075219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d516a1b48c8ad54ffe7410e011b3517"><td class="memItemLeft" align="right" valign="top">const Accessor *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaRawIterator.html#a7d516a1b48c8ad54ffe7410e011b3517">operator-&gt;</a> () const </td></tr>
<tr class="separator:a7d516a1b48c8ad54ffe7410e011b3517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf2951054ae6febd21583cb7a9849b3b"><td class="memItemLeft" align="right" valign="top">Accessor *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaRawIterator.html#abf2951054ae6febd21583cb7a9849b3b">operator-&gt;</a> ()</td></tr>
<tr class="separator:abf2951054ae6febd21583cb7a9849b3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85be66da3f64b9cdbd953041e831d529"><td class="memItemLeft" align="right" valign="top">const Accessor &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaRawIterator.html#a85be66da3f64b9cdbd953041e831d529">access_any</a> () const </td></tr>
<tr class="separator:a85be66da3f64b9cdbd953041e831d529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Advancement of iterators</div></td></tr>
<tr class="memitem:ab830608f33e709aee725ef3a22f314e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriaRawIterator.html">TriaRawIterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaRawIterator.html#ab830608f33e709aee725ef3a22f314e9">operator++</a> ()</td></tr>
<tr class="separator:ab830608f33e709aee725ef3a22f314e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11630e473e0b7636c2755903e6bd84d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriaRawIterator.html">TriaRawIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaRawIterator.html#a11630e473e0b7636c2755903e6bd84d9">operator++</a> (<a class="el" href="classint.html">int</a>)</td></tr>
<tr class="separator:a11630e473e0b7636c2755903e6bd84d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9f2a1cc26773da4433136fba66e9c9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriaRawIterator.html">TriaRawIterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaRawIterator.html#af9f2a1cc26773da4433136fba66e9c9f">operator--</a> ()</td></tr>
<tr class="separator:af9f2a1cc26773da4433136fba66e9c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26c013dac74de2cdcd357bf81c592dc6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriaRawIterator.html">TriaRawIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaRawIterator.html#a26c013dac74de2cdcd357bf81c592dc6">operator--</a> (<a class="el" href="classint.html">int</a>)</td></tr>
<tr class="separator:a26c013dac74de2cdcd357bf81c592dc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Exceptions</div></td></tr>
<tr class="memitem:a79efaf23a8bc9cd7bd555b625f6b7a7b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaRawIterator.html#a79efaf23a8bc9cd7bd555b625f6b7a7b">DeclException1</a> (ExcDereferenceInvalidCell, Accessor,&lt;&lt; &quot;You tried to dereference a cell iterator for which this &quot;&lt;&lt; &quot;is not possible. More information on this iterator: &quot;&lt;&lt; &quot;level=&quot;&lt;&lt; arg1.level()&lt;&lt; &quot;, index=&quot;&lt;&lt; arg1.index()&lt;&lt; &quot;, state=&quot;&lt;&lt; (arg1.state()==<a class="el" href="namespaceIteratorState.html#a4e92f4a9d339ff987cc3eb5b0a1ac507a457da025bc5a3a2231a667bd5c6f3c92">IteratorState::valid</a>?&quot;valid&quot;:(arg1.state()==<a class="el" href="namespaceIteratorState.html#a4e92f4a9d339ff987cc3eb5b0a1ac507a0294fc03dff1d6840ff833fae6f4cdf7">IteratorState::past_the_end</a>?&quot;past_the_end&quot;:&quot;invalid&quot;)))</td></tr>
<tr class="separator:a79efaf23a8bc9cd7bd555b625f6b7a7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a057d72c3cf9ad79627f65590aeb6b814"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaRawIterator.html#a057d72c3cf9ad79627f65590aeb6b814">DeclException1</a> (ExcDereferenceInvalidObject, Accessor,&lt;&lt; &quot;You tried to dereference an iterator for which this &quot;&lt;&lt; &quot;is not possible. More information on this iterator: &quot;&lt;&lt; &quot;index=&quot;&lt;&lt; arg1.index()&lt;&lt; &quot;, state=&quot;&lt;&lt; (arg1.state()==<a class="el" href="namespaceIteratorState.html#a4e92f4a9d339ff987cc3eb5b0a1ac507a457da025bc5a3a2231a667bd5c6f3c92">IteratorState::valid</a>?&quot;valid&quot;:(arg1.state()==<a class="el" href="namespaceIteratorState.html#a4e92f4a9d339ff987cc3eb5b0a1ac507a0294fc03dff1d6840ff833fae6f4cdf7">IteratorState::past_the_end</a>?&quot;past_the_end&quot;:&quot;invalid&quot;)))</td></tr>
<tr class="separator:a057d72c3cf9ad79627f65590aeb6b814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa07527a0f7fd8d6af5fb2e3190688af0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaRawIterator.html#aa07527a0f7fd8d6af5fb2e3190688af0">DeclException0</a> (ExcAdvanceInvalidObject)</td></tr>
<tr class="separator:aa07527a0f7fd8d6af5fb2e3190688af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4522cb27aa9701a864343f325307c9b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaRawIterator.html#af4522cb27aa9701a864343f325307c9b">DeclException0</a> (ExcInvalidComparison)</td></tr>
<tr class="separator:af4522cb27aa9701a864343f325307c9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a93c827e46937aa135d1aa205c60a4210"><td class="memItemLeft" align="right" valign="top">Accessor&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaRawIterator.html#a93c827e46937aa135d1aa205c60a4210">accessor</a></td></tr>
<tr class="separator:a93c827e46937aa135d1aa205c60a4210"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a9dacc3081fd832e48ab08d167cce90e2"><td class="memTemplParams" colspan="2">template&lt;typename SomeAccessor &gt; </td></tr>
<tr class="memitem:a9dacc3081fd832e48ab08d167cce90e2"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTriaRawIterator.html#a9dacc3081fd832e48ab08d167cce90e2">TriaRawIterator</a></td></tr>
<tr class="separator:a9dacc3081fd832e48ab08d167cce90e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c937d2d69cd157e5b4d5d61e0cbdd90"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2c937d2d69cd157e5b4d5d61e0cbdd90"></a>
template&lt;typename SomeAccessor &gt; </td></tr>
<tr class="memitem:a2c937d2d69cd157e5b4d5d61e0cbdd90"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>TriaIterator</b></td></tr>
<tr class="separator:a2c937d2d69cd157e5b4d5d61e0cbdd90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a447f70b258e8135c365834a7f4415670"><td class="memTemplParams" colspan="2"><a class="anchor" id="a447f70b258e8135c365834a7f4415670"></a>
template&lt;typename SomeAccessor &gt; </td></tr>
<tr class="memitem:a447f70b258e8135c365834a7f4415670"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>TriaActiveIterator</b></td></tr>
<tr class="separator:a447f70b258e8135c365834a7f4415670"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Accessor&gt;<br/>
class TriaRawIterator&lt; Accessor &gt;</h3>

<p>This class implements an iterator, analogous to those of the standard template library (STL). It fulfills the requirements of a bidirectional iterator. See the C++ documentation for further details of iterator specification and usage.</p>
<p>In addition to the STL iterators an iterator of this class provides a <code>-&gt;</code> operator, i.e. you can write statements like </p>
<div class="fragment"><div class="line">i-&gt;set_refine_flag ();</div>
</div><!-- fragment --><p>Iterators are used whenever a loop over all lines, quads, cells etc. is to be performed. These loops can then be coded like this: </p>
<div class="fragment"><div class="line">cell_iterator i   = tria.<a class="code" href="classTriangulation.html#a7b87a97ff0d6ffe416aa37fda33c46c7">begin</a>();</div>
<div class="line">cell_iterator end = tria.<a class="code" href="classTriangulation.html#aa234819cf914abe2b700535c682688a7">end</a>();</div>
<div class="line"><span class="keywordflow">for</span> (; i!=end; ++i)</div>
<div class="line">  <span class="keywordflow">if</span> (cell-&gt;at_boundary())</div>
<div class="line">    cell-&gt;set_refine_flag();</div>
</div><!-- fragment --><p>Note the usage of <code>++i</code> instead of <code>i++</code> since this does not involve temporaries and copying. It is recommended to use a fixed value <code>end</code> inside the loop instead of <code>tria.end()</code>, since the creation and copying of these iterators is rather expensive compared to normal pointers.</p>
<p>The objects pointed to are accessors, derived from <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>. Which kind of accessor is determined by the template argument <em>Accessor</em>. These accessors are not so much data structures as they are a collection of functions providing access to the data stored in Tringulation or <a class="el" href="classDoFHandler.html">DoFHandler</a> objects. Using these accessors, the structure of these classes is hidden from the application program.</p>
<h3>Which iterator to use when</h3>
<dl class="section attention"><dt>Attention</dt><dd>Application programs will rarely use <a class="el" href="classTriaRawIterator.html">TriaRawIterator</a>, but rather one of the derived classes <a class="el" href="classTriaIterator.html">TriaIterator</a> or <a class="el" href="classTriaActiveIterator.html">TriaActiveIterator</a>.</dd></dl>
<ul>
<li>
<p class="startli"><a class="el" href="classTriaRawIterator.html">TriaRawIterator</a> objects point to lines, cells, etc in the lists whether they are used or not (in the vectors, also <em>dead</em> objects are stored, since deletion in vectors is expensive and we also do not want to destroy the ordering induced by the numbering in the vectors). Therefore not all raw iterators point to valid objects.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">The derived class <a class="el" href="classTriaIterator.html">TriaIterator</a> selects the valid cells, that is, cells used somewhere in the triangulation hierarchy.</p>
<p class="endli"></p>
</li>
<li>
<a class="el" href="classTriaActiveIterator.html">TriaActiveIterator</a> objects which only loop over active cells. </li>
</ul>
<h3>Purpose</h3>
<p>Iterators are not much slower than operating directly on the data structures, since they perform the loops that you had to handcode yourself anyway. Most iterator and accessor functions are inlined.</p>
<p>The main functionality of iterators, resides in the <code>++</code> and <code>&ndash;</code> operators. These move the iterator forward or backward just as if it were a pointer into an array. Here, this operation is not so easy, since it may include skipping some elements and the transition between the triangulation levels. This is completely hidden from the user, though you can still create an iterator pointing to an arbitrary element. Actually, the operation of moving iterators back and forth is not done in the iterator classes, but rather in the accessor classes. Since these are passed as template arguments, you can write your own versions here to add more functionality.</p>
<p>Furthermore, the iterators described here satisfy the requirement of input and bidirectional iterators as stated by the C++ standard and the STL documentation. It is therefore possible to use the functions from the algorithm section of the C++ standard, e.g. <em>count_if</em> (see the documentation for <a class="el" href="classTriangulation.html">Triangulation</a> for an example) and several others.</p>
<h3>Implementation</h3>
<p>The iterator class itself does not have much functionality. It only becomes useful when assigned an Accessor (the second template parameter), which really does the access to data. An Accessor has to fulfil some requirements:</p>
<ul>
<li>
<p class="startli">It must have two members named <code>present_level</code> and <code>present_index</code> storing the address of the element in the triangulation presently pointed to. These data have to be accessible by all triangulation iterators listed above.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">It must have a constructor which takes a Triangulation* and two unsigned integers, denoting the initial level and index, as well as a data object depending on its type.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">For the <a class="el" href="classTriaIterator.html">TriaIterator</a> and the <a class="el" href="classTriaActiveIterator.html">TriaActiveIterator</a> class, it must have a member function <code>bool used()</code>, for the latter a member function <code>bool active()</code>.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">It must have void operators <code>++</code> and <code>&ndash;</code>.</p>
<p class="endli"></p>
</li>
<li>
It must declare a local <code>typedef AccessorData</code> which states the data type the accessor expects to get passed as fourth constructor argument. By declaring a local data type, the respective iterator class may type-safely enforce that data type to be one of its own constructor argument types. If an accessor class does not need additional data, this type shall be <code>void</code>. </li>
</ul>
<p>Then the iterator is able to do what it is supposed to. All of the necessary functions are implemented in the <code>Accessor</code> base class, but you may write your own version (non-virtual, since we use templates) to add functionality.</p>
<p>The accessors provided by the library are distributed in three groups, determined by whether they access the data of <a class="el" href="classTriangulation.html">Triangulation</a>, <a class="el" href="classDoFHandler.html">DoFHandler</a> or <a class="el" href="classMGDoFHandler.html">MGDoFHandler</a>. They are derived from <a class="el" href="classTriaAccessor.html">TriaAccessor</a>, <a class="el" href="classDoFAccessor.html">DoFAccessor</a> and <a class="el" href="classMGDoFAccessor.html">MGDoFAccessor</a>, respectively. In each group, there is an accessor to cells, which have more functionality.</p>
<dl class="section attention"><dt>Attention</dt><dd>It seems impossible to preserve constness of a triangulation through iterator usage. Thus, if you declare pointers to a <code>const</code> triangulation object, you should be well aware that you might involuntarily alter the data stored in the triangulation.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>More information on valid and invalid iterators can be found in the documentation of <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>, where the iterator states are checked and implemented.</dd></dl>
<h3>Past-the-end iterators</h3>
<p>There is a representation of past-the-end-pointers, denoted by special values of the member variables <code>present_level</code> and <code>present_index:</code> If <code>present_level&gt;=0</code> and <code>present_index&gt;=0</code>, then the object is valid (there is no check whether the triangulation really has that many levels or that many cells on the present level when we investigate the state of an iterator; however, in many places where an iterator is dereferenced we make this check); if <code>present_level==-1</code> and <code>present_index==-1</code>, then the iterator points past the end; in all other cases, the iterator is considered invalid. You can check this by calling the <code><a class="el" href="classTriaRawIterator.html#a450ed05f19c04c787215b18883a34fd6">state()</a></code> function.</p>
<p>An iterator is also invalid, if the pointer pointing to the <a class="el" href="classTriangulation.html">Triangulation</a> object is invalid or zero.</p>
<p>Finally, an iterator is invalid, if the element pointed to by <code>present_level</code> and <code>present_index</code> is not used, i.e. if the <code>used</code> flag is set to false.</p>
<p>The last two checks are not made in <code><a class="el" href="classTriaRawIterator.html#a450ed05f19c04c787215b18883a34fd6">state()</a></code> since both cases should only occur upon unitialized construction through <code>memcpy</code> and the like (the parent triangulation can only be set upon construction). If an iterator is constructed empty through the empty constructor, <code>present_level==-2</code> and <code>present_index==-2</code>. Thus, the iterator is invalid anyway, regardless of the state of the triangulation pointer and the state of the element pointed to.</p>
<p>Past-the-end iterators may also be used to compare an iterator with the <em>before-the-start</em> value, when running backwards. There is no distinction between the iterators pointing past the two ends of a vector.</p>
<p>By defining only one value to be past-the-end and making all other values invalid provides a second track of security: if we should have forgotten a check in the library when an iterator is incremented or decremented, we automatically convert the iterator from the allowed state "past-the-end" to the disallowed state "invalid" which increases the chance that somehwen earlier than for past-the-end iterators an exception is raised.</p>
<p><a class="el" href="classTriangulation.html">Triangulation</a></p>
<dl class="section author"><dt>Author</dt><dd>Wolfgang Bangerth, 1998 </dd>
<dd>
documentation update Guido Kanschat, 2004 </dd></dl>

<p>Definition at line <a class="el" href="dof__accessor_8h_source.html#l00035">35</a> of file <a class="el" href="dof__accessor_8h_source.html">dof_accessor.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a728126c49d7d94b760616f9e88ab974d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Accessor&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Accessor <a class="el" href="classTriaRawIterator.html">TriaRawIterator</a>&lt; Accessor &gt;::<a class="el" href="classTriaRawIterator.html#a728126c49d7d94b760616f9e88ab974d">AccessorType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare the type of the Accessor for use in the outside world. This way other functions can use the Accessor's type without knowledge of how the exact implementation actually is. </p>

<p>Definition at line <a class="el" href="tria__iterator_8h_source.html#l00243">243</a> of file <a class="el" href="tria__iterator_8h_source.html">tria_iterator.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a4de292acbb26dc040c0d54320d052856"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Accessor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DEAL_II_NAMESPACE_OPEN <a class="el" href="classTriaRawIterator.html">TriaRawIterator</a>&lt; Accessor &gt;::<a class="el" href="classTriaRawIterator.html">TriaRawIterator</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Empty constructor. Such an object is not usable! </p>

<p>Definition at line <a class="el" href="tria__iterator_8templates_8h_source.html#l00039">39</a> of file <a class="el" href="tria__iterator_8templates_8h_source.html">tria_iterator.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4e972bae8d2540f2aa3ec1c6ade88cd9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Accessor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaRawIterator.html">TriaRawIterator</a>&lt; Accessor &gt;::<a class="el" href="classTriaRawIterator.html">TriaRawIterator</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriaRawIterator.html">TriaRawIterator</a>&lt; Accessor &gt; &amp;&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy constructor. </p>

<p>Definition at line <a class="el" href="tria__iterator_8templates_8h_source.html#l00047">47</a> of file <a class="el" href="tria__iterator_8templates_8h_source.html">tria_iterator.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a972118d0712cd84d2b7a4fb60d40d3df"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Accessor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaRawIterator.html">TriaRawIterator</a>&lt; Accessor &gt;::<a class="el" href="classTriaRawIterator.html">TriaRawIterator</a> </td>
          <td>(</td>
          <td class="paramtype">const Accessor &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Construct an iterator from the given accessor; the given accessor needs not be of the same type as the accessor of this class is, but it needs to be convertible.</p>
<p>Through this constructor, it is also possible to construct objects for derived iterators: </p>
<div class="fragment"><div class="line"><a class="code" href="classDoFCellAccessor.html">DoFCellAccessor</a> dof_accessor;</div>
<div class="line"><a class="code" href="classTriaActiveIterator.html">Triangulation::active_cell_iterator</a> cell</div>
<div class="line">  = <a class="code" href="classTriaRawIterator.html#a93c827e46937aa135d1aa205c60a4210">accessor</a>;</div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="tria__iterator_8h_source.html#l01057">1057</a> of file <a class="el" href="tria__iterator_8h_source.html">tria_iterator.h</a>.</p>

</div>
</div>
<a class="anchor" id="a915d1e6e745a614dc18f103bd52e7906"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Accessor &gt; </div>
<div class="memtemplate">
template&lt;typename OtherAccessor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaRawIterator.html">TriaRawIterator</a>&lt; Accessor &gt;::<a class="el" href="classTriaRawIterator.html">TriaRawIterator</a> </td>
          <td>(</td>
          <td class="paramtype">const OtherAccessor &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor. Assumes that the other accessor type is convertible to the current one. </p>

<p>Definition at line <a class="el" href="tria__iterator_8h_source.html#l01068">1068</a> of file <a class="el" href="tria__iterator_8h_source.html">tria_iterator.h</a>.</p>

</div>
</div>
<a class="anchor" id="a19ae51088651b23b165a6d28fb0e8c4e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Accessor&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaRawIterator.html">TriaRawIterator</a>&lt; Accessor &gt;::<a class="el" href="classTriaRawIterator.html">TriaRawIterator</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; Accessor::dimension, Accessor::space_dimension &gt; *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename AccessorType::AccessorData *&#160;</td>
          <td class="paramname"><em>local_data</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Proper constructor, initialized with the triangulation, the level and index of the object pointed to. The last parameter is of a type declared by the accessor class. </p>

</div>
</div>
<a class="anchor" id="ac8808d63d54fc5404489bcab6bf15573"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Accessor &gt; </div>
<div class="memtemplate">
template&lt;typename OtherAccessor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaRawIterator.html">TriaRawIterator</a>&lt; Accessor &gt;::<a class="el" href="classTriaRawIterator.html">TriaRawIterator</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriaRawIterator.html">TriaRawIterator</a>&lt; OtherAccessor &gt; &amp;&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is a conversion operator (constructor) which takes another iterator type and copies the data; this conversion works, if there is a conversion path from the <code>OtherAccessor</code> class to the <code>Accessor</code> class of this object. One such path would be derived class to base class, which for example may be used to get a <a class="el" href="classTriangulation.html#a4e117ddf1b985983751fd3b7d305a31a">Triangulation::raw_cell_iterator</a> from a DoFHandler::raw_cell_iterator, since the <a class="el" href="classDoFAccessor.html">DoFAccessor</a> class is derived from the <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a> class. </p>

<p>Definition at line <a class="el" href="tria__iterator_8h_source.html#l01079">1079</a> of file <a class="el" href="tria__iterator_8h_source.html">tria_iterator.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2dae776615895759d9406f7546c7d17f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Accessor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaRawIterator.html">TriaRawIterator</a>&lt; Accessor &gt;::<a class="el" href="classTriaRawIterator.html">TriaRawIterator</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; Accessor::structure_dimension, Accessor::dimension, Accessor::space_dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria_accessor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Accessor::AccessorData *&#160;</td>
          <td class="paramname"><em>local_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Another conversion operator, where we use the pointers to the <a class="el" href="classTriangulation.html">Triangulation</a> from a <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a> object, while the additional data is used according to the actual type of Accessor. </p>

<p>Definition at line <a class="el" href="tria__iterator_8templates_8h_source.html#l00068">68</a> of file <a class="el" href="tria__iterator_8templates_8h_source.html">tria_iterator.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a42b552e4dcb90b2f969b1f8db2fe8432"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Accessor &gt; </div>
<div class="memtemplate">
template&lt;typename OtherAccessor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaRawIterator.html">TriaRawIterator</a>&lt; Accessor &gt;::<a class="el" href="classTriaRawIterator.html">TriaRawIterator</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; OtherAccessor &gt; &amp;&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Conversion constructor. Same as above with the difference that it converts from <a class="el" href="classTriaIterator.html">TriaIterator</a> classes (not <a class="el" href="classTriaRawIterator.html">TriaRawIterator</a>). </p>

<p>Definition at line <a class="el" href="tria__iterator_8h_source.html#l01090">1090</a> of file <a class="el" href="tria__iterator_8h_source.html">tria_iterator.h</a>.</p>

</div>
</div>
<a class="anchor" id="af5e759cf552f254d87dc6c895bf17d71"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Accessor &gt; </div>
<div class="memtemplate">
template&lt;typename OtherAccessor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaRawIterator.html">TriaRawIterator</a>&lt; Accessor &gt;::<a class="el" href="classTriaRawIterator.html">TriaRawIterator</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriaActiveIterator.html">TriaActiveIterator</a>&lt; OtherAccessor &gt; &amp;&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Conversion constructor. Same as above with the difference that it converts from <a class="el" href="classTriaActiveIterator.html">TriaActiveIterator</a> classes (not <a class="el" href="classTriaRawIterator.html">TriaRawIterator</a>). </p>

<p>Definition at line <a class="el" href="tria__iterator_8h_source.html#l01101">1101</a> of file <a class="el" href="tria__iterator_8h_source.html">tria_iterator.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a8985bbac6cc60ae1d9966e51ccad7744"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Accessor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Accessor &amp; <a class="el" href="classTriaRawIterator.html">TriaRawIterator</a>&lt; Accessor &gt;::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Dereferencing operator, returns a reference to an accessor. Usage is thus like <code>(*i).index ();</code></p>
<p>This function has to be specialized explicitly for the different <code>Pointees</code>, to allow an <code>iterator&lt;1,TriangulationLevel&lt;1&gt;::LinesData&gt;</code> to point to <code>tria-&gt;lines.cells[index]</code> while for one dimension higher it has to point to <code>tria-&gt;quads.cells[index]</code>.</p>
<p>You must not dereference invalid or past the end iterators. </p>

<p>Definition at line <a class="el" href="tria__iterator_8h_source.html#l01111">1111</a> of file <a class="el" href="tria__iterator_8h_source.html">tria_iterator.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2af7c49cabff9d77c271206440075219"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Accessor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Accessor &amp; <a class="el" href="classTriaRawIterator.html">TriaRawIterator</a>&lt; Accessor &gt;::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Dereferencing operator, non-<code>const</code> version. </p>

<p>Definition at line <a class="el" href="tria__iterator_8h_source.html#l01128">1128</a> of file <a class="el" href="tria__iterator_8h_source.html">tria_iterator.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7d516a1b48c8ad54ffe7410e011b3517"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Accessor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Accessor * <a class="el" href="classTriaRawIterator.html">TriaRawIterator</a>&lt; Accessor &gt;::operator-&gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Dereferencing operator, returns a reference of the cell pointed to. Usage is thus like <code>i-&gt;index ();</code></p>
<p>There is a <code>const</code> and a non-<code>const</code> version. </p>

<p>Definition at line <a class="el" href="tria__iterator_8h_source.html#l01155">1155</a> of file <a class="el" href="tria__iterator_8h_source.html">tria_iterator.h</a>.</p>

</div>
</div>
<a class="anchor" id="abf2951054ae6febd21583cb7a9849b3b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Accessor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Accessor * <a class="el" href="classTriaRawIterator.html">TriaRawIterator</a>&lt; Accessor &gt;::operator-&gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Dereferencing operator, non-<code>const</code> version. </p>

<p>Definition at line <a class="el" href="tria__iterator_8h_source.html#l01165">1165</a> of file <a class="el" href="tria__iterator_8h_source.html">tria_iterator.h</a>.</p>

</div>
</div>
<a class="anchor" id="a85be66da3f64b9cdbd953041e831d529"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Accessor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Accessor &amp; <a class="el" href="classTriaRawIterator.html">TriaRawIterator</a>&lt; Accessor &gt;::access_any </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>In order be able to assign end-iterators for different accessors to each other, we need an access function which returns the accessor regardless of its state.</p>
<dl class="section warning"><dt>Warning</dt><dd>This function should not be used in application programs. It is only intended for limited purposes inside the library and it makes debugging much harder. </dd></dl>

<p>Definition at line <a class="el" href="tria__iterator_8h_source.html#l01145">1145</a> of file <a class="el" href="tria__iterator_8h_source.html">tria_iterator.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa5865fe8e6c47667aa614f5e53da7821"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Accessor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaRawIterator.html">TriaRawIterator</a>&lt; Accessor &gt; &amp; <a class="el" href="classTriaRawIterator.html">TriaRawIterator</a>&lt; Accessor &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriaRawIterator.html">TriaRawIterator</a>&lt; Accessor &gt; &amp;&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Assignment operator. </p>

<p>Definition at line <a class="el" href="tria__iterator_8templates_8h_source.html#l00081">81</a> of file <a class="el" href="tria__iterator_8templates_8h_source.html">tria_iterator.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad8573a202f9646fcc22de540846d99fb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Accessor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTriaRawIterator.html">TriaRawIterator</a>&lt; Accessor &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriaRawIterator.html">TriaRawIterator</a>&lt; Accessor &gt; &amp;&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Assignment operator. Assignment operator. Assignment operator. Compare for equality. </p>

<p>Definition at line <a class="el" href="tria__iterator_8templates_8h_source.html#l00125">125</a> of file <a class="el" href="tria__iterator_8templates_8h_source.html">tria_iterator.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="af11bdfe301df8da60c40dd4a1f40f997"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Accessor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTriaRawIterator.html">TriaRawIterator</a>&lt; Accessor &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriaRawIterator.html">TriaRawIterator</a>&lt; Accessor &gt; &amp;&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compare for inequality. </p>

<p>Definition at line <a class="el" href="tria__iterator_8templates_8h_source.html#l00134">134</a> of file <a class="el" href="tria__iterator_8templates_8h_source.html">tria_iterator.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac29fa141caa5674a96dc2942524c19ce"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Accessor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTriaRawIterator.html">TriaRawIterator</a>&lt; Accessor &gt;::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriaRawIterator.html">TriaRawIterator</a>&lt; Accessor &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Ordering relation for iterators.</p>
<p>This relation attempts a total ordering of cells. For lower dimensional objects on distributed meshes, we only attempt a partial ordering.</p>
<p>The relation is defined as follows:</p>
<p>For objects of <code>Accessor::structure_dimension &lt; Accessor::dimension</code>, we simply compare the index of such an object. This consitutes an ordering of the elements of same dimension on a mesh on a single process. For a distributed mesh, the result of the ordering relation between faces across processes is not defined, but most likely irrelevant.</p>
<p>For cells, there is a total ordering even in a distributed::parallel::Triangulation. The ordering is lexicographic according to the following hierarchy (in the sense, that the next test is only applied if the previous was inconclusive):</p>
<ol>
<li>
<p class="startli">The past-the-end iterator is always ordered last. Two past-the-end iterators rank the same, thus false is returned in that case.</p>
<p class="endli"></p>
</li>
<li>
The level subdomain id </li>
<li>
If both cells are active, the subdomain id. </li>
<li>
The level of the cell. </li>
<li>
The index of a cell inside the level. </li>
</ol>

<p>Definition at line <a class="el" href="tria__iterator_8h_source.html#l01185">1185</a> of file <a class="el" href="tria__iterator_8h_source.html">tria_iterator.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab830608f33e709aee725ef3a22f314e9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Accessor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaRawIterator.html">TriaRawIterator</a>&lt; Accessor &gt; &amp; <a class="el" href="classTriaRawIterator.html">TriaRawIterator</a>&lt; Accessor &gt;::operator++ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Prefix <code>++</code> operator: <code>++i</code>. This operator advances the iterator to the next element and returns a reference to <code>*this</code>.</p>
<p>The next element is next on this level if there are more. If the present element is the last on this level, the first on the next level is accessed. This is only valid for iterators pointing to cells, faces have no level. </p>

<p>Definition at line <a class="el" href="tria__iterator_8h_source.html#l01206">1206</a> of file <a class="el" href="tria__iterator_8h_source.html">tria_iterator.h</a>.</p>

</div>
</div>
<a class="anchor" id="a11630e473e0b7636c2755903e6bd84d9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Accessor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaRawIterator.html">TriaRawIterator</a>&lt; Accessor &gt; <a class="el" href="classTriaRawIterator.html">TriaRawIterator</a>&lt; Accessor &gt;::operator++ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Postfix <code>++</code> operator: <code>i++</code>. This operator advances the iterator to the next element, but returns an iterator to the element priviously pointed to. Since this involves a temporary and a copy operation and since an <code>iterator</code> is quite a large object for a pointer, use the prefix operator <code>++i</code> whenever possible, especially in the head of for loops (<code>for (; i!=end; ++i)</code>) since there you normally never need the returned value. </p>

<p>Definition at line <a class="el" href="tria__iterator_8templates_8h_source.html#l00154">154</a> of file <a class="el" href="tria__iterator_8templates_8h_source.html">tria_iterator.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="af9f2a1cc26773da4433136fba66e9c9f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Accessor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaRawIterator.html">TriaRawIterator</a>&lt; Accessor &gt; &amp; <a class="el" href="classTriaRawIterator.html">TriaRawIterator</a>&lt; Accessor &gt;::operator-- </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Prefix <code>&ndash;</code> operator: <code>&ndash;i</code>. This operator advances the iterator to the previous element and returns a reference to <code>*this</code>.</p>
<p>The previous element is previous on this level if <code>index&gt;0</code>. If the present element is the first on this level, the last on the previous level is accessed. This is only valid for iterators pointing to cells, faces have no level. </p>

<p>Definition at line <a class="el" href="tria__iterator_8h_source.html#l01219">1219</a> of file <a class="el" href="tria__iterator_8h_source.html">tria_iterator.h</a>.</p>

</div>
</div>
<a class="anchor" id="a26c013dac74de2cdcd357bf81c592dc6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Accessor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaRawIterator.html">TriaRawIterator</a>&lt; Accessor &gt; <a class="el" href="classTriaRawIterator.html">TriaRawIterator</a>&lt; Accessor &gt;::operator-- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Postfix <code>&ndash;</code> operator: <code>i&ndash;</code>. This operator advances the iterator to the previous element, but returns an iterator to the element priviously pointed to. Since this involves a temporary and a copy operation and since an <code>iterator</code> is quite a large object for a pointer, use the prefix operator <code>&ndash;i</code> whenever possible, especially in the head of for loops (<code>for (; i!=end; &ndash;i)</code>) since there you normally never need the returned value. </p>

<p>Definition at line <a class="el" href="tria__iterator_8templates_8h_source.html#l00166">166</a> of file <a class="el" href="tria__iterator_8templates_8h_source.html">tria_iterator.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a450ed05f19c04c787215b18883a34fd6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Accessor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceIteratorState.html#a4e92f4a9d339ff987cc3eb5b0a1ac507">IteratorState::IteratorStates</a> <a class="el" href="classTriaRawIterator.html">TriaRawIterator</a>&lt; Accessor &gt;::state </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the state of the iterator. </p>

<p>Definition at line <a class="el" href="tria__iterator_8h_source.html#l01175">1175</a> of file <a class="el" href="tria__iterator_8h_source.html">tria_iterator.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6088c7a91d8dca52679338f964e7bef2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Accessor &gt; </div>
<div class="memtemplate">
template&lt;class STREAM &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaRawIterator.html">TriaRawIterator</a>&lt; Accessor &gt;::print </td>
          <td>(</td>
          <td class="paramtype">STREAM &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Print the iterator to a stream <code>out</code>. The format is <code>level.index</code>. </p>

<p>Definition at line <a class="el" href="tria__iterator_8h_source.html#l01233">1233</a> of file <a class="el" href="tria__iterator_8h_source.html">tria_iterator.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5106c071e81a13748fa73eafb5780773"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Accessor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classTriaRawIterator.html">TriaRawIterator</a>&lt; Accessor &gt;::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determine an estimate for the memory consumption (in bytes) of this object. </p>

<p>Definition at line <a class="el" href="tria__iterator_8h_source.html#l01246">1246</a> of file <a class="el" href="tria__iterator_8h_source.html">tria_iterator.h</a>.</p>

</div>
</div>
<a class="anchor" id="a79efaf23a8bc9cd7bd555b625f6b7a7b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Accessor&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaRawIterator.html">TriaRawIterator</a>&lt; Accessor &gt;::DeclException1 </td>
          <td>(</td>
          <td class="paramtype">ExcDereferenceInvalidCell&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Accessor&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;You tried to dereference a cell iterator for which this &quot;&lt;&lt; &quot;is not possible. More information on this iterator: &quot;&lt;&lt; &quot;&#160;</td>
          <td class="paramname"><em>level</em> = <code>&quot;&lt;&lt;&#160;arg1.level()&lt;&lt;&#160;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">index&#160;</td>
          <td class="paramname"> = <code>&quot;&lt;&lt;&#160;arg1.index()&lt;&lt;&#160;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exception for TriaObjects with level, i.e. cells. </p>

</div>
</div>
<a class="anchor" id="a057d72c3cf9ad79627f65590aeb6b814"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Accessor&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaRawIterator.html">TriaRawIterator</a>&lt; Accessor &gt;::DeclException1 </td>
          <td>(</td>
          <td class="paramtype">ExcDereferenceInvalidObject&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Accessor&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;You tried to dereference an iterator for which this &quot;&lt;&lt; &quot;is not possible. More information on this iterator: &quot;&lt;&lt; &quot;&#160;</td>
          <td class="paramname"><em>index</em> = <code>&quot;&lt;&lt;&#160;arg1.index()&lt;&lt;&#160;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exception for lower-dimensional TriaObjects without level, i.e. objects faces are constructed with. </p>

</div>
</div>
<a class="anchor" id="aa07527a0f7fd8d6af5fb2e3190688af0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Accessor&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaRawIterator.html">TriaRawIterator</a>&lt; Accessor &gt;::DeclException0 </td>
          <td>(</td>
          <td class="paramtype">ExcAdvanceInvalidObject&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exception </p>

</div>
</div>
<a class="anchor" id="af4522cb27aa9701a864343f325307c9b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Accessor&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaRawIterator.html">TriaRawIterator</a>&lt; Accessor &gt;::DeclException0 </td>
          <td>(</td>
          <td class="paramtype">ExcInvalidComparison&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exception </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="a9dacc3081fd832e48ab08d167cce90e2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Accessor&gt; </div>
<div class="memtemplate">
template&lt;typename SomeAccessor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classTriaRawIterator.html">TriaRawIterator</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Make all other iterator class templates friends of this class. This is necessary for the implementation of conversion constructors.</p>
<p>In fact, we would not need them to be friends if they were for different dimensions, but the compiler dislikes giving a fixed dimension and variable accessor since then it says that would be a artial specialization. </p>

<p>Definition at line <a class="el" href="tria__iterator_8h_source.html#l00635">635</a> of file <a class="el" href="tria__iterator_8h_source.html">tria_iterator.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a93c827e46937aa135d1aa205c60a4210"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Accessor&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Accessor <a class="el" href="classTriaRawIterator.html">TriaRawIterator</a>&lt; Accessor &gt;::accessor</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Object holding the real data. </p>

<p>Definition at line <a class="el" href="tria__iterator_8h_source.html#l00619">619</a> of file <a class="el" href="tria__iterator_8h_source.html">tria_iterator.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/deal.II/dofs/<a class="el" href="dof__accessor_8h_source.html">dof_accessor.h</a></li>
<li>include/deal.II/grid/<a class="el" href="tria__iterator_8h_source.html">tria_iterator.h</a></li>
<li>include/deal.II/grid/<a class="el" href="tria__iterator_8templates_8h_source.html">tria_iterator.templates.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jan 27 2014 15:27:22 for The deal.II Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
