<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>The deal.II Library: VectorTools Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="http://www.dealii.org/deal.ico"></link>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2014 by the deal.II authors"></meta>
<meta name="deal.II-version" content="8.1.0"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 8.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">VectorTools Namespace Reference<div class="ingroups"><a class="el" href="group__numerics.html">Numerical algorithms</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a69967cb7a148a7169963126249213db1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1">NormType</a> { <br/>
&#160;&#160;<a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a485d4198c1f422388b80cadb98af1f27">mean</a>, 
<a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a8a97c0127bcfceec1fefbd0ad5839357">L1_norm</a>, 
<a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">L2_norm</a>, 
<a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1abbc2c7f8863e60f4ac6a6128c06676f6">Lp_norm</a>, 
<br/>
&#160;&#160;<a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a0532fa97d3218aed4fa2e7fb0a2017e4">Linfty_norm</a>, 
<a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a1048f76e7fb0aea6e654ff1cf036a65f">H1_seminorm</a>, 
<a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a6a4df2311989608627aa7bff3898fd3c">H1_norm</a>, 
<a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa24d2a903e0841b2d6794e3329a69930">W1p_seminorm</a>, 
<br/>
&#160;&#160;<a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a619be0eb2626ecbb804b545b1618d6c3">W1p_norm</a>, 
<a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1af043345075b417b8613b1dd242297418">W1infty_seminorm</a>, 
<a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a694dcdb8213d64925e9be0fa90cc7619">W1infty_norm</a>
<br/>
 }</td></tr>
<tr class="separator:a69967cb7a148a7169963126249213db1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aacac6f926b848b3bf406b115869fe696"><td class="memTemplParams" colspan="2"><a class="anchor" id="aacac6f926b848b3bf406b115869fe696"></a>
template&lt;int dim, int spacedim, template&lt; int, int &gt; class DH, class Vector &gt; </td></tr>
<tr class="memitem:aacac6f926b848b3bf406b115869fe696"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>interpolate_to_different_mesh</b> (const DH&lt; dim, spacedim &gt; &amp;dof1, const <a class="el" href="classVector.html">Vector</a> &amp;u1, const DH&lt; dim, spacedim &gt; &amp;dof2, <a class="el" href="classVector.html">Vector</a> &amp;u2)</td></tr>
<tr class="separator:aacac6f926b848b3bf406b115869fe696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9449ff01341d5411bbcc0969bb821c9"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa9449ff01341d5411bbcc0969bb821c9"></a>
template&lt;int dim, int spacedim, template&lt; int, int &gt; class DH, class Vector &gt; </td></tr>
<tr class="memitem:aa9449ff01341d5411bbcc0969bb821c9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>interpolate_to_different_mesh</b> (const DH&lt; dim, spacedim &gt; &amp;dof1, const <a class="el" href="classVector.html">Vector</a> &amp;u1, const DH&lt; dim, spacedim &gt; &amp;dof2, const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints, <a class="el" href="classVector.html">Vector</a> &amp;u2)</td></tr>
<tr class="separator:aa9449ff01341d5411bbcc0969bb821c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3754bfd85fd027b5113dfd08e461a12"><td class="memTemplParams" colspan="2"><a class="anchor" id="af3754bfd85fd027b5113dfd08e461a12"></a>
template&lt;int dim, int spacedim, template&lt; int, int &gt; class DH, class Vector &gt; </td></tr>
<tr class="memitem:af3754bfd85fd027b5113dfd08e461a12"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>interpolate_to_different_mesh</b> (const <a class="el" href="classInterGridMap.html">InterGridMap</a>&lt; DH&lt; dim, spacedim &gt; &gt; &amp;intergridmap, const <a class="el" href="classVector.html">Vector</a> &amp;u1, const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints, <a class="el" href="classVector.html">Vector</a> &amp;u2)</td></tr>
<tr class="separator:af3754bfd85fd027b5113dfd08e461a12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada5043a2254418018b013c07b022e35f"><td class="memTemplParams" colspan="2"><a class="anchor" id="ada5043a2254418018b013c07b022e35f"></a>
template&lt;int dim&gt; </td></tr>
<tr class="memitem:ada5043a2254418018b013c07b022e35f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>project_boundary_values_curl_conforming</b> (const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim &gt; &amp;dof_handler, const unsigned <a class="el" href="classint.html">int</a> first_vector_component, const <a class="el" href="classFunction.html">Function</a>&lt; dim &gt; &amp;boundary_function, const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> boundary_component, <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints, const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim &gt; &amp;mapping_collection)</td></tr>
<tr class="separator:ada5043a2254418018b013c07b022e35f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a973d18f2460b1ca84f430a6907dc1c37"><td class="memTemplParams" colspan="2"><a class="anchor" id="a973d18f2460b1ca84f430a6907dc1c37"></a>
template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </td></tr>
<tr class="memitem:a973d18f2460b1ca84f430a6907dc1c37"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>integrate_difference</b> (const ::<a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;mapping, const ::<a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const InVector &amp;fe_function, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; &amp;exact_solution, OutVector &amp;difference, const ::<a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;q, const <a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1">NormType</a> &amp;norm, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *weight, const <a class="el" href="classdouble.html">double</a> exponent)</td></tr>
<tr class="separator:a973d18f2460b1ca84f430a6907dc1c37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf16420dea77eef668a24aa62a89a924"><td class="memTemplParams" colspan="2"><a class="anchor" id="abf16420dea77eef668a24aa62a89a924"></a>
template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </td></tr>
<tr class="memitem:abf16420dea77eef668a24aa62a89a924"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>integrate_difference</b> (const ::<a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const InVector &amp;fe_function, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; &amp;exact_solution, OutVector &amp;difference, const ::<a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;q, const <a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1">NormType</a> &amp;norm, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *weight, const <a class="el" href="classdouble.html">double</a> exponent)</td></tr>
<tr class="separator:abf16420dea77eef668a24aa62a89a924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21f5d6d4cb385da569e7579dc376c789"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a21f5d6d4cb385da569e7579dc376c789">DeclException0</a> (ExcInvalidBoundaryIndicator)</td></tr>
<tr class="separator:a21f5d6d4cb385da569e7579dc376c789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a370303e6c89ad7d6c0ba6950d7dc488d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a370303e6c89ad7d6c0ba6950d7dc488d">DeclException0</a> (ExcNonInterpolatingFE)</td></tr>
<tr class="separator:a370303e6c89ad7d6c0ba6950d7dc488d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaf107deb45d939076f378ff19f8e5c5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#abaf107deb45d939076f378ff19f8e5c5">DeclException0</a> (ExcPointNotAvailableHere)</td></tr>
<tr class="separator:abaf107deb45d939076f378ff19f8e5c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Interpolation and projection</div></td></tr>
<tr class="memitem:a87efdd37923f76e54015909cb373c8e1"><td class="memTemplParams" colspan="2">template&lt;class VECTOR , int dim, int spacedim, template&lt; int, int &gt; class DH&gt; </td></tr>
<tr class="memitem:a87efdd37923f76e54015909cb373c8e1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a87efdd37923f76e54015909cb373c8e1">interpolate</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const DH&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; &amp;function, VECTOR &amp;vec)</td></tr>
<tr class="separator:a87efdd37923f76e54015909cb373c8e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aa9f5a8067f81a279a2f3fe6323abb1"><td class="memTemplParams" colspan="2">template&lt;class VECTOR , class DH &gt; </td></tr>
<tr class="memitem:a0aa9f5a8067f81a279a2f3fe6323abb1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a0aa9f5a8067f81a279a2f3fe6323abb1">interpolate</a> (const DH &amp;dof, const <a class="el" href="classFunction.html">Function</a>&lt; DH::space_dimension &gt; &amp;function, VECTOR &amp;vec)</td></tr>
<tr class="separator:a0aa9f5a8067f81a279a2f3fe6323abb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e3af70a47cedfaf361cf5c621e94e3d"><td class="memTemplParams" colspan="2">template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </td></tr>
<tr class="memitem:a5e3af70a47cedfaf361cf5c621e94e3d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a5e3af70a47cedfaf361cf5c621e94e3d">interpolate</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_1, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_2, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;transfer, const InVector &amp;data_1, OutVector &amp;data_2)</td></tr>
<tr class="separator:a5e3af70a47cedfaf361cf5c621e94e3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef011bd8868e6f8ce1309cf76d34c68b"><td class="memTemplParams" colspan="2">template&lt;int dim, class VECTOR , int spacedim&gt; </td></tr>
<tr class="memitem:aef011bd8868e6f8ce1309cf76d34c68b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#aef011bd8868e6f8ce1309cf76d34c68b">project</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;quadrature, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; &amp;function, VECTOR &amp;vec_result, const <a class="el" href="classbool.html">bool</a> enforce_zero_boundary, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt; &amp;q_boundary, const <a class="el" href="classbool.html">bool</a> project_to_boundary_first)</td></tr>
<tr class="separator:aef011bd8868e6f8ce1309cf76d34c68b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab0809593cd08397008a0d2e530bf03f"><td class="memTemplParams" colspan="2">template&lt;int dim, class VECTOR , int spacedim&gt; </td></tr>
<tr class="memitem:aab0809593cd08397008a0d2e530bf03f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#aab0809593cd08397008a0d2e530bf03f">project</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;quadrature, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; &amp;function, VECTOR &amp;vec, const <a class="el" href="classbool.html">bool</a> enforce_zero_boundary, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt; &amp;q_boundary, const <a class="el" href="classbool.html">bool</a> project_to_boundary_first)</td></tr>
<tr class="separator:aab0809593cd08397008a0d2e530bf03f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4aae7920ad9a8710e7fd65d4a2d2dd7"><td class="memTemplParams" colspan="2">template&lt;int dim, class VECTOR , int spacedim&gt; </td></tr>
<tr class="memitem:ae4aae7920ad9a8710e7fd65d4a2d2dd7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#ae4aae7920ad9a8710e7fd65d4a2d2dd7">project</a> (const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;quadrature, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; &amp;function, VECTOR &amp;vec_result, const <a class="el" href="classbool.html">bool</a> enforce_zero_boundary, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim-1 &gt; &amp;q_boundary, const <a class="el" href="classbool.html">bool</a> project_to_boundary_first)</td></tr>
<tr class="separator:ae4aae7920ad9a8710e7fd65d4a2d2dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08875eebc3d3f2bb180cbe3f4f54e84d"><td class="memTemplParams" colspan="2">template&lt;int dim, class VECTOR , int spacedim&gt; </td></tr>
<tr class="memitem:a08875eebc3d3f2bb180cbe3f4f54e84d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a08875eebc3d3f2bb180cbe3f4f54e84d">project</a> (const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;quadrature, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; &amp;function, VECTOR &amp;vec, const <a class="el" href="classbool.html">bool</a> enforce_zero_boundary, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim-1 &gt; &amp;q_boundary, const <a class="el" href="classbool.html">bool</a> project_to_boundary_first)</td></tr>
<tr class="separator:a08875eebc3d3f2bb180cbe3f4f54e84d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a199f38e07822b47e5b5957c21ce35d1b"><td class="memTemplParams" colspan="2">template&lt;class DH &gt; </td></tr>
<tr class="memitem:a199f38e07822b47e5b5957c21ce35d1b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a199f38e07822b47e5b5957c21ce35d1b">interpolate_boundary_values</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; DH::dimension, DH::space_dimension &gt; &amp;mapping, const DH &amp;dof, const typename <a class="el" href="structFunctionMap.html">FunctionMap</a>&lt; DH::space_dimension &gt;::type &amp;function_map, std::map&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>, <a class="el" href="classdouble.html">double</a> &gt; &amp;boundary_values, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask_)</td></tr>
<tr class="separator:a199f38e07822b47e5b5957c21ce35d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a057810ea8a924ab0ffdaaed9ff2e4146"><td class="memTemplParams" colspan="2">template&lt;class DH &gt; </td></tr>
<tr class="memitem:a057810ea8a924ab0ffdaaed9ff2e4146"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a057810ea8a924ab0ffdaaed9ff2e4146">interpolate_boundary_values</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; DH::dimension, DH::space_dimension &gt; &amp;mapping, const DH &amp;dof, const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> boundary_component, const <a class="el" href="classFunction.html">Function</a>&lt; DH::space_dimension &gt; &amp;boundary_function, std::map&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>, <a class="el" href="classdouble.html">double</a> &gt; &amp;boundary_values, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask)</td></tr>
<tr class="separator:a057810ea8a924ab0ffdaaed9ff2e4146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4371d4a79b27b76b2a6ca0c06b2a51f8"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a4371d4a79b27b76b2a6ca0c06b2a51f8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a4371d4a79b27b76b2a6ca0c06b2a51f8">interpolate_boundary_values</a> (const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const typename <a class="el" href="structFunctionMap.html">FunctionMap</a>&lt; spacedim &gt;::type &amp;function_map, std::map&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>, <a class="el" href="classdouble.html">double</a> &gt; &amp;boundary_values, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask_)</td></tr>
<tr class="separator:a4371d4a79b27b76b2a6ca0c06b2a51f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb6634f0950a99782b9483cbf12a4fef"><td class="memTemplParams" colspan="2">template&lt;class DH &gt; </td></tr>
<tr class="memitem:abb6634f0950a99782b9483cbf12a4fef"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#abb6634f0950a99782b9483cbf12a4fef">interpolate_boundary_values</a> (const DH &amp;dof, const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> boundary_component, const <a class="el" href="classFunction.html">Function</a>&lt; DH::space_dimension &gt; &amp;boundary_function, std::map&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>, <a class="el" href="classdouble.html">double</a> &gt; &amp;boundary_values, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask)</td></tr>
<tr class="separator:abb6634f0950a99782b9483cbf12a4fef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9855e634bb2c3ab61acf67763be5cb2"><td class="memTemplParams" colspan="2">template&lt;class DH &gt; </td></tr>
<tr class="memitem:ab9855e634bb2c3ab61acf67763be5cb2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#ab9855e634bb2c3ab61acf67763be5cb2">interpolate_boundary_values</a> (const DH &amp;dof, const typename <a class="el" href="structFunctionMap.html">FunctionMap</a>&lt; DH::space_dimension &gt;::type &amp;function_map, std::map&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>, <a class="el" href="classdouble.html">double</a> &gt; &amp;boundary_values, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask)</td></tr>
<tr class="separator:ab9855e634bb2c3ab61acf67763be5cb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f3e96634dbdd78c9a5b0674af496559"><td class="memTemplParams" colspan="2">template&lt;class DH &gt; </td></tr>
<tr class="memitem:ga7f3e96634dbdd78c9a5b0674af496559"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga7f3e96634dbdd78c9a5b0674af496559">interpolate_boundary_values</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; DH::dimension, DH::space_dimension &gt; &amp;mapping, const DH &amp;dof, const typename <a class="el" href="structFunctionMap.html">FunctionMap</a>&lt; DH::space_dimension &gt;::type &amp;function_map, <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask_)</td></tr>
<tr class="separator:ga7f3e96634dbdd78c9a5b0674af496559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22711fb5e71f2ae7c8b117209b4af397"><td class="memTemplParams" colspan="2">template&lt;class DH &gt; </td></tr>
<tr class="memitem:ga22711fb5e71f2ae7c8b117209b4af397"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga22711fb5e71f2ae7c8b117209b4af397">interpolate_boundary_values</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; DH::dimension, DH::space_dimension &gt; &amp;mapping, const DH &amp;dof, const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> boundary_component, const <a class="el" href="classFunction.html">Function</a>&lt; DH::space_dimension &gt; &amp;boundary_function, <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask)</td></tr>
<tr class="separator:ga22711fb5e71f2ae7c8b117209b4af397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2b32c11445e5d5fec898781dddaaf80"><td class="memTemplParams" colspan="2">template&lt;class DH &gt; </td></tr>
<tr class="memitem:gaf2b32c11445e5d5fec898781dddaaf80"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#gaf2b32c11445e5d5fec898781dddaaf80">interpolate_boundary_values</a> (const DH &amp;dof, const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> boundary_component, const <a class="el" href="classFunction.html">Function</a>&lt; DH::space_dimension &gt; &amp;boundary_function, <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask)</td></tr>
<tr class="separator:gaf2b32c11445e5d5fec898781dddaaf80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga765f05b664f0f3f3090d6526f9384430"><td class="memTemplParams" colspan="2">template&lt;class DH &gt; </td></tr>
<tr class="memitem:ga765f05b664f0f3f3090d6526f9384430"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga765f05b664f0f3f3090d6526f9384430">interpolate_boundary_values</a> (const DH &amp;dof, const typename <a class="el" href="structFunctionMap.html">FunctionMap</a>&lt; DH::space_dimension &gt;::type &amp;function_map, <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask)</td></tr>
<tr class="separator:ga765f05b664f0f3f3090d6526f9384430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebbe1c685f39b991ca3eba870787ee68"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:aebbe1c685f39b991ca3eba870787ee68"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#aebbe1c685f39b991ca3eba870787ee68">project_boundary_values</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const typename <a class="el" href="structFunctionMap.html">FunctionMap</a>&lt; spacedim &gt;::type &amp;boundary_functions, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt; &amp;q, std::map&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>, <a class="el" href="classdouble.html">double</a> &gt; &amp;boundary_values, std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; component_mapping)</td></tr>
<tr class="separator:aebbe1c685f39b991ca3eba870787ee68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61b31a2d0ac435a83f6ac93d93e6e147"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a61b31a2d0ac435a83f6ac93d93e6e147"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a61b31a2d0ac435a83f6ac93d93e6e147">project_boundary_values</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const typename <a class="el" href="structFunctionMap.html">FunctionMap</a>&lt; spacedim &gt;::type &amp;boundary_functions, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt; &amp;q, std::map&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>, <a class="el" href="classdouble.html">double</a> &gt; &amp;boundary_values, std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; component_mapping)</td></tr>
<tr class="separator:a61b31a2d0ac435a83f6ac93d93e6e147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3a458ebfbc06e833f4a682f8fd88b29"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ac3a458ebfbc06e833f4a682f8fd88b29"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#ac3a458ebfbc06e833f4a682f8fd88b29">project_boundary_values</a> (const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const typename <a class="el" href="structFunctionMap.html">FunctionMap</a>&lt; spacedim &gt;::type &amp;boundary_functions, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim-1 &gt; &amp;q, std::map&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>, <a class="el" href="classdouble.html">double</a> &gt; &amp;boundary_values, std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; component_mapping)</td></tr>
<tr class="separator:ac3a458ebfbc06e833f4a682f8fd88b29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af163638de6716f0d94cc3ef8d43ff561"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:af163638de6716f0d94cc3ef8d43ff561"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#af163638de6716f0d94cc3ef8d43ff561">project_boundary_values</a> (const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const typename <a class="el" href="structFunctionMap.html">FunctionMap</a>&lt; spacedim &gt;::type &amp;boundary_function, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim-1 &gt; &amp;q, std::map&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>, <a class="el" href="classdouble.html">double</a> &gt; &amp;boundary_values, std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; component_mapping)</td></tr>
<tr class="separator:af163638de6716f0d94cc3ef8d43ff561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe6c2a3531280b809c791c4e90f984d8"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:gabe6c2a3531280b809c791c4e90f984d8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#gabe6c2a3531280b809c791c4e90f984d8">project_boundary_values</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const typename <a class="el" href="structFunctionMap.html">FunctionMap</a>&lt; spacedim &gt;::type &amp;boundary_functions, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt; &amp;q, <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints, std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; component_mapping)</td></tr>
<tr class="separator:gabe6c2a3531280b809c791c4e90f984d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga587d0c6d8f1632fb757cf16594f527d0"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ga587d0c6d8f1632fb757cf16594f527d0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga587d0c6d8f1632fb757cf16594f527d0">project_boundary_values</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const typename <a class="el" href="structFunctionMap.html">FunctionMap</a>&lt; spacedim &gt;::type &amp;boundary_functions, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt; &amp;q, <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints, std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; component_mapping)</td></tr>
<tr class="separator:ga587d0c6d8f1632fb757cf16594f527d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed484d7530047b55d6f7a04d41347a4e"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:gaed484d7530047b55d6f7a04d41347a4e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#gaed484d7530047b55d6f7a04d41347a4e">project_boundary_values_curl_conforming</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; &amp;dof_handler, const unsigned <a class="el" href="classint.html">int</a> first_vector_component, const <a class="el" href="classFunction.html">Function</a>&lt; dim &gt; &amp;boundary_function, const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> boundary_component, <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim &gt; &amp;mapping)</td></tr>
<tr class="separator:gaed484d7530047b55d6f7a04d41347a4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a13fe1b8306a0a6f1fed5009a5f99ab"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:ga8a13fe1b8306a0a6f1fed5009a5f99ab"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga8a13fe1b8306a0a6f1fed5009a5f99ab">project_boundary_values_div_conforming</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; &amp;dof_handler, const unsigned <a class="el" href="classint.html">int</a> first_vector_component, const <a class="el" href="classFunction.html">Function</a>&lt; dim &gt; &amp;boundary_function, const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> boundary_component, <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim &gt; &amp;mapping)</td></tr>
<tr class="separator:ga8a13fe1b8306a0a6f1fed5009a5f99ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4b3a415d08d0bc2b52308ff9eaa79eb"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:gaa4b3a415d08d0bc2b52308ff9eaa79eb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#gaa4b3a415d08d0bc2b52308ff9eaa79eb">project_boundary_values_div_conforming</a> (const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim &gt; &amp;dof_handler, const unsigned <a class="el" href="classint.html">int</a> first_vector_component, const <a class="el" href="classFunction.html">Function</a>&lt; dim &gt; &amp;boundary_function, const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> boundary_component, <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints, const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, dim &gt; &amp;mapping_collection)</td></tr>
<tr class="separator:gaa4b3a415d08d0bc2b52308ff9eaa79eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac705b8be8d8abc9ec2f3d6ca17f2ed20"><td class="memTemplParams" colspan="2">template&lt;int dim, template&lt; int, int &gt; class DH, int spacedim&gt; </td></tr>
<tr class="memitem:gac705b8be8d8abc9ec2f3d6ca17f2ed20"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#gac705b8be8d8abc9ec2f3d6ca17f2ed20">compute_no_normal_flux_constraints</a> (const DH&lt; dim, spacedim &gt; &amp;dof_handler, const unsigned <a class="el" href="classint.html">int</a> first_vector_component, const std::set&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> &gt; &amp;boundary_ids, <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping)</td></tr>
<tr class="separator:gac705b8be8d8abc9ec2f3d6ca17f2ed20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a207f8d66d6e9ef2794f9c44dec293997"><td class="memTemplParams" colspan="2">template&lt;int dim, template&lt; int, int &gt; class DH, int spacedim&gt; </td></tr>
<tr class="memitem:a207f8d66d6e9ef2794f9c44dec293997"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a207f8d66d6e9ef2794f9c44dec293997">compute_normal_flux_constraints</a> (const DH&lt; dim, spacedim &gt; &amp;dof_handler, const unsigned <a class="el" href="classint.html">int</a> first_vector_component, const std::set&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> &gt; &amp;boundary_ids, <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping)</td></tr>
<tr class="separator:a207f8d66d6e9ef2794f9c44dec293997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4dfd07067f428492f6e48e15f7b082b"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, template&lt; int, int &gt; class DH, class VECTOR &gt; </td></tr>
<tr class="memitem:ab4dfd07067f428492f6e48e15f7b082b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#ab4dfd07067f428492f6e48e15f7b082b">interpolate_to_different_mesh</a> (const DH&lt; dim, spacedim &gt; &amp;dof1, const VECTOR &amp;u1, const DH&lt; dim, spacedim &gt; &amp;dof2, VECTOR &amp;u2)</td></tr>
<tr class="separator:ab4dfd07067f428492f6e48e15f7b082b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa461f7cb77aada0058541e5757735397"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, template&lt; int, int &gt; class DH, class VECTOR &gt; </td></tr>
<tr class="memitem:aa461f7cb77aada0058541e5757735397"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#aa461f7cb77aada0058541e5757735397">interpolate_to_different_mesh</a> (const DH&lt; dim, spacedim &gt; &amp;dof1, const VECTOR &amp;u1, const DH&lt; dim, spacedim &gt; &amp;dof2, const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints, VECTOR &amp;u2)</td></tr>
<tr class="separator:aa461f7cb77aada0058541e5757735397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69cb20339402f4abfdd41f25209f4eae"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, template&lt; int, int &gt; class DH, class VECTOR &gt; </td></tr>
<tr class="memitem:a69cb20339402f4abfdd41f25209f4eae"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a69cb20339402f4abfdd41f25209f4eae">interpolate_to_different_mesh</a> (const <a class="el" href="classInterGridMap.html">InterGridMap</a>&lt; DH&lt; dim, spacedim &gt; &gt; &amp;intergridmap, const VECTOR &amp;u1, const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints, VECTOR &amp;u2)</td></tr>
<tr class="separator:a69cb20339402f4abfdd41f25209f4eae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31b221caf4d1f4835a833ac3f578378f"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:ga31b221caf4d1f4835a833ac3f578378f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga31b221caf4d1f4835a833ac3f578378f">project_boundary_values_curl_conforming</a> (const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim &gt; &amp;dof_handler, const unsigned <a class="el" href="classint.html">int</a> first_vector_component, const <a class="el" href="classFunction.html">Function</a>&lt; dim &gt; &amp;boundary_function, const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> boundary_component, <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints, const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, dim &gt; &amp;mapping_collection=<a class="el" href="structhp_1_1StaticMappingQ1.html">hp::StaticMappingQ1</a>&lt; dim &gt;::mapping_collection)</td></tr>
<tr class="separator:ga31b221caf4d1f4835a833ac3f578378f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Assembling of right hand sides</div></td></tr>
<tr class="memitem:a920c5f556c9a56b891b0fbdb279cb58b"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a920c5f556c9a56b891b0fbdb279cb58b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a920c5f556c9a56b891b0fbdb279cb58b">create_right_hand_side</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;quadrature, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; &amp;rhs_function, <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;rhs_vector)</td></tr>
<tr class="separator:a920c5f556c9a56b891b0fbdb279cb58b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40977aea482308f4c7f50faee278c3e0"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a40977aea482308f4c7f50faee278c3e0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a40977aea482308f4c7f50faee278c3e0">create_right_hand_side</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;quadrature, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; &amp;rhs_function, <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;rhs_vector)</td></tr>
<tr class="separator:a40977aea482308f4c7f50faee278c3e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31354fd9c625a84ad3b3f07089d8af4a"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a31354fd9c625a84ad3b3f07089d8af4a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a31354fd9c625a84ad3b3f07089d8af4a">create_right_hand_side</a> (const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;quadrature, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; &amp;rhs_function, <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;rhs_vector)</td></tr>
<tr class="separator:a31354fd9c625a84ad3b3f07089d8af4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cee2b65483fe58cdb629a4ea2811af3"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a3cee2b65483fe58cdb629a4ea2811af3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a3cee2b65483fe58cdb629a4ea2811af3">create_right_hand_side</a> (const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;quadrature, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; &amp;rhs_function, <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;rhs_vector)</td></tr>
<tr class="separator:a3cee2b65483fe58cdb629a4ea2811af3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4ffc41e72e846029d04e7034de60d09"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ac4ffc41e72e846029d04e7034de60d09"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#ac4ffc41e72e846029d04e7034de60d09">create_point_source_vector</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p, <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;rhs_vector)</td></tr>
<tr class="separator:ac4ffc41e72e846029d04e7034de60d09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2125402359b1f023ceb33e2d13b1112d"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a2125402359b1f023ceb33e2d13b1112d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a2125402359b1f023ceb33e2d13b1112d">create_point_source_vector</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p, <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;rhs_vector)</td></tr>
<tr class="separator:a2125402359b1f023ceb33e2d13b1112d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f93fa2c3304d3c596a415b657188bc4"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a4f93fa2c3304d3c596a415b657188bc4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a4f93fa2c3304d3c596a415b657188bc4">create_point_source_vector</a> (const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p, <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;rhs_vector)</td></tr>
<tr class="separator:a4f93fa2c3304d3c596a415b657188bc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13814b79fdf47b3fb61495ba07169cc6"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a13814b79fdf47b3fb61495ba07169cc6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a13814b79fdf47b3fb61495ba07169cc6">create_point_source_vector</a> (const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p, <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;rhs_vector)</td></tr>
<tr class="separator:a13814b79fdf47b3fb61495ba07169cc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a391116457ea643b033ebbc6035993376"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a391116457ea643b033ebbc6035993376"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a391116457ea643b033ebbc6035993376">create_point_source_vector</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;orientation, <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;rhs_vector)</td></tr>
<tr class="separator:a391116457ea643b033ebbc6035993376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad290b9c5f53a13ad8ede1ba251c7f4f"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:aad290b9c5f53a13ad8ede1ba251c7f4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#aad290b9c5f53a13ad8ede1ba251c7f4f">create_point_source_vector</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;orientation, <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;rhs_vector)</td></tr>
<tr class="separator:aad290b9c5f53a13ad8ede1ba251c7f4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac86cbe26b653a34fe480b13ea4a2704a"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ac86cbe26b653a34fe480b13ea4a2704a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#ac86cbe26b653a34fe480b13ea4a2704a">create_point_source_vector</a> (const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;orientation, <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;rhs_vector)</td></tr>
<tr class="separator:ac86cbe26b653a34fe480b13ea4a2704a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2603f88b368e01a6b5eba00b61afb09c"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a2603f88b368e01a6b5eba00b61afb09c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a2603f88b368e01a6b5eba00b61afb09c">create_point_source_vector</a> (const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;orientation, <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;rhs_vector)</td></tr>
<tr class="separator:a2603f88b368e01a6b5eba00b61afb09c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeed485c44a7ce3b7b0657b8f7bc0f5b3"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:aeed485c44a7ce3b7b0657b8f7bc0f5b3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#aeed485c44a7ce3b7b0657b8f7bc0f5b3">create_boundary_right_hand_side</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt; &amp;quadrature, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; &amp;rhs_function, <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;rhs_vector, const std::set&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> &gt; &amp;boundary_indicators)</td></tr>
<tr class="separator:aeed485c44a7ce3b7b0657b8f7bc0f5b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeefd16a72fa7df8dcaa296f3d68ae30"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:adeefd16a72fa7df8dcaa296f3d68ae30"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#adeefd16a72fa7df8dcaa296f3d68ae30">create_boundary_right_hand_side</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt; &amp;quadrature, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; &amp;rhs_function, <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;rhs_vector, const std::set&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> &gt; &amp;boundary_indicators)</td></tr>
<tr class="separator:adeefd16a72fa7df8dcaa296f3d68ae30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e2e49503497dbd89d0212efd7cf396b"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a2e2e49503497dbd89d0212efd7cf396b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a2e2e49503497dbd89d0212efd7cf396b">create_boundary_right_hand_side</a> (const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim-1 &gt; &amp;quadrature, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; &amp;rhs_function, <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;rhs_vector, const std::set&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> &gt; &amp;boundary_indicators)</td></tr>
<tr class="separator:a2e2e49503497dbd89d0212efd7cf396b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a008b79dc8cecae6e50235332fd92f35b"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a008b79dc8cecae6e50235332fd92f35b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a008b79dc8cecae6e50235332fd92f35b">create_boundary_right_hand_side</a> (const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim-1 &gt; &amp;quadrature, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; &amp;rhs_function, <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;rhs_vector, const std::set&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> &gt; &amp;boundary_indicators)</td></tr>
<tr class="separator:a008b79dc8cecae6e50235332fd92f35b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Evaluation of functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>and errors </p>
</div></td></tr>
<tr class="memitem:a7943a1670ee3a54fa18f5bcafcb1e870"><td class="memTemplParams" colspan="2">template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </td></tr>
<tr class="memitem:a7943a1670ee3a54fa18f5bcafcb1e870"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a7943a1670ee3a54fa18f5bcafcb1e870">integrate_difference</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const InVector &amp;fe_function, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; &amp;exact_solution, OutVector &amp;difference, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;q, const <a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1">NormType</a> &amp;norm, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *weight, const <a class="el" href="classdouble.html">double</a> exponent)</td></tr>
<tr class="separator:a7943a1670ee3a54fa18f5bcafcb1e870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98c1adfc5f8b5f393d7f715370915655"><td class="memTemplParams" colspan="2">template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </td></tr>
<tr class="memitem:a98c1adfc5f8b5f393d7f715370915655"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a98c1adfc5f8b5f393d7f715370915655">integrate_difference</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const InVector &amp;fe_function, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; &amp;exact_solution, OutVector &amp;difference, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;q, const <a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1">NormType</a> &amp;norm, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *weight, const <a class="el" href="classdouble.html">double</a> exponent)</td></tr>
<tr class="separator:a98c1adfc5f8b5f393d7f715370915655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae93983876ee890f3c9c8e041cfcac4ea"><td class="memTemplParams" colspan="2">template&lt;int dim, class InVector , int spacedim&gt; </td></tr>
<tr class="memitem:ae93983876ee890f3c9c8e041cfcac4ea"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#ae93983876ee890f3c9c8e041cfcac4ea">point_difference</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const InVector &amp;fe_function, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; &amp;exact_function, <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;difference, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;point)</td></tr>
<tr class="separator:ae93983876ee890f3c9c8e041cfcac4ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedeb7e048650f27810486d4cf6c3a3ab"><td class="memTemplParams" colspan="2">template&lt;int dim, class InVector , int spacedim&gt; </td></tr>
<tr class="memitem:aedeb7e048650f27810486d4cf6c3a3ab"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#aedeb7e048650f27810486d4cf6c3a3ab">point_difference</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const InVector &amp;fe_function, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; &amp;exact_function, <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;difference, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;point)</td></tr>
<tr class="separator:aedeb7e048650f27810486d4cf6c3a3ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52246ae4d0c5669917030ef5f209074f"><td class="memTemplParams" colspan="2">template&lt;int dim, class InVector , int spacedim&gt; </td></tr>
<tr class="memitem:a52246ae4d0c5669917030ef5f209074f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a52246ae4d0c5669917030ef5f209074f">point_value</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const InVector &amp;fe_function, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;point, <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;value)</td></tr>
<tr class="separator:a52246ae4d0c5669917030ef5f209074f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2cf2937e803f1802f943dc88f890db5"><td class="memTemplParams" colspan="2">template&lt;int dim, class InVector , int spacedim&gt; </td></tr>
<tr class="memitem:aa2cf2937e803f1802f943dc88f890db5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#aa2cf2937e803f1802f943dc88f890db5">point_value</a> (const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const InVector &amp;fe_function, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;point, <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;value)</td></tr>
<tr class="separator:aa2cf2937e803f1802f943dc88f890db5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a957bc39d21d7038c93ab47ffbeea1081"><td class="memTemplParams" colspan="2">template&lt;int dim, class InVector , int spacedim&gt; </td></tr>
<tr class="memitem:a957bc39d21d7038c93ab47ffbeea1081"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a957bc39d21d7038c93ab47ffbeea1081">point_value</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const InVector &amp;fe_function, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;point)</td></tr>
<tr class="separator:a957bc39d21d7038c93ab47ffbeea1081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad03389332dc285c35e038d91fc522228"><td class="memTemplParams" colspan="2">template&lt;int dim, class InVector , int spacedim&gt; </td></tr>
<tr class="memitem:ad03389332dc285c35e038d91fc522228"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#ad03389332dc285c35e038d91fc522228">point_value</a> (const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const InVector &amp;fe_function, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;point)</td></tr>
<tr class="separator:ad03389332dc285c35e038d91fc522228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7acdd14905dc47512185fa34a2ab9ffb"><td class="memTemplParams" colspan="2">template&lt;int dim, class InVector , int spacedim&gt; </td></tr>
<tr class="memitem:a7acdd14905dc47512185fa34a2ab9ffb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a7acdd14905dc47512185fa34a2ab9ffb">point_value</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const InVector &amp;fe_function, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;point, <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;value)</td></tr>
<tr class="separator:a7acdd14905dc47512185fa34a2ab9ffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed147b463bcd8916cd056cf6353be634"><td class="memTemplParams" colspan="2">template&lt;int dim, class InVector , int spacedim&gt; </td></tr>
<tr class="memitem:aed147b463bcd8916cd056cf6353be634"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#aed147b463bcd8916cd056cf6353be634">point_value</a> (const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const InVector &amp;fe_function, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;point, <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;value)</td></tr>
<tr class="separator:aed147b463bcd8916cd056cf6353be634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d982cab4fdd13813daebc4fa5bb3115"><td class="memTemplParams" colspan="2">template&lt;int dim, class InVector , int spacedim&gt; </td></tr>
<tr class="memitem:a6d982cab4fdd13813daebc4fa5bb3115"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a6d982cab4fdd13813daebc4fa5bb3115">point_value</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const InVector &amp;fe_function, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;point)</td></tr>
<tr class="separator:a6d982cab4fdd13813daebc4fa5bb3115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25b3eab1a6d870bcbf63c466d774cf12"><td class="memTemplParams" colspan="2">template&lt;int dim, class InVector , int spacedim&gt; </td></tr>
<tr class="memitem:a25b3eab1a6d870bcbf63c466d774cf12"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a25b3eab1a6d870bcbf63c466d774cf12">point_value</a> (const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const InVector &amp;fe_function, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;point)</td></tr>
<tr class="separator:a25b3eab1a6d870bcbf63c466d774cf12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9908aafc34c3075b080c655f75d0fdfd"><td class="memTemplParams" colspan="2">template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </td></tr>
<tr class="memitem:a9908aafc34c3075b080c655f75d0fdfd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a9908aafc34c3075b080c655f75d0fdfd">integrate_difference</a> (const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const InVector &amp;fe_function, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; &amp;exact_solution, OutVector &amp;difference, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;q, const <a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1">NormType</a> &amp;norm, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *weight=0, const <a class="el" href="classdouble.html">double</a> exponent=2.)</td></tr>
<tr class="separator:a9908aafc34c3075b080c655f75d0fdfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fad995e898371bb6362935ba7fda855"><td class="memTemplParams" colspan="2">template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </td></tr>
<tr class="memitem:a5fad995e898371bb6362935ba7fda855"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a5fad995e898371bb6362935ba7fda855">integrate_difference</a> (const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const InVector &amp;fe_function, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; &amp;exact_solution, OutVector &amp;difference, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;q, const <a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1">NormType</a> &amp;norm, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *weight=0, const <a class="el" href="classdouble.html">double</a> exponent=2.)</td></tr>
<tr class="separator:a5fad995e898371bb6362935ba7fda855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:afa2b82480caf313f599fc4182a2506f3"><td class="memTemplParams" colspan="2">template&lt;class VECTOR &gt; </td></tr>
<tr class="memitem:afa2b82480caf313f599fc4182a2506f3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#afa2b82480caf313f599fc4182a2506f3">subtract_mean_value</a> (VECTOR &amp;v, const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;p_select)</td></tr>
<tr class="separator:afa2b82480caf313f599fc4182a2506f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae67f4b58828c8eb9107d0accf20f8d5"><td class="memTemplParams" colspan="2">template&lt;int dim, class InVector , int spacedim&gt; </td></tr>
<tr class="memitem:aae67f4b58828c8eb9107d0accf20f8d5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#aae67f4b58828c8eb9107d0accf20f8d5">compute_mean_value</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;quadrature, const InVector &amp;v, const unsigned <a class="el" href="classint.html">int</a> component)</td></tr>
<tr class="separator:aae67f4b58828c8eb9107d0accf20f8d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaabf9153a6fd4d2755043465c703018c"><td class="memTemplParams" colspan="2">template&lt;int dim, class InVector , int spacedim&gt; </td></tr>
<tr class="memitem:aaabf9153a6fd4d2755043465c703018c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#aaabf9153a6fd4d2755043465c703018c">compute_mean_value</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;quadrature, const InVector &amp;v, const unsigned <a class="el" href="classint.html">int</a> component)</td></tr>
<tr class="separator:aaabf9153a6fd4d2755043465c703018c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Provide a namespace which offers some operations on vectors. Among these are assembling of standard vectors, integration of the difference of a finite element solution and a continuous function, interpolations and projections of continuous functions to the finite element space and other operations.</p>
<dl class="section note"><dt>Note</dt><dd>There exist two versions of almost each function. One with a <a class="el" href="classMapping.html">Mapping</a> argument and one without. If a code uses a mapping different from <a class="el" href="classMappingQ1.html">MappingQ1</a> the functions <b>with</b> mapping argument should be used. Code that uses only <a class="el" href="classMappingQ1.html">MappingQ1</a> may also use the functions without <a class="el" href="classMapping.html">Mapping</a> argument. Each of these latter functions create a <a class="el" href="classMappingQ1.html">MappingQ1</a> object and just call the respective functions with that object as mapping argument. The functions without <a class="el" href="classMapping.html">Mapping</a> argument still exist to ensure backward compatibility. Nevertheless it is advised to change the user's codes to store a specific <a class="el" href="classMapping.html">Mapping</a> object and to use the functions that take this <a class="el" href="classMapping.html">Mapping</a> object as argument. This gives the possibility to easily extend the user codes to work also on mappings of higher degree, this just by exchanging <a class="el" href="classMappingQ1.html">MappingQ1</a> by, for example, a <a class="el" href="classMappingQ.html">MappingQ</a> or another <a class="el" href="classMapping.html">Mapping</a> object of interest.</dd></dl>
<h3>Description of operations</h3>
<p>This collection of methods offers the following operations: </p>
<ul>
<li>
<p class="startli">Interpolation: assign each degree of freedom in the vector to be the value of the function given as argument. This is identical to saying that the resulting finite element function (which is isomorphic to the output vector) has exact function values in all support points of trial functions. The support point of a trial function is the point where its value equals one, e.g. for linear trial functions the support points are four corners of an element. This function therefore relies on the assumption that a finite element is used for which the degrees of freedom are function values (Lagrange elements) rather than gradients, normal derivatives, second derivatives, etc (Hermite elements, quintic Argyris element, etc.).</p>
<p>It seems inevitable that some values of the vector to be created are set twice or even more than that. The reason is that we have to loop over all cells and get the function values for each of the trial functions located thereon. This applies also to the functions located on faces and corners which we thus visit more than once. While setting the value in the vector is not an expensive operation, the evaluation of the given function may be, taking into account that a virtual function has to be called.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Projection: compute the <em>L</em><sup>2</sup>-projection of the given function onto the finite element space, i.e. if <em>f</em> is the function to be projected, compute <em>f<sub>h</sub></em> in <em>V<sub>h</sub></em> such that (<em>f<sub>h</sub></em>,<em>v<sub>h</sub></em>)=(<em>f</em>,<em>v<sub>h</sub></em>) for all discrete test functions <em>v<sub>h</sub></em>. This is done through the solution of the linear system of equations <em> M v = f</em> where <em>M</em> is the mass matrix <img class="formulaInl" alt="$m_{ij} = \int_\Omega \phi_i(x) \phi_j(x) dx$" src="form_606.png"/> and <img class="formulaInl" alt="$f_i = \int_\Omega f(x) \phi_i(x) dx$" src="form_607.png"/>. The solution vector <img class="formulaInl" alt="$v$" src="form_292.png"/> then is the nodal representation of the projection <em>f<sub>h</sub></em>. The <a class="el" href="namespaceVectorTools.html#aef011bd8868e6f8ce1309cf76d34c68b">project()</a> functions are used in the <a class="el" href="step_21.html">step-21</a> and <a class="el" href="step_23.html">step-23</a> tutorial programs.</p>
<p>In order to get proper results, it be may necessary to treat boundary conditions right. Below are listed some cases where this may be needed. If needed, this is done by <em>L</em><sup>2</sup>-projection of the trace of the given function onto the finite element space restricted to the boundary of the domain, then taking this information and using it to eliminate the boundary nodes from the mass matrix of the whole domain, using the <a class="el" href="namespaceMatrixTools.html#a41a069894610445f84840d712d4f891e">MatrixTools::apply_boundary_values()</a> function. The projection of the trace of the function to the boundary is done with the <a class="el" href="namespaceVectorTools.html#aebbe1c685f39b991ca3eba870787ee68">VectorTools::project_boundary_values()</a> (see below) function, which is called with a map of boundary functions FunctioMap in which all boundary indicators from zero to <a class="el" href="namespacenumbers.html#a4e5d3fa25689151c833ba46dcc96fa5b">numbers::internal_face_boundary_id</a>-1 (<a class="el" href="namespacenumbers.html#a4e5d3fa25689151c833ba46dcc96fa5b">numbers::internal_face_boundary_id</a> is used for other purposes, see the <a class="el" href="classTriangulation.html">Triangulation</a> class documentation) point to the function to be projected. The projection to the boundary takes place using a second quadrature formula on the boundary given to the <a class="el" href="namespaceVectorTools.html#aef011bd8868e6f8ce1309cf76d34c68b">project()</a> function. The first quadrature formula is used to compute the right hand side and for numerical quadrature of the mass matrix.</p>
<p>The projection of the boundary values first, then eliminating them from the global system of equations is not needed usually. It may be necessary if you want to enforce special restrictions on the boundary values of the projected function, for example in time dependent problems: you may want to project the initial values but need consistency with the boundary values for later times. Since the latter are projected onto the boundary in each time step, it is necessary that we also project the boundary values of the initial values, before projecting them to the whole domain.</p>
<p>Obviously, the results of the two schemes for projection are different. Usually, when projecting to the boundary first, the <em>L</em><sup>2</sup>-norm of the difference between original function and projection over the whole domain will be larger (factors of five have been observed) while the <em>L</em><sup>2</sup>-norm of the error integrated over the boundary should of course be less. The reverse should also hold if no projection to the boundary is performed.</p>
<p>The selection whether the projection to the boundary first is needed is done with the <code>project_to_boundary_first</code> flag passed to the function. If <code>false</code> is given, the additional quadrature formula for faces is ignored.</p>
<p>You should be aware of the fact that if no projection to the boundary is requested, a function with zero boundary values may not have zero boundary values after projection. There is a flag for this especially important case, which tells the function to enforce zero boundary values on the respective boundary parts. Since enforced zero boundary values could also have been reached through projection, but are more economically obtain using other methods, the <code>project_to_boundary_first</code> flag is ignored if the <code>enforce_zero_boundary</code> flag is set.</p>
<p>The solution of the linear system is presently done using a simple CG method without preconditioning and without multigrid. This is clearly not too efficient, but sufficient in many cases and simple to implement. This detail may change in the future.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Creation of right hand side vectors: The <a class="el" href="namespaceVectorTools.html#a920c5f556c9a56b891b0fbdb279cb58b">create_right_hand_side()</a> function computes the vector <img class="formulaInl" alt="$f_i = \int_\Omega f(x) \phi_i(x) dx$" src="form_607.png"/>. This is the same as what the <code>MatrixCreator::create_*</code> functions which take a right hand side do, but without assembling a matrix.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Creation of right hand side vectors for point sources: The <a class="el" href="namespaceVectorTools.html#ac4ffc41e72e846029d04e7034de60d09">create_point_source_vector()</a> function computes the vector <img class="formulaInl" alt="$f_i = \int_\Omega \delta(x-x_0) \phi_i(x) dx$" src="form_608.png"/>.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Creation of boundary right hand side vectors: The <a class="el" href="namespaceVectorTools.html#aeed485c44a7ce3b7b0657b8f7bc0f5b3">create_boundary_right_hand_side()</a> function computes the vector <img class="formulaInl" alt="$f_i = \int_{\partial\Omega} g(x) \phi_i(x) dx$" src="form_609.png"/>. This is the right hand side contribution of boundary forces when having inhomogeneous Neumann boundary values in Laplace's equation or other second order operators. This function also takes an optional argument denoting over which parts of the boundary the integration shall extend. If the default argument is used, it is applied to all boundaries.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Interpolation of boundary values: The <a class="el" href="namespaceMatrixTools.html#a41a069894610445f84840d712d4f891e">MatrixTools::apply_boundary_values()</a> function takes a list of boundary nodes and their values. You can get such a list by interpolation of a boundary function using the <a class="el" href="namespaceVectorTools.html#a199f38e07822b47e5b5957c21ce35d1b">interpolate_boundary_values()</a> function. To use it, you have to specify a list of pairs of boundary indicators (of type <code><a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a></code>; see the section in the documentation of the <a class="el" href="classTriangulation.html">Triangulation</a> class for more details) and the according functions denoting the dirichlet boundary values of the nodes on boundary faces with this boundary indicator.</p>
<p>Usually, all other boundary conditions, such as inhomogeneous Neumann values or mixed boundary conditions are handled in the weak formulation. No attempt is made to include these into the process of matrix and vector assembly therefore.</p>
<p>Within this function, boundary values are interpolated, i.e. a node is given the point value of the boundary function. In some cases, it may be necessary to use the L2-projection of the boundary function or any other method. For this purpose we refer to the <a class="el" href="namespaceVectorTools.html#aebbe1c685f39b991ca3eba870787ee68">project_boundary_values()</a> function below.</p>
<p>You should be aware that the boundary function may be evaluated at nodes on the interior of faces. These, however, need not be on the true boundary, but rather are on the approximation of the boundary represented by the mapping of the unit cell to the real cell. Since this mapping will in most cases not be the exact one at the face, the boundary function is evaluated at points which are not on the boundary and you should make sure that the returned values are reasonable in some sense anyway.</p>
<p>In 1d the situation is a bit different since there faces (i.e. vertices) have no boundary indicator. It is assumed that if the boundary indicator zero is given in the list of boundary functions, the left boundary point is to be interpolated while the right boundary point is associated with the boundary index 1 in the map. The respective boundary functions are then evaluated at the place of the respective boundary point.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Projection of boundary values: The <a class="el" href="namespaceVectorTools.html#aebbe1c685f39b991ca3eba870787ee68">project_boundary_values()</a> function acts similar to the <a class="el" href="namespaceVectorTools.html#a199f38e07822b47e5b5957c21ce35d1b">interpolate_boundary_values()</a> function, apart from the fact that it does not get the nodal values of boundary nodes by interpolation but rather through the <em>L</em><sup>2</sup>-projection of the trace of the function to the boundary.</p>
<p>The projection takes place on all boundary parts with boundary indicators listed in the map (FunctioMap::FunctionMap) of boundary functions. These boundary parts may or may not be continuous. For these boundary parts, the mass matrix is assembled using the MatrixTools::create_boundary_mass_matrix() function, as well as the appropriate right hand side. Then the resulting system of equations is solved using a simple CG method (without preconditioning), which is in most cases sufficient for the present purpose.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Computing errors: The function <a class="el" href="namespaceVectorTools.html#a7943a1670ee3a54fa18f5bcafcb1e870">integrate_difference()</a> performs the calculation of the error between a given (continuous) reference function and the finite element solution in different norms. The integration is performed using a given quadrature formula and assumes that the given finite element objects equals that used for the computation of the solution.</p>
<p>The result is stored in a vector (named <code>difference</code>), where each entry equals the given norm of the difference on a cell. The order of entries is the same as a <code>cell_iterator</code> takes when started with <code>begin_active</code> and promoted with the <code>++</code> operator.</p>
<p>This data, one number per active cell, can be used to generate graphical output by directly passing it to the <a class="el" href="classDataOut.html">DataOut</a> class through the <a class="el" href="classDataOut__DoFData.html#a59a6b70a4b909e0229a20487dd68cc43">DataOut::add_data_vector</a> function. Alternatively, it can be interpolated to the nodal points of a finite element field using the <a class="el" href="namespaceDoFTools.html#ac6684ffe63aafe7a1d4cf252e102caca">DoFTools::distribute_cell_to_dof_vector</a> function.</p>
<p>Presently, there is the possibility to compute the following values from the difference, on each cell: <code>mean</code>, <code>L1_norm</code>, <code>L2_norm</code>, <code>Linfty_norm</code>, <code>H1_seminorm</code> and <code>H1_norm</code>, see <a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1">VectorTools::NormType</a>. For the mean difference value, the reference function minus the numerical solution is computed, not the other way round.</p>
<p>The infinity norm of the difference on a given cell returns the maximum absolute value of the difference at the quadrature points given by the quadrature formula parameter. This will in some cases not be too good an approximation, since for example the Gauss quadrature formulae do not evaluate the difference at the end or corner points of the cells. You may want to choose a quadrature formula with more quadrature points or one with another distribution of the quadrature points in this case. You should also take into account the superconvergence properties of finite elements in some points: for example in 1D, the standard finite element method is a collocation method and should return the exact value at nodal points. Therefore, the trapezoidal rule should always return a vanishing L-infinity error. Conversely, in 2D the maximum L-infinity error should be located at the vertices or at the center of the cell, which would make it plausible to use the Simpson quadrature rule. On the other hand, there may be superconvergence at Gauss integration points. These examples are not intended as a rule of thumb, rather they are thought to illustrate that the use of the wrong quadrature formula may show a significantly wrong result and care should be taken to chose the right formula.</p>
<p>The <em>H</em><sup>1</sup> seminorm is the <em>L</em><sup>2</sup> norm of the gradient of the difference. The square of the full <em>H</em><sup>1</sup> norm is the sum of the square of seminorm and the square of the <em>L</em><sup>2</sup> norm.</p>
<p>To get the global <em>L<sup>1</sup></em> error, you have to sum up the entries in <code>difference</code>, e.g. using <a class="el" href="classVector.html#a3f4ca94d3f2a069d4756a3f4c40543da">Vector::l1_norm()</a> function. For the global <em>L</em><sup>2</sup> difference, you have to sum up the squares of the entries and take the root of the sum, e.g. using <a class="el" href="classVector.html#af88b324f3e4ee104ae7176e20cb0af4b">Vector::l2_norm()</a>. These two operations represent the <em>l</em><sub>1</sub> and <em>l</em><sub>2</sub> norms of the vectors, but you need not take the absolute value of each entry, since the cellwise norms are already positive.</p>
<p>To get the global mean difference, simply sum up the elements as above. To get the <img class="formulaInl" alt="$L_\infty$" src="form_610.png"/> norm, take the maximum of the vector elements, e.g. using the <a class="el" href="classVector.html#a3e032f3891f0e4f36c71cd8332178d3f">Vector::linfty_norm()</a> function.</p>
<p>For the global <em>H</em><sup>1</sup> norm and seminorm, the same rule applies as for the <em>L</em><sup>2</sup> norm: compute the <em>l</em><sub>2</sub> norm of the cell error vector.</p>
<p class="endli">Note that, in the codimension one case, if you ask for a norm that requires the computation of a gradient, then the provided function is automatically projected along the curve, and the difference is only computed on the tangential part of the gradient, since no information is available on the normal component of the gradient anyway. </p>
</li>
</ul>
<p>All functions use the finite element given to the <a class="el" href="classDoFHandler.html">DoFHandler</a> object the last time that the degrees of freedom were distributed over the triangulation. Also, if access to an object describing the exact form of the boundary is needed, the pointer stored within the triangulation object is accessed.</p>
<dl class="section note"><dt>Note</dt><dd>Instantiations for this template are provided for some vector types, in particular <code><a class="el" href="classVector.html">Vector</a>&lt;float&gt;, <a class="el" href="classVector.html">Vector</a>&lt;double&gt;, <a class="el" href="classBlockVector.html">BlockVector</a>&lt;float&gt;, <a class="el" href="classBlockVector.html">BlockVector</a>&lt;double&gt;</code>; others can be generated in application code (see the section on <a class="el" href="Instantiations.html">Template instantiations</a> in the manual).</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Wolfgang Bangerth, Ralf Hartmann, Guido Kanschat, 1998, 1999, 2000, 2001 </dd></dl>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a69967cb7a148a7169963126249213db1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1">VectorTools::NormType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Denote which norm/integral is to be computed by the <a class="el" href="namespaceVectorTools.html#a7943a1670ee3a54fa18f5bcafcb1e870">integrate_difference()</a> function of this class. The following possibilities are implemented: </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a69967cb7a148a7169963126249213db1a485d4198c1f422388b80cadb98af1f27"></a>mean&#160;</td><td class="fielddoc">
<p>The function or difference of functions is integrated on each cell. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a69967cb7a148a7169963126249213db1a8a97c0127bcfceec1fefbd0ad5839357"></a>L1_norm&#160;</td><td class="fielddoc">
<p>The absolute value of the function is integrated. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e"></a>L2_norm&#160;</td><td class="fielddoc">
<p>The square of the function is integrated and the the square root of the result is computed on each cell. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a69967cb7a148a7169963126249213db1abbc2c7f8863e60f4ac6a6128c06676f6"></a>Lp_norm&#160;</td><td class="fielddoc">
<p>The absolute value to the <em>p</em>th power is integrated and the pth root is computed on each cell. The exponent <em>p</em> is the last parameter of the function. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a69967cb7a148a7169963126249213db1a0532fa97d3218aed4fa2e7fb0a2017e4"></a>Linfty_norm&#160;</td><td class="fielddoc">
<p>The maximum absolute value of the function. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a69967cb7a148a7169963126249213db1a1048f76e7fb0aea6e654ff1cf036a65f"></a>H1_seminorm&#160;</td><td class="fielddoc">
<p><a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">L2_norm</a> of the gradient. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a69967cb7a148a7169963126249213db1a6a4df2311989608627aa7bff3898fd3c"></a>H1_norm&#160;</td><td class="fielddoc">
<p>The square of this norm is the square of the <a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">L2_norm</a> plus the square of the <a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a1048f76e7fb0aea6e654ff1cf036a65f">H1_seminorm</a>. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a69967cb7a148a7169963126249213db1aa24d2a903e0841b2d6794e3329a69930"></a>W1p_seminorm&#160;</td><td class="fielddoc">
<p><a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1abbc2c7f8863e60f4ac6a6128c06676f6">Lp_norm</a> of the gradient. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a69967cb7a148a7169963126249213db1a619be0eb2626ecbb804b545b1618d6c3"></a>W1p_norm&#160;</td><td class="fielddoc">
<p>same as <a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a6a4df2311989608627aa7bff3898fd3c">H1_norm</a> for <em>L<sup>p</sup></em>. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a69967cb7a148a7169963126249213db1af043345075b417b8613b1dd242297418"></a>W1infty_seminorm&#160;</td><td class="fielddoc">
<p><a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a0532fa97d3218aed4fa2e7fb0a2017e4">Linfty_norm</a> of the gradient. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a69967cb7a148a7169963126249213db1a694dcdb8213d64925e9be0fa90cc7619"></a>W1infty_norm&#160;</td><td class="fielddoc">
<p>same as <a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a6a4df2311989608627aa7bff3898fd3c">H1_norm</a> for <em>L<sup>infty</sup></em>. </p>
</td></tr>
</table>

<p>Definition at line <a class="el" href="vector__tools_8h_source.html#l00348">348</a> of file <a class="el" href="vector__tools_8h_source.html">vector_tools.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a87efdd37923f76e54015909cb373c8e1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VECTOR , int dim, int spacedim, template&lt; int, int &gt; class DH&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::interpolate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DH&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VECTOR &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the interpolation of <code>function</code> at the support points to the finite element space described by the <a class="el" href="classTriangulation.html">Triangulation</a> and <a class="el" href="classFiniteElement.html">FiniteElement</a> object with which the given <a class="el" href="classDoFHandler.html">DoFHandler</a> argument is initialized. It is assumed that the number of components of <code>function</code> matches that of the finite element used by <code>dof</code>.</p>
<p>Note that you may have to call <code>hanging_nodes.distribute(vec)</code> with the hanging nodes from space <code>dof</code> afterwards, to make the result continuous again.</p>
<p>The template argument <code>DH</code> may either be of type <a class="el" href="classDoFHandler.html">DoFHandler</a> or <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>.</p>
<p>See the general documentation of this class for further information.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000046">Todo:</a></b></dt><dd>The <code>mapping</code> argument should be replaced by a <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a> in case of a <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>. </dd></dl>

<p>Definition at line <a class="el" href="vector__tools_8templates_8h_source.html#l00078">78</a> of file <a class="el" href="vector__tools_8templates_8h_source.html">vector_tools.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0aa9f5a8067f81a279a2f3fe6323abb1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VECTOR , class DH &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::interpolate </td>
          <td>(</td>
          <td class="paramtype">const DH &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; DH::space_dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VECTOR &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calls the <code><a class="el" href="namespaceVectorTools.html#a87efdd37923f76e54015909cb373c8e1">interpolate()</a></code> function above with <code>mapping=<a class="el" href="classMappingQ1.html">MappingQ1</a>&lt;dim&gt;@()</code>. </p>

<p>Definition at line <a class="el" href="vector__tools_8templates_8h_source.html#l00272">272</a> of file <a class="el" href="vector__tools_8templates_8h_source.html">vector_tools.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5e3af70a47cedfaf361cf5c621e94e3d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::interpolate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>transfer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>data_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>data_2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interpolate different finite element spaces. The interpolation of vector <code>data_1</code> is executed from the FE space represented by <code>dof_1</code> to the vector <code>data_2</code> on FE space <code>dof_2</code>. The interpolation on each cell is represented by the matrix <code>transfer</code>. Curved boundaries are neglected so far.</p>
<p>Note that you may have to call <code>hanging_nodes.distribute(data_2)</code> with the hanging nodes from space <code>dof_2</code> afterwards, to make the result continuous again.</p>
<dl class="section note"><dt>Note</dt><dd>Instantiations for this template are provided for some vector types (see the general documentation of the class), but only the same vector for InVector and OutVector. Other combinations must be instantiated by hand. </dd></dl>

<p>Definition at line <a class="el" href="vector__tools_8templates_8h_source.html#l00285">285</a> of file <a class="el" href="vector__tools_8templates_8h_source.html">vector_tools.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="aef011bd8868e6f8ce1309cf76d34c68b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, class VECTOR , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::project </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VECTOR &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>enforce_zero_boundary</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q_boundary</em> = <code>(dim&#160;&gt;&#160;1?<a class="el" href="classQGauss.html">QGauss</a>&lt;&#160;dim-1&#160;&gt;(2):<a class="el" href="classQuadrature.html">Quadrature</a>&lt;&#160;dim-1&#160;&gt;(0))</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>project_to_boundary_first</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the projection of <code>function</code> to the finite element space.</p>
<p>By default, projection to the boundary and enforcement of zero boundary values are disabled. The ordering of arguments to this function is such that you need not give a second quadrature formula if you don't want to project to the boundary first, but that you must if you want to do so.</p>
<p>This function needs the mass matrix of the finite element space on the present grid. To this end, the mass matrix is assembled exactly using MatrixTools::create_mass_matrix. This function performs numerical quadrature using the given quadrature rule; you should therefore make sure that the given quadrature formula is also sufficient for the integration of the mass matrix.</p>
<p>See the general documentation of this class for further information.</p>
<p>In 1d, the default value of the boundary quadrature formula is an invalid object since integration on the boundary doesn't happen in 1d. </p>

<p>Definition at line <a class="el" href="vector__tools_8templates_8h_source.html#l00665">665</a> of file <a class="el" href="vector__tools_8templates_8h_source.html">vector_tools.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="aab0809593cd08397008a0d2e530bf03f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, class VECTOR , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::project </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VECTOR &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>enforce_zero_boundary</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q_boundary</em> = <code>(dim&#160;&gt;&#160;1?<a class="el" href="classQGauss.html">QGauss</a>&lt;&#160;dim-1&#160;&gt;(2):<a class="el" href="classQuadrature.html">Quadrature</a>&lt;&#160;dim-1&#160;&gt;(0))</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>project_to_boundary_first</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calls the <a class="el" href="namespaceVectorTools.html#aef011bd8868e6f8ce1309cf76d34c68b">project()</a> function above, with <code>mapping=<a class="el" href="classMappingQ1.html">MappingQ1</a>&lt;dim&gt;()</code>. </p>

<p>Definition at line <a class="el" href="vector__tools_8templates_8h_source.html#l00683">683</a> of file <a class="el" href="vector__tools_8templates_8h_source.html">vector_tools.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae4aae7920ad9a8710e7fd65d4a2d2dd7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, class VECTOR , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::project </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VECTOR &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>enforce_zero_boundary</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim-1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q_boundary</em> = <code><a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt;&#160;dim-1&#160;&gt;(dim&#160;&gt;&#160;1?<a class="el" href="classQGauss.html">QGauss</a>&lt;&#160;dim-1&#160;&gt;(2):<a class="el" href="classQuadrature.html">Quadrature</a>&lt;&#160;dim-1&#160;&gt;(0))</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>project_to_boundary_first</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above, but for arguments of type <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>, hp::QuadratureCollection, <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a> </p>

<p>Definition at line <a class="el" href="vector__tools_8templates_8h_source.html#l00699">699</a> of file <a class="el" href="vector__tools_8templates_8h_source.html">vector_tools.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a08875eebc3d3f2bb180cbe3f4f54e84d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, class VECTOR , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::project </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VECTOR &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>enforce_zero_boundary</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim-1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q_boundary</em> = <code><a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt;&#160;dim-1&#160;&gt;(dim&#160;&gt;&#160;1?<a class="el" href="classQGauss.html">QGauss</a>&lt;&#160;dim-1&#160;&gt;(2):<a class="el" href="classQuadrature.html">Quadrature</a>&lt;&#160;dim-1&#160;&gt;(0))</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>project_to_boundary_first</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calls the <a class="el" href="namespaceVectorTools.html#aef011bd8868e6f8ce1309cf76d34c68b">project()</a> function above, with a collection of <a class="el" href="classMappingQ1.html">MappingQ1</a>&lt;dim&gt;() objects. </p>

<p>Definition at line <a class="el" href="vector__tools_8templates_8h_source.html#l00717">717</a> of file <a class="el" href="vector__tools_8templates_8h_source.html">vector_tools.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a920c5f556c9a56b891b0fbdb279cb58b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::create_right_hand_side </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a right hand side vector. Prior content of the given <code>rhs_vector</code> vector is deleted.</p>
<p>See the general documentation of this class for further information. </p>

<p>Definition at line <a class="el" href="vector__tools_8templates_8h_source.html#l00733">733</a> of file <a class="el" href="vector__tools_8templates_8h_source.html">vector_tools.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a40977aea482308f4c7f50faee278c3e0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::create_right_hand_side </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calls the <a class="el" href="namespaceVectorTools.html#a920c5f556c9a56b891b0fbdb279cb58b">create_right_hand_side()</a> function, see above, with <code>mapping=<a class="el" href="classMappingQ1.html">MappingQ1</a>&lt;dim&gt;()</code>. </p>

<p>Definition at line <a class="el" href="vector__tools_8templates_8h_source.html#l00844">844</a> of file <a class="el" href="vector__tools_8templates_8h_source.html">vector_tools.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a31354fd9c625a84ad3b3f07089d8af4a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::create_right_hand_side </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like the previous set of functions, but for hp objects. </p>

<p>Definition at line <a class="el" href="vector__tools_8templates_8h_source.html#l00857">857</a> of file <a class="el" href="vector__tools_8templates_8h_source.html">vector_tools.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3cee2b65483fe58cdb629a4ea2811af3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::create_right_hand_side </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like the previous set of functions, but for hp objects. </p>

<p>Definition at line <a class="el" href="vector__tools_8templates_8h_source.html#l00982">982</a> of file <a class="el" href="vector__tools_8templates_8h_source.html">vector_tools.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac4ffc41e72e846029d04e7034de60d09"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::create_point_source_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a right hand side vector for a point source at point <code>p</code>. In other words, it creates a vector <img class="formulaInl" alt="$F$" src="form_117.png"/> so that <img class="formulaInl" alt="$F_i = \int_\Omega \delta(x-p) \phi_i(x) dx$" src="form_629.png"/>. Prior content of the given <code>rhs_vector</code> vector is deleted.</p>
<p>See the general documentation of this class for further information. </p>

<p>Definition at line <a class="el" href="vector__tools_8templates_8h_source.html#l00996">996</a> of file <a class="el" href="vector__tools_8templates_8h_source.html">vector_tools.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2125402359b1f023ceb33e2d13b1112d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::create_point_source_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calls the <a class="el" href="namespaceVectorTools.html#ac4ffc41e72e846029d04e7034de60d09">create_point_source_vector()</a> function, see above, with <code>mapping=<a class="el" href="classMappingQ1.html">MappingQ1</a>&lt;dim&gt;()</code>. </p>

<p>Definition at line <a class="el" href="vector__tools_8templates_8h_source.html#l01030">1030</a> of file <a class="el" href="vector__tools_8templates_8h_source.html">vector_tools.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4f93fa2c3304d3c596a415b657188bc4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::create_point_source_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like the previous set of functions, but for hp objects. </p>

<p>Definition at line <a class="el" href="vector__tools_8templates_8h_source.html#l01040">1040</a> of file <a class="el" href="vector__tools_8templates_8h_source.html">vector_tools.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a13814b79fdf47b3fb61495ba07169cc6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::create_point_source_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like the previous set of functions, but for hp objects. The function uses the default Q1 mapping object. Note that if your <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a> uses any active fe index other than zero, then you need to call the function above that provides a mapping object for each active fe index. </p>

<p>Definition at line <a class="el" href="vector__tools_8templates_8h_source.html#l01074">1074</a> of file <a class="el" href="vector__tools_8templates_8h_source.html">vector_tools.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a391116457ea643b033ebbc6035993376"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::create_point_source_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>orientation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a right hand side vector for a point source at point <code>p</code> for vector-valued finite elements. Prior content of the given <code>rhs_vector</code> vector is deleted.</p>
<p>See the general documentation of this class for further information. </p>

<p>Definition at line <a class="el" href="vector__tools_8templates_8h_source.html#l01087">1087</a> of file <a class="el" href="vector__tools_8templates_8h_source.html">vector_tools.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="aad290b9c5f53a13ad8ede1ba251c7f4f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::create_point_source_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>orientation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calls the <a class="el" href="namespaceVectorTools.html#ac4ffc41e72e846029d04e7034de60d09">create_point_source_vector()</a> function for vector-valued finite elements, see above, with <code>mapping=<a class="el" href="classMappingQ1.html">MappingQ1</a>&lt;dim&gt;()</code>. </p>

<p>Definition at line <a class="el" href="vector__tools_8templates_8h_source.html#l01123">1123</a> of file <a class="el" href="vector__tools_8templates_8h_source.html">vector_tools.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac86cbe26b653a34fe480b13ea4a2704a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::create_point_source_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>orientation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like the previous set of functions, but for hp objects. </p>

<p>Definition at line <a class="el" href="vector__tools_8templates_8h_source.html#l01134">1134</a> of file <a class="el" href="vector__tools_8templates_8h_source.html">vector_tools.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2603f88b368e01a6b5eba00b61afb09c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::create_point_source_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>orientation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like the previous set of functions, but for hp objects. The function uses the default Q1 mapping object. Note that if your <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a> uses any active fe index other than zero, then you need to call the function above that provides a mapping object for each active fe index. </p>

<p>Definition at line <a class="el" href="vector__tools_8templates_8h_source.html#l01170">1170</a> of file <a class="el" href="vector__tools_8templates_8h_source.html">vector_tools.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="aeed485c44a7ce3b7b0657b8f7bc0f5b3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::create_boundary_right_hand_side </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_indicators</em> = <code>std::set&lt;&#160;<a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a right hand side vector from boundary forces. Prior content of the given <code>rhs_vector</code> vector is deleted.</p>
<p>See the general documentation of this class for further information.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a> </dd></dl>

<p>Definition at line <a class="el" href="vector__tools_8templates_8h_source.html#l01184">1184</a> of file <a class="el" href="vector__tools_8templates_8h_source.html">vector_tools.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="adeefd16a72fa7df8dcaa296f3d68ae30"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::create_boundary_right_hand_side </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_indicators</em> = <code>std::set&lt;&#160;<a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calls the <a class="el" href="namespaceVectorTools.html#aeed485c44a7ce3b7b0657b8f7bc0f5b3">create_boundary_right_hand_side()</a> function, see above, with <code>mapping=<a class="el" href="classMappingQ1.html">MappingQ1</a>&lt;dim&gt;()</code>.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a> </dd></dl>

<p>Definition at line <a class="el" href="vector__tools_8templates_8h_source.html#l01307">1307</a> of file <a class="el" href="vector__tools_8templates_8h_source.html">vector_tools.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2e2e49503497dbd89d0212efd7cf396b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::create_boundary_right_hand_side </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim-1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_indicators</em> = <code>std::set&lt;&#160;<a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as the set of functions above, but for hp objects.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a> </dd></dl>

<p>Definition at line <a class="el" href="vector__tools_8templates_8h_source.html#l01323">1323</a> of file <a class="el" href="vector__tools_8templates_8h_source.html">vector_tools.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a008b79dc8cecae6e50235332fd92f35b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::create_boundary_right_hand_side </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim-1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_indicators</em> = <code>std::set&lt;&#160;<a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calls the <a class="el" href="namespaceVectorTools.html#aeed485c44a7ce3b7b0657b8f7bc0f5b3">create_boundary_right_hand_side()</a> function, see above, with a single Q1 mapping as collection. This function therefore will only work if the only active fe index in use is zero.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a> </dd></dl>

<p>Definition at line <a class="el" href="vector__tools_8templates_8h_source.html#l01458">1458</a> of file <a class="el" href="vector__tools_8templates_8h_source.html">vector_tools.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a199f38e07822b47e5b5957c21ce35d1b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DH &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::interpolate_boundary_values </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; DH::dimension, DH::space_dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DH &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="structFunctionMap.html">FunctionMap</a>&lt; DH::space_dimension &gt;::type &amp;&#160;</td>
          <td class="paramname"><em>function_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute Dirichlet boundary conditions. This function makes up a map of degrees of freedom subject to Dirichlet boundary conditions and the corresponding values to be assigned to them, by interpolation around the boundary. If the <code>boundary_values</code> object contained values before, the new ones are added, or the old ones overwritten if a node of the boundary part to be used was already in the map of boundary values.</p>
<p>The parameter <code>function_map</code> provides a list of boundary indicators to be handled by this function and corresponding boundary value functions. The keys of this map correspond to the number <code>boundary_indicator</code> of the face. <a class="el" href="namespacenumbers.html#a4e5d3fa25689151c833ba46dcc96fa5b">numbers::internal_face_boundary_id</a> is an illegal value for this key since it is reserved for interior faces.</p>
<p>The flags in the last parameter, <code>component_mask</code> denote which components of the finite element space shall be interpolated. If it is left as specified by the default value (i.e. an empty array), all components are interpolated. If it is different from the default value, it is assumed that the number of entries equals the number of components in the boundary functions and the finite element, and those components in the given boundary function will be used for which the respective flag was set in the component mask. See also <a class="el" href="DEALGlossary.html#GlossComponentMask">GlossComponentMask</a>. As an example, assume that you are solving the Stokes equations in 2d, with variables <img class="formulaInl" alt="$(u,v,p)$" src="form_611.png"/> and that you only want to interpolate boundary values for the pressure, then the component mask should correspond to <code>(true,true,false)</code>.</p>
<dl class="section note"><dt>Note</dt><dd>Whether a component mask has been specified or not, the number of components of the functions in <code>function_map</code> must match that of the finite element used by <code>dof</code>. In other words, for the example above, you need to provide a <a class="el" href="classFunction.html">Function</a> object that has 3 components (the two velocities and the pressure), even though you are only interested in the first two of them. <a class="el" href="namespaceVectorTools.html#a199f38e07822b47e5b5957c21ce35d1b">interpolate_boundary_values()</a> will then call this function to obtain a vector of 3 values at each interpolation point but only take the first two and discard the third. In other words, you are free to return whatever you like in the third component of the vector returned by <a class="el" href="classFunction.html#a1fa27ec3204c0929a0b33ae34a97ef8f">Function::vector_value</a>, but the <a class="el" href="classFunction.html">Function</a> object must state that it has 3 components.</dd></dl>
<p>If the finite element used has shape functions that are non-zero in more than one component (in deal.II speak: they are non-primitive), then these components can presently not be used for interpolating boundary values. Thus, the elements in the component mask corresponding to the components of these non-primitive shape functions must be <code>false</code>.</p>
<p>See the general documentation of this class for more information. </p>

<p>Definition at line <a class="el" href="vector__tools_8templates_8h_source.html#l01807">1807</a> of file <a class="el" href="vector__tools_8templates_8h_source.html">vector_tools.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a057810ea8a924ab0ffdaaed9ff2e4146"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DH &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::interpolate_boundary_values </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; DH::dimension, DH::space_dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DH &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>boundary_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; DH::space_dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same function as above, but taking only one pair of boundary indicator and corresponding boundary function. The same comments apply as for the previous function, in particular about the use of the component mask and the requires size of the function object.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a> </dd></dl>

<p>Definition at line <a class="el" href="vector__tools_8templates_8h_source.html#l01822">1822</a> of file <a class="el" href="vector__tools_8templates_8h_source.html">vector_tools.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4371d4a79b27b76b2a6ca0c06b2a51f8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::interpolate_boundary_values </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="structFunctionMap.html">FunctionMap</a>&lt; spacedim &gt;::type &amp;&#160;</td>
          <td class="paramname"><em>function_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like the previous function, but take a mapping collection to go with the <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a> object. </p>

<p>Definition at line <a class="el" href="vector__tools_8templates_8h_source.html#l01838">1838</a> of file <a class="el" href="vector__tools_8templates_8h_source.html">vector_tools.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="abb6634f0950a99782b9483cbf12a4fef"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DH &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::interpolate_boundary_values </td>
          <td>(</td>
          <td class="paramtype">const DH &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>boundary_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; DH::space_dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calls the other <a class="el" href="namespaceVectorTools.html#a199f38e07822b47e5b5957c21ce35d1b">interpolate_boundary_values()</a> function, see above, with <code>mapping=<a class="el" href="classMappingQ1.html">MappingQ1</a>&lt;dim&gt;()</code>. The same comments apply as for the previous function, in particular about the use of the component mask and the requires size of the function object.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a> </dd></dl>

<p>Definition at line <a class="el" href="vector__tools_8templates_8h_source.html#l01853">1853</a> of file <a class="el" href="vector__tools_8templates_8h_source.html">vector_tools.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab9855e634bb2c3ab61acf67763be5cb2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DH &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::interpolate_boundary_values </td>
          <td>(</td>
          <td class="paramtype">const DH &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="structFunctionMap.html">FunctionMap</a>&lt; DH::space_dimension &gt;::type &amp;&#160;</td>
          <td class="paramname"><em>function_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calls the other <a class="el" href="namespaceVectorTools.html#a199f38e07822b47e5b5957c21ce35d1b">interpolate_boundary_values()</a> function, see above, with <code>mapping=<a class="el" href="classMappingQ1.html">MappingQ1</a>&lt;dim&gt;()</code>. The same comments apply as for the previous function, in particular about the use of the component mask and the requires size of the function object. </p>

<p>Definition at line <a class="el" href="vector__tools_8templates_8h_source.html#l01868">1868</a> of file <a class="el" href="vector__tools_8templates_8h_source.html">vector_tools.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="aebbe1c685f39b991ca3eba870787ee68"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::project_boundary_values </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="structFunctionMap.html">FunctionMap</a>&lt; spacedim &gt;::type &amp;&#160;</td>
          <td class="paramname"><em>boundary_functions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td>
          <td class="paramname"><em>component_mapping</em> = <code>std::vector&lt;&#160;unsigned&#160;<a class="el" href="classint.html">int</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Project a function to the boundary of the domain, using the given quadrature formula for the faces. If the <code>boundary_values</code> contained values before, the new ones are added, or the old one overwritten if a node of the boundary part to be projected on already was in the variable.</p>
<p>If <code>component_mapping</code> is empty, it is assumed that the number of components of <code>boundary_function</code> matches that of the finite element used by <code>dof</code>.</p>
<p>In 1d, projection equals interpolation. Therefore, interpolate_boundary_values is called.</p>
<ul>
<li><code>boundary_values:</code> the result of this function, a map containing all indices of degrees of freedom at the boundary (as covered by the boundary parts in <code>boundary_functions</code>) and the computed dof value for this degree of freedom.</li>
</ul>
<ul>
<li><code>component_mapping:</code> if the components in <code>boundary_functions</code> and <code>dof</code> do not coincide, this vector allows them to be remapped. If the vector is not empty, it has to have one entry for each component in <code>dof</code>. This entry is the component number in <code>boundary_functions</code> that should be used for this component in <code>dof</code>. By default, no remapping is applied. </li>
</ul>

<p>Definition at line <a class="el" href="vector__tools_8templates_8h_source.html#l02152">2152</a> of file <a class="el" href="vector__tools_8templates_8h_source.html">vector_tools.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a61b31a2d0ac435a83f6ac93d93e6e147"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::project_boundary_values </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="structFunctionMap.html">FunctionMap</a>&lt; spacedim &gt;::type &amp;&#160;</td>
          <td class="paramname"><em>boundary_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td>
          <td class="paramname"><em>component_mapping</em> = <code>std::vector&lt;&#160;unsigned&#160;<a class="el" href="classint.html">int</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calls the <a class="el" href="namespaceVectorTools.html#aebbe1c685f39b991ca3eba870787ee68">project_boundary_values()</a> function, see above, with <code>mapping=<a class="el" href="classMappingQ1.html">MappingQ1</a>&lt;dim&gt;()</code>. </p>

<p>Definition at line <a class="el" href="vector__tools_8templates_8h_source.html#l02167">2167</a> of file <a class="el" href="vector__tools_8templates_8h_source.html">vector_tools.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac3a458ebfbc06e833f4a682f8fd88b29"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::project_boundary_values </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="structFunctionMap.html">FunctionMap</a>&lt; spacedim &gt;::type &amp;&#160;</td>
          <td class="paramname"><em>boundary_functions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim-1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td>
          <td class="paramname"><em>component_mapping</em> = <code>std::vector&lt;&#160;unsigned&#160;<a class="el" href="classint.html">int</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above, but for objects of type <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a> </p>

<p>Definition at line <a class="el" href="vector__tools_8templates_8h_source.html#l02180">2180</a> of file <a class="el" href="vector__tools_8templates_8h_source.html">vector_tools.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="af163638de6716f0d94cc3ef8d43ff561"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::project_boundary_values </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="structFunctionMap.html">FunctionMap</a>&lt; spacedim &gt;::type &amp;&#160;</td>
          <td class="paramname"><em>boundary_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim-1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td>
          <td class="paramname"><em>component_mapping</em> = <code>std::vector&lt;&#160;unsigned&#160;<a class="el" href="classint.html">int</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calls the <a class="el" href="namespaceVectorTools.html#aebbe1c685f39b991ca3eba870787ee68">project_boundary_values()</a> function, see above, with <code>mapping=<a class="el" href="classMappingQ1.html">MappingQ1</a>&lt;dim&gt;()</code>. </p>

<p>Definition at line <a class="el" href="vector__tools_8templates_8h_source.html#l02196">2196</a> of file <a class="el" href="vector__tools_8templates_8h_source.html">vector_tools.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a207f8d66d6e9ef2794f9c44dec293997"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, template&lt; int, int &gt; class DH, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::compute_normal_flux_constraints </td>
          <td>(</td>
          <td class="paramtype">const DH&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>first_vector_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em> = <code><a class="el" href="structStaticMappingQ1.html">StaticMappingQ1</a>&lt;&#160;dim&#160;&gt;::mapping</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the constraints that correspond to boundary conditions of the form <img class="formulaInl" alt="$\vec n \times \vec u=0$" src="form_628.png"/>, i.e. flow normal to the boundary if <img class="formulaInl" alt="$\vec u$" src="form_602.png"/> is a vector-valued quantity. This function constrains exactly those vector-valued components that are left unconstrained by compute_no_normal_flux_constraints, and leaves the one component unconstrained that is constrained by compute_no_normal_flux_constraints. </p>

<p>Definition at line <a class="el" href="vector__tools_8templates_8h_source.html#l04657">4657</a> of file <a class="el" href="vector__tools_8templates_8h_source.html">vector_tools.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7943a1670ee3a54fa18f5bcafcb1e870"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::integrate_difference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>exact_solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>difference</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NormType &amp;&#160;</td>
          <td class="paramname"><em>norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *&#160;</td>
          <td class="paramname"><em>weight</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>exponent</em> = <code>2.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the error of the finite element solution. Integrate the difference between a reference function which is given as a continuous function object, and a finite element function. The result of this function is the vector <code>difference</code> that contains one value per active cell <img class="formulaInl" alt="$K$" src="form_630.png"/> of the triangulation. Each of the values of this vector <img class="formulaInl" alt="$d$" src="form_172.png"/> equals </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} d_K = \| u-u_h \|_X \end{align*}" src="form_631.png"/>
</p>
<p> where <img class="formulaInl" alt="$X$" src="form_309.png"/> denotes the norm chosen and <img class="formulaInl" alt="$u$" src="form_594.png"/> represents the exact solution.</p>
<p>It is assumed that the number of components of the function <code>exact_solution</code> matches that of the finite element used by <code>dof</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mapping</td><td>The mapping that is used when integrating the difference <img class="formulaInl" alt="$u-u_h$" src="form_632.png"/>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dof</td><td>The <a class="el" href="classDoFHandler.html">DoFHandler</a> object that describes the finite element space in which the solution vector lives. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fe_function</td><td>A vector with nodal values representing the numerical approximation <img class="formulaInl" alt="$u_h$" src="form_633.png"/>. This vector needs to correspond to the finite element space represented by <code>dof</code> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">difference</td><td>The vector of values <img class="formulaInl" alt="$d_K$" src="form_634.png"/> computed as above. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>The quadrature formula used to approximate the integral shown above. Note that some quadrature formulas are more useful than other in integrating <img class="formulaInl" alt="$u-u_h$" src="form_632.png"/>. For example, it is known that the <img class="formulaInl" alt="$Q_1$" src="form_37.png"/> approximation <img class="formulaInl" alt="$u_h$" src="form_633.png"/> to the exact solution <img class="formulaInl" alt="$u$" src="form_594.png"/> of a Laplace equation is particularly accurate (in fact, superconvergent, i.e. accurate to higher order) at the 4 Gauss points of a cell in 2d (or 8 points in 3d) that correspond to a <a class="el" href="classQGauss.html">QGauss(2)</a> object. Consequently, because a <a class="el" href="classQGauss.html">QGauss(2)</a> formula only evaluates the two solutions at these particular points, choosing this quadrature formula may indicate an error far smaller than it actually is. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">norm</td><td>The norm <img class="formulaInl" alt="$X$" src="form_309.png"/> shown above that should be computed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">weight</td><td>The additional argument <code>weight</code> allows to evaluate weighted norms. The weight function may be scalar, establishing a weight in the domain for all components equally. This may be used, for instance, to only integrate over parts of the domain. The weight function may also be vector-valued, with as many components as the finite element: Then, different components get different weights. A typical application is when the error with respect to only one or a subset of the solution variables is to be computed, in which the other components would have weight values equal to zero. The <a class="el" href="classComponentSelectFunction.html">ComponentSelectFunction</a> class is particularly useful for this purpose as it provides such as "mask" weight.. The weight function is expected to be positive, but negative values are not filtered. By default, no weighting function is given, i.e. weight=1 in the whole domain for all vector components uniformly. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">exponent</td><td>This value denotes the <img class="formulaInl" alt="$p$" src="form_65.png"/> used in computing <img class="formulaInl" alt="$L^p$" src="form_635.png"/>-norms and <img class="formulaInl" alt="$W^{1,p}$" src="form_636.png"/>-norms. The value is ignores if a <code>norm</code> other than NormType::Lp_norm or NormType::W1p_norm is chosen.</td></tr>
  </table>
  </dd>
</dl>
<p>See the general documentation of this class for more information.</p>
<dl class="section note"><dt>Note</dt><dd>If the integration here happens over the cells of a parallel::distribute::Triangulation object, then this function computes the vector elements <img class="formulaInl" alt="$d_K$" src="form_634.png"/> for an output vector with as many cells as there are active cells of the triangulation object of the current processor. However, not all active cells are in fact locally owned: some may be ghost or artificial cells (see <a class="el" href="DEALGlossary.html#GlossGhostCell">here</a> and <a class="el" href="DEALGlossary.html#GlossArtificialCell">here</a>). The vector computed will, in the case of a distributed triangulation, contain zeros for cells that are not locally owned. As a consequence, in order to compute the <em>global</em> <img class="formulaInl" alt="$L_2$" src="form_294.png"/> error (for example), the errors from different processors need to be combined, but this is simple because every processor only computes contributions for those cells of the global triangulation it locally owns (and these sets are, by definition, mutually disjoint). Consequently, the following piece of code computes the global <img class="formulaInl" alt="$L_2$" src="form_294.png"/> error across multiple processors sharing a parallel::distribute::Triangulation: <div class="fragment"><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a> local_errors (tria.n_active_cells());</div>
<div class="line"><a class="code" href="namespaceVectorTools.html#a7943a1670ee3a54fa18f5bcafcb1e870">VectorTools::integrate_difference</a> (mapping, dof,</div>
<div class="line">                                   solution, exact_solution,</div>
<div class="line">                                   local_errors,</div>
<div class="line">                                   <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.degree+2),</div>
<div class="line">                                   NormType::L2_norm);</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> total_local_error = local_errors.l2_norm();</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> total_global_error</div>
<div class="line">  = std::sqrt (<a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">Utilities::MPI::sum</a> (total_local_error * total_local_error, MPI_COMM_WORLD));</div>
</div><!-- fragment --> The squaring and taking the square root is necessary in order to compute the sum of squares of norms over all all cells in the definition of the <img class="formulaInl" alt="$L_2$" src="form_294.png"/> norm: <p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \textrm{error} = \sqrt{\sum_K \|u-u_h\|_{L_2(K)}^2} \end{align*}" src="form_637.png"/>
</p>
 Obviously, if you are interested in computing the <img class="formulaInl" alt="$L_1$" src="form_638.png"/> norm of the error, the correct form of the last two lines would have been <div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> total_local_error = local_errors.l1_norm();</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> total_global_error</div>
<div class="line">  = <a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">Utilities::MPI::sum</a> (total_local_error, MPI_COMM_WORLD);</div>
</div><!-- fragment --> instead, and similar considerations hold when computing the <img class="formulaInl" alt="$L_\infty$" src="form_610.png"/> norm of the error.</dd></dl>
<p>Instantiations for this template are provided for some vector types (see the general documentation of the class), but only for InVectors as in the documentation of the class, OutVector only <a class="el" href="classVector.html">Vector&lt;double&gt;</a> and Vector&lt;float&gt;. </p>

<p>Definition at line <a class="el" href="vector__tools_8templates_8h_source.html#l05189">5189</a> of file <a class="el" href="vector__tools_8templates_8h_source.html">vector_tools.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a98c1adfc5f8b5f393d7f715370915655"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::integrate_difference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>exact_solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>difference</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NormType &amp;&#160;</td>
          <td class="paramname"><em>norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *&#160;</td>
          <td class="paramname"><em>weight</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>exponent</em> = <code>2.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calls the <a class="el" href="namespaceVectorTools.html#a7943a1670ee3a54fa18f5bcafcb1e870">integrate_difference()</a> function, see above, with <code>mapping=<a class="el" href="classMappingQ1.html">MappingQ1</a>&lt;dim&gt;()</code>. </p>

<p>Definition at line <a class="el" href="vector__tools_8templates_8h_source.html#l05209">5209</a> of file <a class="el" href="vector__tools_8templates_8h_source.html">vector_tools.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae93983876ee890f3c9c8e041cfcac4ea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, class InVector , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::point_difference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>exact_solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>difference</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classPoint.html">Point</a> error evaluation. Find the first cell containing the given point and compute the difference of a (possibly vector-valued) finite element function and a continuous function (with as many vector components as the finite element) at this point.</p>
<p>This is a wrapper function using a Q1-mapping for cell boundaries to call the other <a class="el" href="namespaceVectorTools.html#ae93983876ee890f3c9c8e041cfcac4ea">point_difference()</a> function.</p>
<dl class="section note"><dt>Note</dt><dd>If the cell in which the point is found is not locally owned, an exception of type VectorTools::ExcPointNotAvailableHere is thrown. </dd></dl>

<p>Definition at line <a class="el" href="vector__tools_8templates_8h_source.html#l05269">5269</a> of file <a class="el" href="vector__tools_8templates_8h_source.html">vector_tools.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="aedeb7e048650f27810486d4cf6c3a3ab"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, class InVector , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::point_difference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>exact_solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>difference</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classPoint.html">Point</a> error evaluation. Find the first cell containing the given point and compute the difference of a (possibly vector-valued) finite element function and a continuous function (with as many vector components as the finite element) at this point.</p>
<p>Compared with the other function of the same name, this function uses an arbitrary mapping to evaluate the difference.</p>
<dl class="section note"><dt>Note</dt><dd>If the cell in which the point is found is not locally owned, an exception of type VectorTools::ExcPointNotAvailableHere is thrown. </dd></dl>

<p>Definition at line <a class="el" href="vector__tools_8templates_8h_source.html#l05286">5286</a> of file <a class="el" href="vector__tools_8templates_8h_source.html">vector_tools.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a52246ae4d0c5669917030ef5f209074f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, class InVector , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::point_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Evaluate a possibly vector-valued finite element function defined by the given <a class="el" href="classDoFHandler.html">DoFHandler</a> and nodal vector at the given point, and return the (vector) value of this function through the last argument.</p>
<p>This is a wrapper function using a Q1-mapping for cell boundaries to call the other <a class="el" href="namespaceVectorTools.html#ae93983876ee890f3c9c8e041cfcac4ea">point_difference()</a> function.</p>
<dl class="section note"><dt>Note</dt><dd>If the cell in which the point is found is not locally owned, an exception of type VectorTools::ExcPointNotAvailableHere is thrown. </dd></dl>

<p>Definition at line <a class="el" href="vector__tools_8templates_8h_source.html#l05331">5331</a> of file <a class="el" href="vector__tools_8templates_8h_source.html">vector_tools.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa2cf2937e803f1802f943dc88f890db5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, class InVector , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::point_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above for hp.</p>
<dl class="section note"><dt>Note</dt><dd>If the cell in which the point is found is not locally owned, an exception of type VectorTools::ExcPointNotAvailableHere is thrown. </dd></dl>

<p>Definition at line <a class="el" href="vector__tools_8templates_8h_source.html#l05347">5347</a> of file <a class="el" href="vector__tools_8templates_8h_source.html">vector_tools.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a957bc39d21d7038c93ab47ffbeea1081"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, class InVector , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> VectorTools::point_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Evaluate a scalar finite element function defined by the given <a class="el" href="classDoFHandler.html">DoFHandler</a> and nodal vector at the given point, and return the value of this function.</p>
<p>Compared with the other function of the same name, this is a wrapper function using a Q1-mapping for cells.</p>
<p>This function is used in the "Possibilities for extensions" part of the results section of <a class="el" href="step_3.html">step-3</a>.</p>
<dl class="section note"><dt>Note</dt><dd>If the cell in which the point is found is not locally owned, an exception of type VectorTools::ExcPointNotAvailableHere is thrown. </dd></dl>

<p>Definition at line <a class="el" href="vector__tools_8templates_8h_source.html#l05362">5362</a> of file <a class="el" href="vector__tools_8templates_8h_source.html">vector_tools.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad03389332dc285c35e038d91fc522228"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, class InVector , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> VectorTools::point_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above for hp.</p>
<dl class="section note"><dt>Note</dt><dd>If the cell in which the point is found is not locally owned, an exception of type VectorTools::ExcPointNotAvailableHere is thrown. </dd></dl>

<p>Definition at line <a class="el" href="vector__tools_8templates_8h_source.html#l05375">5375</a> of file <a class="el" href="vector__tools_8templates_8h_source.html">vector_tools.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7acdd14905dc47512185fa34a2ab9ffb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, class InVector , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::point_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Evaluate a possibly vector-valued finite element function defined by the given <a class="el" href="classDoFHandler.html">DoFHandler</a> and nodal vector at the given point, and return the (vector) value of this function through the last argument.</p>
<p>Compared with the other function of the same name, this function uses an arbitrary mapping to evaluate the difference.</p>
<dl class="section note"><dt>Note</dt><dd>If the cell in which the point is found is not locally owned, an exception of type VectorTools::ExcPointNotAvailableHere is thrown. </dd></dl>

<p>Definition at line <a class="el" href="vector__tools_8templates_8h_source.html#l05388">5388</a> of file <a class="el" href="vector__tools_8templates_8h_source.html">vector_tools.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="aed147b463bcd8916cd056cf6353be634"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, class InVector , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::point_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above for hp.</p>
<dl class="section note"><dt>Note</dt><dd>If the cell in which the point is found is not locally owned, an exception of type VectorTools::ExcPointNotAvailableHere is thrown. </dd></dl>

<p>Definition at line <a class="el" href="vector__tools_8templates_8h_source.html#l05428">5428</a> of file <a class="el" href="vector__tools_8templates_8h_source.html">vector_tools.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6d982cab4fdd13813daebc4fa5bb3115"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, class InVector , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> VectorTools::point_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Evaluate a scalar finite element function defined by the given <a class="el" href="classDoFHandler.html">DoFHandler</a> and nodal vector at the given point, and return the value of this function.</p>
<p>Compared with the other function of the same name, this function uses an arbitrary mapping to evaluate the difference.</p>
<dl class="section note"><dt>Note</dt><dd>If the cell in which the point is found is not locally owned, an exception of type VectorTools::ExcPointNotAvailableHere is thrown. </dd></dl>

<p>Definition at line <a class="el" href="vector__tools_8templates_8h_source.html#l05467">5467</a> of file <a class="el" href="vector__tools_8templates_8h_source.html">vector_tools.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a25b3eab1a6d870bcbf63c466d774cf12"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, class InVector , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> VectorTools::point_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above for hp.</p>
<dl class="section note"><dt>Note</dt><dd>If the cell in which the point is found is not locally owned, an exception of type VectorTools::ExcPointNotAvailableHere is thrown. </dd></dl>

<p>Definition at line <a class="el" href="vector__tools_8templates_8h_source.html#l05504">5504</a> of file <a class="el" href="vector__tools_8templates_8h_source.html">vector_tools.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="afa2b82480caf313f599fc4182a2506f3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VECTOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::subtract_mean_value </td>
          <td>(</td>
          <td class="paramtype">VECTOR &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_select</em> = <code>std::vector&lt;&#160;<a class="el" href="classbool.html">bool</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mean value operations Subtract the (algebraic) mean value from a vector.</p>
<p>This function is most frequently used as a mean-value filter for Stokes: The pressure in Stokes' equations with only Dirichlet boundaries for the velocities is only determined up to a constant. This function allows to subtract the mean value of the pressure. It is usually called in a preconditioner and generates updates with mean value zero. The mean value is computed as the mean value of the degrees of freedom values as given by the input vector; they are not weighted by the area of cells, i.e. the mean is computed as <img class="formulaInl" alt="$\sum_i v_i$" src="form_639.png"/>, rather than as <img class="formulaInl" alt="$\int_\Omega v(x) = \int_\Omega \sum_i v_i \phi_i(x)$" src="form_640.png"/>. The latter can be obtained from the VectorTools::compute_mean_function, however.</p>
<p>Apart from the vector <code>v</code> to operate on, this function takes a boolean mask <code>p_select</code> that has a true entry for every element of the vector for which the mean value shall be computed and later subtracted. The argument is used to denote which components of the solution vector correspond to the pressure, and avoid touching all other components of the vector, such as the velocity components. (Note, however, that the mask is not a <a class="el" href="DEALGlossary.html#GlossComponentMask">GlossComponentMask</a> operating on the vector components of the finite element the solution vector <code>v</code> may be associated with; rather, it is a mask on the entire vector, without reference to what the vector elements mean.)</p>
<p>The boolean mask <code>p_select</code> has an empty vector as default value, which will be interpreted as selecting all vector elements, hence, subtracting the algebraic mean value on the whole vector. This allows to call this function without a boolean mask if the whole vector should be processed.</p>
<dl class="section note"><dt>Note</dt><dd>In the context of using this function to filter out the kernel of an operator (such as the null space of the Stokes operator that consists of the constant pressures), this function only makes sense for finite elements for which the null space indeed consists of the vector <img class="formulaInl" alt="$(1,1,\ldots,1)^T$" src="form_641.png"/>. This is the case for example for the usual Lagrange elements where the sum of all shape functions equals the function that is constant one. However, it is not true for some other functions: for example, for the <a class="el" href="classFE__DGP.html">FE_DGP</a> element (another valid choice for the pressure in Stokes discretizations), the first shape function on each cell is constant while further elements are <img class="formulaInl" alt="$L_2$" src="form_294.png"/> orthogonal to it (on the reference cell); consequently, the sum of all shape functions is not equal to one, and the vector that is associated with the constant mode is not equal to <img class="formulaInl" alt="$(1,1,\ldots,1)^T$" src="form_641.png"/>. For such elements, a different procedure has to be used when subtracting the mean value. </dd></dl>

<p>Definition at line <a class="el" href="vector__tools_8templates_8h_source.html#l05543">5543</a> of file <a class="el" href="vector__tools_8templates_8h_source.html">vector_tools.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="aae67f4b58828c8eb9107d0accf20f8d5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, class InVector , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> VectorTools::compute_mean_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the mean value of one component of the solution.</p>
<p>This function integrates the chosen component over the whole domain and returns the result, i.e. it computes <img class="formulaInl" alt="$\int_\Omega [u_h(x)]_c \; dx$" src="form_642.png"/> where <img class="formulaInl" alt="$c$" src="form_208.png"/> is the vector component and <img class="formulaInl" alt="$u_h$" src="form_633.png"/> is the function representation of the nodal vector given as fourth argument. The integral is evaluated numerically using the quadrature formula given as third argument.</p>
<p>This function is used in the "Possibilities for extensions" part of the results section of <a class="el" href="step_3.html">step-3</a>.</p>
<dl class="section note"><dt>Note</dt><dd>The function is most often used when solving a problem whose solution is only defined up to a constant, for example a pure Neumann problem or the pressure in a Stokes or Navier-Stokes problem. In both cases, subtracting the mean value as computed by the current function, from the nodal vector does not generally yield the desired result of a finite element function with mean value zero. In fact, it only works for Lagrangian elements. For all other elements, you will need to compute the mean value and subtract it right inside the evaluation routine. </dd></dl>

<p>Definition at line <a class="el" href="vector__tools_8templates_8h_source.html#l05592">5592</a> of file <a class="el" href="vector__tools_8templates_8h_source.html">vector_tools.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="aaabf9153a6fd4d2755043465c703018c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, class InVector , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> VectorTools::compute_mean_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calls the other <a class="el" href="namespaceVectorTools.html#aae67f4b58828c8eb9107d0accf20f8d5">compute_mean_value()</a> function, see above, with <code>mapping=<a class="el" href="classMappingQ1.html">MappingQ1</a>&lt;dim&gt;()</code>. </p>

<p>Definition at line <a class="el" href="vector__tools_8templates_8h_source.html#l05651">5651</a> of file <a class="el" href="vector__tools_8templates_8h_source.html">vector_tools.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab4dfd07067f428492f6e48e15f7b082b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, template&lt; int, int &gt; class DH, class VECTOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::interpolate_to_different_mesh </td>
          <td>(</td>
          <td class="paramtype">const DH&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VECTOR &amp;&#160;</td>
          <td class="paramname"><em>u1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DH&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VECTOR &amp;&#160;</td>
          <td class="paramname"><em>u2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gives the interpolation of a <code>dof1-function</code> <code>u1</code> to a <code>dof2-function</code> <code>u2</code>, where <code>dof1</code> and <code>dof2</code> represent different triangulations with a common coarse grid.</p>
<p>dof1 and dof2 need to have the same finite element discretization.</p>
<p>Note that for continuous elements on grids with hanging nodes (i.e. locally refined grids) this function does not give the expected output. Indeed, the resulting output vector does not necessarily respect continuity requirements at hanging nodes, due to local cellwise interpolation.</p>
<p>For this case (continuous elements on grids with hanging nodes), please use the interpolate_to_different_mesh function with an additional <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> argument, see below, or make the field conforming yourself by calling the <code>ConstraintsMatrix::distribute</code> function of your hanging node constraints object. </p>

</div>
</div>
<a class="anchor" id="aa461f7cb77aada0058541e5757735397"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, template&lt; int, int &gt; class DH, class VECTOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::interpolate_to_different_mesh </td>
          <td>(</td>
          <td class="paramtype">const DH&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VECTOR &amp;&#160;</td>
          <td class="paramname"><em>u1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DH&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VECTOR &amp;&#160;</td>
          <td class="paramname"><em>u2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gives the interpolation of a <code>dof1-function</code> <code>u1</code> to a <code>dof2-function</code> <code>u2</code>, where <code>dof1</code> and <code>dof2</code> represent different triangulations with a common coarse grid.</p>
<p>dof1 and dof2 need to have the same finite element discretization.</p>
<p><code>constraints</code> is a hanging node constraints object corresponding to <code>dof2</code>. This object is particularly important when interpolating onto continuous elements on grids with hanging nodes (locally refined grids): Without it - due to cellwise interpolation - the resulting output vector does not necessarily respect continuity requirements at hanging nodes. </p>

</div>
</div>
<a class="anchor" id="a69cb20339402f4abfdd41f25209f4eae"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, template&lt; int, int &gt; class DH, class VECTOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::interpolate_to_different_mesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classInterGridMap.html">InterGridMap</a>&lt; DH&lt; dim, spacedim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>intergridmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VECTOR &amp;&#160;</td>
          <td class="paramname"><em>u1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VECTOR &amp;&#160;</td>
          <td class="paramname"><em>u2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The same function as above, but takes an <a class="el" href="classInterGridMap.html">InterGridMap</a> object directly as a parameter. Useful for interpolating several vectors at the same time.</p>
<p><code>intergridmap</code> has to be initialized via <a class="el" href="classInterGridMap.html#a5d0dd588d51998d78595c709131f2615">InterGridMap::make_mapping</a> pointing from a source <a class="el" href="classDoFHandler.html">DoFHandler</a> to a destination <a class="el" href="classDoFHandler.html">DoFHandler</a>. </p>

</div>
</div>
<a class="anchor" id="a9908aafc34c3075b080c655f75d0fdfd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::integrate_difference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>exact_solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>difference</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NormType &amp;&#160;</td>
          <td class="paramname"><em>norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *&#160;</td>
          <td class="paramname"><em>weight</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>exponent</em> = <code>2.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above for hp. </p>

</div>
</div>
<a class="anchor" id="a5fad995e898371bb6362935ba7fda855"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::integrate_difference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>exact_solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>difference</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NormType &amp;&#160;</td>
          <td class="paramname"><em>norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *&#160;</td>
          <td class="paramname"><em>weight</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>exponent</em> = <code>2.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calls the <a class="el" href="namespaceVectorTools.html#a7943a1670ee3a54fa18f5bcafcb1e870">integrate_difference()</a> function, see above, with <code>mapping=<a class="el" href="classMappingQ1.html">MappingQ1</a>&lt;dim&gt;()</code>. </p>

</div>
</div>
<a class="anchor" id="a21f5d6d4cb385da569e7579dc376c789"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VectorTools::DeclException0 </td>
          <td>(</td>
          <td class="paramtype">ExcInvalidBoundaryIndicator&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exception </p>

</div>
</div>
<a class="anchor" id="a370303e6c89ad7d6c0ba6950d7dc488d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VectorTools::DeclException0 </td>
          <td>(</td>
          <td class="paramtype">ExcNonInterpolatingFE&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exception </p>

</div>
</div>
<a class="anchor" id="abaf107deb45d939076f378ff19f8e5c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VectorTools::DeclException0 </td>
          <td>(</td>
          <td class="paramtype">ExcPointNotAvailableHere&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exception </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jan 27 2014 15:27:27 for The deal.II Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
