<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>The deal.II Library: The step-1 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="http://www.dealii.org/deal.ico"></link>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2014 by the deal.II authors"></meta>
<meta name="deal.II-version" content="8.1.0"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 8.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The step-1 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Aboutthetutorial"> About the tutorial </a>
        <li><a href="#Whatthisprogramdoes"> What this program does </a>
        <li><a href="#Aboutscientificcomputingingeneral"> About scientific computing in general </a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#Creatingthefirstmesh">Creating the first mesh</a>
        <li><a href="#Creatingthesecondmesh">Creating the second mesh</a>
        <li><a href="#Themainfunction">The main function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Possibleextensions"> Possible extensions </a>
      <ul>
        <li><a href="#Differentadaptiverefinementstrategies"> Different adaptive refinement strategies </a>
        <li><a href="#Differentgeometries"> Different geometries </a>
        <li><a href="#Commentsaboutprogramminganddebugging"> Comments about programming and debugging </a>
    </ul>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <a class="anchor" id="Intro"></a> <a class="anchor" id="Introduction"></a></p>
<h1>Introduction</h1>
<p><a class="anchor" id="Aboutthetutorial"></a></p>
<h3>About the tutorial </h3>
<p>Since this is the first tutorial program, let us comment first on how this tutorial and the rest of the deal.II documentation is supposed to work. The documentation for deal.II comes essentially at three different levels:</p>
<ul>
<li>The tutorial: This is a collection of programs that shows how deal.II is used in practice. It doesn't typically discuss individual functions at the level of individual arguments, but rather wants to give the big picture of how things work together. In other words, it discusses "concepts": what are the building blocks of deal.II and how are they used together in finite element programs.</li>
<li>The manual: This is the documentation of every single class and every single (member) function in deal.II. You get there if, for example, you click on the "Main page" or "Classes" tab at the top of this page. This is the place where you would look up what the second argument of <a class="el" href="classTriangulation.html#a6fdc77eaaa3926a066ed48fc47215a39">Triangulation::create_triangulation_compatibility</a> means, to give just one slightly obscure example. You need this level of documentation for when you know what you want to do, but forgot how exactly the function was named, what its arguments are, or what it returns. Note that you also get into the manual whenever you read through the tutorial and click on any of the class or function names, i.e. the tutorial contains a great many links into the manual for whenever you need a more detailed description of a function or class. On the other hand, the manual is not a good place to learn deal.II since it gives you a microscopic view of things without telling you how a function might fit into the bigger picture.</li>
<li>Modules: These are groups of classes and functions that work together or have related functionality. If you click on the "Modules" tab at the top of this page, you end up on a page that lists a number of such groups. Each module discusses the underlying principles of these classes; for example, the <a class="el" href="group__Sparsity.html">Sparsity patterns</a> module talks about all sorts of different issues related to storing sparsity patterns of matrices. This is documentation at an intermediate level: they give you an overview of what's there in a particular area. For example when you wonder what finite element classes exist, you would take a look at the <a class="el" href="group__fe.html">Finite element space descriptions</a> module. The modules are, of course, also cross-linked to the manual (and, at times, to the tutorial); if you click on a class name, say on <a class="el" href="classTriangulation.html">Triangulation</a>, would will also at the very top right under the class name get a link to the modules this class is a member of if you want to learn more about its context.</li>
</ul>
<p>Let's come back to the tutorial, since you are looking at the first program (or "step") of it. Each tutorial program is subdivided into the following sections: </p>
<ol>
<li>
<b>Introduction:</b> This is a discussion of what the program does, including the mathematical model, and what programming techniques are new compared to previous tutorial programs. </li>
<li>
<b>The commented program:</b> An extensively documented listing of the source code. Here, we often document individual lines, or blocks of code, and discuss what they do, how they do it, and why. The comments frequently reference the introduction, i.e. you have to understand <em>what</em> the program wants to achieve (a goal discussed in the introduction) before you can understand <em>how</em> it intends to get there. </li>
<li>
<b>Results:</b> The output of the program, with comments and interpretation. This section also frequently has a subsection that gives suggestions on how to extend the program in various direction; in the earlier programs, this is intended to give you directions for little experiments designed to make your familiar with deal.II, while in later programs it is more about how to use more advanced numerical techniques. </li>
<li>
<b>The plain program:</b> The source code stripped of all comments. This is useful if you want to see the "big
       picture" of the code, since the commented version of the program has so much text in between that it is often difficult to see the entire code of a single function on the screen at once. </li>
</ol>
<p>The tutorials are not only meant to be static documentation, but you should play with them. To this end, go to the <code>examples/step-1</code> directory (or whatever the number of the tutorial is that you're interested in) and type </p>
<div class="fragment"><div class="line">cmake .</div>
<div class="line">make</div>
<div class="line">make run</div>
</div><!-- fragment --><p> The first command sets up the files that describe which include files this tutorial program depends on, how to compile it and how to run it. This command should find the installed deal.II libraries as well that were generated when you compiled and installed everything as described in the <a href="http://www.dealii.org/readme.html">deal.II ReadMe file</a>. If this command should fail to find the deal.II library, then you need to provide the path to the installation using the command </p>
<div class="fragment"><div class="line">cmake -DDEAL_II_DIR=/path/to/installed/deal.II .</div>
</div><!-- fragment --><p> instead.</p>
<p>The second of the commands above compiles the sources into an executable, while the last one executes it (strictly speaking, <code>make run</code> will also compile the code if the executable doesn't exist yet, so you could have skipped the second command if you wanted). This is all that's needed to run the code and produce the output that is discussed in the "Results" section of the tutorial programs. This sequence needs to be repeated in all of the tutorial directories you want to play with.</p>
<p>When learning the library, you need to play with it and see what happens. To this end, open the <code>examples/step-1/step-1.cc</code> source file with your favorite editor and modify it in some way, save it and run it as above. A few suggestions for possibly modifications are given at the end of the results section of this program, where we also provide a few links to other useful pieces of information.</p>
<p><a class="anchor" id="Whatthisprogramdoes"></a></p>
<h3>What this program does </h3>
<p>Let's come back to <a class="el" href="step_1.html">step-1</a>, the current program. In this first example, we don't actually do very much, but show two techniques: what is the syntax to generate triangulation objects, and some elements of simple loops over all cells. We create two grids, one which is a regularly refined square (not very exciting, but a common starting grid for some problems), and one more geometric attempt: a ring-shaped domain, which is refined towards the inner edge. Through this, you will get to know three things every finite element program will have to have somewhere: An object of type <a class="el" href="classTriangulation.html">Triangulation</a> for the mesh; a call to the <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> functions to generate a mesh; and loops over all cells that involve iterators (iterators are a generalization of pointers and are frequently used in the C++ standard library; in the context of deal.II, the <a class="el" href="group__Iterators.html">Iterators on mesh-like containers</a> module talks about them).</p>
<p>The program is otherwise small enough that it doesn't need a whole lot of introduction. Let us just continue with its commented source.</p>
<p><a class="anchor" id="Aboutscientificcomputingingeneral"></a></p>
<h3>About scientific computing in general </h3>
<p>If you are reading through this tutorial program, chances are that you are interested in continuing to use deal.II for your own projects. Thus, you are about to embark on an exercise in programming using a large-scale scientific computing library. Unless you are already an experienced user of large-scale programming methods, this may be new territory for you &mdash; with all the new rules that go along with it such as the fact that you will have to deal with code written by others, that you may have to think about documenting your own code because you may not remember what exactly it is doing a year down the road (or because others will be using it as well), or coming up with ways to test that your program is doing the right thing. None of this is something that we typically train mathematicians, engineers, or scientists in but that is important when you start writing software of more than a few hundred lines. Remember: Producing software is not the same as just writing code.</p>
<p>To make your life easier on this journey let us point to two resources that are worthwhile browsing through before you start any large-scale programming:</p>
<ul>
<li>The <a href="http://code.google.com/p/dealii/wiki/FrequentlyAskedQuestions">deal.II Frequently Asked Questions</a>: This page has a good number of questions that pertain to particular aspects of deal.II, but also to more general questions such as "How do I debug scientific computing codes?" or "Can I
  train myself to write code that has fewer bugs?".</li>
<li>The <a href="http://software-carpentry.org/">Software Carpentry project</a> that provides introductions to many topics that are important to dealing with software, such as version control, make files, testing, etc. It is specifically written for scientists and engineers, not for computer scientists, and has a focus on short, practical lessons.</li>
</ul>
<p>As a general recommendation: If you expect to spend more than a few days writing software in the future, do yourself the favor of learning tools that can make your life more productive, in particular debuggers and integrated development environments. You will find that you will get the time spent learning these tools back severalfold soon by being more productive! <a class="anchor" id="CommProg"></a> </p>
<h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p>
<h3>Include files</h3>
<p>The most fundamental class in the library is the <a class="el" href="classTriangulation.html">Triangulation</a> class, which is declared here:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria.h&gt;</span></div>
</div><!-- fragment --><p>We need the following two includes for loops over cells and/or faces:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_accessor.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_iterator.h&gt;</span></div>
</div><!-- fragment --><p>Here are some functions to generate standard grids:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_generator.h&gt;</span></div>
</div><!-- fragment --><p>We would like to use boundaries which are not straight lines, so we import some classes which predefine some boundary descriptions:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_boundary_lib.h&gt;</span></div>
</div><!-- fragment --><p>Output of grids in various graphics formats:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_out.h&gt;</span></div>
</div><!-- fragment --><p>This is needed for C++ output:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
</div><!-- fragment --><p>And this for the declarations of the `sqrt' and `fabs' functions:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div>
</div><!-- fragment --><p>The final step in importing deal.II is this: All deal.II functions and classes are in a namespace <code>dealii</code>, to make sure they don't clash with symbols from other libraries you may want to use in conjunction with deal.II. One could use these functions and classes by prefixing every use of these names by <code>::</code>, but that would quickly become cumbersome and annoying. Rather, we simply import the entire deal.II namespace for general use:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>dealii;</div>
</div><!-- fragment --><p><a class="anchor" id="Creatingthefirstmesh"></a> </p>
<h3>Creating the first mesh</h3>
<p>In the following, first function, we simply use the unit square as domain and produce a globally refined grid from it.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> first_grid ()</div>
<div class="line">{</div>
</div><!-- fragment --><p>The first thing to do is to define an object for a triangulation of a two-dimensional domain:</p>
<div class="fragment"><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> triangulation;</div>
</div><!-- fragment --><p>Here and in many following cases, the string "&lt;2&gt;" after a class name indicates that this is an object that shall work in two space dimensions. Likewise, there are versions of the triangulation class that are working in one ("&lt;1&gt;") and three ("&lt;3&gt;") space dimensions. The way this works is through some template magic that we will investigate in some more detail in later example programs; there, we will also see how to write programs in an essentially dimension independent way.</p>
<p>Next, we want to fill the triangulation with a single cell for a square domain. The triangulation is the refined four times, to yield 4^4=256 cells in total:</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceGridGenerator.html#a7149c59cefa805a132177cfa6cb953bd">GridGenerator::hyper_cube</a> (triangulation);</div>
<div class="line">triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a> (4);</div>
</div><!-- fragment --><p>Now we want to write a graphical representation of the mesh to an output file. The <a class="el" href="classGridOut.html">GridOut</a> class of deal.II can do that in a number of different output formats; here, we choose encapsulated postscript (eps) format:</p>
<div class="fragment"><div class="line">  std::ofstream out (<span class="stringliteral">&quot;grid-1.eps&quot;</span>);</div>
<div class="line">  <a class="code" href="classGridOut.html">GridOut</a> grid_out;</div>
<div class="line">  grid_out.<a class="code" href="classGridOut.html#a52add81f6036ad80ecfb215f48e96381">write_eps</a> (triangulation, out);</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="Creatingthesecondmesh"></a> </p>
<h3>Creating the second mesh</h3>
<p>The grid in the following, second function is slightly more complicated in that we use a ring domain and refine the result once globally.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> second_grid ()</div>
<div class="line">{</div>
</div><!-- fragment --><p>We start again by defining an object for a triangulation of a two-dimensional domain:</p>
<div class="fragment"><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> triangulation;</div>
</div><!-- fragment --><p>We then fill it with a ring domain. The center of the ring shall be the point (1,0), and inner and outer radius shall be 0.5 and 1. The number of circumferential cells could be adjusted automatically by this function, but we choose to set it explicitly to 10 as the last argument:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> center (1,0);</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> inner_radius = 0.5,</div>
<div class="line">             outer_radius = 1.0;</div>
<div class="line"><a class="code" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell</a> (triangulation,</div>
<div class="line">                            center, inner_radius, outer_radius,</div>
<div class="line">                            10);</div>
</div><!-- fragment --><p>By default, the triangulation assumes that all boundaries are straight and given by the cells of the coarse grid (which we just created). It uses this information when cells at the boundary are refined and new points need to be introduced on the boundary; if the boundary is assumed to be straight, then new points will simply be in the middle of the surrounding ones.</p>
<p>Here, however, we would like to have a curved boundary. Fortunately, some good soul implemented an object which describes the boundary of a ring domain; it only needs the center of the ring and automatically figures out the inner and outer radius when needed. Note that we associate this boundary object with that part of the boundary that has the "boundary
   indicator" zero. By default (at least in 2d and 3d, the 1d case is slightly different), all boundary parts have this number, but you can change this number for some parts of the boundary. In that case, the curved boundary thus associated with number zero will not apply on those parts with a non-zero boundary indicator, but other boundary description objects can be associated with those non-zero indicators. If no boundary description is associated with a particular boundary indicator, a straight boundary is implied. (<a class="el" href="classBoundary.html">Boundary</a> indicators are a slightly complicated topic; if you're confused about what exactly is happening here, you may want to look at the <a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">glossary entry on this topic</a>.)</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classHyperShellBoundary.html">HyperShellBoundary&lt;2&gt;</a> boundary_description(center);</div>
<div class="line">triangulation.<a class="code" href="group__boundary.html#ga0509d862f0e07071dcff837bd58fd082">set_boundary</a> (0, boundary_description);</div>
</div><!-- fragment --><p>In order to demonstrate how to write a loop over all cells, we will refine the grid in five steps towards the inner circle of the domain:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> step=0; step&lt;5; ++step)</div>
<div class="line">  {</div>
</div><!-- fragment --><p>Next, we need an iterator which points to a cell and which we will move over all active cells one by one (active cells are those that are not further refined, and the only ones that can be marked for further refinement, obviously). By convention, we almost always use the names <code>cell</code> and <code>endc</code> for the iterator pointing to the present cell and to the <code>one-past-the-end</code> iterator:</p>
<div class="fragment"><div class="line"><a class="code" href="classTriaActiveIterator.html">Triangulation&lt;2&gt;::active_cell_iterator</a></div>
<div class="line">cell = triangulation.<a class="code" href="classTriangulation.html#af99e25cc64755f18659c0fbc46c3d87d">begin_active</a>(),</div>
<div class="line">endc = triangulation.<a class="code" href="classTriangulation.html#aa234819cf914abe2b700535c682688a7">end</a>();</div>
</div><!-- fragment --><p>The loop over all cells is then rather trivial, and looks like any loop involving pointers instead of iterators:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (; cell!=endc; ++cell)</div>
</div><!-- fragment --><p>Next, we want to loop over all vertices of the cells. Since we are in 2d, we know that each cell has exactly four vertices. However, instead of penning down a 4 in the loop bound, we make a first attempt at writing it in a dimension-independent way by which we find out about the number of vertices of a cell. Using the <a class="el" href="structGeometryInfo.html">GeometryInfo</a> class, we will later have an easier time getting the program to also run in 3d: we only have to change all occurrences of <code>&lt;2&gt;</code> to <code>&lt;3&gt;</code>, and do not have to audit our code for the hidden appearance of magic numbers like a 4 that needs to be replaced by an 8:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> v=0;</div>
<div class="line">     v &lt; GeometryInfo&lt;2&gt;::vertices_per_cell;</div>
<div class="line">     ++v)</div>
<div class="line">  {</div>
</div><!-- fragment --><p>If this cell is at the inner boundary, then at least one of its vertices must sit on the inner ring and therefore have a radial distance from the center of exactly 0.5, up to floating point accuracy. Compute this distance, and if we have found a vertex with this property flag this cell for later refinement. We can then also break the loop over all vertices and move on to the next cell.</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> distance_from_center</div>
<div class="line">    = center.<a class="code" href="classPoint.html#a86ca72325acf82eb9a0bcf61fa5aeb3e">distance</a> (cell-&gt;vertex(v));</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span> (std::fabs(distance_from_center - inner_radius) &lt; 1e-10)</div>
<div class="line">    {</div>
<div class="line">      cell-&gt;set_refine_flag ();</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Now that we have marked all the cells that we want refined, we let the triangulation actually do this refinement. The function that does so owes its long name to the fact that one can also mark cells for coarsening, and the function does coarsening and refinement all at once:</p>
<div class="fragment"><div class="line">  triangulation.<a class="code" href="classTriangulation.html#aaedd900205c1879d8d9ef6ffe7d1a554">execute_coarsening_and_refinement</a> ();</div>
<div class="line">}</div>
</div><!-- fragment --><p>Finally, after these five iterations of refinement, we want to again write the resulting mesh to a file, again in eps format. This works just as above:</p>
<div class="fragment"><div class="line">std::ofstream out (<span class="stringliteral">&quot;grid-2.eps&quot;</span>);</div>
<div class="line"><a class="code" href="classGridOut.html">GridOut</a> grid_out;</div>
<div class="line">grid_out.<a class="code" href="classGridOut.html#a52add81f6036ad80ecfb215f48e96381">write_eps</a> (triangulation, out);</div>
</div><!-- fragment --><p>At this point, all objects created in this function will be destroyed in reverse order. Unfortunately, we defined the boundary object after the triangulation, which still has a pointer to it and the library will produce an error if the boundary object is destroyed before the triangulation. We therefore have to release it, which can be done as follows. Note that this sets the boundary object used for part "0" of the boundary back to a default object, over which the triangulation has full control.</p>
<div class="fragment"><div class="line">triangulation.<a class="code" href="group__boundary.html#ga0509d862f0e07071dcff837bd58fd082">set_boundary</a> (0);</div>
</div><!-- fragment --><p>An alternative to doing so, and one that is frequently more convenient, would have been to declare the boundary object before the triangulation object. In that case, the triangulation would have let lose of the boundary object upon its destruction, and everything would have been fine.</p>
<div class="fragment"><div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="Themainfunction"></a> </p>
<h3>The main function</h3>
<p>Finally, the main function. There isn't much to do here, only to call the two subfunctions, which produce the two grids.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code" href="group__ParameterGui.html#ga0ddf1224851353fc92bfbff6f499fa97">main</a> ()</div>
<div class="line">{</div>
<div class="line">  first_grid ();</div>
<div class="line">  second_grid ();</div>
<div class="line">}</div>
</div><!-- fragment --><p> <a class="anchor" id="Results"></a></p>
<h1>Results</h1>
<p>The program has, after having been run, produced two grids, which look like this:</p>
<table  width="60%" align="center">
<tr>
<td align="center"><div class="image">
<img src="images/step-1.grid-1.png" />
</div>
 <p class="endtd"></p>
</td><td align="center"><div class="image">
<img src="images/step-1.grid-2.png" />
</div>
   </td></tr>
</table>
<p>The left one, well, is not very exciting. The right one is &mdash; at least &mdash; unconventional.</p>
<p>While the second mesh is entirely artificial and made-up, and certainly not very practical in applications, to everyone's surprise it has found its way into the literature: see the paper by M. Mu titled "PDE.MART: A network-based problem-solving environment", ACM Trans. Math. Software, vol. 31, pp. 508-531, 2005. Apparently it is good for some things at least.</p>
<p><a class="anchor" id="Possibleextensions"></a></p>
<h3>Possible extensions </h3>
<p><a class="anchor" id="Differentadaptiverefinementstrategies"></a></p>
<h4>Different adaptive refinement strategies </h4>
<p>This program obviously does not have a whole lot of functionality, but in particular the <code>second_grid</code> function has a bunch of places where you can play with it. For example, you could modify the criterion by which we decide which cells to refine. An example would be to change the condition to this: </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (; cell!=endc; ++cell)</div>
<div class="line">  <span class="keywordflow">if</span> (cell-&gt;center()[1] &gt; 0)</div>
<div class="line">    cell-&gt;set_refine_flag ();</div>
</div><!-- fragment --><p> This would refine all cells for which the <img class="formulaInl" alt="$y$" src="form_10.png"/>-coordinate of the cell's center is greater than zero (the <code><a class="el" href="classTriaAccessor.html#ad997b544e169f0cc3288aa6f5e20880d">TriaAccessor::center</a></code> function that we call by dereferencing the <code>cell</code> iterator returns a <a class="el" href="classPoint.html">Point&lt;2&gt;</a> object; subscripting <code>[0]</code> would give the <img class="formulaInl" alt="$x$" src="form_9.png"/>-coordinate, subscripting <code>[1]</code> the <img class="formulaInl" alt="$y$" src="form_10.png"/>-coordinate). By looking at the functions that <a class="el" href="classTriaAccessor.html">TriaAccessor</a> provides, you can also use more complicated criteria for refinement.</p>
<p><a class="anchor" id="Differentgeometries"></a></p>
<h4>Different geometries </h4>
<p>Another possibility would be to generate meshes of entirely different geometries altogether. While for complex geometries there is no way around using meshes obtained from mesh generators, there is a good number of geometries for which deal.II can create meshes using the functions in the <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> namespace. Take a look at what it provides and see how it could be used in a program like this.</p>
<p>We also discuss a variety of other ways to create and manipulate meshes to <a class="el" href="step_49.html">step-49</a>.</p>
<p><a class="anchor" id="Commentsaboutprogramminganddebugging"></a></p>
<h4>Comments about programming and debugging </h4>
<p>We close with a comment about modifying or writing programs with deal.II in general. When you start working with tutorial programs or your own applications, you will find that mistakes happen: your program will contain code that either aborts the program right away or bugs that simply lead to wrong results. In either case, you will find it extremely helpful to know how to work with a debugger: you may get by for a while by just putting debug output into your program, compiling it, and running it, but ultimately finding bugs with a debugger is much faster, much more convenient, and more reliable because you don't have to recompile the program all the time and because you can inspect the values of variables and how they change.</p>
<p>Rather than postponing learning how to use a debugger till you really can't see any other way to find a bug, here's the one piece of advice we will provide in this program: learn how to use a debugger as soon as possible. It will be time well invested. The deal.II Frequently Asked Questions (FAQ) page linked to from the top-level <a href="http://www.dealii.org/">deal.II webpage</a> also provides a good number of hints on debugging deal.II programs. <a class="anchor" id="PlainProg"></a> </p>
<h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div>
<div class="line"><span class="comment"> * @f$Id: @ref step_1 &quot;step-1&quot;.cc 31349 2013-10-20 19:07:06Z maier @f$</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * Copyright (C) 1999 - 2013 by the deal.II authors</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div>
<div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div>
<div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div>
<div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div>
<div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE at</span></div>
<div class="line"><span class="comment"> * the top level of the deal.II distribution.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_accessor.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_iterator.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_generator.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_boundary_lib.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_out.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">using namespace </span>dealii;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> first_grid ()</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> triangulation;</div>
<div class="line"></div>
<div class="line">  <a class="code" href="namespaceGridGenerator.html#a7149c59cefa805a132177cfa6cb953bd">GridGenerator::hyper_cube</a> (triangulation);</div>
<div class="line">  triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a> (4);</div>
<div class="line"></div>
<div class="line">  std::ofstream out (<span class="stringliteral">&quot;grid-1.eps&quot;</span>);</div>
<div class="line">  <a class="code" href="classGridOut.html">GridOut</a> grid_out;</div>
<div class="line">  grid_out.<a class="code" href="classGridOut.html#a52add81f6036ad80ecfb215f48e96381">write_eps</a> (triangulation, out);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> second_grid ()</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> triangulation;</div>
<div class="line"></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> center (1,0);</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> inner_radius = 0.5,</div>
<div class="line">               outer_radius = 1.0;</div>
<div class="line">  <a class="code" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell</a> (triangulation,</div>
<div class="line">                              center, inner_radius, outer_radius,</div>
<div class="line">                              10);</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classHyperShellBoundary.html">HyperShellBoundary&lt;2&gt;</a> boundary_description(center);</div>
<div class="line">  triangulation.<a class="code" href="group__boundary.html#ga0509d862f0e07071dcff837bd58fd082">set_boundary</a> (0, boundary_description);</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> step=0; step&lt;5; ++step)</div>
<div class="line">    {</div>
<div class="line">      <a class="code" href="classTriaActiveIterator.html">Triangulation&lt;2&gt;::active_cell_iterator</a></div>
<div class="line">      cell = triangulation.<a class="code" href="classTriangulation.html#af99e25cc64755f18659c0fbc46c3d87d">begin_active</a>(),</div>
<div class="line">      endc = triangulation.<a class="code" href="classTriangulation.html#aa234819cf914abe2b700535c682688a7">end</a>();</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> v=0;</div>
<div class="line">             v &lt; GeometryInfo&lt;2&gt;::vertices_per_cell;</div>
<div class="line">             ++v)</div>
<div class="line">          {</div>
<div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> distance_from_center</div>
<div class="line">              = center.<a class="code" href="classPoint.html#a86ca72325acf82eb9a0bcf61fa5aeb3e">distance</a> (cell-&gt;vertex(v));</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> (std::fabs(distance_from_center - inner_radius) &lt; 1e-10)</div>
<div class="line">              {</div>
<div class="line">                cell-&gt;set_refine_flag ();</div>
<div class="line">                <span class="keywordflow">break</span>;</div>
<div class="line">              }</div>
<div class="line">          }</div>
<div class="line"></div>
<div class="line">      triangulation.<a class="code" href="classTriangulation.html#aaedd900205c1879d8d9ef6ffe7d1a554">execute_coarsening_and_refinement</a> ();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  std::ofstream out (<span class="stringliteral">&quot;grid-2.eps&quot;</span>);</div>
<div class="line">  <a class="code" href="classGridOut.html">GridOut</a> grid_out;</div>
<div class="line">  grid_out.<a class="code" href="classGridOut.html#a52add81f6036ad80ecfb215f48e96381">write_eps</a> (triangulation, out);</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  triangulation.<a class="code" href="group__boundary.html#ga0509d862f0e07071dcff837bd58fd082">set_boundary</a> (0);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> <a class="code" href="group__ParameterGui.html#ga0ddf1224851353fc92bfbff6f499fa97">main</a> ()</div>
<div class="line">{</div>
<div class="line">  first_grid ();</div>
<div class="line">  second_grid ();</div>
<div class="line">}</div>
</div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jan 27 2014 15:26:58 for The deal.II Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
