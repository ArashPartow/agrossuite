<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>The deal.II Library: GridRefinement Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="http://www.dealii.org/deal.ico"></link>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2014 by the deal.II authors"></meta>
<meta name="deal.II-version" content="8.1.0"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 8.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">GridRefinement Namespace Reference<div class="ingroups"><a class="el" href="group__grid.html">Grid classes</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a722dd0fd72533bf87367b0ec14e893e0"><td class="memTemplParams" colspan="2">template&lt;int dim, class Vector , int spacedim&gt; </td></tr>
<tr class="memitem:a722dd0fd72533bf87367b0ec14e893e0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridRefinement.html#a722dd0fd72533bf87367b0ec14e893e0">refine_and_coarsen_fixed_number</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const <a class="el" href="classVector.html">Vector</a> &amp;criteria, const <a class="el" href="classdouble.html">double</a> top_fraction_of_cells, const <a class="el" href="classdouble.html">double</a> bottom_fraction_of_cells, const unsigned <a class="el" href="classint.html">int</a> max_n_cells=std::numeric_limits&lt; unsigned <a class="el" href="classint.html">int</a> &gt;::max())</td></tr>
<tr class="separator:a722dd0fd72533bf87367b0ec14e893e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c366e520528adc37e14649ee713156e"><td class="memTemplParams" colspan="2">template&lt;int dim, class Vector , int spacedim&gt; </td></tr>
<tr class="memitem:a2c366e520528adc37e14649ee713156e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridRefinement.html#a2c366e520528adc37e14649ee713156e">refine_and_coarsen_fixed_fraction</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const <a class="el" href="classVector.html">Vector</a> &amp;criteria, const <a class="el" href="classdouble.html">double</a> top_fraction, const <a class="el" href="classdouble.html">double</a> bottom_fraction, const unsigned <a class="el" href="classint.html">int</a> max_n_cells=std::numeric_limits&lt; unsigned <a class="el" href="classint.html">int</a> &gt;::max())</td></tr>
<tr class="separator:a2c366e520528adc37e14649ee713156e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7802b90e5d5d6aeb1eb0b7757c3b96e4"><td class="memTemplParams" colspan="2">template&lt;int dim, class Vector , int spacedim&gt; </td></tr>
<tr class="memitem:a7802b90e5d5d6aeb1eb0b7757c3b96e4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridRefinement.html#a7802b90e5d5d6aeb1eb0b7757c3b96e4">refine_and_coarsen_optimize</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const <a class="el" href="classVector.html">Vector</a> &amp;criteria, const unsigned <a class="el" href="classint.html">int</a> order=2)</td></tr>
<tr class="separator:a7802b90e5d5d6aeb1eb0b7757c3b96e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39ec73541d92105cf81a7a9a46ea6f29"><td class="memTemplParams" colspan="2">template&lt;int dim, class Vector , int spacedim&gt; </td></tr>
<tr class="memitem:a39ec73541d92105cf81a7a9a46ea6f29"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridRefinement.html#a39ec73541d92105cf81a7a9a46ea6f29">refine</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const <a class="el" href="classVector.html">Vector</a> &amp;criteria, const <a class="el" href="classdouble.html">double</a> threshold, const unsigned <a class="el" href="classint.html">int</a> max_to_mark=<a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>)</td></tr>
<tr class="separator:a39ec73541d92105cf81a7a9a46ea6f29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3d610909cb6b4f57ca13a8c8b250236"><td class="memTemplParams" colspan="2">template&lt;int dim, class Vector , int spacedim&gt; </td></tr>
<tr class="memitem:ad3d610909cb6b4f57ca13a8c8b250236"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridRefinement.html#ad3d610909cb6b4f57ca13a8c8b250236">coarsen</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const <a class="el" href="classVector.html">Vector</a> &amp;criteria, const <a class="el" href="classdouble.html">double</a> threshold)</td></tr>
<tr class="separator:ad3d610909cb6b4f57ca13a8c8b250236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69747f64b7eca6d10665d13edd9ba712"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGridRefinement.html#a69747f64b7eca6d10665d13edd9ba712">DeclException0</a> (ExcNegativeCriteria)</td></tr>
<tr class="separator:a69747f64b7eca6d10665d13edd9ba712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad72ab05d12dcbb8ecb4288619757f96c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGridRefinement.html#ad72ab05d12dcbb8ecb4288619757f96c">DeclException0</a> (ExcInvalidParameterValue)</td></tr>
<tr class="separator:ad72ab05d12dcbb8ecb4288619757f96c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Collection of functions controlling refinement and coarsening of <a class="el" href="classTriangulation.html">Triangulation</a> objects.</p>
<p>The functions in this namespace are in two classes. There are the auxiliary functions <a class="el" href="namespaceGridRefinement.html#a39ec73541d92105cf81a7a9a46ea6f29">refine()</a> and <a class="el" href="namespaceGridRefinement.html#ad3d610909cb6b4f57ca13a8c8b250236">coarsen()</a>. More important for users are the other functions, which implement refinement strategies, as being found in the literature on adaptive finite element methods. For mathematical discussion of these methods, consider works by D&ouml;rfler, Morin, Nochetto, Rannacher, Stevenson and many more.</p>
<dl class="section author"><dt>Author</dt><dd>Wolfgang Bangerth, Thomas Richter, Guido Kanschat 1998, 2000, 2009 </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a722dd0fd72533bf87367b0ec14e893e0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, class Vector , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridRefinement::refine_and_coarsen_fixed_number </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>criteria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>top_fraction_of_cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>bottom_fraction_of_cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>max_n_cells</em> = <code>std::numeric_limits&lt;&#160;unsigned&#160;<a class="el" href="classint.html">int</a>&#160;&gt;::<a class="el" href="classVectorizedArray.html#a4a85a2d940158066e2de933cb6587889">max</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function provides a refinement strategy with predictable growth of the mesh.</p>
<p>The function takes a vector of refinement <code>criteria</code> and two values between zero and one denoting the fractions of cells to be refined and coarsened. It flags cells for further processing by <a class="el" href="classTriangulation.html#aaedd900205c1879d8d9ef6ffe7d1a554">Triangulation::execute_coarsening_and_refinement()</a> according to the following greedy algorithm:</p>
<ol>
<li>
<p class="startli">Sort the cells according to descenting values of <code>criteria</code>.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Set the refinement threshold to be the criterion belonging to the cell at position <code>top_fraction_of_cells</code> times <a class="el" href="classTriangulation.html#aa21f25016ce1b9d70d2003a128985870">Triangulation::n_active_cells()</a>.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Set the coarsening threshold accordingly using the cell <code>bottom_fraction_of_cells</code> times <a class="el" href="classTriangulation.html#aa21f25016ce1b9d70d2003a128985870">Triangulation::n_active_cells()</a> from the end of the sorted list.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Use these two thresholds in calls to <a class="el" href="namespaceGridRefinement.html#a39ec73541d92105cf81a7a9a46ea6f29">refine()</a> and <a class="el" href="namespaceGridRefinement.html#ad3d610909cb6b4f57ca13a8c8b250236">coarsen()</a>, respectively.</p>
<p class="endli"></p>
</li>
</ol>
<p>As an example, with no coarsening, setting <code>top_fraction_of_cells</code> to 1/3 will result in approximately doubling the number of cells in two dimensions. The same effect in three dimensions is achieved by refining 1/7th of the cells. These values are good initial guesses, but should be adjusted depending on the singularity of approximated function.</p>
<p>The sorting of criteria is not done actually, since we only need the threshold values in order to call <a class="el" href="namespaceGridRefinement.html#a39ec73541d92105cf81a7a9a46ea6f29">refine()</a> and <a class="el" href="namespaceGridRefinement.html#ad3d610909cb6b4f57ca13a8c8b250236">coarsen()</a>. The order of cells with higher and of those with lower criteria is irrelevant. Getting this value is accomplished by the <code>nth_element</code> function of the <code>C++</code> standard library, which takes only linear time in the number of elements, rather than <code>N log N</code> for sorting all values.</p>
<dl class="section warning"><dt>Warning</dt><dd>This function only sets the coarsening and refinement flags. The mesh is not changed until you call <a class="el" href="classTriangulation.html#aaedd900205c1879d8d9ef6ffe7d1a554">Triangulation::execute_coarsening_and_refinement()</a>.</dd></dl>
<ul>
<li><code>criteria:</code> the refinement criterion computed on each mesh cell. Entries may not be negative.</li>
</ul>
<ul>
<li><code>top_fraction_of_cells</code> is the fraction of cells to be refined. If this number is zero, no cells will be refined. If it equals one, the result will be flagging for global refinement.</li>
</ul>
<ul>
<li><code>bottom_fraction_of_cells</code> is the fraction of cells to be coarsened. If this number is zero, no cells will be coarsened.</li>
</ul>
<ul>
<li><code>max_n_cells</code> can be used to specify a maximal number of cells. If this number is going to be exceeded upon refinement, then refinement and coarsening fractions are going to be adjusted in an attempt to reach the maximum number of cells. Be aware though that through proliferation of refinement due to <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">Triangulation::MeshSmoothing</a>, this number is only an indicator. The default value of this argument is to impose no limit on the number of cells. </li>
</ul>

</div>
</div>
<a class="anchor" id="a2c366e520528adc37e14649ee713156e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, class Vector , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridRefinement::refine_and_coarsen_fixed_fraction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>criteria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>top_fraction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>bottom_fraction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>max_n_cells</em> = <code>std::numeric_limits&lt;&#160;unsigned&#160;<a class="el" href="classint.html">int</a>&#160;&gt;::<a class="el" href="classVectorizedArray.html#a4a85a2d940158066e2de933cb6587889">max</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function provides a refinement strategy controlling the reduction of the error estimate.</p>
<p>Also known as the <b>bulk criterion</b>, this function computes the thresholds for refinement and coarsening such that the <code>criteria</code> of cells getting flagged for refinement make up for a certain fraction of the total error. We explain its operation for refinement, coarsening works analogously.</p>
<p>Let <em>c<sub>K</sub></em> be the criterion of cell <em>K</em>. Then the total error estimate is computed by the formula </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ E = \sum_{K\in \cal T} c_K. \]" src="form_686.png"/>
</p>
<p>If <em> 0 &lt; a &lt; 1</em> is <code>top_fraction</code>, then we refine the smallest subset <img class="formulaInl" alt="$\cal M$" src="form_687.png"/> of the <a class="el" href="classTriangulation.html">Triangulation</a> <img class="formulaInl" alt="$\cal T$" src="form_688.png"/> such that </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ a E \le \sum_{K\in \cal M} c_K \]" src="form_689.png"/>
</p>
<p>The algorithm is performed by the greedy algorithm described in <a class="el" href="namespaceGridRefinement.html#a722dd0fd72533bf87367b0ec14e893e0">refine_and_coarsen_fixed_number()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>The often used formula with squares on the left and right is recovered by actually storing the square of <em>c<sub>K</sub></em> in the vector <code>criteria</code>.</dd></dl>
<p>From the point of view of implementation, this time we really need to sort the array of criteria. Just like the other strategy described above, this function only computes the threshold values and then passes over to <a class="el" href="namespaceGridRefinement.html#a39ec73541d92105cf81a7a9a46ea6f29">refine()</a> and <a class="el" href="namespaceGridRefinement.html#ad3d610909cb6b4f57ca13a8c8b250236">coarsen()</a>.</p>
<ul>
<li><code>criteria:</code> the refinement criterion computed on each mesh cell. Entries may not be negative.</li>
</ul>
<ul>
<li><code>top_fraction</code> is the fraction of the total estimate which should be refined. If this number is zero, no cells will be refined. If it equals one, the result will be flagging for global refinement.</li>
</ul>
<ul>
<li><code>bottom_fraction</code> is the fraction of the estimate coarsened. If this number is zero, no cells will be coarsened.</li>
</ul>
<ul>
<li><code>max_n_cells</code> can be used to specify a maximal number of cells. If this number is going to be exceeded upon refinement, then refinement and coarsening fractions are going to be adjusted in an attempt to reach the maximum number of cells. Be aware though that through proliferation of refinement due to <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">Triangulation::MeshSmoothing</a>, this number is only an indicator. The default value of this argument is to impose no limit on the number of cells. </li>
</ul>

</div>
</div>
<a class="anchor" id="a7802b90e5d5d6aeb1eb0b7757c3b96e4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, class Vector , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridRefinement::refine_and_coarsen_optimize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>criteria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>order</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Refine the triangulation by flagging certain cells to reach an optimal grid: We try to minimize the error multiplied with the number of cells in the new grid. All cells with large error indicator are refined to generate an optimal grid in the above sense. We assume that the error in one cell is reduced to 1-2^{-order} after refinement, if 'order' is the expected order of convergence. This expected order of convergence must be passed as an argument but is defaulted to 2. The new triangulation has ( <img class="formulaInl" alt="$2^d-1$" src="form_690.png"/>) new cells for every flagged cell (the original cell is replaced by <img class="formulaInl" alt="$2^d$" src="form_691.png"/> cells but it then made inactive).</p>
<p>Refer to the general doc of this class for more information. </p>

</div>
</div>
<a class="anchor" id="a39ec73541d92105cf81a7a9a46ea6f29"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, class Vector , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridRefinement::refine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>criteria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>max_to_mark</em> = <code><a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flag all mesh cells for which the value in <code>criteria</code> exceeds <code>threshold</code> for refinement, but only flag up to <code>max_to_mark</code> cells.</p>
<p>The vector <code>criteria</code> contains a nonnegative value for each active cell, ordered in the canonical order of of Triangulation::active_cell_iterator.</p>
<p>The cells are only flagged for refinement, they are not actually refined. To do so, you have to call <a class="el" href="classTriangulation.html#aaedd900205c1879d8d9ef6ffe7d1a554">Triangulation::execute_coarsening_and_refinement()</a>.</p>
<p>This function does not implement a refinement strategy, it is more a helper function for the actual strategies. </p>

</div>
</div>
<a class="anchor" id="ad3d610909cb6b4f57ca13a8c8b250236"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, class Vector , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridRefinement::coarsen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>criteria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flag all mesh cells for which the value in <code>criteria</code> is less than <code>threshold</code> for coarsening.</p>
<p>The vector <code>criteria</code> contains a nonnegative value for each active cell, ordered in the canonical order of of Triangulation::active_cell_iterator.</p>
<p>The cells are only flagged for coarsening, they are not actually coarsened. To do so, you have to call <a class="el" href="classTriangulation.html#aaedd900205c1879d8d9ef6ffe7d1a554">Triangulation::execute_coarsening_and_refinement()</a>.</p>
<p>This function does not implement a refinement strategy, it is more a helper function for the actual strategies. </p>

</div>
</div>
<a class="anchor" id="a69747f64b7eca6d10665d13edd9ba712"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GridRefinement::DeclException0 </td>
          <td>(</td>
          <td class="paramtype">ExcNegativeCriteria&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An exception thrown if the vector with cell criteria contains negative values </p>

</div>
</div>
<a class="anchor" id="ad72ab05d12dcbb8ecb4288619757f96c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GridRefinement::DeclException0 </td>
          <td>(</td>
          <td class="paramtype">ExcInvalidParameterValue&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>One of the threshold parameters causes trouble. Or the refinement and coarsening thresholds overlap. </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jan 27 2014 15:27:23 for The deal.II Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
