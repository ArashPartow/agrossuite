<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>The deal.II Library: FunctionParser&lt; dim &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="http://www.dealii.org/deal.ico"></link>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2014 by the deal.II authors"></meta>
<meta name="deal.II-version" content="8.1.0"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 8.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classFunctionParser-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">FunctionParser&lt; dim &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__functions.html">Functions</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="function__parser_8h_source.html">function_parser.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for FunctionParser&lt; dim &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classFunctionParser__inherit__graph.svg" width="263" height="296"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ae163853688784b9adf75f1f4e3cf226e"><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; std::string, <br class="typebreak"/>
<a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionParser.html#ae163853688784b9adf75f1f4e3cf226e">ConstMap</a></td></tr>
<tr class="separator:ae163853688784b9adf75f1f4e3cf226e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e9a13d72ebddcf3e7400689a452595c"><td class="memItemLeft" align="right" valign="top">typedef ConstMap::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionParser.html#a5e9a13d72ebddcf3e7400689a452595c">ConstMapIterator</a></td></tr>
<tr class="separator:a5e9a13d72ebddcf3e7400689a452595c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad8ac5d54a28d1cc324a8857ed04f0689"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionParser.html#ad8ac5d54a28d1cc324a8857ed04f0689">FunctionParser</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFunction.html#a22de55d2cbd6696fd0274a626614e31a">n_components</a>=1, const <a class="el" href="classdouble.html">double</a> initial_time=0.0)</td></tr>
<tr class="separator:ad8ac5d54a28d1cc324a8857ed04f0689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb026a1dd3fb081399dc94eadd3ff836"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionParser.html#abb026a1dd3fb081399dc94eadd3ff836">~FunctionParser</a> ()</td></tr>
<tr class="separator:abb026a1dd3fb081399dc94eadd3ff836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af557321c57b235584d117ea49b1f7d37"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionParser.html#af557321c57b235584d117ea49b1f7d37">initialize</a> (const std::string &amp;vars, const std::vector&lt; std::string &gt; &amp;expressions, const <a class="el" href="classFunctionParser.html#ae163853688784b9adf75f1f4e3cf226e">ConstMap</a> &amp;constants, const <a class="el" href="classbool.html">bool</a> time_dependent=false, const <a class="el" href="classbool.html">bool</a> use_degrees=false)</td></tr>
<tr class="separator:af557321c57b235584d117ea49b1f7d37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9565dda8af1f282cfc0f40eac6445c70"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionParser.html#a9565dda8af1f282cfc0f40eac6445c70">initialize</a> (const std::string &amp;vars, const std::vector&lt; std::string &gt; &amp;expressions, const <a class="el" href="classFunctionParser.html#ae163853688784b9adf75f1f4e3cf226e">ConstMap</a> &amp;constants, const <a class="el" href="classFunctionParser.html#ae163853688784b9adf75f1f4e3cf226e">ConstMap</a> &amp;units, const <a class="el" href="classbool.html">bool</a> time_dependent=false, const <a class="el" href="classbool.html">bool</a> use_degrees=false)</td></tr>
<tr class="separator:a9565dda8af1f282cfc0f40eac6445c70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af687e9b83f5ee08569a806af637e927d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionParser.html#af687e9b83f5ee08569a806af637e927d">initialize</a> (const std::string &amp;vars, const std::string &amp;expression, const <a class="el" href="classFunctionParser.html#ae163853688784b9adf75f1f4e3cf226e">ConstMap</a> &amp;constants, const <a class="el" href="classbool.html">bool</a> time_dependent=false, const <a class="el" href="classbool.html">bool</a> use_degrees=false)</td></tr>
<tr class="separator:af687e9b83f5ee08569a806af637e927d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae60cdd89bb7f61fcff8b5152d8ea7d99"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionParser.html#ae60cdd89bb7f61fcff8b5152d8ea7d99">initialize</a> (const std::string &amp;vars, const std::string &amp;expression, const <a class="el" href="classFunctionParser.html#ae163853688784b9adf75f1f4e3cf226e">ConstMap</a> &amp;constants, const <a class="el" href="classFunctionParser.html#ae163853688784b9adf75f1f4e3cf226e">ConstMap</a> &amp;units, const <a class="el" href="classbool.html">bool</a> time_dependent=false, const <a class="el" href="classbool.html">bool</a> use_degrees=false)</td></tr>
<tr class="separator:ae60cdd89bb7f61fcff8b5152d8ea7d99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20ec7e1a4b71f37178561c4d1245a9dd"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionParser.html#a20ec7e1a4b71f37178561c4d1245a9dd">value</a> (const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, const unsigned <a class="el" href="classint.html">int</a> component=0) const </td></tr>
<tr class="separator:a20ec7e1a4b71f37178561c4d1245a9dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c4dc84241c81e9be2050b4a351040d8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionParser.html#a1c4dc84241c81e9be2050b4a351040d8">vector_value</a> (const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;values) const </td></tr>
<tr class="separator:a1c4dc84241c81e9be2050b4a351040d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04b3241648d64c76d75c907b188c3ccb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga04b3241648d64c76d75c907b188c3ccb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DeclException2</b> (ExcParseError, <a class="el" href="classint.html">int</a>, char *,&lt;&lt; &quot;Parsing Error at Column &quot;&lt;&lt; arg1&lt;&lt; &quot;. The parser said: &quot;&lt;&lt; arg2)</td></tr>
<tr class="separator:ga04b3241648d64c76d75c907b188c3ccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad277de34886c72ad766121054cf6671e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad277de34886c72ad766121054cf6671e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DeclException2</b> (ExcInvalidExpressionSize, <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;The number of components (&quot;&lt;&lt; arg1&lt;&lt; &quot;) is not equal to the number of expressions (&quot;&lt;&lt; arg2&lt;&lt; &quot;).&quot;)</td></tr>
<tr class="separator:gad277de34886c72ad766121054cf6671e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classFunction"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classFunction')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classFunction.html">Function&lt; dim &gt;</a></td></tr>
<tr class="memitem:a90d8466fe8b3879fdd2caf73b08261e7 inherit pub_methods_classFunction"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a90d8466fe8b3879fdd2caf73b08261e7">Function</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFunction.html#a22de55d2cbd6696fd0274a626614e31a">n_components</a>=1, const <a class="el" href="classdouble.html">double</a> initial_time=0.0)</td></tr>
<tr class="separator:a90d8466fe8b3879fdd2caf73b08261e7 inherit pub_methods_classFunction"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4f43afb9ac9f00ba4392cebd88606d4 inherit pub_methods_classFunction"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#ac4f43afb9ac9f00ba4392cebd88606d4">~Function</a> ()=0</td></tr>
<tr class="separator:ac4f43afb9ac9f00ba4392cebd88606d4 inherit pub_methods_classFunction"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46ef8267edba3f6719cb37cc855e7dc5 inherit pub_methods_classFunction"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFunction.html">Function</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a46ef8267edba3f6719cb37cc855e7dc5">operator=</a> (const <a class="el" href="classFunction.html">Function</a> &amp;f)</td></tr>
<tr class="separator:a46ef8267edba3f6719cb37cc855e7dc5 inherit pub_methods_classFunction"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6f1aceeeb499ff07d828df250f4f3b2 inherit pub_methods_classFunction"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#af6f1aceeeb499ff07d828df250f4f3b2">value_list</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;points, std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;values, const unsigned <a class="el" href="classint.html">int</a> component=0) const</td></tr>
<tr class="separator:af6f1aceeeb499ff07d828df250f4f3b2 inherit pub_methods_classFunction"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97867379f17a1eacb7e274a2b626ade3 inherit pub_methods_classFunction"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a97867379f17a1eacb7e274a2b626ade3">vector_value_list</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;points, std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt; &amp;values) const</td></tr>
<tr class="separator:a97867379f17a1eacb7e274a2b626ade3 inherit pub_methods_classFunction"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad19c5b7fabf50615fce03a61a63efaf7 inherit pub_methods_classFunction"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#ad19c5b7fabf50615fce03a61a63efaf7">vector_values</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;points, std::vector&lt; std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt; &amp;values) const</td></tr>
<tr class="separator:ad19c5b7fabf50615fce03a61a63efaf7 inherit pub_methods_classFunction"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d3c4a52286afb38ccfd677cfaf12bf4 inherit pub_methods_classFunction"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a3d3c4a52286afb38ccfd677cfaf12bf4">gradient</a> (const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, const unsigned <a class="el" href="classint.html">int</a> component=0) const</td></tr>
<tr class="separator:a3d3c4a52286afb38ccfd677cfaf12bf4 inherit pub_methods_classFunction"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab083c97c4b8e03ef1cc81fcf2b1cce45 inherit pub_methods_classFunction"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#ab083c97c4b8e03ef1cc81fcf2b1cce45">vector_gradient</a> (const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt; &gt; &amp;gradients) const</td></tr>
<tr class="separator:ab083c97c4b8e03ef1cc81fcf2b1cce45 inherit pub_methods_classFunction"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1320c32407e552ddd0c778f78a502439 inherit pub_methods_classFunction"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a1320c32407e552ddd0c778f78a502439">gradient_list</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;points, std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt; &gt; &amp;gradients, const unsigned <a class="el" href="classint.html">int</a> component=0) const</td></tr>
<tr class="separator:a1320c32407e552ddd0c778f78a502439 inherit pub_methods_classFunction"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6655835d08360d3f45c06f88fba4c929 inherit pub_methods_classFunction"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a6655835d08360d3f45c06f88fba4c929">vector_gradients</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;points, std::vector&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt; &gt; &gt; &amp;gradients) const</td></tr>
<tr class="separator:a6655835d08360d3f45c06f88fba4c929 inherit pub_methods_classFunction"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadf4d74a5366445dfc1330ca8007a262 inherit pub_methods_classFunction"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#aadf4d74a5366445dfc1330ca8007a262">vector_gradient_list</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;points, std::vector&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt; &gt; &gt; &amp;gradients) const</td></tr>
<tr class="separator:aadf4d74a5366445dfc1330ca8007a262 inherit pub_methods_classFunction"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af199eab1f93f2bdded9f68811230dd00 inherit pub_methods_classFunction"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#af199eab1f93f2bdded9f68811230dd00">laplacian</a> (const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, const unsigned <a class="el" href="classint.html">int</a> component=0) const</td></tr>
<tr class="separator:af199eab1f93f2bdded9f68811230dd00 inherit pub_methods_classFunction"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9128f1c3133751d215513c0c37b9e24 inherit pub_methods_classFunction"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#ae9128f1c3133751d215513c0c37b9e24">vector_laplacian</a> (const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;values) const</td></tr>
<tr class="separator:ae9128f1c3133751d215513c0c37b9e24 inherit pub_methods_classFunction"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a192e6c816980878d387a582487e6cd55 inherit pub_methods_classFunction"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a192e6c816980878d387a582487e6cd55">laplacian_list</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;points, std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;values, const unsigned <a class="el" href="classint.html">int</a> component=0) const</td></tr>
<tr class="separator:a192e6c816980878d387a582487e6cd55 inherit pub_methods_classFunction"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a606b05b313caec6ae0f99f80666ecdfe inherit pub_methods_classFunction"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a606b05b313caec6ae0f99f80666ecdfe">vector_laplacian_list</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;points, std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt; &amp;values) const</td></tr>
<tr class="separator:a606b05b313caec6ae0f99f80666ecdfe inherit pub_methods_classFunction"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f8f15b255e6d36a46dc8e48cf837015 inherit pub_methods_classFunction"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a5f8f15b255e6d36a46dc8e48cf837015">memory_consumption</a> () const</td></tr>
<tr class="separator:a5f8f15b255e6d36a46dc8e48cf837015 inherit pub_methods_classFunction"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classFunctionTime"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classFunctionTime')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classFunctionTime.html">FunctionTime</a></td></tr>
<tr class="memitem:a3f2f7f422c9c12cdf796c2f19b561b88 inherit pub_methods_classFunctionTime"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionTime.html#a3f2f7f422c9c12cdf796c2f19b561b88">FunctionTime</a> (const <a class="el" href="classdouble.html">double</a> initial_time=0.0)</td></tr>
<tr class="separator:a3f2f7f422c9c12cdf796c2f19b561b88 inherit pub_methods_classFunctionTime"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a340b97bb3f66db10515a97fcc87b01ea inherit pub_methods_classFunctionTime"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionTime.html#a340b97bb3f66db10515a97fcc87b01ea">~FunctionTime</a> ()</td></tr>
<tr class="separator:a340b97bb3f66db10515a97fcc87b01ea inherit pub_methods_classFunctionTime"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a47376558f29dbcd7841300429a5071 inherit pub_methods_classFunctionTime"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionTime.html#a8a47376558f29dbcd7841300429a5071">get_time</a> () const </td></tr>
<tr class="separator:a8a47376558f29dbcd7841300429a5071 inherit pub_methods_classFunctionTime"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07df154db543f0e641491763cc2fdcf4 inherit pub_methods_classFunctionTime"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionTime.html#a07df154db543f0e641491763cc2fdcf4">set_time</a> (const <a class="el" href="classdouble.html">double</a> new_time)</td></tr>
<tr class="separator:a07df154db543f0e641491763cc2fdcf4 inherit pub_methods_classFunctionTime"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71d5c299a154a6ab65e8006fea2424c6 inherit pub_methods_classFunctionTime"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionTime.html#a71d5c299a154a6ab65e8006fea2424c6">advance_time</a> (const <a class="el" href="classdouble.html">double</a> delta_t)</td></tr>
<tr class="separator:a71d5c299a154a6ab65e8006fea2424c6 inherit pub_methods_classFunctionTime"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSubscriptor"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSubscriptor')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSubscriptor.html">Subscriptor</a></td></tr>
<tr class="memitem:ae5541017c0966b0af345db75895106f2 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#ae5541017c0966b0af345db75895106f2">Subscriptor</a> ()</td></tr>
<tr class="separator:ae5541017c0966b0af345db75895106f2 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367fce3122075f05f168d14f114b4c65 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a367fce3122075f05f168d14f114b4c65">Subscriptor</a> (const <a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;)</td></tr>
<tr class="separator:a367fce3122075f05f168d14f114b4c65 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c6c557e06110d2127fa6459119e94af inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a6c6c557e06110d2127fa6459119e94af">~Subscriptor</a> ()</td></tr>
<tr class="separator:a6c6c557e06110d2127fa6459119e94af inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24ee69d4b3cf9690d1208b2443cbbb80 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a24ee69d4b3cf9690d1208b2443cbbb80">operator=</a> (const <a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;)</td></tr>
<tr class="separator:a24ee69d4b3cf9690d1208b2443cbbb80 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3422499827ecd52f1d12d65eb6cc3125 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a3422499827ecd52f1d12d65eb6cc3125">subscribe</a> (const char *identifier=0) const </td></tr>
<tr class="separator:a3422499827ecd52f1d12d65eb6cc3125 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b4839b1cffc18781144ede1744b35ea inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a2b4839b1cffc18781144ede1744b35ea">unsubscribe</a> (const char *identifier=0) const </td></tr>
<tr class="separator:a2b4839b1cffc18781144ede1744b35ea inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b45274c8e1936bff024df01d618e86f inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a7b45274c8e1936bff024df01d618e86f">n_subscriptions</a> () const </td></tr>
<tr class="separator:a7b45274c8e1936bff024df01d618e86f inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbbc5f845063b1f23223b7ac96e89e13 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#adbbc5f845063b1f23223b7ac96e89e13">list_subscribers</a> () const </td></tr>
<tr class="separator:adbbc5f845063b1f23223b7ac96e89e13 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2f0251d20c6a5295024de3b2e9b4359 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac2f0251d20c6a5295024de3b2e9b4359">DeclException3</a> (ExcInUse, <a class="el" href="classint.html">int</a>, char *, std::string &amp;,&lt;&lt; &quot;Object of class &quot;&lt;&lt; arg2&lt;&lt; &quot; is still used by &quot;&lt;&lt; arg1&lt;&lt; &quot; other objects.\n&quot;&lt;&lt; &quot;(Additional information: &quot;&lt;&lt; arg3&lt;&lt; &quot;)\n&quot;&lt;&lt; &quot;Note the entry in the Frequently Asked Questions of &quot;&lt;&lt; &quot;deal.II (linked to from http://www.dealii.org/) for &quot;&lt;&lt; &quot;more information on what this error means.&quot;)</td></tr>
<tr class="separator:gac2f0251d20c6a5295024de3b2e9b4359 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e000d9ce953da6afe4bbbaca4397344 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga9e000d9ce953da6afe4bbbaca4397344">DeclException2</a> (ExcNoSubscriber, char *, char *,&lt;&lt; &quot;No subscriber with identifier \&quot;&quot;&lt;&lt; arg2&lt;&lt; &quot;\&quot; did <a class="el" href="classSubscriptor.html#a3422499827ecd52f1d12d65eb6cc3125">subscribe</a> to this object of class &quot;&lt;&lt; arg1)</td></tr>
<tr class="separator:ga9e000d9ce953da6afe4bbbaca4397344 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38 inherit pub_methods_classSubscriptor"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38 inherit pub_methods_classSubscriptor"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:a68efd17a8330ab676d9cd711029b0f38 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ad2a69afb91de468f3bb2de6245258dd6"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionParser.html#ad2a69afb91de468f3bb2de6245258dd6">default_variable_names</a> ()</td></tr>
<tr class="separator:ad2a69afb91de468f3bb2de6245258dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a73f2551114dd00c344d3da2517081841"><td class="memItemLeft" align="right" valign="top">fparser::FunctionParser *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionParser.html#a73f2551114dd00c344d3da2517081841">fp</a></td></tr>
<tr class="separator:a73f2551114dd00c344d3da2517081841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf646e5ac85fd46840bcc0ed65f648c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionParser.html#aaf646e5ac85fd46840bcc0ed65f648c5">initialized</a></td></tr>
<tr class="separator:aaf646e5ac85fd46840bcc0ed65f648c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a645b346a60cb1826c29a904adcac6a46"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionParser.html#a645b346a60cb1826c29a904adcac6a46">n_vars</a></td></tr>
<tr class="separator:a645b346a60cb1826c29a904adcac6a46"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_attribs_classFunction"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classFunction')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classFunction.html">Function&lt; dim &gt;</a></td></tr>
<tr class="memitem:a22de55d2cbd6696fd0274a626614e31a inherit pub_attribs_classFunction"><td class="memItemLeft" align="right" valign="top">const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a22de55d2cbd6696fd0274a626614e31a">n_components</a></td></tr>
<tr class="separator:a22de55d2cbd6696fd0274a626614e31a inherit pub_attribs_classFunction"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_attribs_classFunction"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classFunction')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="classFunction.html">Function&lt; dim &gt;</a></td></tr>
<tr class="memitem:a92dba1a812f73bc2126c4a1711e171f2 inherit pub_static_attribs_classFunction"><td class="memItemLeft" align="right" valign="top">static const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a92dba1a812f73bc2126c4a1711e171f2">dimension</a></td></tr>
<tr class="separator:a92dba1a812f73bc2126c4a1711e171f2 inherit pub_static_attribs_classFunction"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int dim&gt;<br/>
class FunctionParser&lt; dim &gt;</h3>

<p>This class implements a function object that gets its value by parsing a string describing this function. It is a wrapper class for the fparser library (see <a href="http://warp.povusers.org/FunctionParser/">http://warp.povusers.org/FunctionParser/</a>). This class lets you evaluate strings such as "sqrt(1-x^2+y^2)" for given values of 'x' and 'y'. Some of the information contained here is copied verbatim from the fparser.txt file that comes with the fparser library. Please refer also to that file both for clarifications on how this wrapper works, as well as for any issue regarding the licence that applies to this class. This class is used in the <a class="el" href="step_33.html">step-33</a> and <a class="el" href="step_36.html">step-36</a> tutorial programs (the latter being much simpler to understand).</p>
<p>By using this class you indicate that you accept the terms of the licence that comes with the fparser library. If you do not agree with them, you should not use this class or configure the deal.II library without the function parser (see the ReadMe file of deal.II on instructions for this).</p>
<p>The following example shows how to use this class: </p>
<div class="fragment"><div class="line"><span class="comment">// Define some constants that will be used by the function parser</span></div>
<div class="line">std::map&lt;std::string,double&gt; constants;</div>
<div class="line">constants[<span class="stringliteral">&quot;pi&quot;</span>] = <a class="code" href="namespacenumbers.html#a5ee2b45bb5bf8e0ab30d95a6afd0a4e8">numbers::PI</a>;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Define the variables that will be used inside the expressions</span></div>
<div class="line">std::string variables = <span class="stringliteral">&quot;x,y,z&quot;</span>;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Define the expressions of the individual components of a</span></div>
<div class="line"><span class="comment">// vector valued function with two components:</span></div>
<div class="line">std::vector&lt;std::string&gt; expressions(2);</div>
<div class="line">expressions[0] = <span class="stringliteral">&quot;sin(2*pi*x)+sinh(pi*z)&quot;</span>;</div>
<div class="line">expressions[1] = <span class="stringliteral">&quot;sin(2*pi*y)*exp(x^2)&quot;</span>;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Generate an empty function for these two components.</span></div>
<div class="line">ParsedFunction&lt;3&gt; vector_function(2);</div>
<div class="line"></div>
<div class="line"><span class="comment">// And populate it with the newly created objects.</span></div>
<div class="line">vector_function.initialize(variables,</div>
<div class="line">                           expressions,</div>
<div class="line">                           constants);</div>
</div><!-- fragment --><p><a class="el" href="classFunctionParser.html">FunctionParser</a> also provides an option to use <b>units</b> in expressions. We illustrate the use of this functionality with the following example: </p>
<div class="fragment"><div class="line"><span class="comment">// Define some constants that will be used by the function parser</span></div>
<div class="line"> std::map&lt;std::string&gt; constants;</div>
<div class="line"> std::map&lt;std::string&gt; units;</div>
<div class="line"> constants[<span class="stringliteral">&quot;PI&quot;</span>] = <a class="code" href="namespacenumbers.html#a5ee2b45bb5bf8e0ab30d95a6afd0a4e8">numbers::PI</a>;</div>
<div class="line"> units[<span class="stringliteral">&quot;cm&quot;</span>] = 10;</div>
<div class="line"> units[<span class="stringliteral">&quot;m&quot;</span>] = 1000;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Define the variables that will be used inside the expressions</span></div>
<div class="line"> std::string variables = <span class="stringliteral">&quot;x,y&quot;</span>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Define the expressions of the individual components of a</span></div>
<div class="line"> <span class="comment">// vector valued function with two components:</span></div>
<div class="line"> std::vector&lt;std::string&gt; expressions(1);</div>
<div class="line"> expressions[0] = <span class="stringliteral">&quot;x cm + y m + PI cm;</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral"> // Generate an empty function for these two components.</span></div>
<div class="line"><span class="stringliteral"> FunctionParser&lt;2&gt; vector_function;</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral"> // And populate it with the newly created objects.</span></div>
<div class="line"><span class="stringliteral"> vector_function.initialize(variables,</span></div>
<div class="line"><span class="stringliteral">               expressions,</span></div>
<div class="line"><span class="stringliteral">               constants,</span></div>
<div class="line"><span class="stringliteral">               units); //An extra argument here</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral"> // Point at which we want to evaluate the function</span></div>
<div class="line"><span class="stringliteral"> Point&lt;2&gt; point(2.0, 3.0);</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral"> // Output the evaluated function</span></div>
<div class="line"><span class="stringliteral"> std::cout &lt;&lt; &quot;</span><a class="code" href="classFunction.html">Function</a> <span class="stringliteral">&quot; &lt;&lt; &quot;</span>[<span class="stringliteral">&quot; &lt;&lt; expressions[0] &lt;&lt; &quot;</span>]<span class="stringliteral">&quot; &lt;&lt;</span></div>
<div class="line"><span class="stringliteral">   &quot;</span> @point <span class="stringliteral">&quot; &lt;&lt; &quot;</span>[<span class="stringliteral">&quot; &lt;&lt; point &lt;&lt; &quot;</span>]<span class="stringliteral">&quot; &lt;&lt; &quot;</span> is <span class="stringliteral">&quot; &lt;&lt;</span></div>
<div class="line"><span class="stringliteral">   &quot;</span>[<span class="stringliteral">&quot; &lt;&lt;  vector_function.value(point) &lt;&lt; &quot;</span>]<span class="stringliteral">&quot; &lt;&lt; std::endl;</span></div>
</div><!-- fragment --><p>Units are similar to <b>constants</b> in the way they are passed to the parser, i.e. via std::map&lt;std::string,double&gt;. But units are slightly different in that they have a higher precedence than any other operator (except parentheses). Thus for example "5/2in" is parsed as "5/(2*300)". (If you actually do want 5/2 inches, it has to be written as "(5/2)in".)</p>
<p>Overall, the main point of units is to make input expressions more readable since expressing, say, length as 10cm looks more natural than 10*cm.</p>
<p>Beware that the user has full control over units as well as full responsibility for "sanity" of the parsed expressions, because the parser does NOT know anything about the physical nature of units and one would not be warned when adding kilometers to kilograms.</p>
<p>The <b>units</b> argument to the initialize function is <b>optional</b>, i.e. the user does NOT have to use this functionality.</p>
<p>For more information on this feature, please see contrib/functionparser/fparser.txt</p>
<p>See <a href="http://warp.povusers.org/FunctionParser/">http://warp.povusers.org/FunctionParser/</a> for an explanation on how the underlying library works.</p>
<p>From the fparser.txt file : </p>
<pre class="fragment">The library is intended to be very fast. It byte-compiles the
function string at parse time and interpretes this byte-code at
evaluation time.  The evaluation is straightforward and no recursions
are done (uses stack arithmetic).  Empirical tests show that it indeed
is very fast (specially compared to libraries which evaluate functions
by just interpreting the raw function string).</pre><p>This class overloads the virtual methods <a class="el" href="classFunctionParser.html#a20ec7e1a4b71f37178561c4d1245a9dd">value()</a> and <a class="el" href="classFunctionParser.html#a1c4dc84241c81e9be2050b4a351040d8">vector_value()</a> of the <a class="el" href="classFunction.html">Function</a> base class with the byte compiled versions of the expressions given to the <a class="el" href="classFunctionParser.html#af557321c57b235584d117ea49b1f7d37">initialize()</a> methods. Note that the class will not work unless you first call the <a class="el" href="classFunctionParser.html#af557321c57b235584d117ea49b1f7d37">initialize()</a> method that accepts the text description of the function as an argument (among other things). The reason for this is that this text description may be read from an input file, and may therefore not be available at object construction time yet.</p>
<p>The syntax to describe a function follows usual programming practice, and is explained in this snippet from the fparser.txt file : </p>
<pre class="fragment">     The function string understood by the class is very similar to the C-syntax.
     Arithmetic float expressions can be created from float literals, variables
     or functions using the following operators in this order of precedence:

     ()             expressions in parentheses first
     -A             unary minus
     A^B            exponentiation (A raised to the power B)
     A*B  A/B  A%B  multiplication, division and modulo
     A+B  A-B       addition and subtraction
     A=B  A&lt;B  A&gt;B  comparison between A and B (result is either 0 or 1)
     A&amp;B            result is 1 if int(A) and int(B) differ from 0, else 0.
     A|B            result is 1 if int(A) or int(B) differ from 0, else 0.

     Since the unary minus has higher precedence than any other operator, for
     example the following expression is valid: x*-y
     Note that the '=' comparison can be inaccurate due to floating point
     precision problems (eg. "sqrt(100)=10" probably returns 0, not 1).

     The class supports these functions:

     abs(A)    : Absolute value of A. If A is negative, returns -A otherwise
                 returns A.
     acos(A)   : Arc-cosine of A. Returns the angle, measured in radians,
                 whose cosine is A.
     acosh(A)  : Same as acos() but for hyperbolic cosine.
     asin(A)   : Arc-sine of A. Returns the angle, measured in radians, whose
                 sine is A.
     asinh(A)  : Same as asin() but for hyperbolic sine.
     atan(A)   : Arc-tangent of (A). Returns the angle, measured in radians,
                 whose tangent is (A).
     atan2(A,B): Arc-tangent of A/B. The two main differences to atan() is
                 that it will return the right angle depending on the signs of
                 A and B (atan() can only return values between -pi/2 and pi/2),
                 and that the return value of pi/2 and -pi/2 are possible.
     atanh(A)  : Same as atan() but for hyperbolic tangent.
     ceil(A)   : Ceiling of A. Returns the smallest integer greater than A.
                 Rounds up to the next higher integer.
     cos(A)    : Cosine of A. Returns the cosine of the angle A, where A is
                 measured in radians.
     cosh(A)   : Same as cos() but for hyperbolic cosine.
     cot(A)    : Cotangent of A (equivalent to 1/tan(A)).
     csc(A)    : Cosecant of A (equivalent to 1/sin(A)).
     eval(...) : This a recursive call to the function to be evaluated. The
                 number of parameters must be the same as the number of parameters
                 taken by the function. Usually called inside if() to avoid
                 infinite recursion.
     exp(A)    : Exponential of A. Returns the value of e raised to the power
                 A where e is the base of the natural logarithm, i.e. the
                 non-repeating value approximately equal to 2.71828182846.
     floor(A)  : Floor of A. Returns the largest integer less than A. Rounds
                 down to the next lower integer.
     if(A,B,C) : If int(A) differs from 0, the return value of this function is B,
                 else C. Only the parameter which needs to be evaluated is
                 evaluated, the other parameter is skipped; this makes it safe to
                 use eval() in them.
     int(A)    : Rounds A to the closest integer. 0.5 is rounded to 1.
     log(A)    : Natural (base e) logarithm of A.
     log10(A)  : Base 10 logarithm of A.
     max(A,B)  : If A&gt;B, the result is A, else B.
     min(A,B)  : If A&lt;B, the result is A, else B.
     sec(A)    : Secant of A (equivalent to 1/cos(A)).
     sin(A)    : Sine of A. Returns the sine of the angle A, where A is
                 measured in radians.
     sinh(A)   : Same as sin() but for hyperbolic sine.
     sqrt(A)   : Square root of A. Returns the value whose square is A.
     tan(A)    : Tangent of A. Returns the tangent of the angle A, where A
                 is measured in radians.
     tanh(A)   : Same as tan() but for hyperbolic tangent.


   Examples of function string understood by the class:

   "1+2"
   "x-1"
   "-sin(sqrt(x^2+y^2))"
   "sqrt(XCoord*XCoord + YCoord*YCoord)"

   An example of a recursive function is the factorial function:

   "if(n&gt;1, n*eval(n-1), 1)"

 Note that a recursive call has some overhead, which makes it a bit slower
 than any other operation. It may be a good idea to avoid recursive functions
 in very time-critical applications. Recursion also takes some memory, so
 extremely deep recursions should be avoided (eg. millions of nested recursive
 calls).

 Also note that the if() function is the only place where making a recursive
 call is safe. In any other place it will cause an infinite recursion (which
 will make the program eventually run out of memory).</pre><p>Vector-valued functions can either be declared using strings where the function components are separated by semicolons, or using a vector of strings each defining one vector component.</p>
<p>An example of time dependent scalar function is the following: </p>
<div class="fragment"><div class="line"><span class="comment">// Empty constants object</span></div>
<div class="line">std::map&lt;std::string&gt; constants;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Variables that will be used inside the expressions</span></div>
<div class="line">std::string variables = <span class="stringliteral">&quot;x,y,t&quot;</span>;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Define the expression of the scalar time dependent function.</span></div>
<div class="line">std::string expression = <span class="stringliteral">&quot;exp(y*x)*exp(-t)&quot;</span>;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Generate an empty scalar function</span></div>
<div class="line"><a class="code" href="classFunctionParser.html">FunctionParser&lt;2&gt;</a> <span class="keyword">function</span>;</div>
<div class="line"></div>
<div class="line"><span class="comment">// And populate it with the newly created objects.</span></div>
<div class="line"><span class="keyword">function</span>.<a class="code" href="classFunctionParser.html#af557321c57b235584d117ea49b1f7d37">initialize</a>(variables,</div>
<div class="line">                    expression,</div>
<div class="line">                    constants,</div>
<div class="line">                    <span class="keyword">true</span>);        <span class="comment">// This tells the parser that</span></div>
<div class="line">                                  <span class="comment">// it is a time-dependent function</span></div>
<div class="line">                                  <span class="comment">// and there is another variable</span></div>
<div class="line">                                  <span class="comment">// to be taken into account (t).</span></div>
</div><!-- fragment --><p>The following is another example of how to instantiate a vector valued function by using a single string: </p>
<div class="fragment"><div class="line"><span class="comment">// Empty constants object</span></div>
<div class="line">std::map&lt;std::string&gt; constants;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Variables that will be used inside the expressions</span></div>
<div class="line">std::string variables = <span class="stringliteral">&quot;x,y&quot;</span>;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Define the expression of the vector valued  function.</span></div>
<div class="line">std::string expression = <span class="stringliteral">&quot;cos(2*pi*x)*y^2; sin(2*pi*x)*exp(y)&quot;</span>;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Generate an empty vector valued function</span></div>
<div class="line"><a class="code" href="classFunctionParser.html">FunctionParser&lt;2&gt;</a> <span class="keyword">function</span>(2);</div>
<div class="line"></div>
<div class="line"><span class="comment">// And populate it with the newly created objects.</span></div>
<div class="line"><span class="keyword">function</span>.<a class="code" href="classFunctionParser.html#af557321c57b235584d117ea49b1f7d37">initialize</a>(variables,</div>
<div class="line">                    expression,</div>
<div class="line">                    constants);</div>
</div><!-- fragment --><dl class="section author"><dt>Author</dt><dd>Luca Heltai, 2005 </dd></dl>

<p>Definition at line <a class="el" href="function__parser_8h_source.html#l00318">318</a> of file <a class="el" href="function__parser_8h_source.html">function_parser.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="ae163853688784b9adf75f1f4e3cf226e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;std::string, <a class="el" href="classdouble.html">double</a>&gt; <a class="el" href="classFunctionParser.html">FunctionParser</a>&lt; dim &gt;::<a class="el" href="classFunctionParser.html#ae163853688784b9adf75f1f4e3cf226e">ConstMap</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type for the constant map. Used by the <a class="el" href="classFunctionParser.html#af557321c57b235584d117ea49b1f7d37">initialize()</a> method. </p>

<p>Definition at line <a class="el" href="function__parser_8h_source.html#l00351">351</a> of file <a class="el" href="function__parser_8h_source.html">function_parser.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5e9a13d72ebddcf3e7400689a452595c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ConstMap::iterator <a class="el" href="classFunctionParser.html">FunctionParser</a>&lt; dim &gt;::<a class="el" href="classFunctionParser.html#a5e9a13d72ebddcf3e7400689a452595c">ConstMapIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iterator for the constants map. Used by the <a class="el" href="classFunctionParser.html#af557321c57b235584d117ea49b1f7d37">initialize()</a> method. </p>

<p>Definition at line <a class="el" href="function__parser_8h_source.html#l00358">358</a> of file <a class="el" href="function__parser_8h_source.html">function_parser.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ad8ac5d54a28d1cc324a8857ed04f0689"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFunctionParser.html">FunctionParser</a>&lt; dim &gt;::<a class="el" href="classFunctionParser.html">FunctionParser</a> </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_components</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>initial_time</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor for Parsed functions. Its arguments are the same of the base class <a class="el" href="classFunction.html">Function</a>. The only difference is that this object needs to be initialized with <a class="el" href="classFunctionParser.html#af557321c57b235584d117ea49b1f7d37">initialize()</a> method before you can use it. If an attempt to use this function is made before the <a class="el" href="classFunctionParser.html#af557321c57b235584d117ea49b1f7d37">initialize()</a> method has been called, then an exception is thrown. </p>

</div>
</div>
<a class="anchor" id="abb026a1dd3fb081399dc94eadd3ff836"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFunctionParser.html">FunctionParser</a>&lt; dim &gt;::~<a class="el" href="classFunctionParser.html">FunctionParser</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destructor. Explicitly delete the <a class="el" href="classFunctionParser.html">FunctionParser</a> objects (there is one for each component of the function). </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="af557321c57b235584d117ea49b1f7d37"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFunctionParser.html">FunctionParser</a>&lt; dim &gt;::initialize </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>expressions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunctionParser.html#ae163853688784b9adf75f1f4e3cf226e">ConstMap</a> &amp;&#160;</td>
          <td class="paramname"><em>constants</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>time_dependent</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>use_degrees</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the function. This methods accepts the following parameters:</p>
<p><b>vars</b>: a string with the variables that will be used by the expressions to be evaluated. Note that the variables can have any name (of course different from the function names defined above!), but the order IS important. The first variable will correspond to the first component of the point in which the function is evaluated, the second variable to the second component and so forth. If this function is also time dependent, then it is necessary to specify it by setting the <code>time_dependent</code> parameter to true. An exception is thrown if the number of variables specified here is different from dim (if this function is not time-dependent) or from dim+1 (if it is time-dependent).</p>
<p><b>expressions</b>: a list of strings containing the expressions that will be byte compiled by the internal parser (<a class="el" href="classFunctionParser.html">FunctionParser</a>). Note that the size of this vector must match exactly the number of components of the <a class="el" href="classFunctionParser.html">FunctionParser</a>, as declared in the constructor. If this is not the case, an exception is thrown.</p>
<p><b>constants</b>: a map of constants used to pass any necessary constant that we want to specify in our expressions (in the example above the number pi). An expression is valid if and only if it contains only defined variables and defined constants (other than the functions specified above). If a constant is given whose name is not valid (eg: <code>constants["sin"] = 1.5;</code>) an exception is thrown.</p>
<p><b>time_dependent</b>. If this is a time dependent function, then the last variable declared in <b>vars</b> is assumed to be the time variable, and this-&gt;<a class="el" href="classFunctionTime.html#a8a47376558f29dbcd7841300429a5071">get_time()</a> is used to initialize it when evaluating the function. Naturally the number of variables parsed by the <a class="el" href="classFunctionParser.html#af557321c57b235584d117ea49b1f7d37">initialize()</a> method in this case is dim+1. The value of this parameter defaults to false, i.e. do not consider time.</p>
<p><b>use_degrees</b>. Parameter to decide if the trigonometric functions work in radians or degrees. The default for this parameter is false, i.e. use radians and not degrees. </p>

</div>
</div>
<a class="anchor" id="a9565dda8af1f282cfc0f40eac6445c70"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFunctionParser.html">FunctionParser</a>&lt; dim &gt;::initialize </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>expressions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunctionParser.html#ae163853688784b9adf75f1f4e3cf226e">ConstMap</a> &amp;&#160;</td>
          <td class="paramname"><em>constants</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunctionParser.html#ae163853688784b9adf75f1f4e3cf226e">ConstMap</a> &amp;&#160;</td>
          <td class="paramname"><em>units</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>time_dependent</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>use_degrees</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the function. Same as above, but with an additional argument <b> units </b> - a map of units passed to <a class="el" href="classFunctionParser.html">FunctionParser</a> via AddUnint.</p>
<p>Can be used as "3cm". Have higher precedence in parsing, i.e. if cm=10 then 3/2cm is 3 /(2*10). See contrib/functionparser/fparser.txt for more details. </p>

</div>
</div>
<a class="anchor" id="af687e9b83f5ee08569a806af637e927d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFunctionParser.html">FunctionParser</a>&lt; dim &gt;::initialize </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>expression</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunctionParser.html#ae163853688784b9adf75f1f4e3cf226e">ConstMap</a> &amp;&#160;</td>
          <td class="paramname"><em>constants</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>time_dependent</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>use_degrees</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the function. Same as above, but accepts a string rather than a vector of strings. If this is a vector valued function, its componenents are expected to be separated by a semicolon. An exception is thrown if this method is called and the number of components successfully parsed does not match the number of components of the base function. </p>

</div>
</div>
<a class="anchor" id="ae60cdd89bb7f61fcff8b5152d8ea7d99"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFunctionParser.html">FunctionParser</a>&lt; dim &gt;::initialize </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>expression</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunctionParser.html#ae163853688784b9adf75f1f4e3cf226e">ConstMap</a> &amp;&#160;</td>
          <td class="paramname"><em>constants</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunctionParser.html#ae163853688784b9adf75f1f4e3cf226e">ConstMap</a> &amp;&#160;</td>
          <td class="paramname"><em>units</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>time_dependent</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>use_degrees</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the function. Same as above, but with <b>units</b>. </p>

</div>
</div>
<a class="anchor" id="ad2a69afb91de468f3bb2de6245258dd6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classFunctionParser.html">FunctionParser</a>&lt; dim &gt;::default_variable_names </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A function that returns default names for variables, to be used in the first argument of the <a class="el" href="classFunctionParser.html#af557321c57b235584d117ea49b1f7d37">initialize()</a> functions: it returns "x" in 1d, "x,y" in 2d, and "x,y,z" in 3d. </p>

<p>Definition at line <a class="el" href="function__parser_8h_source.html#l00575">575</a> of file <a class="el" href="function__parser_8h_source.html">function_parser.h</a>.</p>

</div>
</div>
<a class="anchor" id="a20ec7e1a4b71f37178561c4d1245a9dd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdouble.html">double</a> <a class="el" href="classFunctionParser.html">FunctionParser</a>&lt; dim &gt;::value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the value of the function at the given point. Unless there is only one component (i.e. the function is scalar), you should state the component you want to have evaluated; it defaults to zero, i.e. the first component. </p>

<p>Reimplemented from <a class="el" href="classFunction.html#a9783cc12b6b205d4019379b0cc6f3956">Function&lt; dim &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a1c4dc84241c81e9be2050b4a351040d8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFunctionParser.html">FunctionParser</a>&lt; dim &gt;::vector_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return all components of a vector-valued function at the given point <code>p</code>.</p>
<p><code>values</code> shall have the right size beforehand, i.e. <a class="el" href="classFunction.html#a22de55d2cbd6696fd0274a626614e31a">n_components</a>. </p>

<p>Reimplemented from <a class="el" href="classFunction.html#a1fa27ec3204c0929a0b33ae34a97ef8f">Function&lt; dim &gt;</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a73f2551114dd00c344d3da2517081841"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">fparser::FunctionParser* <a class="el" href="classFunctionParser.html">FunctionParser</a>&lt; dim &gt;::fp</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A pointer to the actual function parsers. The pointer is to an array of parsers, not just a single one. The length of the array equals the number of vector components. </p>

<p>Definition at line <a class="el" href="function__parser_8h_source.html#l00544">544</a> of file <a class="el" href="function__parser_8h_source.html">function_parser.h</a>.</p>

</div>
</div>
<a class="anchor" id="aaf646e5ac85fd46840bcc0ed65f648c5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classFunctionParser.html">FunctionParser</a>&lt; dim &gt;::initialized</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>State of usability. This variable is checked every time the function is called for evaluation. It's set to true in the <a class="el" href="classFunctionParser.html#af557321c57b235584d117ea49b1f7d37">initialize()</a> methods. </p>

<p>Definition at line <a class="el" href="function__parser_8h_source.html#l00553">553</a> of file <a class="el" href="function__parser_8h_source.html">function_parser.h</a>.</p>

</div>
</div>
<a class="anchor" id="a645b346a60cb1826c29a904adcac6a46"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFunctionParser.html">FunctionParser</a>&lt; dim &gt;::n_vars</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of variables. If this is also a function of time, then the number of variables is dim+1, otherwhise it is dim. In the case that this is a time dependent function, the time is supposed to be the last variable. If <a class="el" href="classFunctionParser.html#a645b346a60cb1826c29a904adcac6a46">n_vars</a> is not identical to the number of the variables parsed by the <a class="el" href="classFunctionParser.html#af557321c57b235584d117ea49b1f7d37">initialize()</a> method, then an exception is thrown. </p>

<p>Definition at line <a class="el" href="function__parser_8h_source.html#l00569">569</a> of file <a class="el" href="function__parser_8h_source.html">function_parser.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/deal.II/base/<a class="el" href="function__parser_8h_source.html">function_parser.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jan 27 2014 15:27:19 for The deal.II Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
