<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>The deal.II Library: ParameterHandler Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="http://www.dealii.org/deal.ico"></link>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2014 by the deal.II authors"></meta>
<meta name="deal.II-version" content="8.1.0"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 8.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classParameterHandler-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ParameterHandler Class Reference<div class="ingroups"><a class="el" href="group__input.html">Input</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="parameter__handler_8h_source.html">parameter_handler.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ParameterHandler:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classParameterHandler__inherit__graph.svg" width="166" height="195"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a8364dda711b93753c6809eefe2a8e827"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827">OutputStyle</a> { <br/>
&#160;&#160;<a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827ae4d13a4598073bfcb69cd0cf4c1f8365">Text</a> = 1, 
<a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827a3b5d289d79f36e819a7bd0d81a52ee37">LaTeX</a> = 2, 
<a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827a5ed7026d01b66b89ee3c1aef3efbfd4a">Description</a> = 3, 
<a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827a2b5a2007249d810f05d23dc837c47510">XML</a> = 4, 
<br/>
&#160;&#160;<a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827a456d0f94d7d72f33234d02a8b2e9030c">JSON</a> = 5, 
<a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827a6d91eaf8deb52a5d3cba991a9bb23ac7">ShortText</a> = 193
<br/>
 }</td></tr>
<tr class="separator:a8364dda711b93753c6809eefe2a8e827"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7aebc6956ea423d376c5fe881b8d5c4d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a7aebc6956ea423d376c5fe881b8d5c4d">ParameterHandler</a> ()</td></tr>
<tr class="separator:a7aebc6956ea423d376c5fe881b8d5c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac60bd0947b174d8b01d3a3f6aabc23e3"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#ac60bd0947b174d8b01d3a3f6aabc23e3">~ParameterHandler</a> ()</td></tr>
<tr class="separator:ac60bd0947b174d8b01d3a3f6aabc23e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24a0eed678d48dae661d90f722aa1cd5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a24a0eed678d48dae661d90f722aa1cd5">read_input</a> (std::istream &amp;input, const std::string &amp;filename=&quot;input file&quot;)</td></tr>
<tr class="separator:a24a0eed678d48dae661d90f722aa1cd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5946f967a214445cc645027a9a13bd3e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a5946f967a214445cc645027a9a13bd3e">read_input</a> (const std::string &amp;filename, const <a class="el" href="classbool.html">bool</a> optional=false, const <a class="el" href="classbool.html">bool</a> write_stripped_file=false)</td></tr>
<tr class="separator:a5946f967a214445cc645027a9a13bd3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19c8a23a6bdfd6936a3a6de29999ba09"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a19c8a23a6bdfd6936a3a6de29999ba09">read_input_from_string</a> (const char *s)</td></tr>
<tr class="separator:a19c8a23a6bdfd6936a3a6de29999ba09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ac24835f0c13ffec54ed206100ce10d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a2ac24835f0c13ffec54ed206100ce10d">read_input_from_xml</a> (std::istream &amp;input)</td></tr>
<tr class="separator:a2ac24835f0c13ffec54ed206100ce10d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6184baed4eba575e422161dc86ed12e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a6184baed4eba575e422161dc86ed12e3">clear</a> ()</td></tr>
<tr class="separator:a6184baed4eba575e422161dc86ed12e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb951f101e0969416f7f47d24c03bcfa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a> (const std::string &amp;entry, const std::string &amp;default_value, const <a class="el" href="classPatterns_1_1PatternBase.html">Patterns::PatternBase</a> &amp;pattern=<a class="el" href="classPatterns_1_1Anything.html">Patterns::Anything</a>(), const std::string &amp;documentation=std::string())</td></tr>
<tr class="separator:afb951f101e0969416f7f47d24c03bcfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af29c20cde6d44186806d559beb468696"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a> (const std::string &amp;subsection)</td></tr>
<tr class="separator:af29c20cde6d44186806d559beb468696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d33f859364fc8730c939c0c36ee544c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a5d33f859364fc8730c939c0c36ee544c">leave_subsection</a> ()</td></tr>
<tr class="separator:a5d33f859364fc8730c939c0c36ee544c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7589d0ed2a7e70532853e1e378130c88"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a7589d0ed2a7e70532853e1e378130c88">get</a> (const std::string &amp;entry_string) const </td></tr>
<tr class="separator:a7589d0ed2a7e70532853e1e378130c88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5315d2dfbf7223851805e9432c92b2be"><td class="memItemLeft" align="right" valign="top">long <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a5315d2dfbf7223851805e9432c92b2be">get_integer</a> (const std::string &amp;entry_string) const </td></tr>
<tr class="separator:a5315d2dfbf7223851805e9432c92b2be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3218c50fa6386b6791a5096ec1e37620"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a3218c50fa6386b6791a5096ec1e37620">get_double</a> (const std::string &amp;entry_name) const </td></tr>
<tr class="separator:a3218c50fa6386b6791a5096ec1e37620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b3601d0dee839d1c732146c0ed8f5bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a5b3601d0dee839d1c732146c0ed8f5bd">get_bool</a> (const std::string &amp;entry_name) const </td></tr>
<tr class="separator:a5b3601d0dee839d1c732146c0ed8f5bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6418ea655b1b550b9dcf63513030196"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">set</a> (const std::string &amp;entry_name, const std::string &amp;new_value)</td></tr>
<tr class="separator:aa6418ea655b1b550b9dcf63513030196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af288e1fe38ac1a1baf1cef3058b63ce1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#af288e1fe38ac1a1baf1cef3058b63ce1">set</a> (const std::string &amp;entry_name, const char *new_value)</td></tr>
<tr class="separator:af288e1fe38ac1a1baf1cef3058b63ce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabb43df4f2325707a82201071793e4fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#aabb43df4f2325707a82201071793e4fa">set</a> (const std::string &amp;entry_name, const long <a class="el" href="classint.html">int</a> &amp;new_value)</td></tr>
<tr class="separator:aabb43df4f2325707a82201071793e4fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03d8a002b574cb451240ecf723ab0fa8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a03d8a002b574cb451240ecf723ab0fa8">set</a> (const std::string &amp;entry_name, const <a class="el" href="classdouble.html">double</a> &amp;new_value)</td></tr>
<tr class="separator:a03d8a002b574cb451240ecf723ab0fa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcee5b1f5f7c6745e8c7b66dcf34104d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#adcee5b1f5f7c6745e8c7b66dcf34104d">set</a> (const std::string &amp;entry_name, const <a class="el" href="classbool.html">bool</a> &amp;new_value)</td></tr>
<tr class="separator:adcee5b1f5f7c6745e8c7b66dcf34104d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d977f31bfae8a9adb84dbaf35f389ea"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a9d977f31bfae8a9adb84dbaf35f389ea">print_parameters</a> (std::ostream &amp;out, const <a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827">OutputStyle</a> style)</td></tr>
<tr class="separator:a9d977f31bfae8a9adb84dbaf35f389ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f6ee701c5188a938b7313bf3997965a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a3f6ee701c5188a938b7313bf3997965a">print_parameters_section</a> (std::ostream &amp;out, const <a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827">OutputStyle</a> style, const unsigned <a class="el" href="classint.html">int</a> indent_level)</td></tr>
<tr class="separator:a3f6ee701c5188a938b7313bf3997965a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2f4db3ea6cd9414cc39d926a0a0959e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#af2f4db3ea6cd9414cc39d926a0a0959e">log_parameters</a> (<a class="el" href="classLogStream.html">LogStream</a> &amp;out)</td></tr>
<tr class="separator:af2f4db3ea6cd9414cc39d926a0a0959e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade326782f2aca595c273f3674294bb1e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#ade326782f2aca595c273f3674294bb1e">log_parameters_section</a> (<a class="el" href="classLogStream.html">LogStream</a> &amp;out)</td></tr>
<tr class="separator:ade326782f2aca595c273f3674294bb1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d0274dd20ec2ee605b5b744328cc02f"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a6d0274dd20ec2ee605b5b744328cc02f">memory_consumption</a> () const </td></tr>
<tr class="separator:a6d0274dd20ec2ee605b5b744328cc02f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca9aef12ecb4cfb4c8ca55941414698b"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:aca9aef12ecb4cfb4c8ca55941414698b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#aca9aef12ecb4cfb4c8ca55941414698b">save</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version) const </td></tr>
<tr class="separator:aca9aef12ecb4cfb4c8ca55941414698b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09fd2ee6d01b78079f894893aacd6c4c"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a09fd2ee6d01b78079f894893aacd6c4c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a09fd2ee6d01b78079f894893aacd6c4c">load</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:a09fd2ee6d01b78079f894893aacd6c4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a9900ee33c0ec10a3e81b718d43eb46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a0a9900ee33c0ec10a3e81b718d43eb46">operator==</a> (const <a class="el" href="classParameterHandler.html">ParameterHandler</a> &amp;prm2) const </td></tr>
<tr class="separator:a0a9900ee33c0ec10a3e81b718d43eb46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga988e0fcf4155d7816b4235e45a24bb6f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga988e0fcf4155d7816b4235e45a24bb6f">DeclException1</a> (ExcEntryAlreadyExists, std::string,&lt;&lt; &quot;The following entry already exists: &quot;&lt;&lt; arg1)</td></tr>
<tr class="separator:ga988e0fcf4155d7816b4235e45a24bb6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bb643b421ec3b21bf06de71b8e8a2c8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga0bb643b421ec3b21bf06de71b8e8a2c8">DeclException2</a> (ExcValueDoesNotMatchPattern, std::string, std::string,&lt;&lt; &quot;The string &lt;&quot;&lt;&lt; arg1&lt;&lt; &quot;&gt; does not match the given pattern &lt;&quot;&lt;&lt; arg2&lt;&lt; &quot;&gt;&quot;)</td></tr>
<tr class="separator:ga0bb643b421ec3b21bf06de71b8e8a2c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e6c7445d8e3519ff2df487449fb2995"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga8e6c7445d8e3519ff2df487449fb2995">DeclException0</a> (ExcAlreadyAtTopLevel)</td></tr>
<tr class="separator:ga8e6c7445d8e3519ff2df487449fb2995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21d0e51a7068c5af6fe7d0fb18b56b52"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga21d0e51a7068c5af6fe7d0fb18b56b52">DeclException1</a> (ExcEntryUndeclared, std::string,&lt;&lt; &quot;You can't ask for entry &lt;&quot;&lt;&lt; arg1&lt;&lt; &quot;&gt; you have not yet declared&quot;)</td></tr>
<tr class="separator:ga21d0e51a7068c5af6fe7d0fb18b56b52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga615b9a1794a19c5db540d046c7d818fc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga615b9a1794a19c5db540d046c7d818fc">DeclException1</a> (ExcConversionError, std::string,&lt;&lt; &quot;Error when trying to convert the following string: &quot;&lt;&lt; arg1)</td></tr>
<tr class="separator:ga615b9a1794a19c5db540d046c7d818fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSubscriptor"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSubscriptor')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSubscriptor.html">Subscriptor</a></td></tr>
<tr class="memitem:ae5541017c0966b0af345db75895106f2 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#ae5541017c0966b0af345db75895106f2">Subscriptor</a> ()</td></tr>
<tr class="separator:ae5541017c0966b0af345db75895106f2 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367fce3122075f05f168d14f114b4c65 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a367fce3122075f05f168d14f114b4c65">Subscriptor</a> (const <a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;)</td></tr>
<tr class="separator:a367fce3122075f05f168d14f114b4c65 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c6c557e06110d2127fa6459119e94af inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a6c6c557e06110d2127fa6459119e94af">~Subscriptor</a> ()</td></tr>
<tr class="separator:a6c6c557e06110d2127fa6459119e94af inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24ee69d4b3cf9690d1208b2443cbbb80 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a24ee69d4b3cf9690d1208b2443cbbb80">operator=</a> (const <a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;)</td></tr>
<tr class="separator:a24ee69d4b3cf9690d1208b2443cbbb80 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3422499827ecd52f1d12d65eb6cc3125 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a3422499827ecd52f1d12d65eb6cc3125">subscribe</a> (const char *identifier=0) const </td></tr>
<tr class="separator:a3422499827ecd52f1d12d65eb6cc3125 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b4839b1cffc18781144ede1744b35ea inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a2b4839b1cffc18781144ede1744b35ea">unsubscribe</a> (const char *identifier=0) const </td></tr>
<tr class="separator:a2b4839b1cffc18781144ede1744b35ea inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b45274c8e1936bff024df01d618e86f inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a7b45274c8e1936bff024df01d618e86f">n_subscriptions</a> () const </td></tr>
<tr class="separator:a7b45274c8e1936bff024df01d618e86f inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbbc5f845063b1f23223b7ac96e89e13 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#adbbc5f845063b1f23223b7ac96e89e13">list_subscribers</a> () const </td></tr>
<tr class="separator:adbbc5f845063b1f23223b7ac96e89e13 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2f0251d20c6a5295024de3b2e9b4359 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac2f0251d20c6a5295024de3b2e9b4359">DeclException3</a> (ExcInUse, <a class="el" href="classint.html">int</a>, char *, std::string &amp;,&lt;&lt; &quot;Object of class &quot;&lt;&lt; arg2&lt;&lt; &quot; is still used by &quot;&lt;&lt; arg1&lt;&lt; &quot; other objects.\n&quot;&lt;&lt; &quot;(Additional information: &quot;&lt;&lt; arg3&lt;&lt; &quot;)\n&quot;&lt;&lt; &quot;Note the entry in the Frequently Asked Questions of &quot;&lt;&lt; &quot;deal.II (linked to from http://www.dealii.org/) for &quot;&lt;&lt; &quot;more information on what this error means.&quot;)</td></tr>
<tr class="separator:gac2f0251d20c6a5295024de3b2e9b4359 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e000d9ce953da6afe4bbbaca4397344 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga9e000d9ce953da6afe4bbbaca4397344">DeclException2</a> (ExcNoSubscriber, char *, char *,&lt;&lt; &quot;No subscriber with identifier \&quot;&quot;&lt;&lt; arg2&lt;&lt; &quot;\&quot; did <a class="el" href="classSubscriptor.html#a3422499827ecd52f1d12d65eb6cc3125">subscribe</a> to this object of class &quot;&lt;&lt; arg1)</td></tr>
<tr class="separator:ga9e000d9ce953da6afe4bbbaca4397344 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38 inherit pub_methods_classSubscriptor"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38 inherit pub_methods_classSubscriptor"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:a68efd17a8330ab676d9cd711029b0f38 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:afb9589874569e5442840fe2f5d016924"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#afb9589874569e5442840fe2f5d016924">ParameterHandler</a> (const <a class="el" href="classParameterHandler.html">ParameterHandler</a> &amp;)</td></tr>
<tr class="separator:afb9589874569e5442840fe2f5d016924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad144b3d53732e7ac72fdacc0223e6ef6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classParameterHandler.html">ParameterHandler</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#ad144b3d53732e7ac72fdacc0223e6ef6">operator=</a> (const <a class="el" href="classParameterHandler.html">ParameterHandler</a> &amp;)</td></tr>
<tr class="separator:ad144b3d53732e7ac72fdacc0223e6ef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ed475f8b574291cd1d1000575fd64f4"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a4ed475f8b574291cd1d1000575fd64f4">get_current_path</a> () const </td></tr>
<tr class="separator:a4ed475f8b574291cd1d1000575fd64f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc471f64604438e32f25b52c9410ed3a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#afc471f64604438e32f25b52c9410ed3a">get_current_full_path</a> (const std::string &amp;name) const </td></tr>
<tr class="separator:afc471f64604438e32f25b52c9410ed3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc2e4082447c1a8106d2db83003637b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#afc2e4082447c1a8106d2db83003637b7">scan_line</a> (std::string line, const std::string &amp;input_filename, const unsigned <a class="el" href="classint.html">int</a> lineno)</td></tr>
<tr class="separator:afc2e4082447c1a8106d2db83003637b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:a4faae22ecf57fc1e46f1c46dd5dc4e2e"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a4faae22ecf57fc1e46f1c46dd5dc4e2e">mangle</a> (const std::string &amp;s)</td></tr>
<tr class="separator:a4faae22ecf57fc1e46f1c46dd5dc4e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed61698fd1939a21e0244030e1645d66"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#aed61698fd1939a21e0244030e1645d66">demangle</a> (const std::string &amp;s)</td></tr>
<tr class="separator:aed61698fd1939a21e0244030e1645d66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace2d2149f8fb0c377a08d95098d546a1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#ace2d2149f8fb0c377a08d95098d546a1">is_parameter_node</a> (const boost::property_tree::ptree &amp;)</td></tr>
<tr class="separator:ace2d2149f8fb0c377a08d95098d546a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ae85ddc962678f3fd4f98c1f98d2259f7"><td class="memItemLeft" align="right" valign="top">std::auto_ptr<br class="typebreak"/>
&lt; boost::property_tree::ptree &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#ae85ddc962678f3fd4f98c1f98d2259f7">entries</a></td></tr>
<tr class="separator:ae85ddc962678f3fd4f98c1f98d2259f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a275cc8f9248a9ba91c88b6c14a2f487d"><td class="memItemLeft" align="right" valign="top">std::vector<br class="typebreak"/>
&lt; std_cxx1x::shared_ptr&lt; const <br class="typebreak"/>
<a class="el" href="classPatterns_1_1PatternBase.html">Patterns::PatternBase</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a275cc8f9248a9ba91c88b6c14a2f487d">patterns</a></td></tr>
<tr class="separator:a275cc8f9248a9ba91c88b6c14a2f487d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefa5b69fc4d1d56dd6bc90e2dcf24d56"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#aefa5b69fc4d1d56dd6bc90e2dcf24d56">subsection_path</a></td></tr>
<tr class="separator:aefa5b69fc4d1d56dd6bc90e2dcf24d56"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr class="memitem:a009fb8cb45463ac3a57f8cb371fbc82b"><td class="memItemLeft" align="right" valign="top">static const char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a009fb8cb45463ac3a57f8cb371fbc82b">path_separator</a> = '.'</td></tr>
<tr class="separator:a009fb8cb45463ac3a57f8cb371fbc82b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a6cb3efd46790a1d4b58f5ffe7bb66c06"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6cb3efd46790a1d4b58f5ffe7bb66c06"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>MultipleParameterLoop</b></td></tr>
<tr class="separator:a6cb3efd46790a1d4b58f5ffe7bb66c06"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="classParameterHandler.html">ParameterHandler</a> class provides a standard interface to an input file which provides at run-time for program parameters such as time step sizes, geometries, right hand sides etc. The input for the program is given in files, streams or strings in memory using text like </p>
<div class="fragment"><div class="line"><a class="code" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">set</a> Time step size = 0.3</div>
<div class="line">set Geometry       = [0,1]x[0,3]</div>
</div><!-- fragment --><p> Input may be sorted into subsection trees in order to give the input a logical structure, and input files may include other files.</p>
<p>The <a class="el" href="classParameterHandler.html">ParameterHandler</a> class is discussed in detail in the <a class="el" href="step_19.html">step-19</a> example program, and is used in more realistic situations in <a class="el" href="step_29.html">step-29</a>, <a class="el" href="step_33.html">step-33</a> and <a class="el" href="step_34.html">step-34</a>.</p>
<h3>Declaring entries</h3>
<p>In order to use the facilities of a <a class="el" href="classParameterHandler.html">ParameterHandler</a> object, one first has to make known the different entries the input file may or may not contain. This is done in the following way:</p>
<div class="fragment"><div class="line">...</div>
<div class="line">ParameterHandler prm;</div>
<div class="line">prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a> (<span class="stringliteral">&quot;Time step size&quot;</span>,</div>
<div class="line">                  <span class="stringliteral">&quot;0.2&quot;</span>,</div>
<div class="line">                  <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(),</div>
<div class="line">                  <span class="stringliteral">&quot;Some documentation&quot;</span>);</div>
<div class="line">prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a> (<span class="stringliteral">&quot;Geometry&quot;</span>,</div>
<div class="line">                  <span class="stringliteral">&quot;[0,1]x[0,1]&quot;</span>,</div>
<div class="line">                  <a class="code" href="classPatterns_1_1Anything.html">Patterns::Anything</a>());</div>
<div class="line">...</div>
</div><!-- fragment --><p> Each entry is declared using the function <a class="el" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry()</a>. The first parameter is the name of the entry (in short: the entry). The second is the default answer to be taken in case the entry is not specified in the input file. The third parameter is a regular expression which the input (and the default answer) has to match. Several such regular expressions are defined in <a class="el" href="namespacePatterns.html">Patterns</a>. This parameter can be omitted, in which case it will default to <a class="el" href="classPatterns_1_1Anything.html">Patterns::Anything</a>, i.e. a pattern that matches every input string. The fourth parameter can be used to document the intent or expected format of an entry; its value is printed as a comment when writing all entries of a <a class="el" href="classParameterHandler.html">ParameterHandler</a> object using the <a class="el" href="classParameterHandler.html#a9d977f31bfae8a9adb84dbaf35f389ea">print_parameters()</a> function to allow for easier understanding of a parameter file. It can be omitted as well, in which case no such documentation will be printed.</p>
<p>Entries may be located in subsections which form a kind of input tree. For example input parameters for linear solver routines should be classified in a subsection named <code>Linear solver</code> or any other suitable name. This is accomplished in the following way: </p>
<div class="fragment"><div class="line">...</div>
<div class="line">  LinEq eq;</div>
<div class="line">  eq.declare_parameters (prm);</div>
<div class="line">...</div>
<div class="line"></div>
<div class="line">void LinEq::declare_parameters (<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm) {</div>
<div class="line">  prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Linear solver&quot;</span>);</div>
<div class="line">  {</div>
<div class="line">    prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a> (<span class="stringliteral">&quot;Solver&quot;</span>,</div>
<div class="line">                       <span class="stringliteral">&quot;CG&quot;</span>,</div>
<div class="line">                       <a class="code" href="classPatterns_1_1Selection.html">Patterns::Selection</a>(<span class="stringliteral">&quot;CG|GMRES|GaussElim&quot;</span>),</div>
<div class="line">                       <span class="stringliteral">&quot;Name of a linear solver for the inner iteration&quot;</span>);</div>
<div class="line">    prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a> (<span class="stringliteral">&quot;Maximum number of iterations&quot;</span>,</div>
<div class="line">                       <span class="stringliteral">&quot;20&quot;</span>,</div>
<div class="line">                       ParameterHandler::RegularExpressions::Integer());</div>
<div class="line">    ...</div>
<div class="line">  }</div>
<div class="line">  prm.<a class="code" href="classParameterHandler.html#a5d33f859364fc8730c939c0c36ee544c">leave_subsection</a> ();</div>
<div class="line">}</div>
</div><!-- fragment --><p>Subsections may be nested. For example a nonlinear solver may have a linear solver as member object. Then the function call tree would be something like (if the class <code>NonLinEq</code> has a member variables <code>eq</code> of type <code>LinEq</code>): </p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> NonLinEq::declare_parameters (<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm) {</div>
<div class="line">  prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a> (<span class="stringliteral">&quot;Nonlinear solver&quot;</span>);</div>
<div class="line">  {</div>
<div class="line">    prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a> (<span class="stringliteral">&quot;Nonlinear method&quot;</span>,</div>
<div class="line">                       <span class="stringliteral">&quot;Newton-Raphson&quot;</span>,</div>
<div class="line">                       ParameterHandler::RegularExpressions::Anything());</div>
<div class="line">    eq.declare_parameters (prm);</div>
<div class="line">  }</div>
<div class="line">  prm.<a class="code" href="classParameterHandler.html#a5d33f859364fc8730c939c0c36ee544c">leave_subsection</a> ();</div>
<div class="line">}</div>
</div><!-- fragment --><p>For class member functions which declare the different entries we propose to use the common name <code>declare_parameters</code>. In normal cases this method can be <code>static</code> since the entries will not depend on any previous knowledge. Classes for which entries should logically be grouped into subsections should declare these subsections themselves. If a class has two or more member variables of the same type both of which should have their own parameters, this parent class' method <code>declare_parameters</code> is responsible to group them into different subsections: </p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> NonLinEq::declare_parameters (<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm) {</div>
<div class="line">  prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a> (<span class="stringliteral">&quot;Nonlinear solver&quot;</span>);</div>
<div class="line">  {</div>
<div class="line">    prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a> (<span class="stringliteral">&quot;Linear solver 1&quot;</span>);</div>
<div class="line">    {</div>
<div class="line">      eq1.declare_parameters (prm);</div>
<div class="line">    }</div>
<div class="line">    prm.<a class="code" href="classParameterHandler.html#a5d33f859364fc8730c939c0c36ee544c">leave_subsection</a> ();</div>
<div class="line"></div>
<div class="line">    prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a> (<span class="stringliteral">&quot;Linear solver 2&quot;</span>);</div>
<div class="line">    {</div>
<div class="line">      eq2.declare_parameters (prm);</div>
<div class="line">    }</div>
<div class="line">    prm.<a class="code" href="classParameterHandler.html#a5d33f859364fc8730c939c0c36ee544c">leave_subsection</a> ();</div>
<div class="line">  }</div>
<div class="line">  prm.<a class="code" href="classParameterHandler.html#a5d33f859364fc8730c939c0c36ee544c">leave_subsection</a> ();</div>
<div class="line">}</div>
</div><!-- fragment --><h3>Input files and special characters</h3>
<p>For the first example above the input file would look like the following: </p>
<div class="fragment"><div class="line">...</div>
<div class="line">subsection Nonlinear solver</div>
<div class="line">  <a class="code" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">set</a> Nonlinear method = Gradient</div>
<div class="line"><span class="preprocessor">  # this is a comment</span></div>
<div class="line">  subsection Linear solver</div>
<div class="line">    <a class="code" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">set</a> <a class="code" href="classSolver.html">Solver</a>                        = CG</div>
<div class="line">    <a class="code" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">set</a> Maxmimum number of iterations = 30</div>
<div class="line">  end</div>
<div class="line">end</div>
<div class="line">...                       # other stuff</div>
</div><!-- fragment --><p> The words <code>subsection</code>, <code>set</code> and <code>end</code> may be either written in lowercase or uppercase letters. Leading and trailing whitespace is removed, multiple whitespace is condensed into only one. Since the latter applies also to the name of an entry, an entry name will not be recognized if in the declaration multiple whitespace is used.</p>
<p>In entry names and values the following characters are not allowed: <code>#</code>, <code>{</code>, <code>}</code>, <code>|</code>. Their use is reserved for the <a class="el" href="classMultipleParameterLoop.html">MultipleParameterLoop</a> class.</p>
<p>Comments starting with # are skipped.</p>
<p>We propose to use the following scheme to name entries: start the first word with a capital letter and use lowercase letters further on. The same applies to the possible entry values to the right of the <code>=</code> sign.</p>
<h3>Including other input files</h3>
<p>An input file can include other include files using the syntax </p>
<div class="fragment"><div class="line">...</div>
<div class="line">include some_other_file.prm</div>
<div class="line">...</div>
</div><!-- fragment --><p> The file so referenced is searched for relative to the current directory (not relative to the directory in which the including parameter file is located, since this is not known to all three versions of the <a class="el" href="classParameterHandler.html#a24a0eed678d48dae661d90f722aa1cd5">read_input()</a> function).</p>
<h3>Reading data from input sources</h3>
<p>In order to read input there are three possibilities: reading from an <code>std::istream</code> object, reading from a file of which the name is given and reading from a string in memory in which the lines are separated by <code>\n</code> characters. These possibilities are used as follows: </p>
<div class="fragment"><div class="line"><a class="code" href="classParameterHandler.html">ParameterHandler</a> prm;</div>
<div class="line">...</div>
<div class="line"><span class="comment">// declaration of entries</span></div>
<div class="line">...</div>
<div class="line">prm.<a class="code" href="classParameterHandler.html#a24a0eed678d48dae661d90f722aa1cd5">read_input</a> (cin);         <span class="comment">// read input from standard in,</span></div>
<div class="line"><span class="comment">// or</span></div>
<div class="line">prm.<a class="code" href="classParameterHandler.html#a24a0eed678d48dae661d90f722aa1cd5">read_input</a> (<span class="stringliteral">&quot;simulation.in&quot;</span>);</div>
<div class="line"><span class="comment">// or</span></div>
<div class="line"><span class="keywordtype">char</span> *in = <span class="stringliteral">&quot;set Time step size = 0.3 \n ...&quot;</span>;</div>
<div class="line">prm.<a class="code" href="classParameterHandler.html#a19c8a23a6bdfd6936a3a6de29999ba09">read_input_from_string</a> (in);</div>
<div class="line">...</div>
</div><!-- fragment --><p> You can use several sources of input successively. Entries which are changed more than once will be overwritten every time they are used.</p>
<p>You should not try to declare entries using <a class="el" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry()</a> and <a class="el" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection()</a> with as yet unknown subsection names after using <a class="el" href="classParameterHandler.html#a24a0eed678d48dae661d90f722aa1cd5">read_input()</a>. The results in this case are unspecified.</p>
<p>If an error occurs upon reading the input, error messages are written to <code>std::cerr</code> and the reader function returns with a return value of <code>false</code>. This is opposed to almost all other functions in deal.II, which would normally throw an exception if an error occurs; this difference in behavior is a relic of the fact that this class predates deal.II and had previously been written for a different project.</p>
<h3>Using the ParameterHandler Graphical User Interface</h3>
<p>An alternative to using the hand-written input files shown above is to use the graphical user interface (GUI) that accompanies this class. For this, you first need to write a description of all the parameters, their default values, patterns and documentation strings into a file in a format that the GUI can understand; this is done using the <a class="el" href="classParameterHandler.html#a9d977f31bfae8a9adb84dbaf35f389ea">ParameterHandler::print_parameters()</a> function with <a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827a2b5a2007249d810f05d23dc837c47510">ParameterHandler::XML</a> as second argument, as discussed in more detail below in the <em>Representation of Parameters</em> section. This file can then be loaded using the executable for the GUI, which should be located in <code>lib/bin/dealii_parameter_gui</code> of your deal.II installation, assuming that you have a sufficiently recent version of the <a href="http://qt.nokia.com/">Qt toolkit</a> installed.</p>
<p>Once loaded, the GUI displays subsections and individual parameters in tree form (see also the discussion in the <em>Representation of Parameters</em> section below). Here is a screen shot with some sub-sections expanded and one parameter selected for editing:</p>
<div class="image">
<img src="parameter_gui.png" alt="parameter_gui.png"/>
<div class="caption">
Parameter GUI</div></div>
<p> Using the GUI, you can edit the values of individual parameters and save the result in the same format as before. It can then be read in using the <a class="el" href="classParameterHandler.html#a2ac24835f0c13ffec54ed206100ce10d">ParameterHandler::read_input_from_xml()</a> function.</p>
<h3>Getting entry values out of a ParameterHandler object</h3>
<p>Each class gets its data out of a <a class="el" href="classParameterHandler.html">ParameterHandler</a> object by calling the <a class="el" href="classParameterHandler.html#a7589d0ed2a7e70532853e1e378130c88">get()</a> member functions like this: </p>
<div class="fragment"><div class="line"> <span class="keywordtype">void</span> NonLinEq::get_parameters (<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm) {</div>
<div class="line">  prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a> (<span class="stringliteral">&quot;Nonlinear solver&quot;</span>);</div>
<div class="line">  std::string method = prm.<a class="code" href="classParameterHandler.html#a7589d0ed2a7e70532853e1e378130c88">get</a> (<span class="stringliteral">&quot;Nonlinear method&quot;</span>);</div>
<div class="line">  eq.get_parameters (prm);</div>
<div class="line">  prm.<a class="code" href="classParameterHandler.html#a5d33f859364fc8730c939c0c36ee544c">leave_subsection</a> ();</div>
<div class="line">}</div>
</div><!-- fragment --><p> <a class="el" href="classParameterHandler.html#a7589d0ed2a7e70532853e1e378130c88">get()</a> returns the value of the given entry. If the entry was not specified in the input source(s), the default value is returned. You have to enter and leave subsections exactly as you did when declaring subsection. You may chose the order in which to transverse the subsection tree.</p>
<p>It is guaranteed that only entries matching the given regular expression are returned, i.e. an input entry value which does not match the regular expression is not stored.</p>
<p>You can use <a class="el" href="classParameterHandler.html#a7589d0ed2a7e70532853e1e378130c88">get()</a> to retrieve the parameter in text form, <a class="el" href="classParameterHandler.html#a5315d2dfbf7223851805e9432c92b2be">get_integer()</a> to get an integer or <a class="el" href="classParameterHandler.html#a3218c50fa6386b6791a5096ec1e37620">get_double()</a> to get a double. You can also use <a class="el" href="classParameterHandler.html#a5b3601d0dee839d1c732146c0ed8f5bd">get_bool()</a>. It will cause an internal error if the string could not be converted to an integer, double or a bool. This should, though, not happen if you correctly specified the regular expression for this entry; you should not try to get out an integer or a double from an entry for which no according regular expression was set. The internal error is raised through the <a class="el" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert()</a> macro family which only works in debug mode.</p>
<p>If you want to print out all user selectable features, use the <a class="el" href="classParameterHandler.html#a9d977f31bfae8a9adb84dbaf35f389ea">print_parameters()</a> function. It is generally a good idea to print all parameters at the beginning of a log file, since this way input and output are together in one file which makes matching at a later time easier. Additionally, the function also print those entries which have not been modified in the input file und are thus set to default values; since default values may change in the process of program development, you cannot know the values of parameters not specified in the input file.</p>
<h3>Style guide for data retrieval</h3>
<p>We propose that every class which gets data out of a <a class="el" href="classParameterHandler.html">ParameterHandler</a> object provides a function named <code>get_parameters</code>. This should be declared <code>virtual</code>. <code>get_parameters</code> functions in derived classes should call the <code>BaseClass::get_parameters</code> function.</p>
<h3>Experience with large parameter lists</h3>
<p>Experience has shown that in programs defining larger numbers of parameters (more than, say, fifty) it is advantageous to define an additional class holding these parameters. This class is more like a C-style structure, having a large number of variables, usually public. It then has at least two functions, which declare and parse the parameters. In the main program, the main class has an object of this parameter class and delegates declaration and parsing of parameters to this object.</p>
<p>The advantage of this approach is that you can keep out the technical details (declaration and parsing) out of the main class and additionally don't clutter up your main class with dozens or more variables denoting the parameters.</p>
<h3>Worked Example</h3>
<p>This is the code: </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;../include/parameter_handler.h&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">using namespace </span>dealii;</div>
<div class="line"></div>
<div class="line"><span class="keyword">class </span>LinEq {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> declare_parameters (<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div>
<div class="line">    <span class="keywordtype">void</span> get_parameters (<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div>
<div class="line">  <span class="keyword">private</span>:</div>
<div class="line">    std::string Method;</div>
<div class="line">    <span class="keywordtype">int</span>    MaxIterations;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">class </span>Problem {</div>
<div class="line">  <span class="keyword">private</span>:</div>
<div class="line">    LinEq eq1, eq2;</div>
<div class="line">    std::string Matrix1, Matrix2;</div>
<div class="line">    std::string outfile;</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> declare_parameters (<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div>
<div class="line">    <span class="keywordtype">void</span> get_parameters (<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> LinEq::declare_parameters (<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm) {</div>
<div class="line">                                   <span class="comment">// declare parameters for the linear</span></div>
<div class="line">                                   <span class="comment">// solver in a subsection</span></div>
<div class="line">  prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a> (<span class="stringliteral">&quot;Linear solver&quot;</span>);</div>
<div class="line">  prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a> (<span class="stringliteral">&quot;Solver&quot;</span>,</div>
<div class="line">                     <span class="stringliteral">&quot;CG&quot;</span>,</div>
<div class="line">                     <a class="code" href="classPatterns_1_1Selection.html">Patterns::Selection</a>(<span class="stringliteral">&quot;CG|BiCGStab|GMRES&quot;</span>),</div>
<div class="line">                     <span class="stringliteral">&quot;Name of a linear solver for the inner iteration&quot;</span>);</div>
<div class="line">  prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a> (<span class="stringliteral">&quot;Maximum number of iterations&quot;</span>,</div>
<div class="line">                     <span class="stringliteral">&quot;20&quot;</span>,</div>
<div class="line">                     <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>());</div>
<div class="line">  prm.<a class="code" href="classParameterHandler.html#a5d33f859364fc8730c939c0c36ee544c">leave_subsection</a> ();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> LinEq::get_parameters (<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm) {</div>
<div class="line">  prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a> (<span class="stringliteral">&quot;Linear solver&quot;</span>);</div>
<div class="line">  Method        = prm.<a class="code" href="classParameterHandler.html#a7589d0ed2a7e70532853e1e378130c88">get</a> (<span class="stringliteral">&quot;Solver&quot;</span>);</div>
<div class="line">  MaxIterations = prm.<a class="code" href="classParameterHandler.html#a5315d2dfbf7223851805e9432c92b2be">get_integer</a> (<span class="stringliteral">&quot;Maximum number of iterations&quot;</span>);</div>
<div class="line">  prm.<a class="code" href="classParameterHandler.html#a5d33f859364fc8730c939c0c36ee544c">leave_subsection</a> ();</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;  LinEq: Method=&quot;</span> &lt;&lt; Method &lt;&lt; <span class="stringliteral">&quot;, MaxIterations=&quot;</span> &lt;&lt; MaxIterations &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> Problem::declare_parameters (<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm) {</div>
<div class="line">                                   <span class="comment">// first some global parameter entries</span></div>
<div class="line">  prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a> (<span class="stringliteral">&quot;Output file&quot;</span>,</div>
<div class="line">                     <span class="stringliteral">&quot;out&quot;</span>,</div>
<div class="line">                     <a class="code" href="classPatterns_1_1Anything.html">Patterns::Anything</a>(),</div>
<div class="line">                     <span class="stringliteral">&quot;Name of the output file, either relative to the present&quot;</span></div>
<div class="line">                     <span class="stringliteral">&quot;path or absolute&quot;</span>);</div>
<div class="line">  prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a> (<span class="stringliteral">&quot;Equation 1&quot;</span>,</div>
<div class="line">                     <span class="stringliteral">&quot;Laplace&quot;</span>,</div>
<div class="line">                     <a class="code" href="classPatterns_1_1Anything.html">Patterns::Anything</a>(),</div>
<div class="line">                     <span class="stringliteral">&quot;String identifying the equation we want to solve&quot;</span>);</div>
<div class="line">  prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a> (<span class="stringliteral">&quot;Equation 2&quot;</span>,</div>
<div class="line">                     <span class="stringliteral">&quot;Elasticity&quot;</span>,</div>
<div class="line">                     <a class="code" href="classPatterns_1_1Anything.html">Patterns::Anything</a>());</div>
<div class="line"></div>
<div class="line">                                   <span class="comment">// declare parameters for the</span></div>
<div class="line">                                   <span class="comment">// first equation</span></div>
<div class="line">  prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a> (<span class="stringliteral">&quot;Equation 1&quot;</span>);</div>
<div class="line">  prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a> (<span class="stringliteral">&quot;Matrix type&quot;</span>,</div>
<div class="line">                     <span class="stringliteral">&quot;Sparse&quot;</span>,</div>
<div class="line">                     <a class="code" href="classPatterns_1_1Selection.html">Patterns::Selection</a>(<span class="stringliteral">&quot;Full|Sparse|Diagonal&quot;</span>),</div>
<div class="line">                     <span class="stringliteral">&quot;Type of the matrix to be used, either full,&quot;</span></div>
<div class="line">                     <span class="stringliteral">&quot;sparse, or diagonal&quot;</span>);</div>
<div class="line">  LinEq::declare_parameters (prm);  <span class="comment">// for eq1</span></div>
<div class="line">  prm.<a class="code" href="classParameterHandler.html#a5d33f859364fc8730c939c0c36ee544c">leave_subsection</a> ();</div>
<div class="line"></div>
<div class="line">                                   <span class="comment">// declare parameters for the</span></div>
<div class="line">                                   <span class="comment">// second equation</span></div>
<div class="line">  prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a> (<span class="stringliteral">&quot;Equation 2&quot;</span>);</div>
<div class="line">  prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a> (<span class="stringliteral">&quot;Matrix type&quot;</span>,</div>
<div class="line">                     <span class="stringliteral">&quot;Sparse&quot;</span>,</div>
<div class="line">                     <a class="code" href="classPatterns_1_1Selection.html">Patterns::Selection</a>(<span class="stringliteral">&quot;Full|Sparse|Diagonal&quot;</span>));</div>
<div class="line">  LinEq::declare_parameters (prm);  <span class="comment">// for eq2</span></div>
<div class="line">  prm.<a class="code" href="classParameterHandler.html#a5d33f859364fc8730c939c0c36ee544c">leave_subsection</a> ();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> Problem::get_parameters (<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm) {</div>
<div class="line">                                   <span class="comment">// entries of the problem class</span></div>
<div class="line">  outfile = prm.<a class="code" href="classParameterHandler.html#a7589d0ed2a7e70532853e1e378130c88">get</a> (<span class="stringliteral">&quot;Output file&quot;</span>);</div>
<div class="line"></div>
<div class="line">  std::string equation1 = prm.<a class="code" href="classParameterHandler.html#a7589d0ed2a7e70532853e1e378130c88">get</a> (<span class="stringliteral">&quot;Equation 1&quot;</span>),</div>
<div class="line">         equation2 = prm.<a class="code" href="classParameterHandler.html#a7589d0ed2a7e70532853e1e378130c88">get</a> (<span class="stringliteral">&quot;Equation 2&quot;</span>);</div>
<div class="line"></div>
<div class="line">                                   <span class="comment">// get parameters for the</span></div>
<div class="line">                                   <span class="comment">// first equation</span></div>
<div class="line">  prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a> (<span class="stringliteral">&quot;Equation 1&quot;</span>);</div>
<div class="line">  Matrix1 = prm.<a class="code" href="classParameterHandler.html#a7589d0ed2a7e70532853e1e378130c88">get</a> (<span class="stringliteral">&quot;Matrix type&quot;</span>);</div>
<div class="line">  eq1.get_parameters (prm);         <span class="comment">// for eq1</span></div>
<div class="line">  prm.<a class="code" href="classParameterHandler.html#a5d33f859364fc8730c939c0c36ee544c">leave_subsection</a> ();</div>
<div class="line"></div>
<div class="line">                                   <span class="comment">// get parameters for the</span></div>
<div class="line">                                   <span class="comment">// second equation</span></div>
<div class="line">  prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a> (<span class="stringliteral">&quot;Equation 2&quot;</span>);</div>
<div class="line">  Matrix2 = prm.<a class="code" href="classParameterHandler.html#a7589d0ed2a7e70532853e1e378130c88">get</a> (<span class="stringliteral">&quot;Matrix type&quot;</span>);</div>
<div class="line">  eq2.get_parameters (prm);         <span class="comment">// for eq2</span></div>
<div class="line">  prm.<a class="code" href="classParameterHandler.html#a5d33f859364fc8730c939c0c36ee544c">leave_subsection</a> ();</div>
<div class="line"></div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;  Problem: outfile=&quot;</span> &lt;&lt; outfile &lt;&lt; std::endl</div>
<div class="line">       &lt;&lt; <span class="stringliteral">&quot;           eq1=&quot;</span>     &lt;&lt; equation1 &lt;&lt; <span class="stringliteral">&quot;, eq2=&quot;</span> &lt;&lt; equation2 &lt;&lt; std::endl</div>
<div class="line">       &lt;&lt; <span class="stringliteral">&quot;           Matrix1=&quot;</span> &lt;&lt; Matrix1 &lt;&lt; <span class="stringliteral">&quot;, Matrix2=&quot;</span> &lt;&lt; Matrix2 &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="group__ParameterGui.html#ga0ddf1224851353fc92bfbff6f499fa97">main</a> () {</div>
<div class="line">  <a class="code" href="classParameterHandler.html">ParameterHandler</a> prm;</div>
<div class="line">  Problem p;</div>
<div class="line"></div>
<div class="line">  p.declare_parameters (prm);</div>
<div class="line"></div>
<div class="line">                                   <span class="comment">// read input from &quot;prmtest.prm&quot;; giving</span></div>
<div class="line">                                   <span class="comment">// argv[1] would also be a good idea</span></div>
<div class="line">  prm.<a class="code" href="classParameterHandler.html#a24a0eed678d48dae661d90f722aa1cd5">read_input</a> (<span class="stringliteral">&quot;prmtest.prm&quot;</span>);</div>
<div class="line"></div>
<div class="line">                                   <span class="comment">// print parameters to std::cout as ASCII text</span></div>
<div class="line">  std::cout &lt;&lt; std::endl &lt;&lt; std::endl;</div>
<div class="line">  prm.<a class="code" href="classParameterHandler.html#a9d977f31bfae8a9adb84dbaf35f389ea">print_parameters</a> (std::cout, <a class="code" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827ae4d13a4598073bfcb69cd0cf4c1f8365">ParameterHandler::Text</a>);</div>
<div class="line"></div>
<div class="line">                                   <span class="comment">// get parameters into the program</span></div>
<div class="line">  std::cout &lt;&lt; std::endl &lt;&lt; std::endl</div>
<div class="line">            &lt;&lt; <span class="stringliteral">&quot;Getting parameters:&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  p.get_parameters (prm);</div>
<div class="line"></div>
<div class="line">                                   <span class="comment">// now run the program with these</span></div>
<div class="line">                                   <span class="comment">// input parameters</span></div>
<div class="line">  p.do_something ();</div>
<div class="line">}</div>
</div><!-- fragment --><p>This is the input file (named "prmtest.prm"): </p>
<div class="fragment"><div class="line"><span class="preprocessor">                            # first declare the types of equations</span></div>
<div class="line"><a class="code" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">set</a> Equation 1 = Poisson</div>
<div class="line"><a class="code" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">set</a> Equation 2 = Navier-Stokes</div>
<div class="line"></div>
<div class="line">subsection Equation 1</div>
<div class="line">  <a class="code" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">set</a> Matrix type = Sparse</div>
<div class="line">  subsection Linear solver    # parameters <span class="keywordflow">for</span> linear solver 1</div>
<div class="line">    <a class="code" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">set</a> Solver                       = Gauss-Seidel</div>
<div class="line">    <a class="code" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">set</a> Maximum number of iterations = 40</div>
<div class="line">  end</div>
<div class="line">end</div>
<div class="line"></div>
<div class="line">subsection Equation 2</div>
<div class="line">  <a class="code" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">set</a> Matrix type = Full</div>
<div class="line">  subsection Linear solver</div>
<div class="line">    <a class="code" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">set</a> Solver                       = CG</div>
<div class="line">    <a class="code" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">set</a> Maximum number of iterations = 100</div>
<div class="line">  end</div>
<div class="line">end</div>
</div><!-- fragment --><p>And here is the output of the program: </p>
<div class="fragment"><div class="line">Line 8:</div>
<div class="line">    The entry value</div>
<div class="line">        Gauss-Seidel</div>
<div class="line">    <span class="keywordflow">for</span> the entry named</div>
<div class="line">        Solver</div>
<div class="line">    does not match the given regular expression</div>
<div class="line">        CG|BiCGStab|GMRES</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">Listing of Parameters</div>
<div class="line">---------------------</div>
<div class="line">  <a class="code" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">set</a> Equation 1  = Poisson  # Laplace</div>
<div class="line">  <a class="code" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">set</a> Equation 2  = Navier-Stokes  # Elasticity</div>
<div class="line">  <a class="code" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">set</a> Output file = out</div>
<div class="line">  subsection Equation 1</div>
<div class="line">    <a class="code" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">set</a> Matrix type = Sparse  # Sparse</div>
<div class="line">    subsection Linear solver</div>
<div class="line">      <a class="code" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">set</a> Maximum number of iterations = 40  # 20</div>
<div class="line">      <a class="code" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">set</a> Solver                       = CG</div>
<div class="line">    end</div>
<div class="line">  end</div>
<div class="line">  subsection Equation 2</div>
<div class="line">    <a class="code" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">set</a> Matrix type = Full  # Sparse</div>
<div class="line">    subsection Linear solver</div>
<div class="line">      <a class="code" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">set</a> Maximum number of iterations = 100  # 20</div>
<div class="line">      <a class="code" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">set</a> Solver                       = CG   # CG</div>
<div class="line">    end</div>
<div class="line">  end</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">Getting parameters:</div>
<div class="line">  LinEq: Method=CG, MaxIterations=40</div>
<div class="line">  LinEq: Method=CG, MaxIterations=100</div>
<div class="line">  Problem: outfile=out</div>
<div class="line">           eq1=Poisson, eq2=Navier-Stokes</div>
<div class="line">           Matrix1=Sparse, Matrix2=Full</div>
</div><!-- fragment --><h3>Representation of Parameters</h3>
<p>Here is some more internal information about the repesentation of parameters:</p>
<p>Logically, parameters and the nested sections they are arranged in can be thought of as a hierarchical directory structure, or a tree. Take, for example, the following code declaring a set of parameters and sections they live in: </p>
<div class="fragment"><div class="line"><a class="code" href="classParameterHandler.html">ParameterHandler</a> prm;</div>
<div class="line"></div>
<div class="line">prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a> (<span class="stringliteral">&quot;Maximal number of iterations&quot;</span>,</div>
<div class="line">                   <span class="stringliteral">&quot;10&quot;</span>,</div>
<div class="line">                   <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a> (1, 1000),</div>
<div class="line">                   <span class="stringliteral">&quot;A parameter that describes the maximal number of &quot;</span></div>
<div class="line">                   <span class="stringliteral">&quot;iterations the CG method is to take before giving &quot;</span></div>
<div class="line">                   <span class="stringliteral">&quot;up on a matrix.&quot;</span>);</div>
<div class="line">prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a> (<span class="stringliteral">&quot;Preconditioner&quot;</span>);</div>
<div class="line">{</div>
<div class="line">  prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a> (<span class="stringliteral">&quot;Kind&quot;</span>,</div>
<div class="line">                     <span class="stringliteral">&quot;SSOR&quot;</span>,</div>
<div class="line">                     <a class="code" href="classPatterns_1_1Selection.html">Patterns::Selection</a> (<span class="stringliteral">&quot;SSOR|Jacobi&quot;</span>),</div>
<div class="line">                     <span class="stringliteral">&quot;A string that describes the kind of preconditioner &quot;</span></div>
<div class="line">                     <span class="stringliteral">&quot;to use.&quot;</span>);</div>
<div class="line">  prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a> (<span class="stringliteral">&quot;Relaxation factor&quot;</span>,</div>
<div class="line">                     <span class="stringliteral">&quot;1.0&quot;</span>,</div>
<div class="line">                     <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a> (0, 1),</div>
<div class="line">                     <span class="stringliteral">&quot;The numerical value (between zero and one) for the &quot;</span></div>
<div class="line">                     <span class="stringliteral">&quot;relaxation factor to use in the preconditioner.&quot;</span>);</div>
<div class="line">}</div>
<div class="line">prm.<a class="code" href="classParameterHandler.html#a5d33f859364fc8730c939c0c36ee544c">leave_subsection</a> ();</div>
</div><!-- fragment --><p>We can think of the parameters so arranged as a file system in which every parameter is a directory. The name of this directory is the name of the parameter, and in this directory lie files that describe the parameter. These files are:</p>
<ul>
<li><code>value</code>: The content of this file is the current value of this parameter; initially, the content of the file equals the default value of the parameter.</li>
<li><code>default_value</code>: The content of this file is the default value value of the parameter.</li>
<li><code>pattern</code>: A textual representation of the pattern that describes the parameter's possible values.</li>
<li><code>pattern_index</code>: A number that indexes the <a class="el" href="classPatterns_1_1PatternBase.html">Patterns::PatternBase</a> object that is used to describe the parameter.</li>
<li><code>documentation</code>: The content of this file is the documentation given for a parameter as the last argument of the <a class="el" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">ParameterHandler::declare_entry</a> call. With the exception of the <code>value</code> file, the contents of files are never changed after declaration of a parameter.</li>
</ul>
<p>Alternatively, a directory in this file system may not have a file called <code>value</code> in it. In that case, the directory represents a subsection as declared above, and the directory's name will correspond to the name of the subsection. It will then have no files in it at all, but it may have further directories in it: some of these directories will be parameters (indicates by the presence of files) or further nested subsections.</p>
<p>Given this explanation, the code above will lead to a hierarchical representation of data that looks like this (the content of files is indicated at the right in a different font): </p>
<div class="image">
<img src="parameter_handler.png" alt="parameter_handler.png"/>
</div>
<p> Once parameters have been read in, the contents of the <code>value</code> "files" may be different while the other files remain untouched.</p>
<p>Using the <a class="el" href="classParameterHandler.html#a9d977f31bfae8a9adb84dbaf35f389ea">ParameterHandler::print_parameters()</a> function with <a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827a2b5a2007249d810f05d23dc837c47510">ParameterHandler::XML</a> as second argument, we can get a complete representation of this data structure in XML. It will look like this: </p>
<div class="fragment"><div class="line">&lt;?xml version=<span class="stringliteral">&quot;1.0&quot;</span> encoding=<span class="stringliteral">&quot;utf-8&quot;</span>?&gt;</div>
<div class="line">&lt;<a class="code" href="classParameterHandler.html">ParameterHandler</a>&gt;</div>
<div class="line">  &lt;Maximal_20number_20of_20iterations&gt;</div>
<div class="line">    &lt;value&gt;10&lt;/value&gt;</div>
<div class="line">    &lt;default_value&gt;10&lt;/default_value&gt;</div>
<div class="line">    &lt;documentation&gt;A parameter that describes the maximal number of iterations the CG method is to take before giving up on a matrix.&lt;/documentation&gt;</div>
<div class="line">    &lt;pattern&gt;0&lt;/pattern&gt;</div>
<div class="line">    &lt;pattern_description&gt;[Integer range 1...1000 (inclusive)]&lt;/pattern_description&gt;</div>
<div class="line">  &lt;/Maximal_20number_20of_20iterations&gt;</div>
<div class="line">  &lt;Preconditioner&gt;</div>
<div class="line">    &lt;Kind&gt;&lt;value&gt;SSOR&lt;/value&gt;</div>
<div class="line">      &lt;default_value&gt;SSOR&lt;/default_value&gt;</div>
<div class="line">      &lt;documentation&gt;A <span class="keywordtype">string</span> that describes the kind of preconditioner to use.&lt;/documentation&gt;</div>
<div class="line">      &lt;pattern&gt;1&lt;/pattern&gt;</div>
<div class="line">      &lt;pattern_description&gt;SSOR|Jacobi&lt;/pattern_description&gt;</div>
<div class="line">    &lt;/Kind&gt;</div>
<div class="line">    &lt;Relaxation_20factor&gt;</div>
<div class="line">      &lt;value&gt;1.0&lt;/value&gt;</div>
<div class="line">      &lt;default_value&gt;1.0&lt;/default_value&gt;</div>
<div class="line">      &lt;documentation&gt;The numerical value (between zero and one) <span class="keywordflow">for</span> the relaxation factor to use in the preconditioner.&lt;/documentation&gt;</div>
<div class="line">      &lt;pattern&gt;2&lt;/pattern&gt;</div>
<div class="line">      &lt;pattern_description&gt;[Floating point range 0...1 (inclusive)]&lt;/pattern_description&gt;</div>
<div class="line">    &lt;/Relaxation_20factor&gt;</div>
<div class="line">  &lt;/Preconditioner&gt;</div>
<div class="line">&lt;<a class="code" href="classParameterHandler.html">ParameterHandler</a>&gt;</div>
</div><!-- fragment --><p> This representation closely resembles the directory/file structure discussed above. The only difference is that directory and file names are mangled: since they should only contain letters and numbers, every character in their names that is not a letter or number is replaced by an underscore followed by its two-digit hexadecimal representation. In addition, the special name "value" is mangled when used as the name of a parameter, given that this name is also used to name special files in the hierarchy structure. Finally, the entire tree is wrapped into a tag <code>ParameterHandler</code> to satisfy the XML requirement that there be only a single top-level construct in each file.</p>
<p>The tree structure (and its XML representation) is what the graphical user interface (see above) uses to represent parameters like a directory/file collection.</p>
<dl class="section author"><dt>Author</dt><dd>Wolfgang Bangerth, October 1997, revised February 1998, 2010, 2011 </dd></dl>

<p>Definition at line <a class="el" href="parameter__handler_8h_source.html#l01517">1517</a> of file <a class="el" href="parameter__handler_8h_source.html">parameter_handler.h</a>.</p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="a8364dda711b93753c6809eefe2a8e827"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827">ParameterHandler::OutputStyle</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>List of possible output formats.</p>
<p>The formats down the list with prefix <em>Short</em> and bit 6 and 7 set reproduce the old behavior of not writing comments or original values to the files. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a8364dda711b93753c6809eefe2a8e827ae4d13a4598073bfcb69cd0cf4c1f8365"></a>Text&#160;</td><td class="fielddoc">
<p>Write human readable output suitable to be read by <a class="el" href="classParameterHandler.html">ParameterHandler</a> again. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8364dda711b93753c6809eefe2a8e827a3b5d289d79f36e819a7bd0d81a52ee37"></a>LaTeX&#160;</td><td class="fielddoc">
<p>Write parameters as a LaTeX table. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8364dda711b93753c6809eefe2a8e827a5ed7026d01b66b89ee3c1aef3efbfd4a"></a>Description&#160;</td><td class="fielddoc">
<p>Write out declared parameters with description and possible values. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8364dda711b93753c6809eefe2a8e827a2b5a2007249d810f05d23dc837c47510"></a>XML&#160;</td><td class="fielddoc">
<p>Write out everything as an <a href="http://en.wikipedia.org/wiki/XML">XML</a> file.</p>
<p>See the general documentation of this class for an example of output. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8364dda711b93753c6809eefe2a8e827a456d0f94d7d72f33234d02a8b2e9030c"></a>JSON&#160;</td><td class="fielddoc">
<p>Write out everything as a <a href="http://en.wikipedia.org/wiki/JSON">JSON</a> file. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8364dda711b93753c6809eefe2a8e827a6d91eaf8deb52a5d3cba991a9bb23ac7"></a>ShortText&#160;</td><td class="fielddoc">
<p>Write input for <a class="el" href="classParameterHandler.html">ParameterHandler</a> without comments or changed default values. </p>
</td></tr>
</table>

<p>Definition at line <a class="el" href="parameter__handler_8h_source.html#l01538">1538</a> of file <a class="el" href="parameter__handler_8h_source.html">parameter_handler.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="afb9589874569e5442840fe2f5d016924"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ParameterHandler::ParameterHandler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParameterHandler.html">ParameterHandler</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inhibit automatic CopyConstructor. </p>

</div>
</div>
<a class="anchor" id="a7aebc6956ea423d376c5fe881b8d5c4d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ParameterHandler::ParameterHandler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. </p>

</div>
</div>
<a class="anchor" id="ac60bd0947b174d8b01d3a3f6aabc23e3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ParameterHandler::~ParameterHandler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor. Declare this only to have a virtual destructor, which is safer as we have virtual functions. It actually does nothing spectacular. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ad144b3d53732e7ac72fdacc0223e6ef6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParameterHandler.html">ParameterHandler</a>&amp; ParameterHandler::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParameterHandler.html">ParameterHandler</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inhibit automatic assignment operator. </p>

</div>
</div>
<a class="anchor" id="a24a0eed678d48dae661d90f722aa1cd5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> ParameterHandler::read_input </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em> = <code>&quot;input&#160;file&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read input from a stream until the stream returns the <code>eof</code> condition or error. The second argument can be used to denote the name of the file (if that's what the input stream represents) we are reading from; this is only used when creating output for error messages.</p>
<p>Return whether the read was successful. </p>

<p>Reimplemented in <a class="el" href="classMultipleParameterLoop.html#acbbf812a6114b5b632d06e013f7dc299">MultipleParameterLoop</a>.</p>

</div>
</div>
<a class="anchor" id="a5946f967a214445cc645027a9a13bd3e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> ParameterHandler::read_input </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>optional</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>write_stripped_file</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read input from a file the name of which is given. The <a class="el" href="classPathSearch.html">PathSearch</a> class "PARAMETERS" is used to find the file.</p>
<p>Return whether the read was successful.</p>
<p>Unless <code>optional</code> is <code>true</code>, this function will automatically generate the requested file with default values if the file did not exist. This file will not contain additional comments if <code>write_stripped_file</code> is <code>true</code>. </p>

<p>Reimplemented in <a class="el" href="classMultipleParameterLoop.html#adc5a215b3b04c00d5965a5333bccaf58">MultipleParameterLoop</a>.</p>

</div>
</div>
<a class="anchor" id="a19c8a23a6bdfd6936a3a6de29999ba09"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> ParameterHandler::read_input_from_string </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read input from a string in memory. The lines in memory have to be separated by <code>\n</code> characters.</p>
<p>Return whether the read was successful. </p>

<p>Reimplemented in <a class="el" href="classMultipleParameterLoop.html#a1cdb07e127432a0ae264f2accf3988be">MultipleParameterLoop</a>.</p>

</div>
</div>
<a class="anchor" id="a2ac24835f0c13ffec54ed206100ce10d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> ParameterHandler::read_input_from_xml </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read a parameter file in XML format. This could be from a file originally written by the <a class="el" href="classParameterHandler.html#a9d977f31bfae8a9adb84dbaf35f389ea">print_parameters()</a> function using the XML output style and then modified by hand as necessary; or from a file written using this method and then modified by the graphical parameter GUI (see the general documentation of this class).</p>
<p>Return whether the read was successful. </p>

</div>
</div>
<a class="anchor" id="a6184baed4eba575e422161dc86ed12e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear all contents. </p>

</div>
</div>
<a class="anchor" id="afb951f101e0969416f7f47d24c03bcfa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::declare_entry </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>default_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPatterns_1_1PatternBase.html">Patterns::PatternBase</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em> = <code><a class="el" href="classPatterns_1_1Anything.html">Patterns::Anything</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>documentation</em> = <code>std::string()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare a new entry with name <code>entry</code>, default and for which any input has to match the <code>pattern</code> (default: any pattern).</p>
<p>The last parameter defaulting to an empty string is used to add a documenting text to each entry which will be printed as a comment when this class is asked to write out all declarations to a stream using the <a class="el" href="classParameterHandler.html#a9d977f31bfae8a9adb84dbaf35f389ea">print_parameters()</a> function.</p>
<p>The function generates an exception of type ExcValueDoesNotMatchPattern if the default value doesn't match the given pattern, using the C++ throw mechanism. However, this exception is only generated <em>after</em> the entry has been created; if you have code where no sensible default value for a parameter is possible, you can then catch and ignore this exception.</p>
<dl class="section note"><dt>Note</dt><dd>An entry can be declared more than once without generating an error, for example to override an earlier default value. </dd></dl>

</div>
</div>
<a class="anchor" id="af29c20cde6d44186806d559beb468696"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::enter_subsection </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>subsection</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enter a subsection; if not yet existent, declare it. </p>

</div>
</div>
<a class="anchor" id="a5d33f859364fc8730c939c0c36ee544c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ParameterHandler::leave_subsection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Leave present subsection. Return <code>false</code> if there is no subsection to leave; <code>true</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a7589d0ed2a7e70532853e1e378130c88"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ParameterHandler::get </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry_string</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return value of entry <code>entry_string</code>. If the entry was changed, then the changed value is returned, otherwise the default value. If the value of an undeclared entry is required, an exception will be thrown. </p>

</div>
</div>
<a class="anchor" id="a5315d2dfbf7223851805e9432c92b2be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long <a class="el" href="classint.html">int</a> ParameterHandler::get_integer </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry_string</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return value of entry <code>entry_string</code> as <code>long int</code>. (A long int is chosen so that even very large unsigned values can be returned by this function). </p>

</div>
</div>
<a class="anchor" id="a3218c50fa6386b6791a5096ec1e37620"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> ParameterHandler::get_double </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return value of entry <code>entry_name</code> as <code>double</code>. </p>

</div>
</div>
<a class="anchor" id="a5b3601d0dee839d1c732146c0ed8f5bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ParameterHandler::get_bool </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return value of entry <code>entry_name</code> as <code>bool</code>. The entry may be "true" or "yes" for <code>true</code>, "false" or "no" for <code>false</code> respectively. </p>

</div>
</div>
<a class="anchor" id="aa6418ea655b1b550b9dcf63513030196"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::set </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>new_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change the value presently stored for <code>entry_name</code> to the one given in the second argument.</p>
<p>The parameter must already exist in the present subsection.</p>
<p>The function throws an exception of type ExcValueDoesNotMatchPattern if the new value does not conform to the pattern for this entry. </p>

</div>
</div>
<a class="anchor" id="af288e1fe38ac1a1baf1cef3058b63ce1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::set </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>new_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above, but an overload where the second argument is a character pointer. This is necessary, since otherwise the call to <code>set("abc","def")</code> will be mapped to the function taking one string and a bool as arguments, which is certainly not what is most often intended.</p>
<p>The function throws an exception of type ExcValueDoesNotMatchPattern if the new value does not conform to the pattern for this entry. </p>

</div>
</div>
<a class="anchor" id="aabb43df4f2325707a82201071793e4fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::set </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long <a class="el" href="classint.html">int</a> &amp;&#160;</td>
          <td class="paramname"><em>new_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change the value presently stored for <code>entry_name</code> to the one given in the second argument.</p>
<p>The parameter must already exist in the present subsection.</p>
<p>The function throws an exception of type ExcValueDoesNotMatchPattern if the new value does not conform to the pattern for this entry. </p>

</div>
</div>
<a class="anchor" id="a03d8a002b574cb451240ecf723ab0fa8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::set </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a> &amp;&#160;</td>
          <td class="paramname"><em>new_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change the value presently stored for <code>entry_name</code> to the one given in the second argument.</p>
<p>The parameter must already exist in the present subsection.</p>
<p>For internal purposes, the new value needs to be converted to a string. This is done using 16 digits of accuracy, so the set value and the one you can get back out using <a class="el" href="classParameterHandler.html#a3218c50fa6386b6791a5096ec1e37620">get_double()</a> may differ in the 16th digit.</p>
<p>The function throws an exception of type ExcValueDoesNotMatchPattern if the new value does not conform to the pattern for this entry. </p>

</div>
</div>
<a class="anchor" id="adcee5b1f5f7c6745e8c7b66dcf34104d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::set </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a> &amp;&#160;</td>
          <td class="paramname"><em>new_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change the value presently stored for <code>entry_name</code> to the one given in the second argument.</p>
<p>The parameter must already exist in the present subsection.</p>
<p>The function throws an exception of type ExcValueDoesNotMatchPattern if the new value does not conform to the pattern for this entry. </p>

</div>
</div>
<a class="anchor" id="a9d977f31bfae8a9adb84dbaf35f389ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; ParameterHandler::print_parameters </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827">OutputStyle</a>&#160;</td>
          <td class="paramname"><em>style</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print all parameters with the given style to <code>out</code>. Presently only <code>Text</code> and <code>LaTeX</code> are implemented.</p>
<p>In <code>Text</code> format, the output is formatted in such a way that it is possible to use it for later input again. This is most useful to record the parameters for a specific run, since if you output the parameters using this function into a log file, you can always recover the results by simply copying the output to your input file.</p>
<p>Besides the name and value of each entry, the output also contains the default value of entries if it is different from the actual value, as well as the documenting string given to the <a class="el" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry()</a> function if available.</p>
<p>In <code>Text</code> format, the output contains the same information but in a format so that the resulting file can be input into a latex document such as a manual for the code for which this object handles run-time parameters. The various sections of parameters are then represented by latex section and subsection commands as well as by nested enumerations.</p>
<p>In addition, all parameter names are listed with <code>\index</code> statements in two indices called <code>prmindex</code> (where the name of each parameter is listed in the index) and <code>prmindexfull</code> where parameter names are listed sorted by the section in which they exist. By default, the LaTeX program ignores these <code>\index</code> commands, but they can be used to generate an index by using the following commands in the preamble of the latex file : </p>
<div class="fragment"><div class="line">\usepackage{imakeidx}</div>
<div class="line">\makeindex[name=prmindex, title=Index of <a class="code" href="namespaceWorkStream.html#ada9b641abb30c50ad0872eda1a702ee3">run</a>-time parameter <a class="code" href="classParameterHandler.html#ae85ddc962678f3fd4f98c1f98d2259f7">entries</a>]</div>
<div class="line">\makeindex[name=prmindexfull, title=Index of <a class="code" href="namespaceWorkStream.html#ada9b641abb30c50ad0872eda1a702ee3">run</a>-time parameters with section names]</div>
</div><!-- fragment --><p> and at the end of the file this: </p>
<div class="fragment"><div class="line">\printindex[prmindex]</div>
<div class="line">\printindex[prmindexfull]</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a3f6ee701c5188a938b7313bf3997965a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::print_parameters_section </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827">OutputStyle</a>&#160;</td>
          <td class="paramname"><em>style</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>indent_level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print out the parameters of the present subsection as given by the <code>subsection_path</code> member variable. This variable is controlled by entering and leaving subsections through the <a class="el" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection()</a> and <a class="el" href="classParameterHandler.html#a5d33f859364fc8730c939c0c36ee544c">leave_subsection()</a> functions.</p>
<p>In most cases, you will not want to use this function directly, but have it called recursively by the previous function. </p>

</div>
</div>
<a class="anchor" id="af2f4db3ea6cd9414cc39d926a0a0959e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::log_parameters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLogStream.html">LogStream</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print parameters to a logstream. This function allows to print all parameters into a log-file. Sections will be indented in the usual log-file style. </p>

</div>
</div>
<a class="anchor" id="ade326782f2aca595c273f3674294bb1e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::log_parameters_section </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLogStream.html">LogStream</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Log parameters in the present subsection. The subsection is determined by the <code>subsection_path</code> member variable. This variable is controlled by entering and leaving subsections through the <a class="el" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection()</a> and <a class="el" href="classParameterHandler.html#a5d33f859364fc8730c939c0c36ee544c">leave_subsection()</a> functions.</p>
<p>In most cases, you will not want to use this function directly, but have it called recursively by the previous function. </p>

</div>
</div>
<a class="anchor" id="a6d0274dd20ec2ee605b5b744328cc02f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t ParameterHandler::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine an estimate for the memory consumption (in bytes) of this object. </p>

</div>
</div>
<a class="anchor" id="aca9aef12ecb4cfb4c8ca55941414698b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::save </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write the data of this object to a stream for the purpose of serialization. </p>

<p>Definition at line <a class="el" href="parameter__handler_8h_source.html#l02395">2395</a> of file <a class="el" href="parameter__handler_8h_source.html">parameter_handler.h</a>.</p>

</div>
</div>
<a class="anchor" id="a09fd2ee6d01b78079f894893aacd6c4c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::load </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read the data of this object from a stream for the purpose of serialization. </p>

<p>Definition at line <a class="el" href="parameter__handler_8h_source.html#l02415">2415</a> of file <a class="el" href="parameter__handler_8h_source.html">parameter_handler.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0a9900ee33c0ec10a3e81b718d43eb46"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ParameterHandler::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParameterHandler.html">ParameterHandler</a> &amp;&#160;</td>
          <td class="paramname"><em>prm2</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test for equality. </p>

</div>
</div>
<a class="anchor" id="a4faae22ecf57fc1e46f1c46dd5dc4e2e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string ParameterHandler::mangle </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Mangle a string so that it doesn't contain any special characters or spaces. </p>

</div>
</div>
<a class="anchor" id="aed61698fd1939a21e0244030e1645d66"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string ParameterHandler::demangle </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unmangle a string into its original form. </p>

</div>
</div>
<a class="anchor" id="ace2d2149f8fb0c377a08d95098d546a1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbool.html">bool</a> ParameterHandler::is_parameter_node </td>
          <td>(</td>
          <td class="paramtype">const boost::property_tree::ptree &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return whether a given node is a parameter node or a subsection node. </p>

</div>
</div>
<a class="anchor" id="a4ed475f8b574291cd1d1000575fd64f4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string ParameterHandler::get_current_path </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the string that identifies the current path into the property tree. This is only a path, i.e. it is not terminated by the path_separator character. </p>

</div>
</div>
<a class="anchor" id="afc471f64604438e32f25b52c9410ed3a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string ParameterHandler::get_current_full_path </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given the name of an entry as argument, the function computes a full path into the parameter tree using the current subsection. </p>

</div>
</div>
<a class="anchor" id="afc2e4082447c1a8106d2db83003637b7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ParameterHandler::scan_line </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input_filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>lineno</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Scan one line of input. <code>input_filename</code> and <code>lineno</code> are the name of the input file and the current number of the line presently scanned (for the logs if there are messages). Return <code>false</code> if line contained stuff that could not be understood, the uppermost subsection was to be left by an <code>END</code> or <code>end</code> statement, a value for a non-declared entry was given or the entry value did not match the regular expression. <code>true</code> otherwise.</p>
<p>The function modifies its argument, but also takes it by value, so the caller's variable is not changed. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a009fb8cb45463ac3a57f8cb371fbc82b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char ParameterHandler::path_separator = '.'</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The separator used when accessing elements of a path into the parameter tree. </p>

<p>Definition at line <a class="el" href="parameter__handler_8h_source.html#l01910">1910</a> of file <a class="el" href="parameter__handler_8h_source.html">parameter_handler.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae85ddc962678f3fd4f98c1f98d2259f7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::auto_ptr&lt;boost::property_tree::ptree&gt; ParameterHandler::entries</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The complete tree of sections and entries. See the general documentation of this class for a description how data is stored in this variable.</p>
<p>The variable is a pointer so that we can use an incomplete type, rather than having to include all of the property_tree stuff from boost. This works around a problem with gcc 4.5. </p>

<p>Definition at line <a class="el" href="parameter__handler_8h_source.html#l01921">1921</a> of file <a class="el" href="parameter__handler_8h_source.html">parameter_handler.h</a>.</p>

</div>
</div>
<a class="anchor" id="a275cc8f9248a9ba91c88b6c14a2f487d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std_cxx1x::shared_ptr&lt;const <a class="el" href="classPatterns_1_1PatternBase.html">Patterns::PatternBase</a>&gt; &gt; ParameterHandler::patterns</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A list of patterns that are used to describe the parameters of this object. The are indexed by nodes in the property tree. </p>

<p>Definition at line <a class="el" href="parameter__handler_8h_source.html#l01927">1927</a> of file <a class="el" href="parameter__handler_8h_source.html">parameter_handler.h</a>.</p>

</div>
</div>
<a class="anchor" id="aefa5b69fc4d1d56dd6bc90e2dcf24d56"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; ParameterHandler::subsection_path</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Path of presently selected subsections; empty list means top level </p>

<p>Definition at line <a class="el" href="parameter__handler_8h_source.html#l01948">1948</a> of file <a class="el" href="parameter__handler_8h_source.html">parameter_handler.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/deal.II/base/<a class="el" href="parameter__handler_8h_source.html">parameter_handler.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jan 27 2014 15:27:20 for The deal.II Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
