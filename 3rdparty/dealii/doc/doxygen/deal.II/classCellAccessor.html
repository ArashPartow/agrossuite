<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>The deal.II Library: CellAccessor&lt; dim, spacedim &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="http://www.dealii.org/deal.ico"></link>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2014 by the deal.II authors"></meta>
<meta name="deal.II-version" content="8.1.0"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 8.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classCellAccessor-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">CellAccessor&lt; dim, spacedim &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__grid.html">Grid classes</a> &#124; <a class="el" href="group__Accessors.html">Accessor classes of the mesh iterators</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="tria__accessor_8h_source.html">tria_accessor.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for CellAccessor&lt; dim, spacedim &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classCellAccessor__inherit__graph.svg" width="308" height="486"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a821bacffe6e9828642c83cf2b2baf13e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; dim, dim, <br class="typebreak"/>
spacedim &gt;::<a class="el" href="classCellAccessor.html#a821bacffe6e9828642c83cf2b2baf13e">AccessorData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a821bacffe6e9828642c83cf2b2baf13e">AccessorData</a></td></tr>
<tr class="separator:a821bacffe6e9828642c83cf2b2baf13e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a014f2d38d74b3c488440ec17637f7abc"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, <br class="typebreak"/>
spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a014f2d38d74b3c488440ec17637f7abc">Container</a></td></tr>
<tr class="separator:a014f2d38d74b3c488440ec17637f7abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classTriaAccessor"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classTriaAccessor')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classTriaAccessor.html">TriaAccessor&lt; dim, dim, spacedim &gt;</a></td></tr>
<tr class="memitem:a02b6af5fc6c46ea424a1dc694bd55510 inherit pub_types_classTriaAccessor"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a><br class="typebreak"/>
&lt; structdim, dim, spacedim &gt;<br class="typebreak"/>
::<a class="el" href="classTriaAccessor.html#a02b6af5fc6c46ea424a1dc694bd55510">AccessorData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a02b6af5fc6c46ea424a1dc694bd55510">AccessorData</a></td></tr>
<tr class="separator:a02b6af5fc6c46ea424a1dc694bd55510 inherit pub_types_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classTriaAccessorBase"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classTriaAccessorBase')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase&lt; structdim, dim, spacedim &gt;</a></td></tr>
<tr class="memitem:abac0375b18754b7a204607a5eab72557 inherit pub_types_classTriaAccessorBase"><td class="memItemLeft" align="right" valign="top">typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#abac0375b18754b7a204607a5eab72557">LocalData</a></td></tr>
<tr class="separator:abac0375b18754b7a204607a5eab72557 inherit pub_types_classTriaAccessorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ga7cbda6466751b42b9660eccc8b8fe4a3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7cbda6466751b42b9660eccc8b8fe4a3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DeclException0</b> (ExcRefineCellNotActive)</td></tr>
<tr class="separator:ga7cbda6466751b42b9660eccc8b8fe4a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b1d6d2729d5ab7580aeddad59b29e19"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9b1d6d2729d5ab7580aeddad59b29e19"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DeclException0</b> (ExcCellFlaggedForRefinement)</td></tr>
<tr class="separator:ga9b1d6d2729d5ab7580aeddad59b29e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga797a1f7e7783e76abc85581a4577dc75"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga797a1f7e7783e76abc85581a4577dc75"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DeclException0</b> (ExcCellFlaggedForCoarsening)</td></tr>
<tr class="separator:ga797a1f7e7783e76abc85581a4577dc75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71443a279ed1b182e9bfe84799a8c176"><td class="memTemplParams" colspan="2"><a class="anchor" id="a71443a279ed1b182e9bfe84799a8c176"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a71443a279ed1b182e9bfe84799a8c176"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classinternal_1_1SubfaceCase.html">internal::SubfaceCase</a>&lt; 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>subface_case</b> (const unsigned <a class="el" href="classint.html">int</a>) const</td></tr>
<tr class="separator:a71443a279ed1b182e9bfe84799a8c176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae88de4b5edebdd501791b8f577d19aa3"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae88de4b5edebdd501791b8f577d19aa3"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ae88de4b5edebdd501791b8f577d19aa3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classinternal_1_1SubfaceCase.html">internal::SubfaceCase</a>&lt; 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>subface_case</b> (const unsigned <a class="el" href="classint.html">int</a>) const</td></tr>
<tr class="separator:ae88de4b5edebdd501791b8f577d19aa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d7f81bb7c5e4b9ce1a2cde6ec28c0e9"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4d7f81bb7c5e4b9ce1a2cde6ec28c0e9"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a4d7f81bb7c5e4b9ce1a2cde6ec28c0e9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classinternal_1_1SubfaceCase.html">internal::SubfaceCase</a>&lt; 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>subface_case</b> (const unsigned <a class="el" href="classint.html">int</a>) const</td></tr>
<tr class="separator:a4d7f81bb7c5e4b9ce1a2cde6ec28c0e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab07e1ea70374ac97a1810048b896b8c1"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab07e1ea70374ac97a1810048b896b8c1"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ab07e1ea70374ac97a1810048b896b8c1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classinternal_1_1SubfaceCase.html">internal::SubfaceCase</a>&lt; 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>subface_case</b> (const unsigned <a class="el" href="classint.html">int</a> face_no) const</td></tr>
<tr class="separator:ab07e1ea70374ac97a1810048b896b8c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefaa331ae5d5f5883dcf26b07089fce7"><td class="memTemplParams" colspan="2"><a class="anchor" id="aefaa331ae5d5f5883dcf26b07089fce7"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:aefaa331ae5d5f5883dcf26b07089fce7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classinternal_1_1SubfaceCase.html">internal::SubfaceCase</a>&lt; 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>subface_case</b> (const unsigned <a class="el" href="classint.html">int</a> face_no) const</td></tr>
<tr class="separator:aefaa331ae5d5f5883dcf26b07089fce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aaa026aaf3c252fba6fe7bbb28c3a0e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7aaa026aaf3c252fba6fe7bbb28c3a0e"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a7aaa026aaf3c252fba6fe7bbb28c3a0e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classinternal_1_1SubfaceCase.html">internal::SubfaceCase</a>&lt; 3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>subface_case</b> (const unsigned <a class="el" href="classint.html">int</a> face_no) const</td></tr>
<tr class="separator:a7aaa026aaf3c252fba6fe7bbb28c3a0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors</div></td></tr>
<tr class="memitem:a41aa4117adc0c7beeb75c9169318886d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a41aa4117adc0c7beeb75c9169318886d">CellAccessor</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; *<a class="el" href="classCellAccessor.html#a82776935c066ef643d35589957f51b12">parent</a>=0, const <a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessorBase.html#af4ed097338b3f2bfb64a244aea0731f6">level</a>=-1, const <a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessorBase.html#a3143d5d5b2a83717179b8ac97458cef1">index</a>=-1, const <a class="el" href="classCellAccessor.html#a821bacffe6e9828642c83cf2b2baf13e">AccessorData</a> *local_data=0)</td></tr>
<tr class="separator:a41aa4117adc0c7beeb75c9169318886d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb3fbe765bc2a08b056175f8f52da568"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#acb3fbe765bc2a08b056175f8f52da568">CellAccessor</a> (const <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; dim, dim, spacedim &gt; &amp;cell_accessor)</td></tr>
<tr class="separator:acb3fbe765bc2a08b056175f8f52da568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab34931ab97b3e7c7da47388b30c36707"><td class="memTemplParams" colspan="2">template&lt;int structdim2, int dim2, int spacedim2&gt; </td></tr>
<tr class="memitem:ab34931ab97b3e7c7da47388b30c36707"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#ab34931ab97b3e7c7da47388b30c36707">CellAccessor</a> (const <a class="el" href="classInvalidAccessor.html">InvalidAccessor</a>&lt; structdim2, dim2, spacedim2 &gt; &amp;)</td></tr>
<tr class="separator:ab34931ab97b3e7c7da47388b30c36707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecdfe299bf81ce75210d54e3f47684fb"><td class="memTemplParams" colspan="2">template&lt;int structdim2, int dim2, int spacedim2&gt; </td></tr>
<tr class="memitem:aecdfe299bf81ce75210d54e3f47684fb"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#aecdfe299bf81ce75210d54e3f47684fb">CellAccessor</a> (const <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim2, dim2, spacedim2 &gt; &amp;)</td></tr>
<tr class="separator:aecdfe299bf81ce75210d54e3f47684fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Accessing sub-objects and neighbors</div></td></tr>
<tr class="memitem:a9f9d1c0c186aa6f058a971fcd3f97535"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classCellAccessor.html">CellAccessor</a><br class="typebreak"/>
&lt; dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a9f9d1c0c186aa6f058a971fcd3f97535">child</a> (const unsigned <a class="el" href="classint.html">int</a> i) const </td></tr>
<tr class="separator:a9f9d1c0c186aa6f058a971fcd3f97535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee0d1f11d9d5da38eb8c0ed274ae5e05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a><br class="typebreak"/>
&lt; dim-1, dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#aee0d1f11d9d5da38eb8c0ed274ae5e05">face</a> (const unsigned <a class="el" href="classint.html">int</a> i) const </td></tr>
<tr class="separator:aee0d1f11d9d5da38eb8c0ed274ae5e05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affef1a87503c86cc822202cd5c0e88ae"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#affef1a87503c86cc822202cd5c0e88ae">face_index</a> (const unsigned <a class="el" href="classint.html">int</a> i) const </td></tr>
<tr class="separator:affef1a87503c86cc822202cd5c0e88ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa26f6e55a1f82c1f628dd9b986f034e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classCellAccessor.html">CellAccessor</a><br class="typebreak"/>
&lt; dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#aa26f6e55a1f82c1f628dd9b986f034e2">neighbor_child_on_subface</a> (const unsigned <a class="el" href="classint.html">int</a> face_no, const unsigned <a class="el" href="classint.html">int</a> subface_no) const </td></tr>
<tr class="separator:aa26f6e55a1f82c1f628dd9b986f034e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c6d18e4ccd2a3932f081e2b46ca8fb0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classCellAccessor.html">CellAccessor</a><br class="typebreak"/>
&lt; dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a7c6d18e4ccd2a3932f081e2b46ca8fb0">neighbor</a> (const unsigned <a class="el" href="classint.html">int</a> i) const </td></tr>
<tr class="separator:a7c6d18e4ccd2a3932f081e2b46ca8fb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9e76a1bf339d3a00a8bc74722a0789c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#aa9e76a1bf339d3a00a8bc74722a0789c">neighbor_index</a> (const unsigned <a class="el" href="classint.html">int</a> i) const </td></tr>
<tr class="separator:aa9e76a1bf339d3a00a8bc74722a0789c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7936f671e25c38ee1aca0c3c3b9720d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#ae7936f671e25c38ee1aca0c3c3b9720d">neighbor_level</a> (const unsigned <a class="el" href="classint.html">int</a> i) const </td></tr>
<tr class="separator:ae7936f671e25c38ee1aca0c3c3b9720d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dc63f3a820c03d2c6b5a639efd5332b"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a8dc63f3a820c03d2c6b5a639efd5332b">neighbor_of_neighbor</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classCellAccessor.html#a7c6d18e4ccd2a3932f081e2b46ca8fb0">neighbor</a>) const </td></tr>
<tr class="separator:a8dc63f3a820c03d2c6b5a639efd5332b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a765d17ca49c33204a201b3244afd1ee2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a765d17ca49c33204a201b3244afd1ee2">neighbor_is_coarser</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classCellAccessor.html#a7c6d18e4ccd2a3932f081e2b46ca8fb0">neighbor</a>) const </td></tr>
<tr class="separator:a765d17ca49c33204a201b3244afd1ee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e00a21287e546a21bd5b248b90f753c"><td class="memItemLeft" align="right" valign="top">std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, <br class="typebreak"/>
unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a0e00a21287e546a21bd5b248b90f753c">neighbor_of_coarser_neighbor</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classCellAccessor.html#a7c6d18e4ccd2a3932f081e2b46ca8fb0">neighbor</a>) const </td></tr>
<tr class="separator:a0e00a21287e546a21bd5b248b90f753c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89ec4e1e3b5864a181216a5744572760"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a89ec4e1e3b5864a181216a5744572760">neighbor_face_no</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classCellAccessor.html#a7c6d18e4ccd2a3932f081e2b46ca8fb0">neighbor</a>) const </td></tr>
<tr class="separator:a89ec4e1e3b5864a181216a5744572760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Dealing with boundary indicators</div></td></tr>
<tr class="memitem:a44aae939f6c02eac1471bc57e0d9a284"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a44aae939f6c02eac1471bc57e0d9a284">at_boundary</a> (const unsigned <a class="el" href="classint.html">int</a> i) const </td></tr>
<tr class="separator:a44aae939f6c02eac1471bc57e0d9a284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8492cf95ee8a6e26419836f0ab5074b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a8492cf95ee8a6e26419836f0ab5074b3">at_boundary</a> () const </td></tr>
<tr class="separator:a8492cf95ee8a6e26419836f0ab5074b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6077227e8a9aeb1dcbd3b239d0bc5162"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a6077227e8a9aeb1dcbd3b239d0bc5162">has_boundary_lines</a> () const </td></tr>
<tr class="separator:a6077227e8a9aeb1dcbd3b239d0bc5162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Dealing with refinement indicators</div></td></tr>
<tr class="memitem:a85e7e44eb2422b02a824189a9d9df4b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a85e7e44eb2422b02a824189a9d9df4b4">refine_flag_set</a> () const </td></tr>
<tr class="separator:a85e7e44eb2422b02a824189a9d9df4b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb6cc537720a5b6381c237abe0887de2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#afb6cc537720a5b6381c237abe0887de2">set_refine_flag</a> (const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt; ref_case=<a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt;::isotropic_refinement) const </td></tr>
<tr class="separator:afb6cc537720a5b6381c237abe0887de2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a228db17fdb8956799a36fc10126c9052"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a228db17fdb8956799a36fc10126c9052">clear_refine_flag</a> () const </td></tr>
<tr class="separator:a228db17fdb8956799a36fc10126c9052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad371e93857bd00c58db3b88bbaab3244"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#ad371e93857bd00c58db3b88bbaab3244">flag_for_face_refinement</a> (const unsigned <a class="el" href="classint.html">int</a> face_no, const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim-1 &gt; &amp;face_refinement_case=<a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim-1 &gt;::isotropic_refinement) const </td></tr>
<tr class="separator:ad371e93857bd00c58db3b88bbaab3244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab90c2f90e801e060935c6eb55b093b3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#ab90c2f90e801e060935c6eb55b093b3e">flag_for_line_refinement</a> (const unsigned <a class="el" href="classint.html">int</a> line_no) const </td></tr>
<tr class="separator:ab90c2f90e801e060935c6eb55b093b3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f012b075d81fecabff90b30a206da17"><td class="memItemLeft" align="right" valign="top">::<a class="el" href="classinternal_1_1SubfaceCase.html">internal::SubfaceCase</a>&lt; dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a7f012b075d81fecabff90b30a206da17">subface_case</a> (const unsigned <a class="el" href="classint.html">int</a> face_no) const </td></tr>
<tr class="separator:a7f012b075d81fecabff90b30a206da17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd2a8a1d0ad8d3b2ef47921ef40eb8cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#acd2a8a1d0ad8d3b2ef47921ef40eb8cf">coarsen_flag_set</a> () const </td></tr>
<tr class="separator:acd2a8a1d0ad8d3b2ef47921ef40eb8cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f91caaf437c938b083f8c5c4c46762a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a3f91caaf437c938b083f8c5c4c46762a">set_coarsen_flag</a> () const </td></tr>
<tr class="separator:a3f91caaf437c938b083f8c5c4c46762a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b0357ba56d345d0602883a094624251"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a5b0357ba56d345d0602883a094624251">clear_coarsen_flag</a> () const </td></tr>
<tr class="separator:a5b0357ba56d345d0602883a094624251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Dealing with material indicators</div></td></tr>
<tr class="memitem:a835e03f0bf287e79f0d3a6dfd7dfb8d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetypes.html#a7ec62ce920d2700c16ec6cf457d0c0aa">types::material_id</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a835e03f0bf287e79f0d3a6dfd7dfb8d1">material_id</a> () const </td></tr>
<tr class="separator:a835e03f0bf287e79f0d3a6dfd7dfb8d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe9098e74cd5e1bec7c01abbbf056e13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#abe9098e74cd5e1bec7c01abbbf056e13">set_material_id</a> (const <a class="el" href="namespacetypes.html#a7ec62ce920d2700c16ec6cf457d0c0aa">types::material_id</a> new_material_id) const </td></tr>
<tr class="separator:abe9098e74cd5e1bec7c01abbbf056e13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab01c9bd81b8927366f451a7b5d06adbc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#ab01c9bd81b8927366f451a7b5d06adbc">recursively_set_material_id</a> (const <a class="el" href="namespacetypes.html#a7ec62ce920d2700c16ec6cf457d0c0aa">types::material_id</a> new_material_id) const </td></tr>
<tr class="separator:ab01c9bd81b8927366f451a7b5d06adbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Dealing with subdomain indicators</div></td></tr>
<tr class="memitem:a154d3931d2fb2e477bb383db571ac0f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a154d3931d2fb2e477bb383db571ac0f6">subdomain_id</a> () const </td></tr>
<tr class="separator:a154d3931d2fb2e477bb383db571ac0f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad34738e065d63bd73b138928ccaae349"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#ad34738e065d63bd73b138928ccaae349">set_subdomain_id</a> (const <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a> new_subdomain_id) const </td></tr>
<tr class="separator:ad34738e065d63bd73b138928ccaae349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a603c4ffeb90974fa7be9f5d85a81a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a6a603c4ffeb90974fa7be9f5d85a81a4">level_subdomain_id</a> () const </td></tr>
<tr class="separator:a6a603c4ffeb90974fa7be9f5d85a81a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabcb6cdb81d137af8816324b25119e0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#aabcb6cdb81d137af8816324b25119e0e">set_level_subdomain_id</a> (const <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a> new_level_subdomain_id) const </td></tr>
<tr class="separator:aabcb6cdb81d137af8816324b25119e0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a918b0a731eca5e0b226a025539fe27df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a918b0a731eca5e0b226a025539fe27df">recursively_set_subdomain_id</a> (const <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a> new_subdomain_id) const </td></tr>
<tr class="separator:a918b0a731eca5e0b226a025539fe27df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Dealing with codim 1 cell orientation</div></td></tr>
<tr class="memitem:ae308f879468cfe0ec2a1ecf6a9989780"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#ae308f879468cfe0ec2a1ecf6a9989780">direction_flag</a> () const </td></tr>
<tr class="separator:ae308f879468cfe0ec2a1ecf6a9989780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82776935c066ef643d35589957f51b12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classCellAccessor.html">CellAccessor</a><br class="typebreak"/>
&lt; dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a82776935c066ef643d35589957f51b12">parent</a> () const </td></tr>
<tr class="separator:a82776935c066ef643d35589957f51b12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Other functions</div></td></tr>
<tr class="memitem:a26f61d6c0326fa797fe54fc226a47b46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a26f61d6c0326fa797fe54fc226a47b46">active</a> () const </td></tr>
<tr class="separator:a26f61d6c0326fa797fe54fc226a47b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5af863cdd8aa98eba0c6b7b236ad341"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#aa5af863cdd8aa98eba0c6b7b236ad341">operator&lt;</a> (const <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt; &amp;other) const </td></tr>
<tr class="separator:aa5af863cdd8aa98eba0c6b7b236ad341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa52e84398560d2213ba71909a81150d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#aa52e84398560d2213ba71909a81150d1">is_locally_owned</a> () const </td></tr>
<tr class="separator:aa52e84398560d2213ba71909a81150d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a91fb34cedb34dc424da9be7ca0636c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a7a91fb34cedb34dc424da9be7ca0636c">is_locally_owned_on_level</a> () const </td></tr>
<tr class="separator:a7a91fb34cedb34dc424da9be7ca0636c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d32a7f84929bd9fa9c63fd2493b4aca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a5d32a7f84929bd9fa9c63fd2493b4aca">is_ghost</a> () const </td></tr>
<tr class="separator:a5d32a7f84929bd9fa9c63fd2493b4aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e198ed6a73bec070efdf54ce1df44ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a5e198ed6a73bec070efdf54ce1df44ca">is_artificial</a> () const </td></tr>
<tr class="separator:a5e198ed6a73bec070efdf54ce1df44ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8040afbac0d008be53c59f1bfbda785"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#aa8040afbac0d008be53c59f1bfbda785">point_inside</a> (const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p) const </td></tr>
<tr class="separator:aa8040afbac0d008be53c59f1bfbda785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a540d948a5a96c649695509a377ea30fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a540d948a5a96c649695509a377ea30fa">set_neighbor</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt; &gt; &amp;pointer) const </td></tr>
<tr class="separator:a540d948a5a96c649695509a377ea30fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a109cd0c706db7ff75f8db6f0e3a1f213"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCellId.html">CellId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a109cd0c706db7ff75f8db6f0e3a1f213">id</a> () const </td></tr>
<tr class="separator:a109cd0c706db7ff75f8db6f0e3a1f213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classTriaAccessor"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classTriaAccessor')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classTriaAccessor.html">TriaAccessor&lt; dim, dim, spacedim &gt;</a></td></tr>
<tr class="memitem:aefba7851f798b49f846872d5b4eb7547 inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#aefba7851f798b49f846872d5b4eb7547">TriaAccessor</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; *parent=0, const <a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessorBase.html#af4ed097338b3f2bfb64a244aea0731f6">level</a>=-1, const <a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessorBase.html#a3143d5d5b2a83717179b8ac97458cef1">index</a>=-1, const <a class="el" href="classTriaAccessor.html#a02b6af5fc6c46ea424a1dc694bd55510">AccessorData</a> *local_data=0)</td></tr>
<tr class="separator:aefba7851f798b49f846872d5b4eb7547 inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaf81fa90cc1506bbdf6a54fb0626985 inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#aeaf81fa90cc1506bbdf6a54fb0626985">TriaAccessor</a> (const <a class="el" href="classInvalidAccessor.html">InvalidAccessor</a>&lt; structdim2, dim2, spacedim2 &gt; &amp;)</td></tr>
<tr class="separator:aeaf81fa90cc1506bbdf6a54fb0626985 inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a397500f10867aa69f4a731cc9ab2de53 inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a397500f10867aa69f4a731cc9ab2de53">TriaAccessor</a> (const <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim2, dim2, spacedim2 &gt; &amp;)</td></tr>
<tr class="separator:a397500f10867aa69f4a731cc9ab2de53 inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae77ca9e315c8b3ced5047fa003e53f9c inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#ae77ca9e315c8b3ced5047fa003e53f9c">used</a> () const</td></tr>
<tr class="separator:ae77ca9e315c8b3ced5047fa003e53f9c inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ad8bd5cf3d4612babdac366b8aa8044 inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a3ad8bd5cf3d4612babdac366b8aa8044">parent_index</a> () const</td></tr>
<tr class="separator:a3ad8bd5cf3d4612babdac366b8aa8044 inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac05e9b672f17aad71aac5665d24d7d9 inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#aac05e9b672f17aad71aac5665d24d7d9">vertex_index</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:aac05e9b672f17aad71aac5665d24d7d9 inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a690c9ecb258b76cae4ca81d77969792e inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a690c9ecb258b76cae4ca81d77969792e">vertex</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:a690c9ecb258b76cae4ca81d77969792e inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd90d433e36c48e5a9d180b119f84837 inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top">typename::internal::Triangulation::Iterators<br class="typebreak"/>
&lt; dim, spacedim &gt;<br class="typebreak"/>
::line_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#acd90d433e36c48e5a9d180b119f84837">line</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:acd90d433e36c48e5a9d180b119f84837 inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8803faab60566e0987a35f92dd561a41 inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a8803faab60566e0987a35f92dd561a41">line_index</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:a8803faab60566e0987a35f92dd561a41 inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0a711f491aa93ea68d30d1f61968750 inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top">typename::internal::Triangulation::Iterators<br class="typebreak"/>
&lt; dim, spacedim &gt;<br class="typebreak"/>
::quad_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#af0a711f491aa93ea68d30d1f61968750">quad</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:af0a711f491aa93ea68d30d1f61968750 inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf9a377d2830f7541093086e1fac7652 inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#aaf9a377d2830f7541093086e1fac7652">quad_index</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:aaf9a377d2830f7541093086e1fac7652 inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cb078eecb57a81994757c7b6c3fdadc inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a6cb078eecb57a81994757c7b6c3fdadc">face_orientation</a> (const unsigned <a class="el" href="classint.html">int</a> face) const</td></tr>
<tr class="separator:a6cb078eecb57a81994757c7b6c3fdadc inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb1e8fb2baf9b1cd14f96b42c051e216 inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#afb1e8fb2baf9b1cd14f96b42c051e216">face_flip</a> (const unsigned <a class="el" href="classint.html">int</a> face) const</td></tr>
<tr class="separator:afb1e8fb2baf9b1cd14f96b42c051e216 inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1944a988428c509ca60d5089dc24ff8 inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#ab1944a988428c509ca60d5089dc24ff8">face_rotation</a> (const unsigned <a class="el" href="classint.html">int</a> face) const</td></tr>
<tr class="separator:ab1944a988428c509ca60d5089dc24ff8 inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdb3ff0f10fe8ee4bb28264dcaa945a7 inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#afdb3ff0f10fe8ee4bb28264dcaa945a7">line_orientation</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessor.html#acd90d433e36c48e5a9d180b119f84837">line</a>) const</td></tr>
<tr class="separator:afdb3ff0f10fe8ee4bb28264dcaa945a7 inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9ddde02b2826ec339ac75933de81948 inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#ac9ddde02b2826ec339ac75933de81948">has_children</a> () const</td></tr>
<tr class="separator:ac9ddde02b2826ec339ac75933de81948 inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace83dea38aded05d86947bed48b75360 inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#ace83dea38aded05d86947bed48b75360">n_children</a> () const</td></tr>
<tr class="separator:ace83dea38aded05d86947bed48b75360 inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a447edf9ba02a500a9c0eb832d2d545e0 inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a447edf9ba02a500a9c0eb832d2d545e0">number_of_children</a> () const</td></tr>
<tr class="separator:a447edf9ba02a500a9c0eb832d2d545e0 inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94dd005ad1f1ad6e39de59361ba8f667 inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a94dd005ad1f1ad6e39de59361ba8f667">max_refinement_depth</a> () const</td></tr>
<tr class="separator:a94dd005ad1f1ad6e39de59361ba8f667 inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d414ec8758c8e7337472034f9385717 inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a><br class="typebreak"/>
&lt; structdim, dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a9d414ec8758c8e7337472034f9385717">child</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:a9d414ec8758c8e7337472034f9385717 inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e322ef114ff44b871cfe2835efca4b2 inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a><br class="typebreak"/>
&lt; structdim, dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a8e322ef114ff44b871cfe2835efca4b2">isotropic_child</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:a8e322ef114ff44b871cfe2835efca4b2 inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c25426284f2b65b0579a0261f30345e inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; structdim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a3c25426284f2b65b0579a0261f30345e">refinement_case</a> () const</td></tr>
<tr class="separator:a3c25426284f2b65b0579a0261f30345e inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7a02bab2d41196295c969db135959ec inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#ab7a02bab2d41196295c969db135959ec">child_index</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:ab7a02bab2d41196295c969db135959ec inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fde62fa0bfac71ee49708692662ddbc inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a6fde62fa0bfac71ee49708692662ddbc">isotropic_child_index</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:a6fde62fa0bfac71ee49708692662ddbc inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a675e7545c66f35f80fdc113cdcf1a632 inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a675e7545c66f35f80fdc113cdcf1a632">boundary_indicator</a> () const</td></tr>
<tr class="separator:a675e7545c66f35f80fdc113cdcf1a632 inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d873908eff8fd51e88be26e51ab5f88 inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga0d873908eff8fd51e88be26e51ab5f88">set_boundary_indicator</a> (const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>) const</td></tr>
<tr class="separator:ga0d873908eff8fd51e88be26e51ab5f88 inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6a1193fe49dddcf65e927641fbc375b inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#gac6a1193fe49dddcf65e927641fbc375b">set_all_boundary_indicators</a> (const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>) const</td></tr>
<tr class="separator:gac6a1193fe49dddcf65e927641fbc375b inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74489073a62342aefcd4c9d378a6e443 inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a74489073a62342aefcd4c9d378a6e443">at_boundary</a> () const</td></tr>
<tr class="separator:a74489073a62342aefcd4c9d378a6e443 inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdc35726ed0492fb093678021e0c7d88 inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classBoundary.html">Boundary</a>&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#acdc35726ed0492fb093678021e0c7d88">get_boundary</a> () const</td></tr>
<tr class="separator:acdc35726ed0492fb093678021e0c7d88 inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9ef866aec5e6379a5dcdefca004f00d inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#aa9ef866aec5e6379a5dcdefca004f00d">user_flag_set</a> () const</td></tr>
<tr class="separator:aa9ef866aec5e6379a5dcdefca004f00d inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc31875bee0375871f29e4d027778726 inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#adc31875bee0375871f29e4d027778726">set_user_flag</a> () const</td></tr>
<tr class="separator:adc31875bee0375871f29e4d027778726 inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a450af9433206c2e41973416b8dca5729 inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a450af9433206c2e41973416b8dca5729">clear_user_flag</a> () const</td></tr>
<tr class="separator:a450af9433206c2e41973416b8dca5729 inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7e9625e2697889b2068413a0b0f29fc inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#ad7e9625e2697889b2068413a0b0f29fc">recursively_set_user_flag</a> () const</td></tr>
<tr class="separator:ad7e9625e2697889b2068413a0b0f29fc inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1b699a816048773a02711b4ea5f1428 inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#ae1b699a816048773a02711b4ea5f1428">recursively_clear_user_flag</a> () const</td></tr>
<tr class="separator:ae1b699a816048773a02711b4ea5f1428 inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85307aa7d549b9b14a18c08ac51c64f4 inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a85307aa7d549b9b14a18c08ac51c64f4">clear_user_data</a> () const</td></tr>
<tr class="separator:a85307aa7d549b9b14a18c08ac51c64f4 inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ea4e3d51d96d3c45e7fcd229cf4443d inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a3ea4e3d51d96d3c45e7fcd229cf4443d">set_user_pointer</a> (void *p) const</td></tr>
<tr class="separator:a3ea4e3d51d96d3c45e7fcd229cf4443d inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0d99593ba52f944ee000567d2a787b2 inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#af0d99593ba52f944ee000567d2a787b2">clear_user_pointer</a> () const</td></tr>
<tr class="separator:af0d99593ba52f944ee000567d2a787b2 inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c0ce458171d13d49ab7d8d1ec2564f0 inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a9c0ce458171d13d49ab7d8d1ec2564f0">user_pointer</a> () const</td></tr>
<tr class="separator:a9c0ce458171d13d49ab7d8d1ec2564f0 inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45cea1cfbf37dc7d96e28a263812e34b inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a45cea1cfbf37dc7d96e28a263812e34b">recursively_set_user_pointer</a> (void *p) const</td></tr>
<tr class="separator:a45cea1cfbf37dc7d96e28a263812e34b inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80cf6c7a0d67ca812f59df398725762b inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a80cf6c7a0d67ca812f59df398725762b">recursively_clear_user_pointer</a> () const</td></tr>
<tr class="separator:a80cf6c7a0d67ca812f59df398725762b inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05a980fd7ad40aeb25307b845cc8de41 inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a05a980fd7ad40aeb25307b845cc8de41">set_user_index</a> (const unsigned <a class="el" href="classint.html">int</a> p) const</td></tr>
<tr class="separator:a05a980fd7ad40aeb25307b845cc8de41 inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fcf1df0cea96e56f1f1bd0e36952a6a inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a4fcf1df0cea96e56f1f1bd0e36952a6a">clear_user_index</a> () const</td></tr>
<tr class="separator:a4fcf1df0cea96e56f1f1bd0e36952a6a inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a532f03a3139203fe80724ca69dd6b031 inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a532f03a3139203fe80724ca69dd6b031">user_index</a> () const</td></tr>
<tr class="separator:a532f03a3139203fe80724ca69dd6b031 inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3269b79055787f7881d8e970bb1f38d inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#ab3269b79055787f7881d8e970bb1f38d">recursively_set_user_index</a> (const unsigned <a class="el" href="classint.html">int</a> p) const</td></tr>
<tr class="separator:ab3269b79055787f7881d8e970bb1f38d inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affbcdc1d37067c21bba11383d3131e91 inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#affbcdc1d37067c21bba11383d3131e91">recursively_clear_user_index</a> () const</td></tr>
<tr class="separator:affbcdc1d37067c21bba11383d3131e91 inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46f3c5bc796657168a0a9e884e8eb3de inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a46f3c5bc796657168a0a9e884e8eb3de">diameter</a> () const</td></tr>
<tr class="separator:a46f3c5bc796657168a0a9e884e8eb3de inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5ad148d9d4daae2fb51065c8e1f1650 inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#af5ad148d9d4daae2fb51065c8e1f1650">extent_in_direction</a> (const unsigned <a class="el" href="classint.html">int</a> axis) const</td></tr>
<tr class="separator:af5ad148d9d4daae2fb51065c8e1f1650 inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a5249641294ea5b969027871240efca inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a0a5249641294ea5b969027871240efca">minimum_vertex_distance</a> () const</td></tr>
<tr class="separator:a0a5249641294ea5b969027871240efca inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad997b544e169f0cc3288aa6f5e20880d inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#ad997b544e169f0cc3288aa6f5e20880d">center</a> () const</td></tr>
<tr class="separator:ad997b544e169f0cc3288aa6f5e20880d inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ff7254e304eff585eb8bb4435ab0da5 inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a7ff7254e304eff585eb8bb4435ab0da5">barycenter</a> () const</td></tr>
<tr class="separator:a7ff7254e304eff585eb8bb4435ab0da5 inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b30ad1f163241e360ce7d93ca0a32d8 inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a2b30ad1f163241e360ce7d93ca0a32d8">measure</a> () const</td></tr>
<tr class="separator:a2b30ad1f163241e360ce7d93ca0a32d8 inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ff5068315fda48956c4bc347c2329bf inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a5ff5068315fda48956c4bc347c2329bf">is_translation_of</a> (const <a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt; &gt; &amp;o) const</td></tr>
<tr class="separator:a5ff5068315fda48956c4bc347c2329bf inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classTriaAccessorBase"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classTriaAccessorBase')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase&lt; structdim, dim, spacedim &gt;</a></td></tr>
<tr class="memitem:af4ed097338b3f2bfb64a244aea0731f6 inherit pub_methods_classTriaAccessorBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#af4ed097338b3f2bfb64a244aea0731f6">level</a> () const</td></tr>
<tr class="separator:af4ed097338b3f2bfb64a244aea0731f6 inherit pub_methods_classTriaAccessorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3143d5d5b2a83717179b8ac97458cef1 inherit pub_methods_classTriaAccessorBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a3143d5d5b2a83717179b8ac97458cef1">index</a> () const</td></tr>
<tr class="separator:a3143d5d5b2a83717179b8ac97458cef1 inherit pub_methods_classTriaAccessorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a957c6410e9d99a54641b7df806cd09cb inherit pub_methods_classTriaAccessorBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceIteratorState.html#a4e92f4a9d339ff987cc3eb5b0a1ac507">IteratorState::IteratorStates</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a957c6410e9d99a54641b7df806cd09cb">state</a> () const</td></tr>
<tr class="separator:a957c6410e9d99a54641b7df806cd09cb inherit pub_methods_classTriaAccessorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c901a95e677434e7e978c997d3597b9 inherit pub_methods_classTriaAccessorBase"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, <br class="typebreak"/>
spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a3c901a95e677434e7e978c997d3597b9">get_triangulation</a> () const</td></tr>
<tr class="separator:a3c901a95e677434e7e978c997d3597b9 inherit pub_methods_classTriaAccessorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aaa9ed640c41c76419f15cca3dd6d482f"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#aaa9ed640c41c76419f15cca3dd6d482f">neighbor_of_neighbor_internal</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classCellAccessor.html#a7c6d18e4ccd2a3932f081e2b46ca8fb0">neighbor</a>) const </td></tr>
<tr class="separator:aaa9ed640c41c76419f15cca3dd6d482f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d238b428b85e843a13ec90bf1e4c22c"><td class="memTemplParams" colspan="2">template&lt;int dim_, int spacedim_&gt; </td></tr>
<tr class="memitem:a9d238b428b85e843a13ec90bf1e4c22c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a9d238b428b85e843a13ec90bf1e4c22c">point_inside_codim</a> (const <a class="el" href="classPoint.html">Point</a>&lt; spacedim_ &gt; &amp;p) const </td></tr>
<tr class="separator:a9d238b428b85e843a13ec90bf1e4c22c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classTriaAccessorBase"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classTriaAccessorBase')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase&lt; structdim, dim, spacedim &gt;</a></td></tr>
<tr class="memitem:a387785fb43f984834ca832a5c2220a47 inherit pro_methods_classTriaAccessorBase"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a387785fb43f984834ca832a5c2220a47">TriaAccessorBase</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; *parent=0, const <a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessorBase.html#af4ed097338b3f2bfb64a244aea0731f6">level</a>=-1, const <a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessorBase.html#a3143d5d5b2a83717179b8ac97458cef1">index</a>=-1, const <a class="el" href="classTriaAccessorBase.html#a128cc1347bb71169ed219f0ab02ef6c7">AccessorData</a> *=0)</td></tr>
<tr class="separator:a387785fb43f984834ca832a5c2220a47 inherit pro_methods_classTriaAccessorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a4886931412b07810633bea245faf3f inherit pro_methods_classTriaAccessorBase"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a9a4886931412b07810633bea245faf3f">TriaAccessorBase</a> (const <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a> &amp;)</td></tr>
<tr class="separator:a9a4886931412b07810633bea245faf3f inherit pro_methods_classTriaAccessorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8528ff8dd913f697569d667ea55792fc inherit pro_methods_classTriaAccessorBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a8528ff8dd913f697569d667ea55792fc">copy_from</a> (const <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a> &amp;)</td></tr>
<tr class="separator:a8528ff8dd913f697569d667ea55792fc inherit pro_methods_classTriaAccessorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8de03cb84fa56ed0f7570d404a280045 inherit pro_methods_classTriaAccessorBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a8de03cb84fa56ed0f7570d404a280045">operator=</a> (const <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a> &amp;)</td></tr>
<tr class="separator:a8de03cb84fa56ed0f7570d404a280045 inherit pro_methods_classTriaAccessorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac636033983051b71dd73a66ff2a3711b inherit pro_methods_classTriaAccessorBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#ac636033983051b71dd73a66ff2a3711b">operator=</a> (const <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a> *)</td></tr>
<tr class="separator:ac636033983051b71dd73a66ff2a3711b inherit pro_methods_classTriaAccessorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ac4bbb8734a21160e97c6bfa0af8035 inherit pro_methods_classTriaAccessorBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a8ac4bbb8734a21160e97c6bfa0af8035">operator&lt;</a> (const <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a> &amp;other) const</td></tr>
<tr class="separator:a8ac4bbb8734a21160e97c6bfa0af8035 inherit pro_methods_classTriaAccessorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d700399f7b9cb17a2bad81bac511857 inherit pro_methods_classTriaAccessorBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a5d700399f7b9cb17a2bad81bac511857">operator==</a> (const <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a> &amp;) const</td></tr>
<tr class="separator:a5d700399f7b9cb17a2bad81bac511857 inherit pro_methods_classTriaAccessorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b2dffe88eeaaff0477c57a86bde3eb5 inherit pro_methods_classTriaAccessorBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a5b2dffe88eeaaff0477c57a86bde3eb5">operator!=</a> (const <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a> &amp;) const</td></tr>
<tr class="separator:a5b2dffe88eeaaff0477c57a86bde3eb5 inherit pro_methods_classTriaAccessorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f8499dae82dc55292860c8397f88577 inherit pro_methods_classTriaAccessorBase"><td class="memItemLeft" align="right" valign="top">::<a class="el" href="classinternal_1_1Triangulation_1_1TriaObjects.html">internal::Triangulation::TriaObjects</a><br class="typebreak"/>
&lt;::<a class="el" href="classinternal_1_1Triangulation_1_1TriaObject.html">internal::Triangulation::TriaObject</a><br class="typebreak"/>
&lt; structdim &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a7f8499dae82dc55292860c8397f88577">objects</a> () const</td></tr>
<tr class="separator:a7f8499dae82dc55292860c8397f88577 inherit pro_methods_classTriaAccessorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9e9b62ad7bdc2f06734a42394cb8152 inherit pro_methods_classTriaAccessorBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#af9e9b62ad7bdc2f06734a42394cb8152">operator++</a> ()</td></tr>
<tr class="separator:af9e9b62ad7bdc2f06734a42394cb8152 inherit pro_methods_classTriaAccessorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f79706320c4ea24baffc35ecc5b54f2 inherit pro_methods_classTriaAccessorBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a6f79706320c4ea24baffc35ecc5b54f2">operator--</a> ()</td></tr>
<tr class="separator:a6f79706320c4ea24baffc35ecc5b54f2 inherit pro_methods_classTriaAccessorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a0251f12c004dd353f06224ba82562687"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a0251f12c004dd353f06224ba82562687">set_direction_flag</a> (const <a class="el" href="classbool.html">bool</a> new_direction_flag) const </td></tr>
<tr class="separator:a0251f12c004dd353f06224ba82562687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb4f085f243b833b2d99cb97f649038d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#abb4f085f243b833b2d99cb97f649038d">operator=</a> (const <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt; &amp;)</td></tr>
<tr class="separator:abb4f085f243b833b2d99cb97f649038d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:abe9e690d5d7904f804316e15362a2191"><td class="memTemplParams" colspan="2"><a class="anchor" id="abe9e690d5d7904f804316e15362a2191"></a>
template&lt;int , int &gt; </td></tr>
<tr class="memitem:abe9e690d5d7904f804316e15362a2191"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Triangulation</b></td></tr>
<tr class="separator:abe9e690d5d7904f804316e15362a2191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cba6935d1886a01bc644a2301bc8321"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4cba6935d1886a01bc644a2301bc8321"></a>
struct&#160;</td><td class="memItemRight" valign="bottom"><b>::internal::Triangulation::Implementation</b></td></tr>
<tr class="separator:a4cba6935d1886a01bc644a2301bc8321"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_attribs_classTriaAccessorBase"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classTriaAccessorBase')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase&lt; structdim, dim, spacedim &gt;</a></td></tr>
<tr class="memitem:afb869f4fa86da4bbd79f85ccbfa29eba inherit pub_static_attribs_classTriaAccessorBase"><td class="memItemLeft" align="right" valign="top">static const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#afb869f4fa86da4bbd79f85ccbfa29eba">space_dimension</a></td></tr>
<tr class="separator:afb869f4fa86da4bbd79f85ccbfa29eba inherit pub_static_attribs_classTriaAccessorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad36db15ea6d052ad2a1eb09bc932d1e5 inherit pub_static_attribs_classTriaAccessorBase"><td class="memItemLeft" align="right" valign="top">static const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#ad36db15ea6d052ad2a1eb09bc932d1e5">dimension</a></td></tr>
<tr class="separator:ad36db15ea6d052ad2a1eb09bc932d1e5 inherit pub_static_attribs_classTriaAccessorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84324a684d990408ed5d9d19cf0cf6ed inherit pub_static_attribs_classTriaAccessorBase"><td class="memItemLeft" align="right" valign="top">static const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a84324a684d990408ed5d9d19cf0cf6ed">structure_dimension</a></td></tr>
<tr class="separator:a84324a684d990408ed5d9d19cf0cf6ed inherit pub_static_attribs_classTriaAccessorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_types_classTriaAccessorBase"><td colspan="2" onclick="javascript:toggleInherit('pro_types_classTriaAccessorBase')"><img src="closed.png" alt="-"/>&#160;Protected Types inherited from <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase&lt; structdim, dim, spacedim &gt;</a></td></tr>
<tr class="memitem:a128cc1347bb71169ed219f0ab02ef6c7 inherit pro_types_classTriaAccessorBase"><td class="memItemLeft" align="right" valign="top">typedef void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a128cc1347bb71169ed219f0ab02ef6c7">AccessorData</a></td></tr>
<tr class="separator:a128cc1347bb71169ed219f0ab02ef6c7 inherit pro_types_classTriaAccessorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classTriaAccessorBase"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classTriaAccessorBase')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase&lt; structdim, dim, spacedim &gt;</a></td></tr>
<tr class="memitem:a81a3cdcd97691343465dca8d86a99367 inherit pro_attribs_classTriaAccessorBase"><td class="memItemLeft" align="right" valign="top">typename::internal::TriaAccessor::PresentLevelType<br class="typebreak"/>
&lt; structdim, dim &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a81a3cdcd97691343465dca8d86a99367">present_level</a></td></tr>
<tr class="separator:a81a3cdcd97691343465dca8d86a99367 inherit pro_attribs_classTriaAccessorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a5ea7bb2adb9bba2f5e6d4fbabb5403 inherit pro_attribs_classTriaAccessorBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a9a5ea7bb2adb9bba2f5e6d4fbabb5403">present_index</a></td></tr>
<tr class="separator:a9a5ea7bb2adb9bba2f5e6d4fbabb5403 inherit pro_attribs_classTriaAccessorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c322f16af8170f562cb7f7200a085e5 inherit pro_attribs_classTriaAccessorBase"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, <br class="typebreak"/>
spacedim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a8c322f16af8170f562cb7f7200a085e5">tria</a></td></tr>
<tr class="separator:a8c322f16af8170f562cb7f7200a085e5 inherit pro_attribs_classTriaAccessorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int dim, int spacedim&gt;<br/>
class CellAccessor&lt; dim, spacedim &gt;</h3>

<p>This class allows access to a cell: a line in one dimension, a quad in two dimension, etc.</p>
<p>The following refers to any dimension:</p>
<p>This class allows access to a <code>cell</code>, which is a line in 1D and a quad in 2D. Cells have more functionality than lines or quads by themselves, for example they can be flagged for refinement, they have neighbors, they have the possibility to check whether they are at the boundary etc. This class offers access to all this data.</p>
<dl class="section author"><dt>Author</dt><dd>Wolfgang Bangerth, 1998, 1999, 2000 </dd></dl>

<p>Definition at line <a class="el" href="tria__iterator__selector_8h_source.html#l00025">25</a> of file <a class="el" href="tria__iterator__selector_8h_source.html">tria_iterator_selector.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a821bacffe6e9828642c83cf2b2baf13e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt;dim,dim,spacedim&gt;::<a class="el" href="classCellAccessor.html#a821bacffe6e9828642c83cf2b2baf13e">AccessorData</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::<a class="el" href="classCellAccessor.html#a821bacffe6e9828642c83cf2b2baf13e">AccessorData</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Propagate the AccessorData type into the present class. </p>

<p>Definition at line <a class="el" href="tria__accessor_8h_source.html#l02229">2229</a> of file <a class="el" href="tria__accessor_8h_source.html">tria_accessor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a014f2d38d74b3c488440ec17637f7abc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classTriangulation.html">Triangulation</a>&lt;dim, spacedim&gt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::<a class="el" href="classCellAccessor.html#a014f2d38d74b3c488440ec17637f7abc">Container</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Define the type of the container this is part of. </p>

<p>Definition at line <a class="el" href="tria__accessor_8h_source.html#l02235">2235</a> of file <a class="el" href="tria__accessor_8h_source.html">tria_accessor.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a41aa4117adc0c7beeb75c9169318886d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::<a class="el" href="classCellAccessor.html">CellAccessor</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; *&#160;</td>
          <td class="paramname"><em>parent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCellAccessor.html#a821bacffe6e9828642c83cf2b2baf13e">AccessorData</a> *&#160;</td>
          <td class="paramname"><em>local_data</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor. </p>

<p>Definition at line <a class="el" href="tria__accessor_8templates_8h_source.html#l02469">2469</a> of file <a class="el" href="tria__accessor_8templates_8h_source.html">tria_accessor.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="acb3fbe765bc2a08b056175f8f52da568"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::<a class="el" href="classCellAccessor.html">CellAccessor</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; dim, dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>cell_accessor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy constructor. </p>

<p>Definition at line <a class="el" href="tria__accessor_8templates_8h_source.html#l02481">2481</a> of file <a class="el" href="tria__accessor_8templates_8h_source.html">tria_accessor.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab34931ab97b3e7c7da47388b30c36707"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;int structdim2, int dim2, int spacedim2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::<a class="el" href="classCellAccessor.html">CellAccessor</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classInvalidAccessor.html">InvalidAccessor</a>&lt; structdim2, dim2, spacedim2 &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Conversion constructor. This constructor exists to make certain constructs simpler to write in dimension independent code. For example, it allows assigning a face iterator to a line iterator, an operation that is useful in 2d but doesn't make any sense in 3d. The constructor here exists for the purpose of making the code conform to C++ but it will unconditionally abort; in other words, assigning a face iterator to a line iterator is better put into an if-statement that checks that the dimension is two, and assign to a quad iterator in 3d (an operator that, without this constructor would be illegal if we happen to compile for 2d). </p>

<p>Definition at line <a class="el" href="tria__accessor_8h_source.html#l03169">3169</a> of file <a class="el" href="tria__accessor_8h_source.html">tria_accessor.h</a>.</p>

</div>
</div>
<a class="anchor" id="aecdfe299bf81ce75210d54e3f47684fb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;int structdim2, int dim2, int spacedim2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::<a class="el" href="classCellAccessor.html">CellAccessor</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim2, dim2, spacedim2 &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Another conversion operator between objects that don't make sense, just like the previous one. </p>

<p>Definition at line <a class="el" href="tria__accessor_8h_source.html#l03199">3199</a> of file <a class="el" href="tria__accessor_8h_source.html">tria_accessor.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a9f9d1c0c186aa6f058a971fcd3f97535"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt; &gt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::child </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a pointer to the <code>ith</code> child. Overloaded version which returns a more reasonable iterator class. </p>

<p>Definition at line <a class="el" href="tria__accessor_8templates_8h_source.html#l02887">2887</a> of file <a class="el" href="tria__accessor_8templates_8h_source.html">tria_accessor.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="aee0d1f11d9d5da38eb8c0ed274ae5e05"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; dim-1, dim, spacedim &gt; &gt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::face </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an iterator to the <code>ith</code> face of this cell. </p>

<p>Definition at line <a class="el" href="tria__accessor_8templates_8h_source.html#l02540">2540</a> of file <a class="el" href="tria__accessor_8templates_8h_source.html">tria_accessor.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="affef1a87503c86cc822202cd5c0e88ae"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::face_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the (global) index of the <code>ith</code> face of this cell.</p>
<dl class="section note"><dt>Note</dt><dd>Despite the name, the index returned here is only global in the sense that it is specific to a particular <a class="el" href="classTriangulation.html">Triangulation</a> object or, in the case the triangulation is actually of type <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>, specific to that part of the distributed triangulation stored on the current processor. </dd></dl>

<p>Definition at line <a class="el" href="tria__accessor_8templates_8h_source.html#l02550">2550</a> of file <a class="el" href="tria__accessor_8templates_8h_source.html">tria_accessor.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa26f6e55a1f82c1f628dd9b986f034e2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt;<a class="el" href="classCellAccessor.html">CellAccessor</a>&lt;dim, spacedim&gt; &gt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::neighbor_child_on_subface </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>subface_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an iterator to that cell that neighbors the present cell on the given face and subface number.</p>
<p>To succeed, the present cell must not be further refined, and the neighbor on the given face must be further refined exactly once; the returned cell is then a child of that neighbor.</p>
<p>The function may not be called in 1d, since there we have no subfaces. The implementation of this function is rather straightforward in 2d, by first determining which face of the neighbor cell the present cell is bordering on (this is what the <code>neighbor_of_neighbor</code> function does), and then asking <code>GeometryInfo::child_cell_on_subface</code> for the index of the child.</p>
<p>However, the situation is more complicated in 3d, since there faces may have more than one orientation, and we have to use <code>face_orientation</code>, <code>face_flip</code> and <code>face_rotation</code> for both this and the neighbor cell to figure out which cell we want to have.</p>
<p>This can lead to surprising results: if we are sitting on a cell and are asking for a cell behind subface <code>sf</code>, then this means that we are considering the subface for the face in the natural direction for the present cell. However, if the face as seen from this cell has <code><a class="el" href="classTriaAccessor.html#a6cb078eecb57a81994757c7b6c3fdadc">face_orientation()</a>==false</code>, then the child of the face that separates the present cell from the neighboring cell's child is not necessarily the <code>sf-th</code> child of the face of this cell. This is so because the <code>subface_no</code> on a cell corresponds to the subface with respect to the intrinsic ordering of the present cell, whereas children of face iterators are computed with respect to the intrinsic ordering of faces; these two orderings are only identical if the face orientation is <code>true</code>, and reversed otherwise.</p>
<p>Similarly, effects of <code><a class="el" href="classTriaAccessor.html#afb1e8fb2baf9b1cd14f96b42c051e216">face_flip()</a>==true</code> and <code><a class="el" href="classTriaAccessor.html#ab1944a988428c509ca60d5089dc24ff8">face_rotation()</a>==true()</code>, both of which indicate a non-standard face have to be considered.</p>
<p>Fortunately, this is only very rarely of concern, since usually one simply wishes to loop over all finer neighbors at a given face of an active cell. Only in the process of refinement of a <a class="el" href="classTriangulation.html">Triangulation</a> we want to set neighbor information for both our child cells and the neighbor's children. Since we can respect orientation of faces from our current cell in that case, we do NOT respect face_orientation, face_flip and face_rotation of the present cell within this function, i.e. the returned neighbor's child is behind subface <code>subface</code> concerning the intrinsic ordering of the given face. </p>

</div>
</div>
<a class="anchor" id="a7c6d18e4ccd2a3932f081e2b46ca8fb0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt; &gt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::neighbor </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a pointer to the <code>ith</code> neighbor. If the neighbor does not exist, an invalid iterator is returned.</p>
<p><b>Note</b> (cf. TriaLevel&lt;0&gt;): The neighbor of a cell has at most the same level as this cell, i.e. it may or may not be refined. </p>

<p>Definition at line <a class="el" href="tria__accessor_8templates_8h_source.html#l02871">2871</a> of file <a class="el" href="tria__accessor_8templates_8h_source.html">tria_accessor.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa9e76a1bf339d3a00a8bc74722a0789c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::neighbor_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the index of the <code>ith</code> neighbor. If the neighbor does not exist, its index is -1. </p>

<p>Definition at line <a class="el" href="tria__accessor_8templates_8h_source.html#l02575">2575</a> of file <a class="el" href="tria__accessor_8templates_8h_source.html">tria_accessor.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae7936f671e25c38ee1aca0c3c3b9720d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::neighbor_level </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the level of the <code>ith</code> neighbor. If the neighbor does not exist, its level is -1. </p>

<p>Definition at line <a class="el" href="tria__accessor_8templates_8h_source.html#l02587">2587</a> of file <a class="el" href="tria__accessor_8templates_8h_source.html">tria_accessor.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8dc63f3a820c03d2c6b5a639efd5332b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::neighbor_of_neighbor </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>neighbor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the how-many'th neighbor this cell is of <code>cell-&gt;neighbor(neighbor)</code>, i.e. return the <code>face_no</code> such that <code>cell-&gt;neighbor(neighbor)-&gt;neighbor(face_no)==cell</code>. This function is the right one if you want to know how to get back from a neighbor to the present cell.</p>
<p>Note that this operation is only useful if the neighbor is not coarser than the present cell. If the neighbor is coarser this function throws an exception. Use the <code>neighbor_of_coarser_neighbor</code> function in that case. </p>

</div>
</div>
<a class="anchor" id="a765d17ca49c33204a201b3244afd1ee2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::neighbor_is_coarser </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>neighbor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return, whether the neighbor is coarser then the present cell. This is important in case of ansiotropic refinement where this information does not depend on the levels of the cells.</p>
<p>Note, that in an anisotropic setting, a cell can only be coarser than another one at a given face, not on a general basis. The face of the finer cell is contained in the corresponding face of the coarser cell, the finer face is either a child or a grandchild of the coarser face. </p>

</div>
</div>
<a class="anchor" id="a0e00a21287e546a21bd5b248b90f753c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>&gt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::neighbor_of_coarser_neighbor </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>neighbor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is a generalization of the <code>neighbor_of_neighbor</code> function for the case of a coarser neighbor. It returns a pair of numbers, face_no and subface_no, with the following property, if the neighbor is not refined: <code>cell-&gt;neighbor(neighbor)-&gt;neighbor_child_on_subface(face_no,subface_no)==cell</code>. In 3D, a coarser neighbor can still be refined. In that case subface_no denotes the child index of the neighbors face that relates to our face: <code>cell-&gt;neighbor(neighbor)-&gt;face(face_no)-&gt;child(subface_no)==cell-&gt;face(neighbor)</code>. This case in 3d and how it can happen is discussed in the introduction of the <a class="el" href="step_30.html">step-30</a> tutorial program.</p>
<p>This function is impossible for <code>dim==1</code>. </p>

</div>
</div>
<a class="anchor" id="a89ec4e1e3b5864a181216a5744572760"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::neighbor_face_no </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>neighbor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is a generalization of the <code>neighbor_of_neighbor</code> and the <code>neighbor_of_coarser_neighbor</code> functions. It checks whether the neighbor is coarser or not and calls the respective function. In both cases, only the face_no is returned. </p>

<p>Definition at line <a class="el" href="tria__accessor_8templates_8h_source.html#l02994">2994</a> of file <a class="el" href="tria__accessor_8templates_8h_source.html">tria_accessor.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a44aae939f6c02eac1471bc57e0d9a284"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::at_boundary </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether the <code>ith</code> vertex or face (depending on the dimension) is part of the boundary. This is true, if the <code>ith</code> neighbor does not exist. </p>

</div>
</div>
<a class="anchor" id="a8492cf95ee8a6e26419836f0ab5074b3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::at_boundary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether the cell is at the boundary. Being at the boundary is defined by one face being on the boundary. Note that this does not catch cases where only one vertex of a quad or of a hex is at the boundary, or where only one line of a hex is at the boundary while the interiors of all faces are in the interior of the domain. For the latter case, the <code>has_boundary_lines</code> function is the right one to ask. </p>

</div>
</div>
<a class="anchor" id="a6077227e8a9aeb1dcbd3b239d0bc5162"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::has_boundary_lines </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is a slight variation to the <code>at_boundary</code> function: for 1 and 2 dimensions, it is equivalent, for three dimensions it returns whether at least one of the 12 lines of the hexahedron is at a boundary. This, of course, includes the case where a whole face is at the boundary, but also some other cases. </p>

</div>
</div>
<a class="anchor" id="a85e7e44eb2422b02a824189a9d9df4b4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::refine_flag_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the <code>RefinementCase&lt;dim&gt;</code> this cell was flagged to be refined with. </p>

<p>Definition at line <a class="el" href="tria__accessor_8templates_8h_source.html#l02599">2599</a> of file <a class="el" href="tria__accessor_8templates_8h_source.html">tria_accessor.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="afb6cc537720a5b6381c237abe0887de2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::set_refine_flag </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt;&#160;</td>
          <td class="paramname"><em>ref_case</em> = <code><a class="el" href="classRefinementCase.html">RefinementCase</a>&lt;dim&gt;::isotropic_refinement</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Flag the cell pointed to for refinement. This function is only allowed for active cells. </p>

<p>Definition at line <a class="el" href="tria__accessor_8templates_8h_source.html#l02617">2617</a> of file <a class="el" href="tria__accessor_8templates_8h_source.html">tria_accessor.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a228db17fdb8956799a36fc10126c9052"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::clear_refine_flag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clear the refinement flag. </p>

<p>Definition at line <a class="el" href="tria__accessor_8templates_8h_source.html#l02631">2631</a> of file <a class="el" href="tria__accessor_8templates_8h_source.html">tria_accessor.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad371e93857bd00c58db3b88bbaab3244"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::flag_for_face_refinement </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim-1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>face_refinement_case</em> = <code><a class="el" href="classRefinementCase.html">RefinementCase</a>&lt;dim-1&gt;::isotropic_refinement</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Modify the refinement flag of the cell to ensure (at least) the given refinement case <code>face_refinement_case</code> at face <code>face_no</code>, taking into account orientation, flip and rotation of the face. Return, whether the refinement flag had to be modified. This function is only allowed for active cells. </p>

<p>Definition at line <a class="el" href="tria__accessor_8templates_8h_source.html#l02643">2643</a> of file <a class="el" href="tria__accessor_8templates_8h_source.html">tria_accessor.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab90c2f90e801e060935c6eb55b093b3e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::flag_for_line_refinement </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>line_no</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Modify the refinement flag of the cell to ensure that line <code>face_no</code> will be refined. Return, whether the refinement flag had to be modified. This function is only allowed for active cells. </p>

<p>Definition at line <a class="el" href="tria__accessor_8templates_8h_source.html#l02675">2675</a> of file <a class="el" href="tria__accessor_8templates_8h_source.html">tria_accessor.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7f012b075d81fecabff90b30a206da17"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">::<a class="el" href="classinternal_1_1SubfaceCase.html">internal::SubfaceCase</a>&lt;dim&gt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::subface_case </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the SubfaceCase of face <code>face_no</code>. Note that this is not identical to asking <code>cell-&gt;face(face_no)-&gt;<a class="el" href="classTriaAccessor.html#a3c25426284f2b65b0579a0261f30345e">refinement_case()</a></code> since the latter returns a <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt;dim-1&gt; and thus only considers one (anisotropic) refinement, whereas this function considers the complete refinement situation including possible refinement of the face's children. This function may only be called for active cells in 2d and 3d. </p>

</div>
</div>
<a class="anchor" id="acd2a8a1d0ad8d3b2ef47921ef40eb8cf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::coarsen_flag_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return whether the coarsen flag is set or not. </p>

<p>Definition at line <a class="el" href="tria__accessor_8templates_8h_source.html#l02829">2829</a> of file <a class="el" href="tria__accessor_8templates_8h_source.html">tria_accessor.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3f91caaf437c938b083f8c5c4c46762a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::set_coarsen_flag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Flag the cell pointed to for coarsening. This function is only allowed for active cells. </p>

<p>Definition at line <a class="el" href="tria__accessor_8templates_8h_source.html#l02847">2847</a> of file <a class="el" href="tria__accessor_8templates_8h_source.html">tria_accessor.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5b0357ba56d345d0602883a094624251"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::clear_coarsen_flag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clear the coarsen flag. </p>

<p>Definition at line <a class="el" href="tria__accessor_8templates_8h_source.html#l02860">2860</a> of file <a class="el" href="tria__accessor_8templates_8h_source.html">tria_accessor.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a835e03f0bf287e79f0d3a6dfd7dfb8d1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#a7ec62ce920d2700c16ec6cf457d0c0aa">types::material_id</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::material_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the material id of this cell.</p>
<p>For a typical use of this function, see the <a class="el" href="step_28.html">step-28</a> tutorial program.</p>
<p>See the <a class="el" href="DEALGlossary.html#GlossMaterialId">glossary</a> for more information. </p>

</div>
</div>
<a class="anchor" id="abe9098e74cd5e1bec7c01abbbf056e13"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::set_material_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a7ec62ce920d2700c16ec6cf457d0c0aa">types::material_id</a>&#160;</td>
          <td class="paramname"><em>new_material_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the material id of this cell.</p>
<p>For a typical use of this function, see the <a class="el" href="step_28.html">step-28</a> tutorial program.</p>
<p>See the <a class="el" href="DEALGlossary.html#GlossMaterialId">glossary</a> for more information. </p>

</div>
</div>
<a class="anchor" id="ab01c9bd81b8927366f451a7b5d06adbc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::recursively_set_material_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a7ec62ce920d2700c16ec6cf457d0c0aa">types::material_id</a>&#160;</td>
          <td class="paramname"><em>new_material_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the material id of this cell and all its children (and grand-children, and so on) to the given value.</p>
<p>See the <a class="el" href="DEALGlossary.html#GlossMaterialId">glossary</a> for more information. </p>

</div>
</div>
<a class="anchor" id="a154d3931d2fb2e477bb383db571ac0f6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::subdomain_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the subdomain id of this cell.</p>
<p>See the <a class="el" href="DEALGlossary.html#GlossSubdomainId">glossary</a> for more information.</p>
<dl class="section note"><dt>Note</dt><dd>The subdomain of a cell is a property only defined for active cells, i.e., cells that are not further refined. Consequently, you can only call this function if the cell it refers to has no children. For multigrid methods in parallel, it is also important to know which processor owns non-active cells, and for this you can call <a class="el" href="classCellAccessor.html#a6a603c4ffeb90974fa7be9f5d85a81a4">level_subdomain_id()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ad34738e065d63bd73b138928ccaae349"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::set_subdomain_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a>&#160;</td>
          <td class="paramname"><em>new_subdomain_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the subdomain id of this cell.</p>
<p>See the <a class="el" href="DEALGlossary.html#GlossSubdomainId">glossary</a> for more information. This function should not be called if you use a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object.</p>
<dl class="section note"><dt>Note</dt><dd>The subdomain of a cell is a property only defined for active cells, i.e., cells that are not further refined. Consequently, you can only call this function if the cell it refers to has no children. For multigrid methods in parallel, it is also important to know which processor owns non-active cells, and for this you can call <a class="el" href="classCellAccessor.html#a6a603c4ffeb90974fa7be9f5d85a81a4">level_subdomain_id()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a6a603c4ffeb90974fa7be9f5d85a81a4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::level_subdomain_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the level subdomain id of this cell. This is used for parallel multigrid. </p>

</div>
</div>
<a class="anchor" id="aabcb6cdb81d137af8816324b25119e0e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::set_level_subdomain_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a>&#160;</td>
          <td class="paramname"><em>new_level_subdomain_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the level subdomain id of this cell. This is used for parallel multigrid. </p>

</div>
</div>
<a class="anchor" id="a918b0a731eca5e0b226a025539fe27df"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::recursively_set_subdomain_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a>&#160;</td>
          <td class="paramname"><em>new_subdomain_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the subdomain id of this cell (if it is active) or all its terminal children (and grand-children, and so on, as long as they have no children of their own) to the given value. Since the subdomain id is a concept that is only defined for cells that are active (i.e., have no children of their own), this function only sets the subdomain ids for all children and grand children of this cell that are actually active, skipping intermediate child cells.</p>
<p>See the <a class="el" href="DEALGlossary.html#GlossSubdomainId">glossary</a> for more information. This function should not be called if you use a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object since there the subdomain id is implicitly defined by which processor you're on. </p>

</div>
</div>
<a class="anchor" id="ae308f879468cfe0ec2a1ecf6a9989780"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::direction_flag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the orientation of this cell.</p>
<p>For the meaning of this flag, see <a class="el" href="DEALGlossary.html#GlossDirectionFlag">GlossDirectionFlag</a> . </p>

</div>
</div>
<a class="anchor" id="a82776935c066ef643d35589957f51b12"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt;<a class="el" href="classCellAccessor.html">CellAccessor</a>&lt;dim,spacedim&gt; &gt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::parent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an iterator to the parent. Throws an exception if this cell has no parent, i.e. has level 0. </p>

</div>
</div>
<a class="anchor" id="a26f61d6c0326fa797fe54fc226a47b46"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::active </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Test whether the cell has children (this is the criterion for activity of a cell).</p>
<p>See the <a class="el" href="DEALGlossary.html#GlossActive">glossary</a> for more information. </p>

<p>Definition at line <a class="el" href="tria__accessor_8templates_8h_source.html#l02903">2903</a> of file <a class="el" href="tria__accessor_8templates_8h_source.html">tria_accessor.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa5af863cdd8aa98eba0c6b7b236ad341"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Ordering of accessors. This function implements a total ordering of cells even on a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>. This function first compares <a class="el" href="classCellAccessor.html#a6a603c4ffeb90974fa7be9f5d85a81a4">level_subdomain_id()</a>. If these are equal, and both cells are active, it compares <a class="el" href="classCellAccessor.html#a154d3931d2fb2e477bb383db571ac0f6">subdomain_id()</a>. If this is inconclusive, <a class="el" href="classTriaAccessorBase.html#a8ac4bbb8734a21160e97c6bfa0af8035">TriaAccessorBase::operator &lt;</a> () is called. </p>

<p>Definition at line <a class="el" href="tria__accessor_8templates_8h_source.html#l03010">3010</a> of file <a class="el" href="tria__accessor_8templates_8h_source.html">tria_accessor.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa52e84398560d2213ba71909a81150d1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::is_locally_owned </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return whether this cell is owned by the current processor or is owned by another processor. The function always returns true if applied to an object of type <a class="el" href="classTriangulation.html">Triangulation</a>, but may yield false if the triangulation is of type <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>.</p>
<p>See the <a class="el" href="DEALGlossary.html#GlossGhostCell">glossary</a> and the <a class="el" href="group__distributed.html">Parallel computing with multiple processors using distributed memory</a> module for more information.</p>
<dl class="section post"><dt>Postcondition</dt><dd>The returned value is equal to <code>!is_ghost() &amp;&amp; !is_artificial()</code>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Whether a cell is a ghost cell, artificial, or is locally owned or is a property that only pertains to cells that are active. Consequently, you can only call this function if the cell it refers to has no children. </dd></dl>

<p>Definition at line <a class="el" href="tria__accessor_8templates_8h_source.html#l02913">2913</a> of file <a class="el" href="tria__accessor_8templates_8h_source.html">tria_accessor.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7a91fb34cedb34dc424da9be7ca0636c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::is_locally_owned_on_level </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return true if either the <a class="el" href="classTriangulation.html">Triangulation</a> is not distributed or if <a class="el" href="classCellAccessor.html#a6a603c4ffeb90974fa7be9f5d85a81a4">level_subdomain_id()</a> is equal to the id of the current processor. </p>

<p>Definition at line <a class="el" href="tria__accessor_8templates_8h_source.html#l02936">2936</a> of file <a class="el" href="tria__accessor_8templates_8h_source.html">tria_accessor.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5d32a7f84929bd9fa9c63fd2493b4aca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::is_ghost </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return whether this cell exists in the global mesh but (i) is owned by another processor, i.e. has a subdomain_id different from the one the current processor owns and (ii) is adjacent to a cell owned by the current processor.</p>
<p>This function only makes sense if the triangulation used is of kind <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>. In all other cases, the returned value is always false.</p>
<p>See the <a class="el" href="DEALGlossary.html#GlossGhostCell">glossary</a> and the <a class="el" href="group__distributed.html">Parallel computing with multiple processors using distributed memory</a> module for more information.</p>
<dl class="section post"><dt>Postcondition</dt><dd>The returned value is equal to <code>!is_locally_owned() &amp;&amp; !is_artificial()</code>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Whether a cell is a ghost cell, artificial, or is locally owned or is a property that only pertains to cells that are active. Consequently, you can only call this function if the cell it refers to has no children. </dd></dl>

<p>Definition at line <a class="el" href="tria__accessor_8templates_8h_source.html#l02955">2955</a> of file <a class="el" href="tria__accessor_8templates_8h_source.html">tria_accessor.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5e198ed6a73bec070efdf54ce1df44ca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::is_artificial </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return whether this cell is artificial, i.e. it isn't one of the cells owned by the current processor, and it also doesn't border on one. As a consequence, it exists in the mesh to ensure that each processor has all coarse mesh cells and that the 2:1 ratio of neighboring cells is maintained, but it is not one of the cells we should work on on the current processor. In particular, there is no guarantee that this cell isn't, in fact, further refined on one of the other processors.</p>
<p>This function only makes sense if the triangulation used is of kind <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>. In all other cases, the returned value is always false.</p>
<p>See the <a class="el" href="DEALGlossary.html#GlossArtificialCell">glossary</a> and the <a class="el" href="group__distributed.html">Parallel computing with multiple processors using distributed memory</a> module for more information.</p>
<dl class="section post"><dt>Postcondition</dt><dd>The returned value is equal to <code>!is_ghost() &amp;&amp; !is_artificial()</code>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Whether a cell is a ghost cell, artificial, or is locally owned or is a property that only pertains to cells that are active. Consequently, you can only call this function if the cell it refers to has no children. </dd></dl>

<p>Definition at line <a class="el" href="tria__accessor_8templates_8h_source.html#l02979">2979</a> of file <a class="el" href="tria__accessor_8templates_8h_source.html">tria_accessor.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa8040afbac0d008be53c59f1bfbda785"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::point_inside </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test whether the point <code>p</code> is inside this cell. Points on the boundary are counted as being inside the cell.</p>
<p>Note that this function assumes that the mapping between unit cell and real cell is (bi-, tri-)linear, i.e. that faces in 2d and edges in 3d are straight lines. If you have higher order transformations, results may be different as to whether a point is in- or outside the cell in real space.</p>
<p>In case of codim&gt;0, the point is first projected to the manifold where the cell is embedded and then check if this projection is inside the cell. </p>

</div>
</div>
<a class="anchor" id="a540d948a5a96c649695509a377ea30fa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::set_neighbor </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>pointer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the neighbor <code>i</code> of this cell to the cell pointed to by <code>pointer</code>.</p>
<p>This function shouldn't really be public (but needs to for various reasons in order not to make a long list of functions friends): it modifies internal data structures and may leave things. Do not use it from application codes. </p>

</div>
</div>
<a class="anchor" id="a109cd0c706db7ff75f8db6f0e3a1f213"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCellId.html">CellId</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a unique ID for the current cell. This ID is constructed from the path in the hierarchy from the coarse father cell and works correctly in parallel computations.</p>
<p>Note: This operation takes O(log(level)) time. </p>

<p>Definition at line <a class="el" href="tria__accessor_8h_source.html#l03211">3211</a> of file <a class="el" href="tria__accessor_8h_source.html">tria_accessor.h</a>.</p>

</div>
</div>
<a class="anchor" id="aaa9ed640c41c76419f15cca3dd6d482f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::neighbor_of_neighbor_internal </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>neighbor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function assumes that the neighbor is not coarser than the current cell. In this case it returns the <a class="el" href="classCellAccessor.html#a8dc63f3a820c03d2c6b5a639efd5332b">neighbor_of_neighbor()</a> value. If, however, the neighbor is coarser this function returns an <code>invalid_unsigned_int</code>.</p>
<p>This function is not for public use. Use the function <a class="el" href="classCellAccessor.html#a8dc63f3a820c03d2c6b5a639efd5332b">neighbor_of_neighbor()</a> instead which throws an exception if called for a coarser neighbor. If neighbor is indeed coarser (you get to know this by e.g. the <a class="el" href="classCellAccessor.html#a765d17ca49c33204a201b3244afd1ee2">neighbor_is_coarser()</a> function) then the <a class="el" href="classCellAccessor.html#a0e00a21287e546a21bd5b248b90f753c">neighbor_of_coarser_neighbor()</a> function should be call. If you'd like to know only the <code>face_no</code> which is required to get back from the neighbor to the present cell then simply use the <a class="el" href="classCellAccessor.html#a89ec4e1e3b5864a181216a5744572760">neighbor_face_no()</a> function which can be used for coarser as well as noncoarser neighbors. </p>

</div>
</div>
<a class="anchor" id="a9d238b428b85e843a13ec90bf1e4c22c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;int dim_, int spacedim_&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::point_inside_codim </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>As for any codim&gt;0 we can use a similar code and c++ does not allow partial templates. we use this auxiliary function that is then called from point_inside. </p>

</div>
</div>
<a class="anchor" id="a0251f12c004dd353f06224ba82562687"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::set_direction_flag </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>new_direction_flag</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the orientation of this cell.</p>
<p>For the meaning of this flag, see <a class="el" href="DEALGlossary.html#GlossDirectionFlag">GlossDirectionFlag</a> . </p>

</div>
</div>
<a class="anchor" id="abb4f085f243b833b2d99cb97f649038d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy operator. This is normally used in a context like <code>iterator a,b; *a=*b;</code>. Since the meaning is to copy the object pointed to by <code>b</code> to the object pointed to by <code>a</code> and since accessors are not real but virtual objects, this operation is not useful for iterators on triangulations. We declare this function here private, thus it may not be used from outside. Furthermore it is not implemented and will give a linker error if used anyway. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/deal.II/grid/<a class="el" href="tria__iterator__selector_8h_source.html">tria_iterator_selector.h</a></li>
<li>include/deal.II/grid/<a class="el" href="tria__accessor_8h_source.html">tria_accessor.h</a></li>
<li>include/deal.II/grid/<a class="el" href="tria__accessor_8templates_8h_source.html">tria_accessor.templates.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jan 27 2014 15:27:16 for The deal.II Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
