<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>The deal.II Library: MatrixTools Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="http://www.dealii.org/deal.ico"></link>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2014 by the deal.II authors"></meta>
<meta name="deal.II-version" content="8.1.0"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 8.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">MatrixTools Namespace Reference<div class="ingroups"><a class="el" href="group__numerics.html">Numerical algorithms</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a41a069894610445f84840d712d4f891e"><td class="memTemplParams" colspan="2">template&lt;typename number &gt; </td></tr>
<tr class="memitem:a41a069894610445f84840d712d4f891e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMatrixTools.html#a41a069894610445f84840d712d4f891e">apply_boundary_values</a> (const std::map&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>, <a class="el" href="classdouble.html">double</a> &gt; &amp;boundary_values, <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;matrix, <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;solution, <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;right_hand_side, const <a class="el" href="classbool.html">bool</a> eliminate_columns=true)</td></tr>
<tr class="separator:a41a069894610445f84840d712d4f891e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c01e5050670d9db0a0cd17d2c8624aa"><td class="memTemplParams" colspan="2">template&lt;typename number &gt; </td></tr>
<tr class="memitem:a7c01e5050670d9db0a0cd17d2c8624aa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMatrixTools.html#a7c01e5050670d9db0a0cd17d2c8624aa">apply_boundary_values</a> (const std::map&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>, <a class="el" href="classdouble.html">double</a> &gt; &amp;boundary_values, <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt; &amp;matrix, <a class="el" href="classBlockVector.html">BlockVector</a>&lt; number &gt; &amp;solution, <a class="el" href="classBlockVector.html">BlockVector</a>&lt; number &gt; &amp;right_hand_side, const <a class="el" href="classbool.html">bool</a> eliminate_columns=true)</td></tr>
<tr class="separator:a7c01e5050670d9db0a0cd17d2c8624aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a424a5b1a661b3151e4e1f68bbb19c809"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMatrixTools.html#a424a5b1a661b3151e4e1f68bbb19c809">apply_boundary_values</a> (const std::map&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>, <a class="el" href="classdouble.html">double</a> &gt; &amp;boundary_values, <a class="el" href="classPETScWrappers_1_1SparseMatrix.html">PETScWrappers::SparseMatrix</a> &amp;matrix, <a class="el" href="classPETScWrappers_1_1Vector.html">PETScWrappers::Vector</a> &amp;solution, <a class="el" href="classPETScWrappers_1_1Vector.html">PETScWrappers::Vector</a> &amp;right_hand_side, const <a class="el" href="classbool.html">bool</a> eliminate_columns=true)</td></tr>
<tr class="separator:a424a5b1a661b3151e4e1f68bbb19c809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26b81352fcf862218943831dbb38f0a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMatrixTools.html#a26b81352fcf862218943831dbb38f0a0">apply_boundary_values</a> (const std::map&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>, <a class="el" href="classdouble.html">double</a> &gt; &amp;boundary_values, <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">PETScWrappers::MPI::SparseMatrix</a> &amp;matrix, <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> &amp;solution, <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> &amp;right_hand_side, const <a class="el" href="classbool.html">bool</a> eliminate_columns=true)</td></tr>
<tr class="separator:a26b81352fcf862218943831dbb38f0a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44b3ccba089f59cbc3915fe33deaac17"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMatrixTools.html#a44b3ccba089f59cbc3915fe33deaac17">apply_boundary_values</a> (const std::map&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>, <a class="el" href="classdouble.html">double</a> &gt; &amp;boundary_values, <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">PETScWrappers::MPI::SparseMatrix</a> &amp;matrix, <a class="el" href="classPETScWrappers_1_1Vector.html">PETScWrappers::Vector</a> &amp;solution, <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> &amp;right_hand_side, const <a class="el" href="classbool.html">bool</a> eliminate_columns=true)</td></tr>
<tr class="separator:a44b3ccba089f59cbc3915fe33deaac17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a970d07b0c5ee64f0f486d27f7d191772"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMatrixTools.html#a970d07b0c5ee64f0f486d27f7d191772">apply_boundary_values</a> (const std::map&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>, <a class="el" href="classdouble.html">double</a> &gt; &amp;boundary_values, <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html">PETScWrappers::MPI::BlockSparseMatrix</a> &amp;matrix, <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockVector.html">PETScWrappers::MPI::BlockVector</a> &amp;solution, <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockVector.html">PETScWrappers::MPI::BlockVector</a> &amp;right_hand_side, const <a class="el" href="classbool.html">bool</a> eliminate_columns=true)</td></tr>
<tr class="separator:a970d07b0c5ee64f0f486d27f7d191772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02cf546530b1d9b17000c754f7e57ac1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMatrixTools.html#a02cf546530b1d9b17000c754f7e57ac1">apply_boundary_values</a> (const std::map&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>, <a class="el" href="classdouble.html">double</a> &gt; &amp;boundary_values, <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">TrilinosWrappers::SparseMatrix</a> &amp;matrix, <a class="el" href="classTrilinosWrappers_1_1Vector.html">TrilinosWrappers::Vector</a> &amp;solution, <a class="el" href="classTrilinosWrappers_1_1Vector.html">TrilinosWrappers::Vector</a> &amp;right_hand_side, const <a class="el" href="classbool.html">bool</a> eliminate_columns=true)</td></tr>
<tr class="separator:a02cf546530b1d9b17000c754f7e57ac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73fe60abef07bd2dc78f81fb7de947a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMatrixTools.html#a73fe60abef07bd2dc78f81fb7de947a0">apply_boundary_values</a> (const std::map&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>, <a class="el" href="classdouble.html">double</a> &gt; &amp;boundary_values, <a class="el" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> &amp;matrix, <a class="el" href="classTrilinosWrappers_1_1BlockVector.html">TrilinosWrappers::BlockVector</a> &amp;solution, <a class="el" href="classTrilinosWrappers_1_1BlockVector.html">TrilinosWrappers::BlockVector</a> &amp;right_hand_side, const <a class="el" href="classbool.html">bool</a> eliminate_columns=true)</td></tr>
<tr class="separator:a73fe60abef07bd2dc78f81fb7de947a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee2315dbb1df6efc31836b20ea8b4f7e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMatrixTools.html#aee2315dbb1df6efc31836b20ea8b4f7e">apply_boundary_values</a> (const std::map&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>, <a class="el" href="classdouble.html">double</a> &gt; &amp;boundary_values, <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">TrilinosWrappers::SparseMatrix</a> &amp;matrix, <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> &amp;solution, <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> &amp;right_hand_side, const <a class="el" href="classbool.html">bool</a> eliminate_columns=true)</td></tr>
<tr class="separator:aee2315dbb1df6efc31836b20ea8b4f7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac18236b061ae92dae42f5491865536f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMatrixTools.html#ac18236b061ae92dae42f5491865536f8">apply_boundary_values</a> (const std::map&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>, <a class="el" href="classdouble.html">double</a> &gt; &amp;boundary_values, <a class="el" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> &amp;matrix, <a class="el" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> &amp;solution, <a class="el" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> &amp;right_hand_side, const <a class="el" href="classbool.html">bool</a> eliminate_columns=true)</td></tr>
<tr class="separator:ac18236b061ae92dae42f5491865536f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4da987e01ca7fe9e70e60be5b5a6bce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMatrixTools.html#ae4da987e01ca7fe9e70e60be5b5a6bce">local_apply_boundary_values</a> (const std::map&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>, <a class="el" href="classdouble.html">double</a> &gt; &amp;boundary_values, const std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;local_dof_indices, <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;local_matrix, <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;local_rhs, const <a class="el" href="classbool.html">bool</a> eliminate_columns)</td></tr>
<tr class="separator:ae4da987e01ca7fe9e70e60be5b5a6bce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58032d8f8e597d3e01691595344a4728"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMatrixTools.html#a58032d8f8e597d3e01691595344a4728">DeclException0</a> (ExcBlocksDontMatch)</td></tr>
<tr class="separator:a58032d8f8e597d3e01691595344a4728"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Provide a collection of functions operating on matrices. These include the application of boundary conditions to a linear system of equations and others.</p>
<h3><a class="el" href="classBoundary.html">Boundary</a> conditions</h3>
<p>The <a class="el" href="namespaceMatrixTools.html#a41a069894610445f84840d712d4f891e">apply_boundary_values()</a> function inserts boundary conditions into a system of equations. To actually do this you have to specify a list of degree of freedom indices along with the values these degrees of freedom shall assume. To see how to get such a list, see the discussion of the <a class="el" href="namespaceVectorTools.html#a199f38e07822b47e5b5957c21ce35d1b">VectorTools::interpolate_boundary_values</a> function.</p>
<p>There are two ways to incorporate fixed degrees of freedom such as boundary nodes into a linear system, as discussed below.</p>
<h3>Global elimination</h3>
<p>In the first method, we first assemble the global linear system without respect for fixed degrees of freedom, and in a second step eliminate them again from the linear system. The inclusion into the assembly process is as follows: when the matrix and vectors are set up, a list of nodes subject to Dirichlet bc is made and matrix and vectors are modified accordingly. This is done by deleting all entries in the matrix in the line of this degree of freedom, setting the main diagonal entry to a suitable positive value and the right hand side element to a value so that the solution of the linear system will have the boundary value at this node. To decouple the remaining linear system of equations and to make the system symmetric again (at least if it was before), one Gauss elimination step is performed with this line, by adding this (now almost empty) line to all other lines which couple with the given degree of freedom and thus eliminating all coupling between this degree of freedom and others. Now the respective column also consists only of zeroes, apart from the main diagonal entry. Alternatively, the functions in this class take a boolean parameter that allows to omit this last step, if symmetry of the resulting linear system is not required. Note that usually even CG can cope with a non-symmetric linear system with this particular structure.</p>
<p>Finding which rows contain an entry in the column for which we are presently performing a Gauss elimination step is either difficult or very simple, depending on the circumstances. If the sparsity pattern is symmetric (whether the matrix is symmetric is irrelevant here), then we can infer the rows which have a nonzero entry in the present column by looking at which columns in the present row are nonempty. In this case, we only need to look into a fixed number of rows and need not search all rows. On the other hand, if the sparsity pattern is nonsymmetric, then we need to use an iterative solver which can handle nonsymmetric matrices in any case, so there may be no need to do the Gauss elimination anyway. In fact, this is the way the function works: it takes a parameter (<code>elininate_columns</code>) that specifies whether the sparsity pattern is symmetric; if so, then the column is eliminated and the right hand side is also modified accordingly. If not, then only the row is deleted and the column is not touched at all, and all right hand side values apart from the one corresponding to the present row remain unchanged.</p>
<p>If the sparsity pattern for your matrix is non-symmetric, you must set the value of this parameter to <code>false</code> in any case, since then we can't eliminate the column without searching all rows, which would be too expensive (if <code>N</code> be the number of rows, and <code>m</code> the number of nonzero elements per row, then eliminating one column is an <code>O(N*log(m))</code> operation, since searching in each row takes <code>log(m)</code> operations). If your sparsity pattern is symmetric, but your matrix is not, then you might specify <code>false</code> as well. If your sparsity pattern and matrix are both symmetric, you might want to specify <code>true</code> (the complexity of eliminating one row is then <code>O(m*log(m))</code>, since we only have to search <code>m</code> rows for the respective element of the column). Given the fact that <code>m</code> is roughly constant, irrespective of the discretization, and that the number of boundary nodes is <code>sqrt(N)</code> in 2d, the algorithm for symmetric sparsity patterns is <code>O(sqrt(N)*m*log(m))</code>, while it would be <code>O(N*sqrt(N)*log(m))</code> for the general case; the latter is too expensive to be performed.</p>
<p>It seems as if we had to make clear not to overwrite the lines of other boundary nodes when doing the Gauss elimination step. However, since we reset the right hand side when passing such a node, it is not a problem to change the right hand side values of other boundary nodes not yet processed. It would be a problem to change those entries of nodes already processed, but since the matrix entry of the present column on the row of an already processed node is zero, the Gauss step does not change the right hand side. We need therefore not take special care of other boundary nodes.</p>
<p>To make solving faster, we preset the solution vector with the right boundary values (as to why this is necessary, see the discussion below in the description of local elimination). It it not clear whether the deletion of coupling between the boundary degree of freedom and other dofs really forces the corresponding entry in the solution vector to have the right value when using iterative solvers, since their search directions may contain components in the direction of the boundary node. For this reason, we perform a very simple line balancing by not setting the main diagonal entry to unity, but rather to the value it had before deleting this line, or to the first nonzero main diagonal entry if it is zero for some reason. Of course we have to change the right hand side appropriately. This is not a very good strategy, but it at least should give the main diagonal entry a value in the right order of dimension, which makes the solution process a bit more stable. A refined algorithm would set the entry to the mean of the other diagonal entries, but this seems to be too expensive.</p>
<p>In some cases, it might be interesting to solve several times with the same matrix, but for different right hand sides or boundary values. However, since the modification for boundary values of the right hand side vector depends on the original matrix, this is not possible without storing the original matrix somewhere and applying the <code>apply_boundary_conditions</code> function to a copy of it each time we want to solve. In that case, you can use the <a class="el" href="classFilteredMatrix.html">FilteredMatrix</a> class in the <code>LAC</code> sublibrary. There you can also find a formal (mathematical) description of the process of modifying the matrix and right hand side vectors for boundary values.</p>
<h3>Local elimination</h3>
<p>The second way of handling boundary values is to modify the local matrix and vector contributions appropriately before transferring them into the global sparse matrix and vector. This is what <a class="el" href="namespaceMatrixTools.html#ae4da987e01ca7fe9e70e60be5b5a6bce">local_apply_boundary_values()</a> does. The advantage is that we save the call to the apply_boundary_values function (which is expensive because it has to work on sparse data structures). On the other hand, the <a class="el" href="namespaceMatrixTools.html#ae4da987e01ca7fe9e70e60be5b5a6bce">local_apply_boundary_values()</a> function is called many times, even if we only have a very small number of fixed boundary nodes, and the main drawback is that this function doesn't work as expected if there are hanging nodes that also need to be treated. The reason that this function doesn't work is that it is meant to be run before distribution into the global matrix, i.e. before hanging nodes are distributed; since hanging nodes can be constrained to a boundary node, the treatment of hanging nodes can add entries again to rows and columns corresponding to boundary values and that we have already vacated in the local elimination step. To make things worse, in 3d constrained nodes can even lie on the boundary. Thus, it is imperative that boundary node elimination happens <em>after</em> hanging node elimination, but this can't be achieved with local elimination of boundary nodes unless there are no hanging node constraints at all.</p>
<p>Local elimination has one additional drawback: we don't have access to the solution vector, only to the local contributions to the matrix and right hand side. The problem with this is subtle, but can lead to very hard to find difficulties: when we eliminate a degree of freedom, we delete the row and column of this unknown, and set the diagonal entry to some positive value. To make the problem more or less well-conditioned, we set this diagonal entry to the absolute value of its prior value if that was non-zero, or to the average magnitude of all other nonzero diagonal elements. Then we set the right hand side value such that the resulting solution entry has the right value as given by the boundary values. Since we add these contributions up over all local contributions, the diagonal entry and the respective value in the right hand side are added up correspondingly, so that the entry in the solution of the linear system is still valid.</p>
<p>A problem arises, however, if the diagonal entries so chosen are not appropriate for the linear system. Consider, for example, a mixed Laplace problem with matrix <code>[[A B][C^T 0]]</code>, where we only specify boundary values for the second component of the solution. In the mixed formulation, the stress-strain tensor only appears in either the matrix <code>B</code> or <code>C</code>, so one of them may be significantly larger or smaller than the other one. Now, if we eliminate boundary values, we delete some rows and columns, but we also introduce a few entries on the diagonal of the lower right block, so that we get the system <code>[[A' B'][C'^T X]]</code>. The diagonal entries in the matrix <code>X</code> will be of the same order of magnitude as those in <code>A</code>. Now, if we solve this system in the Schur complement formulation, we have to invert the matrix <code>X-C'^TA'^{-1}B'</code>. Deleting rows and columns above makes sure that boundary nodes indeed have empty rows and columns in the Schur complement as well, except for the entries in <code>X</code>. However, the entries in <code>X</code> may be of significantly different orders of magnitude than those in <code>C'^TA'^{-1}B'</code>! If this is the case, we may run into trouble with iterative solvers. For example, assume that we start with zero entries in the solution vector and that the entries in <code>X</code> are several orders of magnitude too small; in this case, iterative solvers will compute the residual vector in each step and form correction vectors, but since the entries in <code>X</code> are so small, the residual contributions for boundary nodes are really small, despite the fact that the boundary nodes are still at values close to zero and not in accordance with the prescribed boundary values. Since the residual is so small, the corrections the iterative solver computes are very small, and in the end the solver will indicate convergence to a small total residual with the boundary values still being significantly wrong.</p>
<p>We avoid this problem in the global elimination process described above by 'priming' the solution vector with the correct values for boundary nodes. However, we can't do this for the local elimination process. Therefore, if you experience a problem like the one above, you need to either increase the diagonal entries in <code>X</code> to a size that matches those in the other part of the Schur complement, or, simpler, prime the solution vector before you start the solver.</p>
<p>In conclusion, local elimination of boundary nodes only works if there are no hanging nodes and even then doesn't always work fully satisfactorily.</p>
<dl class="section author"><dt>Author</dt><dd>Wolfgang Bangerth, 1998, 2000, 2004, 2005 </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a41a069894610445f84840d712d4f891e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void MatrixTools::apply_boundary_values </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>right_hand_side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>eliminate_columns</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply Dirichlet boundary conditions to the system matrix and vectors as described in the general documentation. </p>

</div>
</div>
<a class="anchor" id="a7c01e5050670d9db0a0cd17d2c8624aa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void MatrixTools::apply_boundary_values </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBlockVector.html">BlockVector</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBlockVector.html">BlockVector</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>right_hand_side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>eliminate_columns</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply Dirichlet boundary conditions to the system matrix and vectors as described in the general documentation. This function works for block sparse matrices and block vectors </p>

</div>
</div>
<a class="anchor" id="a424a5b1a661b3151e4e1f68bbb19c809"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MatrixTools::apply_boundary_values </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1SparseMatrix.html">PETScWrappers::SparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1Vector.html">PETScWrappers::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1Vector.html">PETScWrappers::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>right_hand_side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>eliminate_columns</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply Dirichlet boundary conditions to the system matrix and vectors as described in the general documentation. This function works on the classes that are used to wrap PETSc objects.</p>
<p>Note that this function is not very efficient: it needs to alternatingly read and write into the matrix, a situation that PETSc does not handle too well. In addition, we only get rid of rows corresponding to boundary nodes, but the corresponding case of deleting the respective columns (i.e. if <code>eliminate_columns</code> is <code>true</code>) is not presently implemented, and probably will never because it is too expensive without direct access to the PETSc data structures. (This leads to the situation where the action indicates by the default value of the last argument is actually not implemented; that argument has <code>true</code> as its default value to stay consistent with the other functions of same name in this class.) A third reason against this function is that it doesn't handle the case where the matrix is distributed across an MPI system.</p>
<p>This function is used in <a class="el" href="step_17.html">step-17</a> and <a class="el" href="step_18.html">step-18</a>. </p>

</div>
</div>
<a class="anchor" id="a26b81352fcf862218943831dbb38f0a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MatrixTools::apply_boundary_values </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">PETScWrappers::MPI::SparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>right_hand_side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>eliminate_columns</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same function, but for parallel PETSc matrices. </p>

</div>
</div>
<a class="anchor" id="a44b3ccba089f59cbc3915fe33deaac17"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MatrixTools::apply_boundary_values </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">PETScWrappers::MPI::SparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1Vector.html">PETScWrappers::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>right_hand_side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>eliminate_columns</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same function, but for parallel PETSc matrices. Note that this function only operates on the local range of the parallel matrix, i.e. it only eliminates rows corresponding to degrees of freedom for which the row is stored on the present processor. All other boundary nodes are ignored, and it doesn't matter whether they are present in the first argument to this function or not. A consequence of this, however, is that this function has to be called from all processors that participate in sharing the contents of the given matrices and vectors. It is also implied that the local range for all objects passed to this function is the same. </p>

</div>
</div>
<a class="anchor" id="a970d07b0c5ee64f0f486d27f7d191772"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MatrixTools::apply_boundary_values </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html">PETScWrappers::MPI::BlockSparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1MPI_1_1BlockVector.html">PETScWrappers::MPI::BlockVector</a> &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1MPI_1_1BlockVector.html">PETScWrappers::MPI::BlockVector</a> &amp;&#160;</td>
          <td class="paramname"><em>right_hand_side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>eliminate_columns</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above but for <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>. </p>

</div>
</div>
<a class="anchor" id="a02cf546530b1d9b17000c754f7e57ac1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MatrixTools::apply_boundary_values </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">TrilinosWrappers::SparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTrilinosWrappers_1_1Vector.html">TrilinosWrappers::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTrilinosWrappers_1_1Vector.html">TrilinosWrappers::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>right_hand_side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>eliminate_columns</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply Dirichlet boundary conditions to the system matrix and vectors as described in the general documentation. This function works on the classes that are used to wrap Trilinos objects.</p>
<p>Note that this function is not very efficient: it needs to alternatingly read and write into the matrix, a situation that Trilinos does not handle too well. In addition, we only get rid of rows corresponding to boundary nodes, but the corresponding case of deleting the respective columns (i.e. if <code>eliminate_columns</code> is <code>true</code>) is not presently implemented, and probably will never because it is too expensive without direct access to the Trilinos data structures. (This leads to the situation where the action indicates by the default value of the last argument is actually not implemented; that argument has <code>true</code> as its default value to stay consistent with the other functions of same name in this class.) A third reason against this function is that it doesn't handle the case where the matrix is distributed across an MPI system. </p>

</div>
</div>
<a class="anchor" id="a73fe60abef07bd2dc78f81fb7de947a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MatrixTools::apply_boundary_values </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTrilinosWrappers_1_1BlockVector.html">TrilinosWrappers::BlockVector</a> &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTrilinosWrappers_1_1BlockVector.html">TrilinosWrappers::BlockVector</a> &amp;&#160;</td>
          <td class="paramname"><em>right_hand_side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>eliminate_columns</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function does the same as the one above, except now working on block structures. </p>

</div>
</div>
<a class="anchor" id="aee2315dbb1df6efc31836b20ea8b4f7e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MatrixTools::apply_boundary_values </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">TrilinosWrappers::SparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>right_hand_side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>eliminate_columns</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply Dirichlet boundary conditions to the system matrix and vectors as described in the general documentation. This function works on the classes that are used to wrap Trilinos objects.</p>
<p>Note that this function is not very efficient: it needs to alternatingly read and write into the matrix, a situation that Trilinos does not handle too well. In addition, we only get rid of rows corresponding to boundary nodes, but the corresponding case of deleting the respective columns (i.e. if <code>eliminate_columns</code> is <code>true</code>) is not presently implemented, and probably will never because it is too expensive without direct access to the Trilinos data structures. (This leads to the situation where the action indicates by the default value of the last argument is actually not implemented; that argument has <code>true</code> as its default value to stay consistent with the other functions of same name in this class.) This function does work on MPI vector types. </p>

</div>
</div>
<a class="anchor" id="ac18236b061ae92dae42f5491865536f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MatrixTools::apply_boundary_values </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> &amp;&#160;</td>
          <td class="paramname"><em>right_hand_side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>eliminate_columns</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function does the same as the one above, except now working on block structures. </p>

</div>
</div>
<a class="anchor" id="ae4da987e01ca7fe9e70e60be5b5a6bce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MatrixTools::local_apply_boundary_values </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>eliminate_columns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Rather than applying boundary values to the global matrix and vector after creating the global matrix, this function does so during assembly, by modifying the local matrix and vector contributions. If you call this function on all local contributions, the resulting matrix will have the same entries, and the final call to <a class="el" href="namespaceMatrixTools.html#a41a069894610445f84840d712d4f891e">apply_boundary_values()</a> on the global system will not be necessary.</p>
<p>Since this function does not have to work on the complicated data structures of sparse matrices, it is relatively cheap. It may therefore be a win if you have many fixed degrees of freedom (e.g. boundary nodes), or if access to the sparse matrix is expensive (e.g. for block sparse matrices, or for PETSc or trilinos matrices). However, it doesn't work as expected if there are also hanging nodes to be considered. More caveats are listed in the general documentation of this class. </p>

</div>
</div>
<a class="anchor" id="a58032d8f8e597d3e01691595344a4728"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MatrixTools::DeclException0 </td>
          <td>(</td>
          <td class="paramtype">ExcBlocksDontMatch&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exception </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jan 27 2014 15:27:24 for The deal.II Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
