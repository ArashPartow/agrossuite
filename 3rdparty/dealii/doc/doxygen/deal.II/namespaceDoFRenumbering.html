<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>The deal.II Library: DoFRenumbering Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="http://www.dealii.org/deal.ico"></link>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2014 by the deal.II authors"></meta>
<meta name="deal.II-version" content="8.1.0"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 8.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">DoFRenumbering Namespace Reference<div class="ingroups"><a class="el" href="group__dofs.html">Degrees of Freedom</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceDoFRenumbering_1_1boost"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering_1_1boost.html">boost</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDoFRenumbering_1_1CompareDownstream.html">CompareDownstream</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDoFRenumbering_1_1ComparePointwiseDownstream.html">ComparePointwiseDownstream</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a1b3c68c71dd7c9d82747709c55ae2ed2"><td class="memTemplParams" colspan="2">template&lt;class DH &gt; </td></tr>
<tr class="memitem:a1b3c68c71dd7c9d82747709c55ae2ed2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#a1b3c68c71dd7c9d82747709c55ae2ed2">Cuthill_McKee</a> (DH &amp;dof_handler, const <a class="el" href="classbool.html">bool</a> reversed_numbering=false, const <a class="el" href="classbool.html">bool</a> use_constraints=false, const std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;starting_indices=std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt;())</td></tr>
<tr class="separator:a1b3c68c71dd7c9d82747709c55ae2ed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa17da7d2137c288ff61804d7af853b8a"><td class="memTemplParams" colspan="2">template&lt;class DH &gt; </td></tr>
<tr class="memitem:aa17da7d2137c288ff61804d7af853b8a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#aa17da7d2137c288ff61804d7af853b8a">compute_Cuthill_McKee</a> (std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;new_dof_indices, const DH &amp;, const <a class="el" href="classbool.html">bool</a> reversed_numbering=false, const <a class="el" href="classbool.html">bool</a> use_constraints=false, const std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;starting_indices=std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt;())</td></tr>
<tr class="separator:aa17da7d2137c288ff61804d7af853b8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaa68e34b5fe8507f260487eb161573d"><td class="memTemplParams" colspan="2">template&lt;class DH &gt; </td></tr>
<tr class="memitem:adaa68e34b5fe8507f260487eb161573d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#adaa68e34b5fe8507f260487eb161573d">Cuthill_McKee</a> (DH &amp;dof_handler, const unsigned <a class="el" href="classint.html">int</a> level, const <a class="el" href="classbool.html">bool</a> reversed_numbering=false, const std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;starting_indices=std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt;())</td></tr>
<tr class="separator:adaa68e34b5fe8507f260487eb161573d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72cd110d34fdd80069c796b5741d9705"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga72cd110d34fdd80069c796b5741d9705">DeclException0</a> (ExcRenumberingIncomplete)</td></tr>
<tr class="separator:ga72cd110d34fdd80069c796b5741d9705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99f2014cc912b772cc8adc8ac8f6518e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga99f2014cc912b772cc8adc8ac8f6518e">DeclException0</a> (ExcInvalidComponentOrder)</td></tr>
<tr class="separator:ga99f2014cc912b772cc8adc8ac8f6518e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83637b63307643d565ed0a550c29c9e5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga83637b63307643d565ed0a550c29c9e5">DeclException0</a> (ExcNotDGFEM)</td></tr>
<tr class="separator:ga83637b63307643d565ed0a550c29c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Component-wise numberings</div></td></tr>
<tr class="memitem:a52c1941406d1ce2937e29a46edf111f4"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a52c1941406d1ce2937e29a46edf111f4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">component_wise</a> (<a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;target_component=std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;())</td></tr>
<tr class="separator:a52c1941406d1ce2937e29a46edf111f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a430d58fb5b4bc3ce863e001cb5868a61"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a430d58fb5b4bc3ce863e001cb5868a61"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#a430d58fb5b4bc3ce863e001cb5868a61">component_wise</a> (<a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim &gt; &amp;dof_handler, const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;target_component=std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;())</td></tr>
<tr class="separator:a430d58fb5b4bc3ce863e001cb5868a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbd417a0e85168c160f37c7af6cca424"><td class="memTemplParams" colspan="2">template&lt;class DH &gt; </td></tr>
<tr class="memitem:abbd417a0e85168c160f37c7af6cca424"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#abbd417a0e85168c160f37c7af6cca424">component_wise</a> (DH &amp;dof_handler, const unsigned <a class="el" href="classint.html">int</a> level, const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;target_component=std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;())</td></tr>
<tr class="separator:abbd417a0e85168c160f37c7af6cca424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a285b2035c88c4e3056fe9ac19173352f"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a285b2035c88c4e3056fe9ac19173352f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#a285b2035c88c4e3056fe9ac19173352f">component_wise</a> (<a class="el" href="classMGDoFHandler.html">MGDoFHandler</a>&lt; dim &gt; &amp;dof_handler, const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;target_component=std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;())</td></tr>
<tr class="separator:a285b2035c88c4e3056fe9ac19173352f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab4613fd6a1a984e492be6d6b7f12c63"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, class ITERATOR , class ENDITERATOR &gt; </td></tr>
<tr class="memitem:aab4613fd6a1a984e492be6d6b7f12c63"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#aab4613fd6a1a984e492be6d6b7f12c63">compute_component_wise</a> (std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;new_dof_indices, const ITERATOR &amp;start, const ENDITERATOR &amp;end, const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;target_component, <a class="el" href="classbool.html">bool</a> is_level_operation)</td></tr>
<tr class="separator:aab4613fd6a1a984e492be6d6b7f12c63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Block-wise numberings</div></td></tr>
<tr class="memitem:a658593cab0e93a92a7d8ce0ffe086518"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a658593cab0e93a92a7d8ce0ffe086518"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#a658593cab0e93a92a7d8ce0ffe086518">block_wise</a> (<a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler)</td></tr>
<tr class="separator:a658593cab0e93a92a7d8ce0ffe086518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a081699be1effe63621ec61329b60842f"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a081699be1effe63621ec61329b60842f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#a081699be1effe63621ec61329b60842f">block_wise</a> (<a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim &gt; &amp;dof_handler)</td></tr>
<tr class="separator:a081699be1effe63621ec61329b60842f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a574584fe949162fdb6a8e6294f4ff3ff"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a574584fe949162fdb6a8e6294f4ff3ff"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#a574584fe949162fdb6a8e6294f4ff3ff">block_wise</a> (<a class="el" href="classMGDoFHandler.html">MGDoFHandler</a>&lt; dim &gt; &amp;dof_handler, const unsigned <a class="el" href="classint.html">int</a> level)</td></tr>
<tr class="separator:a574584fe949162fdb6a8e6294f4ff3ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad935c60c29ef8c771bfadda7e5987491"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:ad935c60c29ef8c771bfadda7e5987491"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#ad935c60c29ef8c771bfadda7e5987491">block_wise</a> (<a class="el" href="classMGDoFHandler.html">MGDoFHandler</a>&lt; dim &gt; &amp;dof_handler)</td></tr>
<tr class="separator:ad935c60c29ef8c771bfadda7e5987491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa617c6c7ed3579adf03c9de3b9686027"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, class ITERATOR , class ENDITERATOR &gt; </td></tr>
<tr class="memitem:aa617c6c7ed3579adf03c9de3b9686027"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#aa617c6c7ed3579adf03c9de3b9686027">compute_block_wise</a> (std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;new_dof_indices, const ITERATOR &amp;start, const ENDITERATOR &amp;end)</td></tr>
<tr class="separator:aa617c6c7ed3579adf03c9de3b9686027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Various cell-wise numberings</div></td></tr>
<tr class="memitem:af0306c2a1b1eeef2e3d54e0bf36d7bd7"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:af0306c2a1b1eeef2e3d54e0bf36d7bd7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#af0306c2a1b1eeef2e3d54e0bf36d7bd7">hierarchical</a> (<a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; &amp;dof_handler)</td></tr>
<tr class="separator:af0306c2a1b1eeef2e3d54e0bf36d7bd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03ba25740a79e98003455d2fe8bc62e7"><td class="memTemplParams" colspan="2">template&lt;class DH &gt; </td></tr>
<tr class="memitem:a03ba25740a79e98003455d2fe8bc62e7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#a03ba25740a79e98003455d2fe8bc62e7">cell_wise</a> (DH &amp;dof_handler, const std::vector&lt; typename DH::active_cell_iterator &gt; &amp;cell_order)</td></tr>
<tr class="separator:a03ba25740a79e98003455d2fe8bc62e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46197ff3e8082434b65d240203ccf3e7"><td class="memTemplParams" colspan="2">template&lt;class DH &gt; </td></tr>
<tr class="memitem:a46197ff3e8082434b65d240203ccf3e7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#a46197ff3e8082434b65d240203ccf3e7">compute_cell_wise</a> (std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;renumbering, std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;inverse_renumbering, const DH &amp;dof_handler, const std::vector&lt; typename DH::active_cell_iterator &gt; &amp;cell_order)</td></tr>
<tr class="separator:a46197ff3e8082434b65d240203ccf3e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afebf46f39c8e5d4a93c07d3e6f5da33e"><td class="memTemplParams" colspan="2">template&lt;class DH &gt; </td></tr>
<tr class="memitem:afebf46f39c8e5d4a93c07d3e6f5da33e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#afebf46f39c8e5d4a93c07d3e6f5da33e">cell_wise</a> (DH &amp;dof_handler, const unsigned <a class="el" href="classint.html">int</a> level, const std::vector&lt; typename DH::level_cell_iterator &gt; &amp;cell_order)</td></tr>
<tr class="separator:afebf46f39c8e5d4a93c07d3e6f5da33e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c1cab15b24d6e4b8b58f5979cf99e33"><td class="memTemplParams" colspan="2">template&lt;class DH &gt; </td></tr>
<tr class="memitem:a6c1cab15b24d6e4b8b58f5979cf99e33"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#a6c1cab15b24d6e4b8b58f5979cf99e33">compute_cell_wise</a> (std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;renumbering, std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;inverse_renumbering, const DH &amp;dof_handler, const unsigned <a class="el" href="classint.html">int</a> level, const std::vector&lt; typename DH::level_cell_iterator &gt; &amp;cell_order)</td></tr>
<tr class="separator:a6c1cab15b24d6e4b8b58f5979cf99e33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Directional numberings</div></td></tr>
<tr class="memitem:a1cb4a6e4ff75599b3191cbdad0b7ec3e"><td class="memTemplParams" colspan="2">template&lt;class DH &gt; </td></tr>
<tr class="memitem:a1cb4a6e4ff75599b3191cbdad0b7ec3e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#a1cb4a6e4ff75599b3191cbdad0b7ec3e">downstream</a> (DH &amp;dof_handler, const <a class="el" href="classPoint.html">Point</a>&lt; DH::space_dimension &gt; &amp;direction, const <a class="el" href="classbool.html">bool</a> dof_wise_renumbering=false)</td></tr>
<tr class="separator:a1cb4a6e4ff75599b3191cbdad0b7ec3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a103a51ff65a70da0044271cd44ab3b47"><td class="memTemplParams" colspan="2">template&lt;class DH &gt; </td></tr>
<tr class="memitem:a103a51ff65a70da0044271cd44ab3b47"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#a103a51ff65a70da0044271cd44ab3b47">downstream</a> (DH &amp;dof_handler, const unsigned <a class="el" href="classint.html">int</a> level, const <a class="el" href="classPoint.html">Point</a>&lt; DH::space_dimension &gt; &amp;direction, const <a class="el" href="classbool.html">bool</a> dof_wise_renumbering=false)</td></tr>
<tr class="separator:a103a51ff65a70da0044271cd44ab3b47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a557abc401b20e072b444205236d92959"><td class="memTemplParams" colspan="2">template&lt;class DH &gt; </td></tr>
<tr class="memitem:a557abc401b20e072b444205236d92959"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#a557abc401b20e072b444205236d92959">downstream_dg</a> (DH &amp;dof, const <a class="el" href="classPoint.html">Point</a>&lt; DH::space_dimension &gt; &amp;direction) <a class="el" href="group__Sparsity.html#ga0849dabf81f46d4d964e251c286784dd">DEAL_II_DEPRECATED</a></td></tr>
<tr class="separator:a557abc401b20e072b444205236d92959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1199fa326bcec29a1267394071e74da"><td class="memTemplParams" colspan="2">template&lt;class DH &gt; </td></tr>
<tr class="memitem:aa1199fa326bcec29a1267394071e74da"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#aa1199fa326bcec29a1267394071e74da">downstream_dg</a> (DH &amp;dof, unsigned <a class="el" href="classint.html">int</a> level, const <a class="el" href="classPoint.html">Point</a>&lt; DH::space_dimension &gt; &amp;direction) <a class="el" href="group__Sparsity.html#ga0849dabf81f46d4d964e251c286784dd">DEAL_II_DEPRECATED</a></td></tr>
<tr class="separator:aa1199fa326bcec29a1267394071e74da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19aaf0a9f91f745fd86fbcfbab19cd83"><td class="memTemplParams" colspan="2">template&lt;class DH &gt; </td></tr>
<tr class="memitem:a19aaf0a9f91f745fd86fbcfbab19cd83"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#a19aaf0a9f91f745fd86fbcfbab19cd83">compute_downstream</a> (std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;new_dof_indices, std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;reverse, const DH &amp;dof_handler, const <a class="el" href="classPoint.html">Point</a>&lt; DH::space_dimension &gt; &amp;direction, const <a class="el" href="classbool.html">bool</a> dof_wise_renumbering)</td></tr>
<tr class="separator:a19aaf0a9f91f745fd86fbcfbab19cd83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ffd965626a3d655fef493d2224dbc85"><td class="memTemplParams" colspan="2">template&lt;class DH &gt; </td></tr>
<tr class="memitem:a2ffd965626a3d655fef493d2224dbc85"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#a2ffd965626a3d655fef493d2224dbc85">compute_downstream</a> (std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;new_dof_indices, std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;reverse, const DH &amp;dof_handler, const unsigned <a class="el" href="classint.html">int</a> level, const <a class="el" href="classPoint.html">Point</a>&lt; DH::space_dimension &gt; &amp;direction, const <a class="el" href="classbool.html">bool</a> dof_wise_renumbering)</td></tr>
<tr class="separator:a2ffd965626a3d655fef493d2224dbc85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a693d4dfdb59807540b2ce081fb3b72a0"><td class="memTemplParams" colspan="2">template&lt;class DH &gt; </td></tr>
<tr class="memitem:a693d4dfdb59807540b2ce081fb3b72a0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#a693d4dfdb59807540b2ce081fb3b72a0">clockwise_dg</a> (DH &amp;dof_handler, const <a class="el" href="classPoint.html">Point</a>&lt; DH::space_dimension &gt; &amp;center, const <a class="el" href="classbool.html">bool</a> counter=false)</td></tr>
<tr class="separator:a693d4dfdb59807540b2ce081fb3b72a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac762041aec2adf536927a90ab7b2b6fe"><td class="memTemplParams" colspan="2">template&lt;class DH &gt; </td></tr>
<tr class="memitem:ac762041aec2adf536927a90ab7b2b6fe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#ac762041aec2adf536927a90ab7b2b6fe">clockwise_dg</a> (DH &amp;dof_handler, const unsigned <a class="el" href="classint.html">int</a> level, const <a class="el" href="classPoint.html">Point</a>&lt; DH::space_dimension &gt; &amp;center, const <a class="el" href="classbool.html">bool</a> counter=false)</td></tr>
<tr class="separator:ac762041aec2adf536927a90ab7b2b6fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb8a899e596815666bd37bede8dc5613"><td class="memTemplParams" colspan="2">template&lt;class DH &gt; </td></tr>
<tr class="memitem:aeb8a899e596815666bd37bede8dc5613"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#aeb8a899e596815666bd37bede8dc5613">compute_clockwise_dg</a> (std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;new_dof_indices, const DH &amp;dof_handler, const <a class="el" href="classPoint.html">Point</a>&lt; DH::space_dimension &gt; &amp;center, const <a class="el" href="classbool.html">bool</a> counter)</td></tr>
<tr class="separator:aeb8a899e596815666bd37bede8dc5613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Selective and random numberings</div></td></tr>
<tr class="memitem:a00954aa6ae38836018ba2b679de955ed"><td class="memTemplParams" colspan="2">template&lt;class DH &gt; </td></tr>
<tr class="memitem:a00954aa6ae38836018ba2b679de955ed"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#a00954aa6ae38836018ba2b679de955ed">sort_selected_dofs_back</a> (DH &amp;dof_handler, const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;selected_dofs)</td></tr>
<tr class="separator:a00954aa6ae38836018ba2b679de955ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73c35727cf3708012f460de0095ba8b7"><td class="memTemplParams" colspan="2">template&lt;class DH &gt; </td></tr>
<tr class="memitem:a73c35727cf3708012f460de0095ba8b7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#a73c35727cf3708012f460de0095ba8b7">sort_selected_dofs_back</a> (DH &amp;dof_handler, const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;selected_dofs, const unsigned <a class="el" href="classint.html">int</a> level)</td></tr>
<tr class="separator:a73c35727cf3708012f460de0095ba8b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb4e8abf9ed246eb4bbdabf693fa70ea"><td class="memTemplParams" colspan="2">template&lt;class DH &gt; </td></tr>
<tr class="memitem:abb4e8abf9ed246eb4bbdabf693fa70ea"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#abb4e8abf9ed246eb4bbdabf693fa70ea">compute_sort_selected_dofs_back</a> (std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;new_dof_indices, const DH &amp;dof_handler, const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;selected_dofs)</td></tr>
<tr class="separator:abb4e8abf9ed246eb4bbdabf693fa70ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a705c30107b966f2b512534f6c2e5c663"><td class="memTemplParams" colspan="2">template&lt;class DH &gt; </td></tr>
<tr class="memitem:a705c30107b966f2b512534f6c2e5c663"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#a705c30107b966f2b512534f6c2e5c663">compute_sort_selected_dofs_back</a> (std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;new_dof_indices, const DH &amp;dof_handler, const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;selected_dofs, const unsigned <a class="el" href="classint.html">int</a> level)</td></tr>
<tr class="separator:a705c30107b966f2b512534f6c2e5c663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03217e28c3320f44588dfaee40c6c0a7"><td class="memTemplParams" colspan="2">template&lt;class DH &gt; </td></tr>
<tr class="memitem:a03217e28c3320f44588dfaee40c6c0a7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#a03217e28c3320f44588dfaee40c6c0a7">random</a> (DH &amp;dof_handler)</td></tr>
<tr class="separator:a03217e28c3320f44588dfaee40c6c0a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c0cf6bacd16eb36b97ec96b1bb4503b"><td class="memTemplParams" colspan="2">template&lt;class DH &gt; </td></tr>
<tr class="memitem:a8c0cf6bacd16eb36b97ec96b1bb4503b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#a8c0cf6bacd16eb36b97ec96b1bb4503b">compute_random</a> (std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;new_dof_indices, const DH &amp;dof_handler)</td></tr>
<tr class="separator:a8c0cf6bacd16eb36b97ec96b1bb4503b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Numberings based on cell attributes</div></td></tr>
<tr class="memitem:af21ead37a274586c21c61bbce6dedd56"><td class="memTemplParams" colspan="2">template&lt;class DH &gt; </td></tr>
<tr class="memitem:af21ead37a274586c21c61bbce6dedd56"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#af21ead37a274586c21c61bbce6dedd56">subdomain_wise</a> (DH &amp;dof_handler)</td></tr>
<tr class="separator:af21ead37a274586c21c61bbce6dedd56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a343c0a240cbeddc3ba0740dbb51d7deb"><td class="memTemplParams" colspan="2">template&lt;class DH &gt; </td></tr>
<tr class="memitem:a343c0a240cbeddc3ba0740dbb51d7deb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#a343c0a240cbeddc3ba0740dbb51d7deb">compute_subdomain_wise</a> (std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;new_dof_indices, const DH &amp;dof_handler)</td></tr>
<tr class="separator:a343c0a240cbeddc3ba0740dbb51d7deb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Implementation of a number of renumbering algorithms for the degrees of freedom on a triangulation.</p>
<h3>Cuthill-McKee like algorithms</h3>
<p>Within this class, the Cuthill-McKee algorithm is implemented. It starts at a degree of freedom, searches the other DoFs for those which are coupled with the one we started with and numbers these in a certain way. It then finds the second level of DoFs, namely those that couple with those of the previous level (which were those that coupled with the initial DoF) and numbers these. And so on. For the details of the algorithm, especially the numbering within each level, please see H. R. Schwarz: "Methode der finiten Elemente". The reverse Cuthill-McKee algorithm does the same job, but numbers all elements in the reverse order.</p>
<p>These algorithms have one major drawback: they require a good starting point, i.e. the degree of freedom index that will get a new index of zero. The renumbering functions therefore allow the caller to specify such an initial DoF, e.g. by exploiting knowledge of the actual topology of the domain. It is also possible to give several starting indices, which may be used to simulate a simple upstream numbering (by giving the inflow dofs as starting values) or to make preconditioning faster (by letting the Dirichlet boundary indices be starting points).</p>
<p>If no starting index is given, one is chosen automatically, namely one with the smallest coordination number (the coordination number is the number of other dofs this dof couples with). This dof is usually located on the boundary of the domain. There is, however, large ambiguity in this when using the hierarchical meshes used in this library, since in most cases the computational domain is not approximated by tilting and deforming elements and by plugging together variable numbers of elements at vertices, but rather by hierarchical refinement. There is therefore a large number of dofs with equal coordination numbers. The renumbering algorithms will therefore not give optimal results.</p>
<p>In the book of Schwarz (H.R.Schwarz: Methode der finiten Elemente), it is advised to test many starting points, if possible all with the smallest coordination number and also those with slightly higher numbers. However, this seems only possible for meshes with at most several dozen or a few hundred elements found in small engineering problems of the early 1980s (the second edition was published in 1984), but certainly not with those used in this library, featuring several 10,000 to a few 100,000 elements.</p>
<h4>Implementation of renumbering schemes</h4>
<p>The renumbering algorithms need quite a lot of memory, since they have to store for each dof with which other dofs it couples. This is done using a <a class="el" href="classSparsityPattern.html">SparsityPattern</a> object used to store the sparsity pattern of matrices. It is not useful for the user to do anything between distributing the dofs and renumbering, i.e. the calls to <a class="el" href="classDoFHandler.html#afcfcc3b473f444f50d206ae62dfe3694">DoFHandler::distribute_dofs</a> and <a class="el" href="classDoFHandler.html#a44e80b846cf60a8671969ce90ae3625b">DoFHandler::renumber_dofs</a> should follow each other immediately. If you try to create a sparsity pattern or anything else in between, these will be invalid afterwards.</p>
<p>The renumbering may take care of dof-to-dof couplings only induced by eliminating constraints. In addition to the memory consumption mentioned above, this also takes quite some computational time, but it may be switched off upon calling the <code>renumber_dofs</code> function. This will then give inferior results, since knots in the graph (representing dofs) are not found to be neighbors even if they would be after condensation.</p>
<p>The renumbering algorithms work on a purely algebraic basis, due to the isomorphism between the graph theoretical groundwork underlying the algorithms and binary matrices (matrices of which the entries are binary values) represented by the sparsity patterns. In special, the algorithms do not try to exploit topological knowledge (e.g. corner detection) to find appropriate starting points. This way, however, they work in arbitrary space dimension.</p>
<p>If you want to give starting points, you may give a list of dof indices which will form the first step of the renumbering. The dofs of the list will be consecutively numbered starting with zero, i.e. this list is not renumbered according to the coordination number of the nodes. Indices not in the allowed range are deleted. If no index is allowed, the algorithm will search for its own starting point.</p>
<h4>Results of renumbering</h4>
<p>The renumbering schemes mentioned above do not lead to optimal results. However, after all there is no algorithm that accomplishes this within reasonable time. There are situations where the lack of optimality even leads to worse results than with the original, crude, levelwise numbering scheme; one of these examples is a mesh of four cells of which always those cells are refined which are neighbors to the center (you may call this mesh a `zoom in' mesh). In one such example the bandwidth was increased by about 50 per cent.</p>
<p>In most other cases, the bandwidth is reduced significantly. The reduction is the better the less structured the grid is. With one grid where the cells were refined according to a random driven algorithm, the bandwidth was reduced by a factor of six.</p>
<p>Using the constraint information usually leads to reductions in bandwidth of 10 or 20 per cent, but may for some very unstructured grids also lead to an increase. You have to weigh the decrease in your case with the time spent to use the constraint information, which usually is several times longer than the `pure' renumbering algorithm.</p>
<p>In almost all cases, the renumbering scheme finds a corner to start with. Since there is more than one corner in most grids and since even an interior degree of freedom may be a better starting point, giving the starting point by the user may be a viable way if you have a simple scheme to derive a suitable point (e.g. by successively taking the third child of the cell top left of the coarsest level, taking its third vertex and the dof index thereof, if you want the top left corner vertex). If you do not know beforehand what your grid will look like (e.g. when using adaptive algorithms), searching a best starting point may be difficult, however, and in many cases will not justify the effort.</p>
<h3>Component-wise and block-wise numberings</h3>
<p>For finite elements composed of several base elements using the <a class="el" href="classFESystem.html">FESystem</a> class, or for elements which provide several components themselves, it may be of interest to sort the DoF indices by component. This will then bring out the block matrix structure, since otherwise the degrees of freedom are numbered cell-wise without taking into account that they may belong to different components. For example, one may want to sort degree of freedom for a Stokes discretization so that we first get all velocities and then all the pressures so that the resulting matrix naturally decomposes into a <img class="formulaInl" alt="$2\times 2$" src="form_150.png"/> system.</p>
<p>This kind of numbering may be obtained by calling the <a class="el" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">component_wise()</a> function of this class. Since it does not touch the order of indices within each component, it may be worthwhile to first renumber using the Cuthill-McKee or a similar algorithm and afterwards renumbering component-wise. This will bring out the matrix structure and additionally have a good numbering within each block.</p>
<p>The <a class="el" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">component_wise()</a> function allows not only to honor enumeration based on vector components, but also allows to group together vector components into "blocks" using a defaulted argument to the various DoFRenumber::component_wise() functions (see <a class="el" href="DEALGlossary.html#GlossComponent">GlossComponent</a> vs <a class="el" href="DEALGlossary.html#GlossBlock">GlossBlock</a> for a description of the difference). The blocks designated through this argument may, but do not have to be, equal to the blocks that the finite element reports. For example, a typical Stokes element would be </p>
<div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> stokes_fe (<a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(2), dim,   <span class="comment">// dim velocities</span></div>
<div class="line">                         <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(1), 1);    <span class="comment">// one pressure</span></div>
</div><!-- fragment --><p> This element has <code>dim+1</code> vector components and equally many blocks. However, one may want to consider the velocities as one logical block so that all velocity degrees of freedom are enumerated the same way, independent of whether they are <img class="formulaInl" alt="$x$" src="form_9.png"/>- or <img class="formulaInl" alt="$y$" src="form_10.png"/>-velocities. This is done, for example, in <a class="el" href="step_20.html">step-20</a> and <a class="el" href="step_22.html">step-22</a> as well as several other tutorial programs.</p>
<p>On the other hand, if you really want to use block structure reported by the finite element itself (a case that is often the case if you have finite elements that have multiple vector components, e.g. the <a class="el" href="classFE__RaviartThomas.html">FE_RaviartThomas</a> or <a class="el" href="classFE__Nedelec.html">FE_Nedelec</a> elements) then you can use the DoFRenumber::block_wise instead of the <a class="el" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a> functions.</p>
<h3>Cell-wise numbering</h3>
<p>Given an ordered vector of cells, the function <a class="el" href="namespaceDoFRenumbering.html#a03ba25740a79e98003455d2fe8bc62e7">cell_wise()</a> sorts the degrees of freedom such that degrees on earlier cells of this vector will occur before degrees on later cells.</p>
<p>This rule produces a well-defined ordering for discontinuous Galerkin methods (<a class="el" href="classFE__DGP.html">FE_DGP</a>, <a class="el" href="classFE__DGQ.html">FE_DGQ</a>). For continuous methods, we use the additional rule that each degree of freedom is ordered according to the first cell in the ordered vector it belongs to.</p>
<p>Applications of this scheme are <a class="el" href="namespaceDoFRenumbering.html#a1cb4a6e4ff75599b3191cbdad0b7ec3e">downstream()</a> and clock_wise_dg(). The first orders the cells according to a downstream direction and then applies <a class="el" href="namespaceDoFRenumbering.html#a03ba25740a79e98003455d2fe8bc62e7">cell_wise()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>For DG elements, the internal numbering in each cell remains unaffected. This cannot be guaranteed for continuous elements anymore, since degrees of freedom shared with an earlier cell will be accounted for by the other cell.</dd></dl>
<h3>Random renumbering</h3>
<p>The <a class="el" href="namespaceDoFRenumbering.html#a03217e28c3320f44588dfaee40c6c0a7">random()</a> function renumbers degrees of freedom randomly. This function is probably seldom of use, except to check the dependence of solvers (iterative or direct ones) on the numbering of the degrees of freedom. It uses the <code>random_shuffle</code> function from the C++ standard library to do its work.</p>
<h3>A comparison of reordering strategies</h3>
<p>As a benchmark of comparison, let us consider what the different sparsity patterns produced by the various algorithms when using the <img class="formulaInl" alt="$Q_2^d\times Q_1$" src="form_390.png"/> element combination typically employed in the discretization of Stokes equations, when used on the mesh obtained in <a class="el" href="step_22.html">step-22</a> after one adaptive mesh refinement in 3d. The space dimension together with the coupled finite element leads to a rather dense system matrix with, on average around 180 nonzero entries per row. After applying each of the reordering strategies shown below, the degrees of freedom are also sorted using <a class="el" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a> into velocity and pressure groups; this produces the <img class="formulaInl" alt="$2\times 2$" src="form_150.png"/> block structure seen below with the large velocity-velocity block at top left, small pressure-pressure block at bottom right, and coupling blocks at top right and bottom left.</p>
<p>The goal of reordering strategies is to improve the preconditioner. In <a class="el" href="step_22.html">step-22</a> we use a <a class="el" href="classSparseILU.html">SparseILU</a> to preconditioner for the velocity-velocity block at the top left. The quality of the preconditioner can then be measured by the number of CG iterations required to solve a linear system with this block. For some of the reordering strategies below we record this number for adaptive refinement cycle 3, with 93176 degrees of freedom; because we solve several linear systems with the same matrix in the Schur complement, the average number of iterations is reported. The lower the number the better the preconditioner and consequently the better the renumbering of degrees of freedom is suited for this task. We also state the run-time of the program, in part determined by the number of iterations needed, for the first 4 cycles on one of our machines. Note that the reported times correspond to the run time of the entire program, not just the affected solver; if a program runs twice as fast with one particular ordering than with another one, then this means that the actual solver is actually several times faster.</p>
<table class="doxtable">
<tr>
<td><div class="image">
<img src="reorder_sparsity_step_31_original.png" alt="reorder_sparsity_step_31_original.png"/>
</div>
  </td><td><div class="image">
<img src="reorder_sparsity_step_31_random.png" alt="reorder_sparsity_step_31_random.png"/>
</div>
  </td><td><div class="image">
<img src="reorder_sparsity_step_31_deal_cmk.png" alt="reorder_sparsity_step_31_deal_cmk.png"/>
</div>
   </td></tr>
<tr>
<td><p class="starttd">Enumeration as produced by deal.II's <a class="el" href="classDoFHandler.html#afcfcc3b473f444f50d206ae62dfe3694">DoFHandler::distribute_dofs</a> function and no further reordering apart from the component-wise one.</p>
<p class="endtd">With this renumbering, we needed an average of 92.2 iterations for the testcase outlined above, and a runtime of 7min53s.  </p>
</td><td><p class="starttd">Random enumeration as produced by applying <a class="el" href="namespaceDoFRenumbering.html#a03217e28c3320f44588dfaee40c6c0a7">DoFRenumbering::random</a> after calling <a class="el" href="classDoFHandler.html#afcfcc3b473f444f50d206ae62dfe3694">DoFHandler::distribute_dofs</a>. This enumeration produces nonzero entries in matrices pretty much everywhere, appearing here as an entirely unstructured matrix.</p>
<p class="endtd">With this renumbering, we needed an average of 71 iterations for the testcase outlined above, and a runtime of 10min55s. The longer runtime despite less iterations compared to the default ordering may be due to the fact that computing and applying the ILU requires us to jump back and forth all through memory due to the lack of localization of matrix entries around the diagonal; this then leads to many cache misses and consequently bad timings.  </p>
</td><td><p class="starttd">Cuthill-McKee enumeration as produced by calling the deal.II implementation of the algorithm provided by <a class="el" href="namespaceDoFRenumbering.html#a1b3c68c71dd7c9d82747709c55ae2ed2">DoFRenumbering::Cuthill_McKee</a> after <a class="el" href="classDoFHandler.html#afcfcc3b473f444f50d206ae62dfe3694">DoFHandler::distribute_dofs</a>.</p>
<p>With this renumbering, we needed an average of 57.3 iterations for the testcase outlined above, and a runtime of 6min10s.   </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><div class="image">
<img src="reorder_sparsity_step_31_boost_cmk.png" alt="reorder_sparsity_step_31_boost_cmk.png"/>
</div>
  </td><td><div class="image">
<img src="reorder_sparsity_step_31_boost_king.png" alt="reorder_sparsity_step_31_boost_king.png"/>
</div>
  </td><td><div class="image">
<img src="reorder_sparsity_step_31_boost_md.png" alt="reorder_sparsity_step_31_boost_md.png"/>
</div>
   </td></tr>
<tr>
<td><p class="starttd">Cuthill-McKee enumeration as produced by calling the BOOST implementation of the algorithm provided by <a class="el" href="namespaceDoFRenumbering_1_1boost.html#a637992c61ea77a26aa95b011c431f5ef">DoFRenumbering::boost::Cuthill_McKee</a> after <a class="el" href="classDoFHandler.html#afcfcc3b473f444f50d206ae62dfe3694">DoFHandler::distribute_dofs</a>.</p>
<p class="endtd">With this renumbering, we needed an average of 51.7 iterations for the testcase outlined above, and a runtime of 5min52s.  </p>
</td><td><p class="starttd">King enumeration as produced by calling the BOOST implementation of the algorithm provided by <a class="el" href="namespaceDoFRenumbering_1_1boost.html#a20feb31685326bf244390dd97ca535c9">DoFRenumbering::boost::king_ordering</a> after <a class="el" href="classDoFHandler.html#afcfcc3b473f444f50d206ae62dfe3694">DoFHandler::distribute_dofs</a>. The sparsity pattern appears denser than with BOOST's Cuthill-McKee algorithm; however, this is only an illusion: the number of nonzero entries is the same, they are simply not as well clustered.</p>
<p class="endtd">With this renumbering, we needed an average of 51.0 iterations for the testcase outlined above, and a runtime of 5min03s. Although the number of iterations is only slightly less than with BOOST's Cuthill-McKee implementation, runtime is significantly less. This, again, may be due to cache effects. As a consequence, this is the algorithm best suited to the testcase, and is in fact used in <a class="el" href="step_22.html">step-22</a>.  </p>
</td><td><p class="starttd">Minimum degree enumeration as produced by calling the BOOST implementation of the algorithm provided by <a class="el" href="namespaceDoFRenumbering_1_1boost.html#aed0953e2637d6ae75b29ee6a02eb66c5">DoFRenumbering::boost::minimum_degree</a> after <a class="el" href="classDoFHandler.html#afcfcc3b473f444f50d206ae62dfe3694">DoFHandler::distribute_dofs</a>. The minimum degree algorithm does not attempt to minimize the bandwidth of a matrix but to minimize the amount of fill-in a LU decomposition would produce, i.e. the number of places in the matrix that would be occupied by elements of an LU decomposition that are not already occupied by elements of the original matrix. The resulting sparsity pattern obviously has an entirely different structure than the ones produced by algorithms trying to minimize the bandwidth.</p>
<p>With this renumbering, we needed an average of 58.9 iterations for the testcase outlined above, and a runtime of 6min11s.  </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><div class="image">
<img src="reorder_sparsity_step_31_downstream.png" alt="reorder_sparsity_step_31_downstream.png"/>
</div>
  </td><td></td><td></td></tr>
<tr>
<td><p class="starttd">Downstream enumeration using <a class="el" href="namespaceDoFRenumbering.html#a1cb4a6e4ff75599b3191cbdad0b7ec3e">DoFRenumbering::downstream</a> using a direction that points diagonally through the domain.</p>
<p class="endtd">With this renumbering, we needed an average of 90.5 iterations for the testcase outlined above, and a runtime of 7min05s.  </p>
</td><td></td><td></td></tr>
</table>
<h3><a class="el" href="classMultigrid.html">Multigrid</a> DoF numbering</h3>
<p>Most of the algorithms listed above also work on multigrid degree of freedom numberings. Refer to the actual function declarations to get more information on this.</p>
<dl class="section author"><dt>Author</dt><dd>Wolfgang Bangerth, Guido Kanschat, 1998, 1999, 2000, 2004, 2007, 2008 </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a1b3c68c71dd7c9d82747709c55ae2ed2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DH &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::Cuthill_McKee </td>
          <td>(</td>
          <td class="paramtype">DH &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>reversed_numbering</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>use_constraints</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>starting_indices</em> = <code>std::vector&lt;&#160;<a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Renumber the degrees of freedom according to the Cuthill-McKee method, eventually using the reverse numbering scheme.</p>
<p>See the general documentation of this class for details on the different methods.</p>
<p>As an example of the results of this algorithm, take a look at the comparison of various algorithms in the documentation of the <a class="el" href="namespaceDoFRenumbering.html">DoFRenumbering</a> namespace. </p>

</div>
</div>
<a class="anchor" id="aa17da7d2137c288ff61804d7af853b8a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DH &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::compute_Cuthill_McKee </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DH &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>reversed_numbering</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>use_constraints</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>starting_indices</em> = <code>std::vector&lt;&#160;<a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the renumbering vector needed by the <a class="el" href="namespaceDoFRenumbering.html#a1b3c68c71dd7c9d82747709c55ae2ed2">Cuthill_McKee()</a> function. Does not perform the renumbering on the <a class="el" href="classDoFHandler.html">DoFHandler</a> dofs but returns the renumbering vector. </p>

</div>
</div>
<a class="anchor" id="adaa68e34b5fe8507f260487eb161573d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DH &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::Cuthill_McKee </td>
          <td>(</td>
          <td class="paramtype">DH &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>reversed_numbering</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>starting_indices</em> = <code>std::vector&lt;&#160;<a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Renumber the degrees of freedom according to the Cuthill-McKee method, eventually using the reverse numbering scheme, in this case for a multigrid numbering of degrees of freedom.</p>
<p>You can give a triangulation level to which this function is to be applied. Since with a level-wise numbering there are no hanging nodes, no constraints can be used, so the respective parameter of the previous function is omitted.</p>
<p>See the general documentation of this class for details on the different methods. </p>

</div>
</div>
<a class="anchor" id="a52c1941406d1ce2937e29a46edf111f4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::component_wise </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>target_component</em> = <code>std::vector&lt;&#160;unsigned&#160;<a class="el" href="classint.html">int</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sort the degrees of freedom by vector component. The numbering within each component is not touched, so a degree of freedom with index <img class="formulaInl" alt="$i$" src="form_77.png"/>, belonging to some component, and another degree of freedom with index <img class="formulaInl" alt="$j$" src="form_391.png"/> belonging to the same component will be assigned new indices <img class="formulaInl" alt="$n(i)$" src="form_392.png"/> and <img class="formulaInl" alt="$n(j)$" src="form_393.png"/> with <img class="formulaInl" alt="$n(i)<n(j)$" src="form_394.png"/> if <img class="formulaInl" alt="$i<j$" src="form_395.png"/> and <img class="formulaInl" alt="$n(i)>n(j)$" src="form_396.png"/> if <img class="formulaInl" alt="$i>j$" src="form_397.png"/>.</p>
<p>You can specify that the components are ordered in a different way than suggested by the <a class="el" href="classFESystem.html">FESystem</a> object you use. To this end, set up the vector <code>target_component</code> such that the entry at index <code>i</code> denotes the number of the target component for dofs with component <code>i</code> in the <a class="el" href="classFESystem.html">FESystem</a>. Naming the same target component more than once is possible and results in a blocking of several components into one. This is discussed in <a class="el" href="step_22.html">step-22</a>. If you omit this argument, the same order as given by the finite element is used.</p>
<p>If one of the base finite elements from which the global finite element under consideration here, is a non-primitive one, i.e. its shape functions have more than one non-zero component, then it is not possible to associate these degrees of freedom with a single vector component. In this case, they are associated with the first vector component to which they belong.</p>
<p>For finite elements with only one component, or a single non-primitive base element, this function is the identity operation.</p>
<dl class="section note"><dt>Note</dt><dd>A similar function, which renumbered all levels existed for <a class="el" href="classMGDoFHandler.html">MGDoFHandler</a>. This function was deleted. Thus, you have to call the level function for each level now. </dd></dl>

</div>
</div>
<a class="anchor" id="a430d58fb5b4bc3ce863e001cb5868a61"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::component_wise </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>target_component</em> = <code>std::vector&lt;&#160;unsigned&#160;<a class="el" href="classint.html">int</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sort the degrees of freedom by component. It does the same thing as the above function. </p>

</div>
</div>
<a class="anchor" id="abbd417a0e85168c160f37c7af6cca424"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DH &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::component_wise </td>
          <td>(</td>
          <td class="paramtype">DH &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>target_component</em> = <code>std::vector&lt;&#160;unsigned&#160;<a class="el" href="classint.html">int</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sort the degrees of freedom by component. It does the same thing as the above function, only that it does this for one single level of a multi-level discretization. The non-multigrid part of the <a class="el" href="classMGDoFHandler.html">MGDoFHandler</a> is not touched. </p>

</div>
</div>
<a class="anchor" id="a285b2035c88c4e3056fe9ac19173352f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::component_wise </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMGDoFHandler.html">MGDoFHandler</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>target_component</em> = <code>std::vector&lt;&#160;unsigned&#160;<a class="el" href="classint.html">int</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sort the degrees of freedom by component. It does the same thing as the previous functions, but more: it renumbers not only every level of the multigrid part, but also the global, i.e. non-multigrid components. </p>

</div>
</div>
<a class="anchor" id="aab4613fd6a1a984e492be6d6b7f12c63"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, class ITERATOR , class ENDITERATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> DoFRenumbering::compute_component_wise </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ITERATOR &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ENDITERATOR &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>target_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>is_level_operation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the renumbering vector needed by the <a class="el" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">component_wise()</a> functions. Does not perform the renumbering on the <a class="el" href="classDoFHandler.html">DoFHandler</a> dofs but returns the renumbering vector. </p>

</div>
</div>
<a class="anchor" id="a658593cab0e93a92a7d8ce0ffe086518"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::block_wise </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sort the degrees of freedom by vector block. The numbering within each block is not touched, so a degree of freedom with index <img class="formulaInl" alt="$i$" src="form_77.png"/>, belonging to some block, and another degree of freedom with index <img class="formulaInl" alt="$j$" src="form_391.png"/> belonging to the same block will be assigned new indices <img class="formulaInl" alt="$n(i)$" src="form_392.png"/> and <img class="formulaInl" alt="$n(j)$" src="form_393.png"/> with <img class="formulaInl" alt="$n(i)<n(j)$" src="form_394.png"/> if <img class="formulaInl" alt="$i<j$" src="form_395.png"/> and <img class="formulaInl" alt="$n(i)>n(j)$" src="form_396.png"/> if <img class="formulaInl" alt="$i>j$" src="form_397.png"/>. </p>

</div>
</div>
<a class="anchor" id="a081699be1effe63621ec61329b60842f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::block_wise </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sort the degrees of freedom by block. It does the same thing as the above function.</p>
<p>This function only succeeds if each of the elements in the <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a> attached to the <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a> argument has exactly the same number of blocks (see <a class="el" href="DEALGlossary.html#GlossBlock">the glossary</a> for more information). Note that this is not always given: while the <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a> class ensures that all of its elements have the same number of vector components, they need not have the same number of blocks. At the same time, this function here needs to match individual blocks across elements and therefore requires that elements have the same number of blocks and that subsequent blocks in one element have the same meaning as in another element. </p>

</div>
</div>
<a class="anchor" id="a574584fe949162fdb6a8e6294f4ff3ff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::block_wise </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMGDoFHandler.html">MGDoFHandler</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sort the degrees of freedom by block. It does the same thing as the above function, only that it does this for one single level of a multi-level discretization. The non-multigrid part of the <a class="el" href="classMGDoFHandler.html">MGDoFHandler</a> is not touched. </p>

</div>
</div>
<a class="anchor" id="ad935c60c29ef8c771bfadda7e5987491"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::block_wise </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMGDoFHandler.html">MGDoFHandler</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sort the degrees of freedom by block. It does the same thing as the previous functions, but more: it renumbers not only every level of the multigrid part, but also the global, i.e. non-multigrid components. </p>

</div>
</div>
<a class="anchor" id="aa617c6c7ed3579adf03c9de3b9686027"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, class ITERATOR , class ENDITERATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> DoFRenumbering::compute_block_wise </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ITERATOR &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ENDITERATOR &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the renumbering vector needed by the <a class="el" href="namespaceDoFRenumbering.html#a658593cab0e93a92a7d8ce0ffe086518">block_wise()</a> functions. Does not perform the renumbering on the <a class="el" href="classDoFHandler.html">DoFHandler</a> dofs but returns the renumbering vector. </p>

</div>
</div>
<a class="anchor" id="af0306c2a1b1eeef2e3d54e0bf36d7bd7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::hierarchical </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Renumber the degrees cell by cell in hierarchical order (also known as z-order). The main usage is that this guarantees the same ordering independent of the number of processors involved in a parallel distributed computation. </p>

</div>
</div>
<a class="anchor" id="a03ba25740a79e98003455d2fe8bc62e7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DH &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::cell_wise </td>
          <td>(</td>
          <td class="paramtype">DH &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; typename DH::active_cell_iterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>cell_order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cell-wise renumbering. This function takes the ordered set of cells in <code>cell_order</code>, and makes sure that all degrees of freedom in a cell with higher index are behind all degrees of freedom of a cell with lower index. The order inside a cell block will be the same as before this renumbering. </p>

</div>
</div>
<a class="anchor" id="a46197ff3e8082434b65d240203ccf3e7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DH &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::compute_cell_wise </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>renumbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>inverse_renumbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DH &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; typename DH::active_cell_iterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>cell_order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the renumbering vector needed by the <a class="el" href="namespaceDoFRenumbering.html#a03ba25740a79e98003455d2fe8bc62e7">cell_wise()</a> function. Does not perform the renumbering on the <a class="el" href="classDoFHandler.html">DoFHandler</a> dofs but returns the renumbering vector. </p>

</div>
</div>
<a class="anchor" id="afebf46f39c8e5d4a93c07d3e6f5da33e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DH &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::cell_wise </td>
          <td>(</td>
          <td class="paramtype">DH &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; typename DH::level_cell_iterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>cell_order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cell-wise renumbering on one level. See the other function with the same name. </p>

</div>
</div>
<a class="anchor" id="a6c1cab15b24d6e4b8b58f5979cf99e33"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DH &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::compute_cell_wise </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>renumbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>inverse_renumbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DH &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; typename DH::level_cell_iterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>cell_order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the renumbering vector needed by the <a class="el" href="namespaceDoFRenumbering.html#a03ba25740a79e98003455d2fe8bc62e7">cell_wise()</a> level renumbering function. Does not perform the renumbering on the <a class="el" href="classDoFHandler.html">DoFHandler</a> dofs but returns the renumbering vector. </p>

</div>
</div>
<a class="anchor" id="a1cb4a6e4ff75599b3191cbdad0b7ec3e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DH &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::downstream </td>
          <td>(</td>
          <td class="paramtype">DH &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; DH::space_dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>dof_wise_renumbering</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Downstream numbering with respect to a constant flow direction. If the additional argument <code>dof_wise_renumbering</code> is set to <code>false</code>, the numbering is performed cell-wise, otherwise it is performed based on the location of the support points.</p>
<p>The cells are sorted such that the centers of higher numbers are further downstream with respect to the constant vector <code>direction</code> than the centers of lower numbers. Even if this yields a downstream numbering with respect to the flux on the edges for fairly general grids, this might not be guaranteed for all meshes.</p>
<p>If the <code>dof_wise_renumbering</code> argument is set to <code>false</code>, this function produces a downstream ordering of the mesh cells and calls <a class="el" href="namespaceDoFRenumbering.html#a03ba25740a79e98003455d2fe8bc62e7">cell_wise()</a>. Therefore, the output only makes sense for Discontinuous Galerkin Finite Elements (all degrees of freedom have to be associated with the interior of the cell in that case) in that case.</p>
<p>If <code>dof_wise_renumbering</code> is set to <code>true</code>, the degrees of freedom are renumbered based on the support point location of the individual degrees of freedom (obviously, the finite element needs to define support points for this to work). The numbering of points with the same position in downstream location (e.g. those parallel to the flow direction, or several dofs within a <a class="el" href="classFESystem.html">FESystem</a>) will be unaffected. </p>

</div>
</div>
<a class="anchor" id="a103a51ff65a70da0044271cd44ab3b47"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DH &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::downstream </td>
          <td>(</td>
          <td class="paramtype">DH &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; DH::space_dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>dof_wise_renumbering</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cell-wise downstream numbering with respect to a constant flow direction on one level. See the other function with the same name. </p>

</div>
</div>
<a class="anchor" id="a557abc401b20e072b444205236d92959"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DH &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::downstream_dg </td>
          <td>(</td>
          <td class="paramtype">DH &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; DH::space_dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000106">Deprecated:</a></b></dt><dd>Use <a class="el" href="namespaceDoFRenumbering.html#a1cb4a6e4ff75599b3191cbdad0b7ec3e">downstream()</a> instead. </dd></dl>

<p>Definition at line <a class="el" href="dof__renumbering_8h_source.html#l00904">904</a> of file <a class="el" href="dof__renumbering_8h_source.html">dof_renumbering.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa1199fa326bcec29a1267394071e74da"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DH &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::downstream_dg </td>
          <td>(</td>
          <td class="paramtype">DH &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; DH::space_dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000107">Deprecated:</a></b></dt><dd>Use <a class="el" href="namespaceDoFRenumbering.html#a1cb4a6e4ff75599b3191cbdad0b7ec3e">downstream()</a> instead. </dd></dl>

<p>Definition at line <a class="el" href="dof__renumbering_8h_source.html#l00922">922</a> of file <a class="el" href="dof__renumbering_8h_source.html">dof_renumbering.h</a>.</p>

</div>
</div>
<a class="anchor" id="a19aaf0a9f91f745fd86fbcfbab19cd83"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DH &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::compute_downstream </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>reverse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DH &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; DH::space_dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>dof_wise_renumbering</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the renumbering vector needed by the <a class="el" href="namespaceDoFRenumbering.html#a1cb4a6e4ff75599b3191cbdad0b7ec3e">downstream()</a> function. Does not perform the renumbering on the <a class="el" href="classDoFHandler.html">DoFHandler</a> dofs but returns the renumbering vector. </p>

</div>
</div>
<a class="anchor" id="a2ffd965626a3d655fef493d2224dbc85"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DH &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::compute_downstream </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>reverse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DH &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; DH::space_dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>dof_wise_renumbering</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the renumbering vector needed by the <a class="el" href="namespaceDoFRenumbering.html#a1cb4a6e4ff75599b3191cbdad0b7ec3e">downstream()</a> function. Does not perform the renumbering on the <a class="el" href="classDoFHandler.html">DoFHandler</a> dofs but returns the renumbering vector. </p>

</div>
</div>
<a class="anchor" id="a693d4dfdb59807540b2ce081fb3b72a0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DH &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::clockwise_dg </td>
          <td>(</td>
          <td class="paramtype">DH &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; DH::space_dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>counter</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cell-wise clockwise numbering.</p>
<p>This function produces a (counter)clockwise ordering of the mesh cells with respect to the hub <code>center</code> and calls <a class="el" href="namespaceDoFRenumbering.html#a03ba25740a79e98003455d2fe8bc62e7">cell_wise()</a>. Therefore, it only works with Discontinuous Galerkin Finite Elements, i.e. all degrees of freedom have to be associated with the interior of the cell. </p>

</div>
</div>
<a class="anchor" id="ac762041aec2adf536927a90ab7b2b6fe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DH &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::clockwise_dg </td>
          <td>(</td>
          <td class="paramtype">DH &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; DH::space_dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>counter</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cell-wise clockwise numbering on one level. See the other function with the same name. </p>

</div>
</div>
<a class="anchor" id="aeb8a899e596815666bd37bede8dc5613"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DH &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::compute_clockwise_dg </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DH &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; DH::space_dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>counter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the renumbering vector needed by the <a class="el" href="namespaceDoFRenumbering.html#a693d4dfdb59807540b2ce081fb3b72a0">clockwise_dg()</a> functions. Does not perform the renumbering on the <a class="el" href="classDoFHandler.html">DoFHandler</a> dofs but returns the renumbering vector. </p>

</div>
</div>
<a class="anchor" id="a00954aa6ae38836018ba2b679de955ed"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DH &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::sort_selected_dofs_back </td>
          <td>(</td>
          <td class="paramtype">DH &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>selected_dofs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sort those degrees of freedom which are tagged with <code>true</code> in the <code>selected_dofs</code> array to the back of the DoF numbers. The sorting is stable, i.e. the relative order within the tagged degrees of freedom is preserved, as is the relative order within the untagged ones.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The <code>selected_dofs</code> array must have as many elements as the <code>dof_handler</code> has degrees of freedom. </dd></dl>

</div>
</div>
<a class="anchor" id="a73c35727cf3708012f460de0095ba8b7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DH &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::sort_selected_dofs_back </td>
          <td>(</td>
          <td class="paramtype">DH &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>selected_dofs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sort those degrees of freedom which are tagged with <code>true</code> in the <code>selected_dofs</code> array on the level <code>level</code> to the back of the DoF numbers. The sorting is stable, i.e. the relative order within the tagged degrees of freedom is preserved, as is the relative order within the untagged ones.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The <code>selected_dofs</code> array must have as many elements as the <code>dof_handler</code> has degrees of freedom on the given level. </dd></dl>

</div>
</div>
<a class="anchor" id="abb4e8abf9ed246eb4bbdabf693fa70ea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DH &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::compute_sort_selected_dofs_back </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DH &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>selected_dofs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the renumbering vector needed by the <a class="el" href="namespaceDoFRenumbering.html#a00954aa6ae38836018ba2b679de955ed">sort_selected_dofs_back()</a> function. Does not perform the renumbering on the <a class="el" href="classDoFHandler.html">DoFHandler</a> dofs but returns the renumbering vector.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The <code>selected_dofs</code> array must have as many elements as the <code>dof_handler</code> has degrees of freedom. </dd></dl>

</div>
</div>
<a class="anchor" id="a705c30107b966f2b512534f6c2e5c663"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DH &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::compute_sort_selected_dofs_back </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DH &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>selected_dofs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the renumbering vector on each level needed by the <a class="el" href="namespaceDoFRenumbering.html#a00954aa6ae38836018ba2b679de955ed">sort_selected_dofs_back()</a> function. Does not perform the renumbering on the <a class="el" href="classMGDoFHandler.html">MGDoFHandler</a> dofs but returns the renumbering vector.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The <code>selected_dofs</code> array must have as many elements as the <code>dof_handler</code> has degrees of freedom on the given level. </dd></dl>

</div>
</div>
<a class="anchor" id="a03217e28c3320f44588dfaee40c6c0a7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DH &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::random </td>
          <td>(</td>
          <td class="paramtype">DH &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Renumber the degrees of freedom in a random way. </p>

</div>
</div>
<a class="anchor" id="a8c0cf6bacd16eb36b97ec96b1bb4503b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DH &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::compute_random </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DH &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the renumbering vector needed by the <a class="el" href="namespaceDoFRenumbering.html#a03217e28c3320f44588dfaee40c6c0a7">random()</a> function. Does not perform the renumbering on the <a class="el" href="classDoFHandler.html">DoFHandler</a> dofs but returns the renumbering vector. </p>

</div>
</div>
<a class="anchor" id="af21ead37a274586c21c61bbce6dedd56"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DH &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::subdomain_wise </td>
          <td>(</td>
          <td class="paramtype">DH &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Renumber the degrees of freedom such that they are associated with the subdomain id of the cells they are living on, i.e. first all degrees of freedom that belong to cells with subdomain zero, then all with subdomain one, etc. This is useful when doing parallel computations after assigning subdomain ids using a partitioner (see the <a class="el" href="namespaceGridTools.html#a5b4706b77042db5437cf81fd13e62b20">GridTools::partition_triangulation</a> function for this).</p>
<p>Note that degrees of freedom associated with faces, edges, and vertices may be associated with multiple subdomains if they are sitting on partition boundaries. It would therefore be undefined with which subdomain they have to be associated. For this, we use what we get from the <a class="el" href="namespaceDoFTools.html#a21ed56f06e60447282b0948cfed2537c">DoFTools::get_subdomain_association</a> function.</p>
<p>The algorithm is stable, i.e. if two dofs i,j have <code>i&lt;j</code> and belong to the same subdomain, then they will be in this order also after reordering. </p>

</div>
</div>
<a class="anchor" id="a343c0a240cbeddc3ba0740dbb51d7deb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DH &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::compute_subdomain_wise </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DH &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the renumbering vector needed by the <a class="el" href="namespaceDoFRenumbering.html#af21ead37a274586c21c61bbce6dedd56">subdomain_wise()</a> function. Does not perform the renumbering on the <code><a class="el" href="classDoFHandler.html">DoFHandler</a></code> dofs but returns the renumbering vector. </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jan 27 2014 15:27:23 for The deal.II Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
