<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>The deal.II Library: MatrixFree&lt; dim, Number &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="http://www.dealii.org/deal.ico"></link>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2014 by the deal.II authors"></meta>
<meta name="deal.II-version" content="8.1.0"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 8.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classMatrixFree-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">MatrixFree&lt; dim, Number &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="matrix__free_8h_source.html">matrix_free.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMatrixFree_1_1DoFHandlers.html">DoFHandlers</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">1: Construction and initialization</div></td></tr>
<tr class="memitem:af1f4179cbc3bccee11516564807a14f7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#af1f4179cbc3bccee11516564807a14f7">MatrixFree</a> ()</td></tr>
<tr class="separator:af1f4179cbc3bccee11516564807a14f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1103f9bc3a5ff09027e68eca4010d88"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#ad1103f9bc3a5ff09027e68eca4010d88">~MatrixFree</a> ()</td></tr>
<tr class="separator:ad1103f9bc3a5ff09027e68eca4010d88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b2b86483ad9ee30c1185310fce4aeec"><td class="memTemplParams" colspan="2">template&lt;typename DH , typename Quadrature &gt; </td></tr>
<tr class="memitem:a4b2b86483ad9ee30c1185310fce4aeec"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a4b2b86483ad9ee30c1185310fce4aeec">reinit</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim &gt; &amp;mapping, const DH &amp;dof_handler, const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraint, const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;locally_owned_dofs, const <a class="el" href="classQuadrature.html">Quadrature</a> &amp;quad, const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a> additional_data=<a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>())</td></tr>
<tr class="separator:a4b2b86483ad9ee30c1185310fce4aeec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ea97cc6f9aa1de6924f1cffa0d5ce46"><td class="memTemplParams" colspan="2">template&lt;typename DH , typename Quadrature &gt; </td></tr>
<tr class="memitem:a2ea97cc6f9aa1de6924f1cffa0d5ce46"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a2ea97cc6f9aa1de6924f1cffa0d5ce46">reinit</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim &gt; &amp;mapping, const DH &amp;dof_handler, const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraint, const <a class="el" href="classQuadrature.html">Quadrature</a> &amp;quad, const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a> additional_data=<a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>())</td></tr>
<tr class="separator:a2ea97cc6f9aa1de6924f1cffa0d5ce46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9e0324a4e5f81a876953031ee9fb115"><td class="memTemplParams" colspan="2">template&lt;typename DH , typename Quadrature &gt; </td></tr>
<tr class="memitem:af9e0324a4e5f81a876953031ee9fb115"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#af9e0324a4e5f81a876953031ee9fb115">reinit</a> (const DH &amp;dof_handler, const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraint, const <a class="el" href="classQuadrature.html">Quadrature</a> &amp;quad, const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a> additional_data=<a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>())</td></tr>
<tr class="separator:af9e0324a4e5f81a876953031ee9fb115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f1c910cc6530681d260c3d874624ccf"><td class="memTemplParams" colspan="2">template&lt;typename DH , typename Quadrature &gt; </td></tr>
<tr class="memitem:a3f1c910cc6530681d260c3d874624ccf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a3f1c910cc6530681d260c3d874624ccf">reinit</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim &gt; &amp;mapping, const std::vector&lt; const DH * &gt; &amp;dof_handler, const std::vector&lt; const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> * &gt; &amp;constraint, const std::vector&lt; <a class="el" href="classIndexSet.html">IndexSet</a> &gt; &amp;locally_owned_set, const std::vector&lt; <a class="el" href="classQuadrature.html">Quadrature</a> &gt; &amp;quad, const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a> additional_data=<a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>())</td></tr>
<tr class="separator:a3f1c910cc6530681d260c3d874624ccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ff55d92cea7d049e765785f49c0a182"><td class="memTemplParams" colspan="2">template&lt;typename DH , typename Quadrature &gt; </td></tr>
<tr class="memitem:a5ff55d92cea7d049e765785f49c0a182"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a5ff55d92cea7d049e765785f49c0a182">reinit</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim &gt; &amp;mapping, const std::vector&lt; const DH * &gt; &amp;dof_handler, const std::vector&lt; const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> * &gt; &amp;constraint, const std::vector&lt; <a class="el" href="classQuadrature.html">Quadrature</a> &gt; &amp;quad, const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a> additional_data=<a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>())</td></tr>
<tr class="separator:a5ff55d92cea7d049e765785f49c0a182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a312a06ccd147bd9cd80ff5ee957b699c"><td class="memTemplParams" colspan="2">template&lt;typename DH , typename Quadrature &gt; </td></tr>
<tr class="memitem:a312a06ccd147bd9cd80ff5ee957b699c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a312a06ccd147bd9cd80ff5ee957b699c">reinit</a> (const std::vector&lt; const DH * &gt; &amp;dof_handler, const std::vector&lt; const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> * &gt; &amp;constraint, const std::vector&lt; <a class="el" href="classQuadrature.html">Quadrature</a> &gt; &amp;quad, const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a> additional_data=<a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>())</td></tr>
<tr class="separator:a312a06ccd147bd9cd80ff5ee957b699c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a1ac76327633731e7d783a256170911"><td class="memTemplParams" colspan="2">template&lt;typename DH , typename Quadrature &gt; </td></tr>
<tr class="memitem:a8a1ac76327633731e7d783a256170911"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a8a1ac76327633731e7d783a256170911">reinit</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim &gt; &amp;mapping, const std::vector&lt; const DH * &gt; &amp;dof_handler, const std::vector&lt; const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> * &gt; &amp;constraint, const <a class="el" href="classQuadrature.html">Quadrature</a> &amp;quad, const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a> additional_data=<a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>())</td></tr>
<tr class="separator:a8a1ac76327633731e7d783a256170911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e07eda8a73a7ed9f5e1f6ca0ec93959"><td class="memTemplParams" colspan="2">template&lt;typename DH , typename Quadrature &gt; </td></tr>
<tr class="memitem:a2e07eda8a73a7ed9f5e1f6ca0ec93959"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a2e07eda8a73a7ed9f5e1f6ca0ec93959">reinit</a> (const std::vector&lt; const DH * &gt; &amp;dof_handler, const std::vector&lt; const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> * &gt; &amp;constraint, const <a class="el" href="classQuadrature.html">Quadrature</a> &amp;quad, const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a> additional_data=<a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>())</td></tr>
<tr class="separator:a2e07eda8a73a7ed9f5e1f6ca0ec93959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0ea8c23f9dd724c4bdba90920c89dae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#af0ea8c23f9dd724c4bdba90920c89dae">copy_from</a> (const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt; &amp;matrix_free_base)</td></tr>
<tr class="separator:af0ea8c23f9dd724c4bdba90920c89dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada65411919b8f5cac76c36f7f510ccc9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#ada65411919b8f5cac76c36f7f510ccc9">clear</a> ()</td></tr>
<tr class="separator:ada65411919b8f5cac76c36f7f510ccc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">2: Loop over cells</div></td></tr>
<tr class="memitem:afcc5d69d8b3ac27ec73cb22e1d4b8614"><td class="memTemplParams" colspan="2">template&lt;typename OutVector , typename InVector &gt; </td></tr>
<tr class="memitem:afcc5d69d8b3ac27ec73cb22e1d4b8614"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#afcc5d69d8b3ac27ec73cb22e1d4b8614">cell_loop</a> (const std_cxx1x::function&lt; void(const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt; &amp;, OutVector &amp;, const InVector &amp;, const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;)&gt; &amp;cell_operation, OutVector &amp;dst, const InVector &amp;src) const </td></tr>
<tr class="separator:afcc5d69d8b3ac27ec73cb22e1d4b8614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b7ad915c543cc4b9b763f01c272319e"><td class="memTemplParams" colspan="2">template&lt;typename CLASS , typename OutVector , typename InVector &gt; </td></tr>
<tr class="memitem:a8b7ad915c543cc4b9b763f01c272319e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a8b7ad915c543cc4b9b763f01c272319e">cell_loop</a> (void(CLASS::*function_pointer)(const <a class="el" href="classMatrixFree.html">MatrixFree</a> &amp;, OutVector &amp;, const InVector &amp;, const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;) const, const CLASS *owning_class, OutVector &amp;dst, const InVector &amp;src) const </td></tr>
<tr class="separator:a8b7ad915c543cc4b9b763f01c272319e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f6a5bcd289145728875255c0f45c867"><td class="memTemplParams" colspan="2">template&lt;typename CLASS , typename OutVector , typename InVector &gt; </td></tr>
<tr class="memitem:a2f6a5bcd289145728875255c0f45c867"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a2f6a5bcd289145728875255c0f45c867">cell_loop</a> (void(CLASS::*function_pointer)(const <a class="el" href="classMatrixFree.html">MatrixFree</a> &amp;, OutVector &amp;, const InVector &amp;, const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;), CLASS *owning_class, OutVector &amp;dst, const InVector &amp;src) const </td></tr>
<tr class="separator:a2f6a5bcd289145728875255c0f45c867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9985619d8ae38f50e7e093b08bd2cf09"><td class="memItemLeft" align="right" valign="top">std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, <br class="typebreak"/>
unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a9985619d8ae38f50e7e093b08bd2cf09">create_cell_subrange_hp</a> (const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;range, const unsigned <a class="el" href="classint.html">int</a> fe_degree, const unsigned <a class="el" href="classint.html">int</a> vector_component=0) const </td></tr>
<tr class="separator:a9985619d8ae38f50e7e093b08bd2cf09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab36077620ea052f87249f2bcce2da07c"><td class="memItemLeft" align="right" valign="top">std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, <br class="typebreak"/>
unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#ab36077620ea052f87249f2bcce2da07c">create_cell_subrange_hp_by_index</a> (const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;range, const unsigned <a class="el" href="classint.html">int</a> fe_index, const unsigned <a class="el" href="classint.html">int</a> vector_component=0) const </td></tr>
<tr class="separator:ab36077620ea052f87249f2bcce2da07c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">3: Initialization of vectors</div></td></tr>
<tr class="memitem:a8c884a4ed29022156b70629bf66171bf"><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr class="memitem:a8c884a4ed29022156b70629bf66171bf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a8c884a4ed29022156b70629bf66171bf">initialize_dof_vector</a> (<a class="el" href="classVectorType.html">VectorType</a> &amp;vec, const unsigned <a class="el" href="classint.html">int</a> vector_component=0) const </td></tr>
<tr class="separator:a8c884a4ed29022156b70629bf66171bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e9c7706c0ae87aae56433107f256ccc"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:a2e9c7706c0ae87aae56433107f256ccc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a2e9c7706c0ae87aae56433107f256ccc">initialize_dof_vector</a> (<a class="el" href="classparallel_1_1distributed_1_1Vector.html">parallel::distributed::Vector</a>&lt; Number2 &gt; &amp;vec, const unsigned <a class="el" href="classint.html">int</a> vector_component=0) const </td></tr>
<tr class="separator:a2e9c7706c0ae87aae56433107f256ccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70b8d93c1f10d3d930cc82e0eb5ee025"><td class="memItemLeft" align="right" valign="top">const std_cxx1x::shared_ptr<br class="typebreak"/>
&lt; const <br class="typebreak"/>
<a class="el" href="classUtilities_1_1MPI_1_1Partitioner.html">Utilities::MPI::Partitioner</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a70b8d93c1f10d3d930cc82e0eb5ee025">get_vector_partitioner</a> (const unsigned <a class="el" href="classint.html">int</a> vector_component=0) const </td></tr>
<tr class="separator:a70b8d93c1f10d3d930cc82e0eb5ee025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bc802d584bfcf4b68ab79bb92dd25e3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a0bc802d584bfcf4b68ab79bb92dd25e3">get_locally_owned_set</a> (const unsigned <a class="el" href="classint.html">int</a> fe_component=0) const </td></tr>
<tr class="separator:a0bc802d584bfcf4b68ab79bb92dd25e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c277d45f4e80ebd6b37d66891d79aa8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a5c277d45f4e80ebd6b37d66891d79aa8">get_ghost_set</a> (const unsigned <a class="el" href="classint.html">int</a> fe_component=0) const </td></tr>
<tr class="separator:a5c277d45f4e80ebd6b37d66891d79aa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac87bf2eb35ff9c5b6a5a6e977a15016f"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#ac87bf2eb35ff9c5b6a5a6e977a15016f">get_constrained_dofs</a> (const unsigned <a class="el" href="classint.html">int</a> fe_component=0) const </td></tr>
<tr class="separator:ac87bf2eb35ff9c5b6a5a6e977a15016f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cab744529aef389a126a74e825eabb6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a9cab744529aef389a126a74e825eabb6">renumber_dofs</a> (std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;renumbering, const unsigned <a class="el" href="classint.html">int</a> vector_component=0)</td></tr>
<tr class="separator:a9cab744529aef389a126a74e825eabb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">4: General information</div></td></tr>
<tr class="memitem:a9ef14c089eeb6fe02a098f95125e0dec"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a9ef14c089eeb6fe02a098f95125e0dec">n_components</a> () const </td></tr>
<tr class="separator:a9ef14c089eeb6fe02a098f95125e0dec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e5c7065474b19aaf4fc267b9fd804ef"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a6e5c7065474b19aaf4fc267b9fd804ef">n_physical_cells</a> () const </td></tr>
<tr class="separator:a6e5c7065474b19aaf4fc267b9fd804ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcababa3f89a9e27b85341074fcee075"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#afcababa3f89a9e27b85341074fcee075">n_macro_cells</a> () const </td></tr>
<tr class="separator:afcababa3f89a9e27b85341074fcee075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a181ce4a4b7849cb4d0724cfac41989dc"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a181ce4a4b7849cb4d0724cfac41989dc">get_dof_handler</a> (const unsigned <a class="el" href="classint.html">int</a> fe_component=0) const </td></tr>
<tr class="separator:a181ce4a4b7849cb4d0724cfac41989dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7f8aabd3ed1a6ea63beb4c995a3a1de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt;::cell_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#ab7f8aabd3ed1a6ea63beb4c995a3a1de">get_cell_iterator</a> (const unsigned <a class="el" href="classint.html">int</a> macro_cell_number, const unsigned <a class="el" href="classint.html">int</a> vector_number, const unsigned <a class="el" href="classint.html">int</a> fe_component=0) const </td></tr>
<tr class="separator:ab7f8aabd3ed1a6ea63beb4c995a3a1de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee41d10d4357bd27d38aebe675b12958"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim &gt;<br class="typebreak"/>
::active_cell_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#aee41d10d4357bd27d38aebe675b12958">get_hp_cell_iterator</a> (const unsigned <a class="el" href="classint.html">int</a> macro_cell_number, const unsigned <a class="el" href="classint.html">int</a> vector_number, const unsigned <a class="el" href="classint.html">int</a> fe_component=0) const </td></tr>
<tr class="separator:aee41d10d4357bd27d38aebe675b12958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6649fe3fda9ea346e19b6b6da5345182"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a6649fe3fda9ea346e19b6b6da5345182">at_irregular_cell</a> (const unsigned <a class="el" href="classint.html">int</a> macro_cell_number) const </td></tr>
<tr class="separator:a6649fe3fda9ea346e19b6b6da5345182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af22a35f5022a0301134c70500e304518"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#af22a35f5022a0301134c70500e304518">n_components_filled</a> (const unsigned <a class="el" href="classint.html">int</a> macro_cell_number) const </td></tr>
<tr class="separator:af22a35f5022a0301134c70500e304518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeff34ac8fdd0ef0875d53a3596e5e8a"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#afeff34ac8fdd0ef0875d53a3596e5e8a">get_dofs_per_cell</a> (const unsigned <a class="el" href="classint.html">int</a> fe_component=0, const unsigned <a class="el" href="classint.html">int</a> hp_active_fe_index=0) const </td></tr>
<tr class="separator:afeff34ac8fdd0ef0875d53a3596e5e8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43614e88524616d7814c95d035146f08"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a43614e88524616d7814c95d035146f08">get_n_q_points</a> (const unsigned <a class="el" href="classint.html">int</a> quad_index=0, const unsigned <a class="el" href="classint.html">int</a> hp_active_fe_index=0) const </td></tr>
<tr class="separator:a43614e88524616d7814c95d035146f08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2011108a766dbc3ccbe996b9cfd3429"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#ab2011108a766dbc3ccbe996b9cfd3429">get_dofs_per_face</a> (const unsigned <a class="el" href="classint.html">int</a> fe_component=0, const unsigned <a class="el" href="classint.html">int</a> hp_active_fe_index=0) const </td></tr>
<tr class="separator:ab2011108a766dbc3ccbe996b9cfd3429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c556ada58307ea1c8147a252acb9fb2"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a5c556ada58307ea1c8147a252acb9fb2">get_n_q_points_face</a> (const unsigned <a class="el" href="classint.html">int</a> quad_index=0, const unsigned <a class="el" href="classint.html">int</a> hp_active_fe_index=0) const </td></tr>
<tr class="separator:a5c556ada58307ea1c8147a252acb9fb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c55303608bfbbb0d256795a76da547c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a3c55303608bfbbb0d256795a76da547c">get_quadrature</a> (const unsigned <a class="el" href="classint.html">int</a> quad_index=0, const unsigned <a class="el" href="classint.html">int</a> hp_active_fe_index=0) const </td></tr>
<tr class="separator:a3c55303608bfbbb0d256795a76da547c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a859dfc43073aa9af7fc1070039725ac9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a859dfc43073aa9af7fc1070039725ac9">get_face_quadrature</a> (const unsigned <a class="el" href="classint.html">int</a> quad_index=0, const unsigned <a class="el" href="classint.html">int</a> hp_active_fe_index=0) const </td></tr>
<tr class="separator:a859dfc43073aa9af7fc1070039725ac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18544623f4eff3d5408fd2e0f1ebcf6e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a18544623f4eff3d5408fd2e0f1ebcf6e">indices_initialized</a> () const </td></tr>
<tr class="separator:a18544623f4eff3d5408fd2e0f1ebcf6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca9282df9e5260cfe659bf5e2dea262f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#aca9282df9e5260cfe659bf5e2dea262f">mapping_initialized</a> () const </td></tr>
<tr class="separator:aca9282df9e5260cfe659bf5e2dea262f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acccb7e2db859dede4c09279e7d418784"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#acccb7e2db859dede4c09279e7d418784">memory_consumption</a> () const </td></tr>
<tr class="separator:acccb7e2db859dede4c09279e7d418784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2052164b9acd225386e185c4190691c"><td class="memTemplParams" colspan="2">template&lt;typename STREAM &gt; </td></tr>
<tr class="memitem:af2052164b9acd225386e185c4190691c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#af2052164b9acd225386e185c4190691c">print_memory_consumption</a> (STREAM &amp;out) const </td></tr>
<tr class="separator:af2052164b9acd225386e185c4190691c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa13d505cb85d604ea40ac225863c6323"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#aa13d505cb85d604ea40ac225863c6323">print</a> (std::ostream &amp;out) const </td></tr>
<tr class="separator:aa13d505cb85d604ea40ac225863c6323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">5: Access of internal data structure (expert mode)</div></td></tr>
<tr class="memitem:a2c932a8d3de24e76f9286197b398334d"><td class="memItemLeft" align="right" valign="top">const <br class="typebreak"/>
<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1TaskInfo.html">internal::MatrixFreeFunctions::TaskInfo</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a2c932a8d3de24e76f9286197b398334d">get_task_info</a> () const </td></tr>
<tr class="separator:a2c932a8d3de24e76f9286197b398334d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad74b79444278dcd6a61ad92756a8c31b"><td class="memItemLeft" align="right" valign="top">const <br class="typebreak"/>
<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1SizeInfo.html">internal::MatrixFreeFunctions::SizeInfo</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#ad74b79444278dcd6a61ad92756a8c31b">get_size_info</a> () const </td></tr>
<tr class="separator:ad74b79444278dcd6a61ad92756a8c31b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d691770863222a37f3c076fda03b20c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d691770863222a37f3c076fda03b20c"></a>
const <br class="typebreak"/>
<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1MappingInfo.html">internal::MatrixFreeFunctions::MappingInfo</a><br class="typebreak"/>
&lt; dim, Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>get_mapping_info</b> () const </td></tr>
<tr class="separator:a9d691770863222a37f3c076fda03b20c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a243acdec9a28f8987c463e2bdd9be071"><td class="memItemLeft" align="right" valign="top">const <br class="typebreak"/>
internal::MatrixFreeFunctions::DoFInfo &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a243acdec9a28f8987c463e2bdd9be071">get_dof_info</a> (const unsigned <a class="el" href="classint.html">int</a> fe_component=0) const </td></tr>
<tr class="separator:a243acdec9a28f8987c463e2bdd9be071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3e6795f1bcbaf5c74d1d8022be72358"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#ae3e6795f1bcbaf5c74d1d8022be72358">n_constraint_pool_entries</a> () const </td></tr>
<tr class="separator:ae3e6795f1bcbaf5c74d1d8022be72358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abde94fe8c003019307a647ab82ff5ad8"><td class="memItemLeft" align="right" valign="top">const Number *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#abde94fe8c003019307a647ab82ff5ad8">constraint_pool_begin</a> (const unsigned <a class="el" href="classint.html">int</a> pool_index) const </td></tr>
<tr class="separator:abde94fe8c003019307a647ab82ff5ad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac95e2ef95a4424a8045fa82acf28f5e6"><td class="memItemLeft" align="right" valign="top">const Number *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#ac95e2ef95a4424a8045fa82acf28f5e6">constraint_pool_end</a> (const unsigned <a class="el" href="classint.html">int</a> pool_index) const </td></tr>
<tr class="separator:ac95e2ef95a4424a8045fa82acf28f5e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3e0b3c6ab24a38a86f9fb60ee0bab13"><td class="memItemLeft" align="right" valign="top">const <br class="typebreak"/>
<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1ShapeInfo.html">internal::MatrixFreeFunctions::ShapeInfo</a><br class="typebreak"/>
&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#ac3e0b3c6ab24a38a86f9fb60ee0bab13">get_shape_info</a> (const unsigned <a class="el" href="classint.html">int</a> fe_component=0, const unsigned <a class="el" href="classint.html">int</a> quad_index=0, const unsigned <a class="el" href="classint.html">int</a> hp_active_fe_index=0, const unsigned <a class="el" href="classint.html">int</a> hp_active_quad_index=0) const </td></tr>
<tr class="separator:ac3e0b3c6ab24a38a86f9fb60ee0bab13"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a8271cff099d1ddd6315efea189061675"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a8271cff099d1ddd6315efea189061675">internal_reinit</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim &gt; &amp;mapping, const std::vector&lt; const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; * &gt; &amp;dof_handler, const std::vector&lt; const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> * &gt; &amp;constraint, const std::vector&lt; <a class="el" href="classIndexSet.html">IndexSet</a> &gt; &amp;locally_owned_set, const std::vector&lt; <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; 1 &gt; &gt; &amp;quad, const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a> additional_data)</td></tr>
<tr class="separator:a8271cff099d1ddd6315efea189061675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac8628bd327631403434caea71d9865c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#aac8628bd327631403434caea71d9865c">internal_reinit</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim &gt; &amp;mapping, const std::vector&lt; const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim &gt; * &gt; &amp;dof_handler, const std::vector&lt; const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> * &gt; &amp;constraint, const std::vector&lt; <a class="el" href="classIndexSet.html">IndexSet</a> &gt; &amp;locally_owned_set, const std::vector&lt; <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; 1 &gt; &gt; &amp;quad, const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a> additional_data)</td></tr>
<tr class="separator:aac8628bd327631403434caea71d9865c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb2f2654aca8bfb67ddaaf44454d821e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#aeb2f2654aca8bfb67ddaaf44454d821e">initialize_indices</a> (const std::vector&lt; const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> * &gt; &amp;constraint, const std::vector&lt; <a class="el" href="classIndexSet.html">IndexSet</a> &gt; &amp;locally_owned_set)</td></tr>
<tr class="separator:aeb2f2654aca8bfb67ddaaf44454d821e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bad3622872d522090507a219b0efb93"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a4bad3622872d522090507a219b0efb93">initialize_dof_handlers</a> (const std::vector&lt; const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; * &gt; &amp;<a class="el" href="classMatrixFree.html#a057e94bb1e5a222bc314479fa29d31ed">dof_handlers</a>, const unsigned <a class="el" href="classint.html">int</a> level)</td></tr>
<tr class="separator:a4bad3622872d522090507a219b0efb93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cfb1333896c5803dc9f5900edf73228"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a8cfb1333896c5803dc9f5900edf73228">initialize_dof_handlers</a> (const std::vector&lt; const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim &gt; * &gt; &amp;<a class="el" href="classMatrixFree.html#a057e94bb1e5a222bc314479fa29d31ed">dof_handlers</a>, const unsigned <a class="el" href="classint.html">int</a> level)</td></tr>
<tr class="separator:a8cfb1333896c5803dc9f5900edf73228"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a057e94bb1e5a222bc314479fa29d31ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structMatrixFree_1_1DoFHandlers.html">DoFHandlers</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a057e94bb1e5a222bc314479fa29d31ed">dof_handlers</a></td></tr>
<tr class="separator:a057e94bb1e5a222bc314479fa29d31ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a809308f14c114b50967bae3c274c8c70"><td class="memItemLeft" align="right" valign="top">std::vector<br class="typebreak"/>
&lt; internal::MatrixFreeFunctions::DoFInfo &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a809308f14c114b50967bae3c274c8c70">dof_info</a></td></tr>
<tr class="separator:a809308f14c114b50967bae3c274c8c70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19632f7ddcd8ccd6cf53ffd0e4564098"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Number &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a19632f7ddcd8ccd6cf53ffd0e4564098">constraint_pool_data</a></td></tr>
<tr class="separator:a19632f7ddcd8ccd6cf53ffd0e4564098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26b1125b841a2e45709d1e008c943626"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a26b1125b841a2e45709d1e008c943626">constraint_pool_row_index</a></td></tr>
<tr class="separator:a26b1125b841a2e45709d1e008c943626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd233be90c57c51be1107d8643daf25c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1MappingInfo.html">internal::MatrixFreeFunctions::MappingInfo</a><br class="typebreak"/>
&lt; dim, Number &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#acd233be90c57c51be1107d8643daf25c">mapping_info</a></td></tr>
<tr class="separator:acd233be90c57c51be1107d8643daf25c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22928fb178a580ecf368fd657982ddcf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTable.html">Table</a><br class="typebreak"/>
&lt; 4, <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1ShapeInfo.html">internal::MatrixFreeFunctions::ShapeInfo</a><br class="typebreak"/>
&lt; Number &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a22928fb178a580ecf368fd657982ddcf">shape_info</a></td></tr>
<tr class="separator:a22928fb178a580ecf368fd657982ddcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fe96d5df46f76ca3d98ef57ec27a5e2"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair<br class="typebreak"/>
&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a7fe96d5df46f76ca3d98ef57ec27a5e2">cell_level_index</a></td></tr>
<tr class="separator:a7fe96d5df46f76ca3d98ef57ec27a5e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23e4ee0c4f798956a22383f1f9e9eb6d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1SizeInfo.html">internal::MatrixFreeFunctions::SizeInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a23e4ee0c4f798956a22383f1f9e9eb6d">size_info</a></td></tr>
<tr class="separator:a23e4ee0c4f798956a22383f1f9e9eb6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33df2e9baaab5baa8032c70eebbc7951"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1TaskInfo.html">internal::MatrixFreeFunctions::TaskInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a33df2e9baaab5baa8032c70eebbc7951">task_info</a></td></tr>
<tr class="separator:a33df2e9baaab5baa8032c70eebbc7951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88d6c660ceb8d60fc2584e1fb57961df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a88d6c660ceb8d60fc2584e1fb57961df">indices_are_initialized</a></td></tr>
<tr class="separator:a88d6c660ceb8d60fc2584e1fb57961df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94607b35b2b190f93608fbb2bd07d837"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a94607b35b2b190f93608fbb2bd07d837">mapping_is_initialized</a></td></tr>
<tr class="separator:a94607b35b2b190f93608fbb2bd07d837"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int dim, typename Number = double&gt;<br/>
class MatrixFree&lt; dim, Number &gt;</h3>

<p>This class collects all the data that is stored for the matrix free implementation. The storage scheme is tailored towards several loops performed with the same data, i.e., typically doing many matrix-vector products or residual computations on the same mesh. The class is used in <a class="el" href="step_37.html">step-37</a> and <a class="el" href="step_48.html">step-48</a>.</p>
<p>This class does not implement any operations involving finite element basis functions, i.e., regarding the operation performed on the cells. For these operations, the class <a class="el" href="classFEEvaluation.html">FEEvaluation</a> is designed to use the data collected in this class.</p>
<p>The stored data can be subdivided into three main components:</p>
<ul>
<li>DoFInfo: It stores how local degrees of freedom relate to global degrees of freedom. It includes a description of constraints that are evaluated as going through all local degrees of freedom on a cell.</li>
<li>MappingInfo: It stores the transformations from real to unit cells that are necessary in order to build derivatives of finite element functions and find location of quadrature weights in physical space.</li>
<li>ShapeInfo: It contains the shape functions of the finite element, evaluated on the unit cell.</li>
</ul>
<p>Besides the initialization routines, this class implements only a single operation, namely a loop over all cells (<a class="el" href="classMatrixFree.html#afcc5d69d8b3ac27ec73cb22e1d4b8614">cell_loop()</a>). This loop is scheduled in such a way that cells that share degrees of freedom are not worked on simultaneously, which implies that it is possible to write to vectors (or matrices) in parallel without having to explicitly synchronize access to these vectors and matrices. This class does not implement any shape values, all it does is to cache the respective data. To implement finite element operations, use the class <a class="el" href="classFEEvaluation.html">FEEvaluation</a> (or some of the related classes).</p>
<p>This class traverses the cells in a different order than the usual <a class="el" href="classTriangulation.html">Triangulation</a> class in deal.II, in order to be flexible with respect to parallelization in shared memory and vectorization.</p>
<p>Vectorization is implemented by merging several topological cells into one so-called macro cell. This enables the application of all cell-related operations for several cells with one CPU instruction and is one of the main features of this framework.</p>
<dl class="section author"><dt>Author</dt><dd>Katharina Kormann, Martin Kronbichler, 2010, 2011 </dd></dl>

<p>Definition at line <a class="el" href="matrix__free_8h_source.html#l00107">107</a> of file <a class="el" href="matrix__free_8h_source.html">matrix_free.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="af1f4179cbc3bccee11516564807a14f7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DEAL_II_NAMESPACE_OPEN <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::<a class="el" href="classMatrixFree.html">MatrixFree</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default empty constructor. Does nothing. </p>

<p>Definition at line <a class="el" href="matrix__free_8templates_8h_source.html#l00040">40</a> of file <a class="el" href="matrix__free_8templates_8h_source.html">matrix_free.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad1103f9bc3a5ff09027e68eca4010d88"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::~<a class="el" href="classMatrixFree.html">MatrixFree</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destructor. </p>

<p>Definition at line <a class="el" href="matrix__free_8templates_8h_source.html#l00049">49</a> of file <a class="el" href="matrix__free_8templates_8h_source.html">matrix_free.templates.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a4b2b86483ad9ee30c1185310fce4aeec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
<div class="memtemplate">
template&lt;typename DH , typename Quadrature &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DH &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>locally_owned_dofs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a> &amp;&#160;</td>
          <td class="paramname"><em>quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>&#160;</td>
          <td class="paramname"><em>additional_data</em> = <code><a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extracts the information needed to perform loops over cells. The <a class="el" href="classDoFHandler.html">DoFHandler</a> and <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> describe the layout of degrees of freedom, the <a class="el" href="classDoFHandler.html">DoFHandler</a> and the mapping describe the transformations from unit to real cell, and the finite element underlying the <a class="el" href="classDoFHandler.html">DoFHandler</a> together with the quadrature formula describe the local operations. Note that the finite element underlying the <a class="el" href="classDoFHandler.html">DoFHandler</a> must either be scalar or contain several copies of the same element. Mixing several different elements into one <a class="el" href="classFESystem.html">FESystem</a> is not allowed. In that case, use the initialization function with several <a class="el" href="classDoFHandler.html">DoFHandler</a> arguments.</p>
<p>The <code><a class="el" href="classIndexSet.html">IndexSet</a></code> <code>locally_owned_dofs</code> is used to specify the parallel partitioning with MPI. Usually, this needs not be specified, and the other initialization function without and <code><a class="el" href="classIndexSet.html">IndexSet</a></code> description can be used, which gets the partitioning information builtin into the <a class="el" href="classDoFHandler.html">DoFHandler</a>. </p>

</div>
</div>
<a class="anchor" id="a2ea97cc6f9aa1de6924f1cffa0d5ce46"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
<div class="memtemplate">
template&lt;typename DH , typename Quadrature &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DH &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a> &amp;&#160;</td>
          <td class="paramname"><em>quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>&#160;</td>
          <td class="paramname"><em>additional_data</em> = <code><a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes the data structures. Same as above, but with index set stored in the <a class="el" href="classDoFHandler.html">DoFHandler</a> for describing the locally owned degrees of freedom. </p>

</div>
</div>
<a class="anchor" id="af9e0324a4e5f81a876953031ee9fb115"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
<div class="memtemplate">
template&lt;typename DH , typename Quadrature &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const DH &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a> &amp;&#160;</td>
          <td class="paramname"><em>quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>&#160;</td>
          <td class="paramname"><em>additional_data</em> = <code><a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes the data structures. Same as above, but with mapping <code><a class="el" href="classMappingQ1.html">MappingQ1</a></code>. </p>

</div>
</div>
<a class="anchor" id="a3f1c910cc6530681d260c3d874624ccf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
<div class="memtemplate">
template&lt;typename DH , typename Quadrature &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const DH * &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classIndexSet.html">IndexSet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>locally_owned_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classQuadrature.html">Quadrature</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>&#160;</td>
          <td class="paramname"><em>additional_data</em> = <code><a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extracts the information needed to perform loops over cells. The <a class="el" href="classDoFHandler.html">DoFHandler</a> and <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> describe the layout of degrees of freedom, the <a class="el" href="classDoFHandler.html">DoFHandler</a> and the mapping describe the transformations from unit to real cell, and the finite element underlying the <a class="el" href="classDoFHandler.html">DoFHandler</a> together with the quadrature formula describe the local operations. As opposed to the scalar case treated with the other initialization functions, this function allows for problems with two or more different finite elements. The <a class="el" href="structMatrixFree_1_1DoFHandlers.html">DoFHandlers</a> to each element must be passed as pointers to the initialization function. Note that the finite element underlying an <a class="el" href="classDoFHandler.html">DoFHandler</a> must either be scalar or contain several copies of the same element. Mixing several different elements into one <code>FE_System</code> is not allowed.</p>
<p>This function also allows for using several quadrature formulas, e.g. when the description contains independent integrations of elements of different degrees. However, the number of different quadrature formulas can be sets independently from the number of <a class="el" href="structMatrixFree_1_1DoFHandlers.html">DoFHandlers</a>, when several elements are always integrated with the same quadrature formula.</p>
<p>The <code><a class="el" href="classIndexSet.html">IndexSet</a></code> <code>locally_owned_dofs</code> is used to specify the parallel partitioning with MPI. Usually, this needs not be specified, and the other initialization function without and <code><a class="el" href="classIndexSet.html">IndexSet</a></code> description can be used, which gets the partitioning information from the <a class="el" href="classDoFHandler.html">DoFHandler</a>. This is the most general initialization function. </p>

</div>
</div>
<a class="anchor" id="a5ff55d92cea7d049e765785f49c0a182"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
<div class="memtemplate">
template&lt;typename DH , typename Quadrature &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const DH * &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classQuadrature.html">Quadrature</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>&#160;</td>
          <td class="paramname"><em>additional_data</em> = <code><a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes the data structures. Same as before, but now the index set description of the locally owned range of degrees of freedom is taken from the <a class="el" href="classDoFHandler.html">DoFHandler</a>. </p>

</div>
</div>
<a class="anchor" id="a312a06ccd147bd9cd80ff5ee957b699c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
<div class="memtemplate">
template&lt;typename DH , typename Quadrature &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; const DH * &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classQuadrature.html">Quadrature</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>&#160;</td>
          <td class="paramname"><em>additional_data</em> = <code><a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes the data structures. Same as above, but with mapping <code><a class="el" href="classMappingQ1.html">MappingQ1</a></code>. </p>

</div>
</div>
<a class="anchor" id="a8a1ac76327633731e7d783a256170911"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
<div class="memtemplate">
template&lt;typename DH , typename Quadrature &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const DH * &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a> &amp;&#160;</td>
          <td class="paramname"><em>quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>&#160;</td>
          <td class="paramname"><em>additional_data</em> = <code><a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes the data structures. Same as before, but now the index set description of the locally owned range of degrees of freedom is taken from the <a class="el" href="classDoFHandler.html">DoFHandler</a>. Moreover, only a single quadrature formula is used, as might be necessary when several components in a vector-valued problem are integrated together based on the same quadrature formula. </p>

</div>
</div>
<a class="anchor" id="a2e07eda8a73a7ed9f5e1f6ca0ec93959"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
<div class="memtemplate">
template&lt;typename DH , typename Quadrature &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; const DH * &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a> &amp;&#160;</td>
          <td class="paramname"><em>quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>&#160;</td>
          <td class="paramname"><em>additional_data</em> = <code><a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes the data structures. Same as above, but with mapping <code><a class="el" href="classMappingQ1.html">MappingQ1</a></code>. </p>

</div>
</div>
<a class="anchor" id="af0ea8c23f9dd724c4bdba90920c89dae"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::copy_from </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix_free_base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy function. Creates a deep copy of all data structures. It is usually enough to keep the data for different operations once, so this function should not be needed very often. </p>

<p>Definition at line <a class="el" href="matrix__free_8templates_8h_source.html#l00056">56</a> of file <a class="el" href="matrix__free_8templates_8h_source.html">matrix_free.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="ada65411919b8f5cac76c36f7f510ccc9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clears all data fields and brings the class into a condition similar to after having called the default constructor. </p>

<p>Definition at line <a class="el" href="matrix__free_8templates_8h_source.html#l00792">792</a> of file <a class="el" href="matrix__free_8templates_8h_source.html">matrix_free.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="afcc5d69d8b3ac27ec73cb22e1d4b8614"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
<div class="memtemplate">
template&lt;typename OutVector , typename InVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::cell_loop </td>
          <td>(</td>
          <td class="paramtype">const std_cxx1x::function&lt; void(const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt; &amp;, OutVector &amp;, const InVector &amp;, const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>cell_operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method runs the loop over all cells (in parallel) and performs the MPI data exchange on the source vector and destination vector. The first argument indicates a function object that has the following signature: <code>cell_operation (const MatrixFree&lt;dim,Number&gt; &amp;, OutVector &amp;, InVector &amp;, std::pair&lt;unsigned int,unsigned int&gt; &amp;)</code>, where the first argument passes the data of the calling class and the last argument defines the range of cells which should be worked on (typically more than one cell should be worked on in order to reduce overheads). One can pass a pointer to an object in this place if it has an <code>operator()</code> with the correct set of arguments since such a pointer can be converted to the function object. </p>

</div>
</div>
<a class="anchor" id="a8b7ad915c543cc4b9b763f01c272319e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
<div class="memtemplate">
template&lt;typename CLASS , typename OutVector , typename InVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::cell_loop </td>
          <td>(</td>
          <td class="paramtype">void(CLASS::*)(const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt; &amp;, OutVector &amp;, const InVector &amp;, const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;) const&#160;</td>
          <td class="paramname"><em>function_pointer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CLASS *&#160;</td>
          <td class="paramname"><em>owning_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is the second variant to run the loop over all cells, now providing a function pointer to a member function of class <code>CLASS</code> with the signature <code>cell_operation (const MatrixFree&lt;dim,Number&gt; &amp;, OutVector &amp;, InVector &amp;, std::pair&lt;unsigned int,unsigned int&gt;&amp;)const</code>. This method obviates the need to call std_cxx1x::bind to bind the class into the given function in case the local function needs to access data in the class (i.e., it is a non-static member function). </p>

</div>
</div>
<a class="anchor" id="a2f6a5bcd289145728875255c0f45c867"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
<div class="memtemplate">
template&lt;typename CLASS , typename OutVector , typename InVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::cell_loop </td>
          <td>(</td>
          <td class="paramtype">void(CLASS::*)(const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt; &amp;, OutVector &amp;, const InVector &amp;, const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;)&#160;</td>
          <td class="paramname"><em>function_pointer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CLASS *&#160;</td>
          <td class="paramname"><em>owning_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above, but for class member functions which are non-const. </p>

</div>
</div>
<a class="anchor" id="a9985619d8ae38f50e7e093b08bd2cf09"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;unsigned <a class="el" href="classint.html">int</a>,unsigned <a class="el" href="classint.html">int</a>&gt; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::create_cell_subrange_hp </td>
          <td>(</td>
          <td class="paramtype">const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>fe_degree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>vector_component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>In the hp adaptive case, a subrange of cells as computed during the cell loop might contain elements of different degrees. Use this function to compute what the subrange for an individual finite element degree is. The finite element degree is associated to the vector component given in the function call. </p>

</div>
</div>
<a class="anchor" id="ab36077620ea052f87249f2bcce2da07c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;unsigned <a class="el" href="classint.html">int</a>,unsigned <a class="el" href="classint.html">int</a>&gt; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::create_cell_subrange_hp_by_index </td>
          <td>(</td>
          <td class="paramtype">const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>fe_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>vector_component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>In the hp adaptive case, a subrange of cells as computed during the cell loop might contain elements of different degrees. Use this function to compute what the subrange for a given index the hp finite element, as opposed to the finite element degree in the other function. </p>

</div>
</div>
<a class="anchor" id="a8c884a4ed29022156b70629bf66171bf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::initialize_dof_vector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>vector_component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize function for a general vector. The length of the vector is equal to the total number of degrees in the <a class="el" href="classDoFHandler.html">DoFHandler</a>. If the vector is of class <a class="el" href="classparallel_1_1distributed_1_1Vector.html">parallel::distributed::Vector</a>&lt;Number&gt;, the ghost entries are set accordingly. For vector-valued problems with several <a class="el" href="structMatrixFree_1_1DoFHandlers.html">DoFHandlers</a> underlying this class, the parameter <code>vector_component</code> defines which component is to be used. </p>

</div>
</div>
<a class="anchor" id="a2e9c7706c0ae87aae56433107f256ccc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::initialize_dof_vector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classparallel_1_1distributed_1_1Vector.html">parallel::distributed::Vector</a>&lt; Number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>vector_component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize function for a distributed vector. The length of the vector is equal to the total number of degrees in the <a class="el" href="classDoFHandler.html">DoFHandler</a>. If the vector is of class <a class="el" href="classparallel_1_1distributed_1_1Vector.html">parallel::distributed::Vector</a>&lt;Number&gt;, the ghost entries are set accordingly. For vector-valued problems with several <a class="el" href="structMatrixFree_1_1DoFHandlers.html">DoFHandlers</a> underlying this class, the parameter <code>vector_component</code> defines which component is to be used. </p>

</div>
</div>
<a class="anchor" id="a70b8d93c1f10d3d930cc82e0eb5ee025"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std_cxx1x::shared_ptr&lt;const <a class="el" href="classUtilities_1_1MPI_1_1Partitioner.html">Utilities::MPI::Partitioner</a>&gt;&amp; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::get_vector_partitioner </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>vector_component</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the partitioner that represents the locally owned data and the ghost indices where access is needed to for the cell loop. The partitioner is constructed from the locally owned dofs and ghost dofs given by the respective fields. If you want to have specific information about these objects, you can query them with the respective access functions. If you just want to initialize a (parallel) vector, you should usually prefer this data structure as the data exchange information can be reused from one vector to another. </p>

</div>
</div>
<a class="anchor" id="a0bc802d584bfcf4b68ab79bb92dd25e3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classIndexSet.html">IndexSet</a>&amp; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::get_locally_owned_set </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>fe_component</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the set of cells that are oned by the processor. </p>

</div>
</div>
<a class="anchor" id="a5c277d45f4e80ebd6b37d66891d79aa8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classIndexSet.html">IndexSet</a>&amp; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::get_ghost_set </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>fe_component</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the set of ghost cells needed but not owned by the processor. </p>

</div>
</div>
<a class="anchor" id="ac87bf2eb35ff9c5b6a5a6e977a15016f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;unsigned <a class="el" href="classint.html">int</a>&gt;&amp; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::get_constrained_dofs </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>fe_component</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a list of all degrees of freedom that are constrained. The list is returned in MPI-local index space for the locally owned range of the vector, not in global MPI index space that spans all MPI processors. To get numbers in global index space, call <code><a class="el" href="classMatrixFree.html#a70b8d93c1f10d3d930cc82e0eb5ee025">get_vector_partitioner()</a>-&gt;local_to_global</code> on an entry of the vector. In addition, it only returns the indices for degrees of freedom that are owned locally, not for ghosts. </p>

</div>
</div>
<a class="anchor" id="a9cab744529aef389a126a74e825eabb6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::renumber_dofs </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>renumbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>vector_component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calls renumber_dofs function in dof_info which renumbers the degrees of freedom according to the ordering for parallelization. </p>

</div>
</div>
<a class="anchor" id="a9ef14c089eeb6fe02a098f95125e0dec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::n_components </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of different <a class="el" href="structMatrixFree_1_1DoFHandlers.html">DoFHandlers</a> specified at initialization. </p>

</div>
</div>
<a class="anchor" id="a6e5c7065474b19aaf4fc267b9fd804ef"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::n_physical_cells </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of cells this structure is based on. If you are using a usual <a class="el" href="classDoFHandler.html">DoFHandler</a>, it corresponds to the number of (locally owned) active cells. Note that most data structures in this class do not directly act on this number but rather on <a class="el" href="classMatrixFree.html#afcababa3f89a9e27b85341074fcee075">n_macro_cells()</a> which gives the number of cells as seen when lumping several cells together with vectorization. </p>

</div>
</div>
<a class="anchor" id="afcababa3f89a9e27b85341074fcee075"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::n_macro_cells </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of macro cells that this structure works on, i.e., the number of cell chunks that are worked on after the application of vectorization which in general works on several cells at once. The cell range in <code>cell_loop</code> runs from zero to <a class="el" href="classMatrixFree.html#afcababa3f89a9e27b85341074fcee075">n_macro_cells()</a> (exclusive), so this is the appropriate size if you want to store arrays of data for all cells to be worked on. This number is approximately <a class="el" href="classMatrixFree.html#a6e5c7065474b19aaf4fc267b9fd804ef">n_physical_cells()</a>/VectorizedArray::n_array_elements (depending on how many cell chunks that do not get filled up completely). </p>

</div>
</div>
<a class="anchor" id="a181ce4a4b7849cb4d0724cfac41989dc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt;dim&gt;&amp; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::get_dof_handler </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>fe_component</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>In case this structure was built based on a <a class="el" href="classDoFHandler.html">DoFHandler</a>, this returns the <a class="el" href="classDoFHandler.html">DoFHandler</a>. </p>

</div>
</div>
<a class="anchor" id="ab7f8aabd3ed1a6ea63beb4c995a3a1de"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDoFHandler.html">DoFHandler</a>&lt;dim&gt;::cell_iterator <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::get_cell_iterator </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>macro_cell_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>vector_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>fe_component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This returns the cell iterator in deal.II speak to a given cell in the renumbering of this structure.</p>
<p>Note that the cell iterators in deal.II go through cells differently to what the cell loop of this class does. This is because several cells are worked on together (vectorization), and since cells with neighbors on different MPI processors need to be accessed at a certain time when accessing remote data and overlapping communication with computation. </p>

</div>
</div>
<a class="anchor" id="aee41d10d4357bd27d38aebe675b12958"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt;dim&gt;::active_cell_iterator <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::get_hp_cell_iterator </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>macro_cell_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>vector_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>fe_component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This returns the cell iterator in deal.II speak to a given cell in the renumbering of this structure. This function returns an exception in case the structure was not constructed based on an <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>.</p>
<p>Note that the cell iterators in deal.II go through cells differently to what the cell loop of this class does. This is because several cells are worked on together (vectorization), and since cells with neighbors on different MPI processors need to be accessed at a certain time when accessing remote data and overlapping communication with computation. </p>

</div>
</div>
<a class="anchor" id="a6649fe3fda9ea346e19b6b6da5345182"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::at_irregular_cell </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>macro_cell_number</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Since this class uses vectorized data types with usually more than one value in the data field, a situation might occur when some components of the vector type do not correspond to an actual cell in the mesh. When using only this class, one usually does not need to bother about that fact since the values are padded with zeros. However, when this class is mixed with deal.II access to cells, care needs to be taken. This function returns <code>true</code> if not all <code>vectorization_length</code> cells for the given <code>macro_cell</code> are real cells. To find out how many cells are actually used, use the function <code>n_components_filled</code>. </p>

</div>
</div>
<a class="anchor" id="af22a35f5022a0301134c70500e304518"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::n_components_filled </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>macro_cell_number</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use this function to find out how many cells over the length of vectorization data types correspond to real cells in the mesh. For most given <code>macro_cells</code>, this is just <code>vectorization_length</code> many, but there might be one or a few meshes (where the numbers do not add up) where there are less such components filled, indicated by the function <code>at_irregular_cell</code>. </p>

</div>
</div>
<a class="anchor" id="afeff34ac8fdd0ef0875d53a3596e5e8a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::get_dofs_per_cell </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>fe_component</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>hp_active_fe_index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of degrees of freedom per cell for a given hp index. </p>

</div>
</div>
<a class="anchor" id="a43614e88524616d7814c95d035146f08"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::get_n_q_points </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>quad_index</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>hp_active_fe_index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of quadrature points per cell for a given hp index. </p>

</div>
</div>
<a class="anchor" id="ab2011108a766dbc3ccbe996b9cfd3429"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::get_dofs_per_face </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>fe_component</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>hp_active_fe_index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of degrees of freedom on each face of the cell for given hp index. </p>

</div>
</div>
<a class="anchor" id="a5c556ada58307ea1c8147a252acb9fb2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::get_n_q_points_face </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>quad_index</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>hp_active_fe_index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of quadrature points on each face of the cell for given hp index. </p>

</div>
</div>
<a class="anchor" id="a3c55303608bfbbb0d256795a76da547c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt;dim&gt;&amp; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::get_quadrature </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>quad_index</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>hp_active_fe_index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the quadrature rule for given hp index. </p>

</div>
</div>
<a class="anchor" id="a859dfc43073aa9af7fc1070039725ac9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt;dim-1&gt;&amp; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::get_face_quadrature </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>quad_index</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>hp_active_fe_index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the quadrature rule for given hp index. </p>

</div>
</div>
<a class="anchor" id="a18544623f4eff3d5408fd2e0f1ebcf6e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::indices_initialized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Queries whether or not the indexation has been set. </p>

</div>
</div>
<a class="anchor" id="aca9282df9e5260cfe659bf5e2dea262f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::mapping_initialized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Queries whether or not the geometry-related information for the cells has been set. </p>

</div>
</div>
<a class="anchor" id="acccb7e2db859dede4c09279e7d418784"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an approximation of the memory consumption of this class in bytes. </p>

<p>Definition at line <a class="el" href="matrix__free_8templates_8h_source.html#l00808">808</a> of file <a class="el" href="matrix__free_8templates_8h_source.html">matrix_free.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="af2052164b9acd225386e185c4190691c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename STREAM &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::print_memory_consumption </td>
          <td>(</td>
          <td class="paramtype">STREAM &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints a detailed summary of memory consumption in the different structures of this class to the given output stream. </p>

<p>Definition at line <a class="el" href="matrix__free_8templates_8h_source.html#l00824">824</a> of file <a class="el" href="matrix__free_8templates_8h_source.html">matrix_free.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa13d505cb85d604ea40ac225863c6323"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints a summary of this class to the given output stream. It is focused on the indices, and does not print all the data stored. </p>

<p>Definition at line <a class="el" href="matrix__free_8templates_8h_source.html#l00854">854</a> of file <a class="el" href="matrix__free_8templates_8h_source.html">matrix_free.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2c932a8d3de24e76f9286197b398334d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1TaskInfo.html">internal::MatrixFreeFunctions::TaskInfo</a>&amp; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::get_task_info </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns information on task graph. </p>

</div>
</div>
<a class="anchor" id="ad74b79444278dcd6a61ad92756a8c31b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1SizeInfo.html">internal::MatrixFreeFunctions::SizeInfo</a>&amp; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::get_size_info </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns information on system size. </p>

</div>
</div>
<a class="anchor" id="a243acdec9a28f8987c463e2bdd9be071"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const internal::MatrixFreeFunctions::DoFInfo&amp; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::get_dof_info </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>fe_component</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns information on indexation degrees of freedom. </p>

</div>
</div>
<a class="anchor" id="ae3e6795f1bcbaf5c74d1d8022be72358"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::n_constraint_pool_entries </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of weights in the constraint pool. </p>

</div>
</div>
<a class="anchor" id="abde94fe8c003019307a647ab82ff5ad8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const Number* <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::constraint_pool_begin </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>pool_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a pointer to the first number in the constraint pool data with index <code>pool_index</code> (to be used together with <code><a class="el" href="classMatrixFree.html#ac95e2ef95a4424a8045fa82acf28f5e6">constraint_pool_end()</a></code>). </p>

</div>
</div>
<a class="anchor" id="ac95e2ef95a4424a8045fa82acf28f5e6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const Number* <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::constraint_pool_end </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>pool_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a pointer to one past the last number in the constraint pool data with index <code>pool_index</code> (to be used together with <code><a class="el" href="classMatrixFree.html#abde94fe8c003019307a647ab82ff5ad8">constraint_pool_begin()</a></code>). </p>

</div>
</div>
<a class="anchor" id="ac3e0b3c6ab24a38a86f9fb60ee0bab13"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1ShapeInfo.html">internal::MatrixFreeFunctions::ShapeInfo</a>&lt;Number&gt;&amp; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::get_shape_info </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>fe_component</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>quad_index</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>hp_active_fe_index</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>hp_active_quad_index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the unit cell information for given hp index. </p>

</div>
</div>
<a class="anchor" id="a8271cff099d1ddd6315efea189061675"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::internal_reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classIndexSet.html">IndexSet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>locally_owned_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; 1 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>&#160;</td>
          <td class="paramname"><em>additional_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the actual reinit function that sets up the indices for the <a class="el" href="classDoFHandler.html">DoFHandler</a> case. </p>

</div>
</div>
<a class="anchor" id="aac8628bd327631403434caea71d9865c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::internal_reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classIndexSet.html">IndexSet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>locally_owned_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; 1 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>&#160;</td>
          <td class="paramname"><em>additional_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as before but for <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a> instead of generic <a class="el" href="classDoFHandler.html">DoFHandler</a> type. </p>

</div>
</div>
<a class="anchor" id="aeb2f2654aca8bfb67ddaaf44454d821e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::initialize_indices </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classIndexSet.html">IndexSet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>locally_owned_set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes the fields in DoFInfo together with the constraint pool that holds all different weights in the constraints (not part of DoFInfo because several DoFInfo classes can have the same weights which consequently only need to be stored once). </p>

<p>Definition at line <a class="el" href="matrix__free_8templates_8h_source.html#l00463">463</a> of file <a class="el" href="matrix__free_8templates_8h_source.html">matrix_free.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4bad3622872d522090507a219b0efb93"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::initialize_dof_handlers </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handlers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes the <a class="el" href="structMatrixFree_1_1DoFHandlers.html">DoFHandlers</a> based on a <a class="el" href="classhp_1_1DoFHandler.html">DoFHandler&lt;dim&gt;</a> argument. </p>

<p>Definition at line <a class="el" href="matrix__free_8templates_8h_source.html#l00383">383</a> of file <a class="el" href="matrix__free_8templates_8h_source.html">matrix_free.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8cfb1333896c5803dc9f5900edf73228"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::initialize_dof_handlers </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handlers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes the <a class="el" href="structMatrixFree_1_1DoFHandlers.html">DoFHandlers</a> based on a hp::DoFHandler&lt;dim&gt; argument. </p>

<p>Definition at line <a class="el" href="matrix__free_8templates_8h_source.html#l00427">427</a> of file <a class="el" href="matrix__free_8templates_8h_source.html">matrix_free.templates.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a057e94bb1e5a222bc314479fa29d31ed"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structMatrixFree_1_1DoFHandlers.html">DoFHandlers</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::dof_handlers</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pointers to the <a class="el" href="structMatrixFree_1_1DoFHandlers.html">DoFHandlers</a> underlying the current problem. </p>

<p>Definition at line <a class="el" href="matrix__free_8h_source.html#l00873">873</a> of file <a class="el" href="matrix__free_8h_source.html">matrix_free.h</a>.</p>

</div>
</div>
<a class="anchor" id="a809308f14c114b50967bae3c274c8c70"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;internal::MatrixFreeFunctions::DoFInfo&gt; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::dof_info</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Contains the information about degrees of freedom on the individual cells and constraints. </p>

<p>Definition at line <a class="el" href="matrix__free_8h_source.html#l00879">879</a> of file <a class="el" href="matrix__free_8h_source.html">matrix_free.h</a>.</p>

</div>
</div>
<a class="anchor" id="a19632f7ddcd8ccd6cf53ffd0e4564098"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;Number&gt; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::constraint_pool_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Contains the weights for constraints stored in DoFInfo. Filled into a separate field since several vector components might share similar weights, which reduces memory consumption. Moreover, it obviates template arguments on DoFInfo and keeps it a plain field of indices only. </p>

<p>Definition at line <a class="el" href="matrix__free_8h_source.html#l00887">887</a> of file <a class="el" href="matrix__free_8h_source.html">matrix_free.h</a>.</p>

</div>
</div>
<a class="anchor" id="a26b1125b841a2e45709d1e008c943626"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;unsigned <a class="el" href="classint.html">int</a>&gt; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::constraint_pool_row_index</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Contains an indicator to the start of the ith index in the constraint pool data. </p>

<p>Definition at line <a class="el" href="matrix__free_8h_source.html#l00893">893</a> of file <a class="el" href="matrix__free_8h_source.html">matrix_free.h</a>.</p>

</div>
</div>
<a class="anchor" id="acd233be90c57c51be1107d8643daf25c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1MappingInfo.html">internal::MatrixFreeFunctions::MappingInfo</a>&lt;dim,Number&gt; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::mapping_info</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Holds information on transformation of cells from reference cell to real cell that is needed for evaluating integrals. </p>

<p>Definition at line <a class="el" href="matrix__free_8h_source.html#l00899">899</a> of file <a class="el" href="matrix__free_8h_source.html">matrix_free.h</a>.</p>

</div>
</div>
<a class="anchor" id="a22928fb178a580ecf368fd657982ddcf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTable.html">Table</a>&lt;4,<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1ShapeInfo.html">internal::MatrixFreeFunctions::ShapeInfo</a>&lt;Number&gt; &gt; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::shape_info</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Contains shape value information on the unit cell. </p>

<p>Definition at line <a class="el" href="matrix__free_8h_source.html#l00904">904</a> of file <a class="el" href="matrix__free_8h_source.html">matrix_free.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7fe96d5df46f76ca3d98ef57ec27a5e2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::pair&lt;unsigned <a class="el" href="classint.html">int</a>,unsigned <a class="el" href="classint.html">int</a>&gt; &gt; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::cell_level_index</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Describes how the cells are gone through. With the cell level (first index in this field) and the index within the level, one can reconstruct a deal.II cell iterator and use all the traditional things deal.II offers to do with cell iterators. </p>

<p>Definition at line <a class="el" href="matrix__free_8h_source.html#l00912">912</a> of file <a class="el" href="matrix__free_8h_source.html">matrix_free.h</a>.</p>

</div>
</div>
<a class="anchor" id="a23e4ee0c4f798956a22383f1f9e9eb6d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1SizeInfo.html">internal::MatrixFreeFunctions::SizeInfo</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::size_info</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stores how many cells we have, how many cells that we see after applying vectorization (i.e., the number of macro cells), and MPI-related stuff. </p>

<p>Definition at line <a class="el" href="matrix__free_8h_source.html#l00918">918</a> of file <a class="el" href="matrix__free_8h_source.html">matrix_free.h</a>.</p>

</div>
</div>
<a class="anchor" id="a33df2e9baaab5baa8032c70eebbc7951"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1TaskInfo.html">internal::MatrixFreeFunctions::TaskInfo</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::task_info</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Information regarding the shared memory parallelization. </p>

<p>Definition at line <a class="el" href="matrix__free_8h_source.html#l00923">923</a> of file <a class="el" href="matrix__free_8h_source.html">matrix_free.h</a>.</p>

</div>
</div>
<a class="anchor" id="a88d6c660ceb8d60fc2584e1fb57961df"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::indices_are_initialized</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stores whether indices have been initialized. </p>

<p>Definition at line <a class="el" href="matrix__free_8h_source.html#l00928">928</a> of file <a class="el" href="matrix__free_8h_source.html">matrix_free.h</a>.</p>

</div>
</div>
<a class="anchor" id="a94607b35b2b190f93608fbb2bd07d837"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::mapping_is_initialized</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stores whether indices have been initialized. </p>

<p>Definition at line <a class="el" href="matrix__free_8h_source.html#l00933">933</a> of file <a class="el" href="matrix__free_8h_source.html">matrix_free.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/deal.II/matrix_free/<a class="el" href="matrix__free_8h_source.html">matrix_free.h</a></li>
<li>include/deal.II/matrix_free/<a class="el" href="matrix__free_8templates_8h_source.html">matrix_free.templates.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jan 27 2014 15:27:20 for The deal.II Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
