<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>The deal.II Library: PETScWrappers::MatrixBase Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="http://www.dealii.org/deal.ico"></link>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2014 by the deal.II authors"></meta>
<meta name="deal.II-version" content="8.1.0"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 8.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacePETScWrappers.html">PETScWrappers</a></li><li class="navelem"><a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classPETScWrappers_1_1MatrixBase-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">PETScWrappers::MatrixBase Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group__PETScWrappers.html">PETScWrappers</a> &#124; <a class="el" href="group__Matrix1.html">Basic matrices</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="petsc__matrix__base_8h_source.html">petsc_matrix_base.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for PETScWrappers::MatrixBase:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classPETScWrappers_1_1MatrixBase__inherit__graph.svg" width="595" height="216"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPETScWrappers_1_1MatrixBase_1_1LastAction.html">LastAction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a9daaa67d19e61e1f59135e31b6002820"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="classPETScWrappers_1_1MatrixIterators_1_1const__iterator.html">MatrixIterators::const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a9daaa67d19e61e1f59135e31b6002820">const_iterator</a></td></tr>
<tr class="separator:a9daaa67d19e61e1f59135e31b6002820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02115578620b6df0638b8754bad6aaaa"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a></td></tr>
<tr class="separator:a02115578620b6df0638b8754bad6aaaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af69f9f200e7a90df0c74bd9a96bb9cd8"><td class="memItemLeft" align="right" valign="top">typedef PetscScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#af69f9f200e7a90df0c74bd9a96bb9cd8">value_type</a></td></tr>
<tr class="separator:af69f9f200e7a90df0c74bd9a96bb9cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afe8c5db4389d2eb35ea78e1b2db6c041"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#afe8c5db4389d2eb35ea78e1b2db6c041">MatrixBase</a> ()</td></tr>
<tr class="separator:afe8c5db4389d2eb35ea78e1b2db6c041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacca3ef8ca7e0c094407fb7a66d3a7f2"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#aacca3ef8ca7e0c094407fb7a66d3a7f2">~MatrixBase</a> ()</td></tr>
<tr class="separator:aacca3ef8ca7e0c094407fb7a66d3a7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a456bd309a8f32efc7e25c02cf3afa80e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a456bd309a8f32efc7e25c02cf3afa80e">operator=</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#af69f9f200e7a90df0c74bd9a96bb9cd8">value_type</a> d)</td></tr>
<tr class="separator:a456bd309a8f32efc7e25c02cf3afa80e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b895d26bc6c0a0cf96d37d00e5853c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a1b895d26bc6c0a0cf96d37d00e5853c4">clear</a> ()</td></tr>
<tr class="separator:a1b895d26bc6c0a0cf96d37d00e5853c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5067751068b7290030fe97cc8cadd02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#af5067751068b7290030fe97cc8cadd02">set</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> i, const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> j, const PetscScalar value)</td></tr>
<tr class="separator:af5067751068b7290030fe97cc8cadd02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2a6e591d33f2af5e44a20c8b3e30943"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#af2a6e591d33f2af5e44a20c8b3e30943">set</a> (const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> &gt; &amp;indices, const <a class="el" href="classPETScWrappers_1_1FullMatrix.html">FullMatrix</a>&lt; PetscScalar &gt; &amp;full_matrix, const <a class="el" href="classbool.html">bool</a> elide_zero_values=false)</td></tr>
<tr class="separator:af2a6e591d33f2af5e44a20c8b3e30943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90d04e83f54969c8c504da62bdee60a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a90d04e83f54969c8c504da62bdee60a8">set</a> (const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> &gt; &amp;row_indices, const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> &gt; &amp;col_indices, const <a class="el" href="classPETScWrappers_1_1FullMatrix.html">FullMatrix</a>&lt; PetscScalar &gt; &amp;full_matrix, const <a class="el" href="classbool.html">bool</a> elide_zero_values=false)</td></tr>
<tr class="separator:a90d04e83f54969c8c504da62bdee60a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc988c43c687b2af0b7e4352def7f19b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#abc988c43c687b2af0b7e4352def7f19b">set</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> row, const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> &gt; &amp;col_indices, const std::vector&lt; PetscScalar &gt; &amp;values, const <a class="el" href="classbool.html">bool</a> elide_zero_values=false)</td></tr>
<tr class="separator:abc988c43c687b2af0b7e4352def7f19b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9fe7cc7dd404261b63b7ee651233de1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#ae9fe7cc7dd404261b63b7ee651233de1">set</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> row, const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> n_cols, const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> *col_indices, const PetscScalar *values, const <a class="el" href="classbool.html">bool</a> elide_zero_values=false)</td></tr>
<tr class="separator:ae9fe7cc7dd404261b63b7ee651233de1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a017ad4b1e0e18954db42d489e91ed0bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a017ad4b1e0e18954db42d489e91ed0bb">add</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> i, const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> j, const PetscScalar value)</td></tr>
<tr class="separator:a017ad4b1e0e18954db42d489e91ed0bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97b079c5bf7843592a347a9874752eef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a97b079c5bf7843592a347a9874752eef">add</a> (const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> &gt; &amp;indices, const <a class="el" href="classPETScWrappers_1_1FullMatrix.html">FullMatrix</a>&lt; PetscScalar &gt; &amp;full_matrix, const <a class="el" href="classbool.html">bool</a> elide_zero_values=true)</td></tr>
<tr class="separator:a97b079c5bf7843592a347a9874752eef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a068368a605f2661042e104f0ad3eef47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a068368a605f2661042e104f0ad3eef47">add</a> (const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> &gt; &amp;row_indices, const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> &gt; &amp;col_indices, const <a class="el" href="classPETScWrappers_1_1FullMatrix.html">FullMatrix</a>&lt; PetscScalar &gt; &amp;full_matrix, const <a class="el" href="classbool.html">bool</a> elide_zero_values=true)</td></tr>
<tr class="separator:a068368a605f2661042e104f0ad3eef47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8298c20ffaf1ba83c286e119fd53e7d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a8298c20ffaf1ba83c286e119fd53e7d0">add</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> row, const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> &gt; &amp;col_indices, const std::vector&lt; PetscScalar &gt; &amp;values, const <a class="el" href="classbool.html">bool</a> elide_zero_values=true)</td></tr>
<tr class="separator:a8298c20ffaf1ba83c286e119fd53e7d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abec5dd7bf11e94aeeeca18e94576c06e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#abec5dd7bf11e94aeeeca18e94576c06e">add</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> row, const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> n_cols, const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> *col_indices, const PetscScalar *values, const <a class="el" href="classbool.html">bool</a> elide_zero_values=true, const <a class="el" href="classbool.html">bool</a> col_indices_are_sorted=false)</td></tr>
<tr class="separator:abec5dd7bf11e94aeeeca18e94576c06e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af918fe8858fea210e01de289340c2468"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#af918fe8858fea210e01de289340c2468">clear_row</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> row, const PetscScalar new_diag_value=0)</td></tr>
<tr class="separator:af918fe8858fea210e01de289340c2468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25c2d67d301ec5cb4181b071168a6783"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a25c2d67d301ec5cb4181b071168a6783">clear_rows</a> (const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> &gt; &amp;rows, const PetscScalar new_diag_value=0)</td></tr>
<tr class="separator:a25c2d67d301ec5cb4181b071168a6783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a915064dcbbb9ad4b442dbe5c5549cf80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a915064dcbbb9ad4b442dbe5c5549cf80">compress</a> (::VectorOperation::values operation)</td></tr>
<tr class="separator:a915064dcbbb9ad4b442dbe5c5549cf80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8009bfff8d1f0c5bf2f937fe432cc07d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a8009bfff8d1f0c5bf2f937fe432cc07d">compress</a> () <a class="el" href="group__Sparsity.html#ga0849dabf81f46d4d964e251c286784dd">DEAL_II_DEPRECATED</a></td></tr>
<tr class="separator:a8009bfff8d1f0c5bf2f937fe432cc07d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aade3f2e65a4577eb8c0e3555f89d57c3"><td class="memItemLeft" align="right" valign="top">PetscScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#aade3f2e65a4577eb8c0e3555f89d57c3">operator()</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> i, const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> j) const </td></tr>
<tr class="separator:aade3f2e65a4577eb8c0e3555f89d57c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22984c60a5fe9068660fabd40a5ce53d"><td class="memItemLeft" align="right" valign="top">PetscScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a22984c60a5fe9068660fabd40a5ce53d">el</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> i, const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> j) const </td></tr>
<tr class="separator:a22984c60a5fe9068660fabd40a5ce53d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95933bbb4071c848a8b92d4485036faa"><td class="memItemLeft" align="right" valign="top">PetscScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a95933bbb4071c848a8b92d4485036faa">diag_element</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> i) const </td></tr>
<tr class="separator:a95933bbb4071c848a8b92d4485036faa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a160bb716f3c1b1ae61a2236202bc1548"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a160bb716f3c1b1ae61a2236202bc1548">m</a> () const </td></tr>
<tr class="separator:a160bb716f3c1b1ae61a2236202bc1548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b6f48b837cb76abd399b88c1b403511"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a0b6f48b837cb76abd399b88c1b403511">n</a> () const </td></tr>
<tr class="separator:a0b6f48b837cb76abd399b88c1b403511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af999bbdae2681f194851fd6324339b9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#af999bbdae2681f194851fd6324339b9b">local_size</a> () const </td></tr>
<tr class="separator:af999bbdae2681f194851fd6324339b9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab423cd9ac2486652bc25f454203e3a8d"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a>, <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#ab423cd9ac2486652bc25f454203e3a8d">local_range</a> () const </td></tr>
<tr class="separator:ab423cd9ac2486652bc25f454203e3a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b7add56ba269c8bb28bdfd84ae01bcb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a3b7add56ba269c8bb28bdfd84ae01bcb">in_local_range</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> index) const </td></tr>
<tr class="separator:a3b7add56ba269c8bb28bdfd84ae01bcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1aadd5aebcdc166b840df3430a23606"><td class="memItemLeft" align="right" valign="top">virtual const MPI_Comm &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#ae1aadd5aebcdc166b840df3430a23606">get_mpi_communicator</a> () const =0</td></tr>
<tr class="separator:ae1aadd5aebcdc166b840df3430a23606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae25dabe0da4df7a6fb304aab79b2229c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#ae25dabe0da4df7a6fb304aab79b2229c">n_nonzero_elements</a> () const </td></tr>
<tr class="separator:ae25dabe0da4df7a6fb304aab79b2229c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a043c524171974cccf7d3a4d2083e283c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a043c524171974cccf7d3a4d2083e283c">row_length</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> row) const </td></tr>
<tr class="separator:a043c524171974cccf7d3a4d2083e283c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37269099033157d4672084019cd1cdd8"><td class="memItemLeft" align="right" valign="top">PetscReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a37269099033157d4672084019cd1cdd8">l1_norm</a> () const </td></tr>
<tr class="separator:a37269099033157d4672084019cd1cdd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c7c4a43d023399a418f48f405f6b353"><td class="memItemLeft" align="right" valign="top">PetscReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a7c7c4a43d023399a418f48f405f6b353">linfty_norm</a> () const </td></tr>
<tr class="separator:a7c7c4a43d023399a418f48f405f6b353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1784d8b3dd267cc2baf9de49cb20ee26"><td class="memItemLeft" align="right" valign="top">PetscReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a1784d8b3dd267cc2baf9de49cb20ee26">frobenius_norm</a> () const </td></tr>
<tr class="separator:a1784d8b3dd267cc2baf9de49cb20ee26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6384d2f86acd571191846e2be0c36c8"><td class="memItemLeft" align="right" valign="top">PetscScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#ad6384d2f86acd571191846e2be0c36c8">matrix_norm_square</a> (const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;v) const </td></tr>
<tr class="separator:ad6384d2f86acd571191846e2be0c36c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bc3c46020d6e6d7b30b15240ebc3721"><td class="memItemLeft" align="right" valign="top">PetscScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a5bc3c46020d6e6d7b30b15240ebc3721">matrix_scalar_product</a> (const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;u, const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;v) const </td></tr>
<tr class="separator:a5bc3c46020d6e6d7b30b15240ebc3721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fe8d5b551795ecf72ab341d761f6286"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a2fe8d5b551795ecf72ab341d761f6286">operator*=</a> (const PetscScalar factor)</td></tr>
<tr class="separator:a2fe8d5b551795ecf72ab341d761f6286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93432e7f384d42eb0790e4911cf2b0fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a93432e7f384d42eb0790e4911cf2b0fa">operator/=</a> (const PetscScalar factor)</td></tr>
<tr class="separator:a93432e7f384d42eb0790e4911cf2b0fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ebcb9648709b8ccb058b72214b8fdb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4ebcb9648709b8ccb058b72214b8fdb8">add</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp;other, const PetscScalar factor)</td></tr>
<tr class="separator:a4ebcb9648709b8ccb058b72214b8fdb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfe2eed88867f29534b2779a972a7c68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#abfe2eed88867f29534b2779a972a7c68">vmult</a> (<a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;dst, const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;src) const </td></tr>
<tr class="separator:abfe2eed88867f29534b2779a972a7c68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af59aa059096e7a99492fb3c5a14ad9ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#af59aa059096e7a99492fb3c5a14ad9ed">Tvmult</a> (<a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;dst, const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;src) const </td></tr>
<tr class="separator:af59aa059096e7a99492fb3c5a14ad9ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2590978107e33f54baf5b5f88c0c1353"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a2590978107e33f54baf5b5f88c0c1353">vmult_add</a> (<a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;dst, const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;src) const </td></tr>
<tr class="separator:a2590978107e33f54baf5b5f88c0c1353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b2bb8515088830246aa50cab7fd8ede"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a8b2bb8515088830246aa50cab7fd8ede">Tvmult_add</a> (<a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;dst, const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;src) const </td></tr>
<tr class="separator:a8b2bb8515088830246aa50cab7fd8ede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8d48930fe206963c8af4d1aa1535f74"><td class="memItemLeft" align="right" valign="top">PetscScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#ab8d48930fe206963c8af4d1aa1535f74">residual</a> (<a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;dst, const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;x, const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;b) const </td></tr>
<tr class="separator:ab8d48930fe206963c8af4d1aa1535f74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4de878181eb3b3ca47fc103acc906192"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a9daaa67d19e61e1f59135e31b6002820">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4de878181eb3b3ca47fc103acc906192">begin</a> () const </td></tr>
<tr class="separator:a4de878181eb3b3ca47fc103acc906192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac80404c8c8e761537bbaa3058163eba7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a9daaa67d19e61e1f59135e31b6002820">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#ac80404c8c8e761537bbaa3058163eba7">end</a> () const </td></tr>
<tr class="separator:ac80404c8c8e761537bbaa3058163eba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ae944890718e1c2d3b0822a49535f3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a9daaa67d19e61e1f59135e31b6002820">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a6ae944890718e1c2d3b0822a49535f3c">begin</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> r) const </td></tr>
<tr class="separator:a6ae944890718e1c2d3b0822a49535f3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb280e9cca362081748098cf6381efa3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a9daaa67d19e61e1f59135e31b6002820">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#aeb280e9cca362081748098cf6381efa3">end</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> r) const </td></tr>
<tr class="separator:aeb280e9cca362081748098cf6381efa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a475d3b2788947c60c18368c5136b118c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a475d3b2788947c60c18368c5136b118c">operator Mat</a> () const </td></tr>
<tr class="separator:a475d3b2788947c60c18368c5136b118c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacd76b6ce3247735964836a82eedff6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#aacd76b6ce3247735964836a82eedff6d">transpose</a> ()</td></tr>
<tr class="separator:aacd76b6ce3247735964836a82eedff6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a1057a35382b7c328e6c85b0f5ab35e"><td class="memItemLeft" align="right" valign="top">PetscBool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4a1057a35382b7c328e6c85b0f5ab35e">is_symmetric</a> (const <a class="el" href="classdouble.html">double</a> tolerance=1.e-12)</td></tr>
<tr class="separator:a4a1057a35382b7c328e6c85b0f5ab35e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f2f6b575f15d540cf10688b30d09941"><td class="memItemLeft" align="right" valign="top">PetscBool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a9f2f6b575f15d540cf10688b30d09941">is_hermitian</a> (const <a class="el" href="classdouble.html">double</a> tolerance=1.e-12)</td></tr>
<tr class="separator:a9f2f6b575f15d540cf10688b30d09941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad127fd1b40ab452473f96cc298694528"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#ad127fd1b40ab452473f96cc298694528">write_ascii</a> (const PetscViewerFormat format=PETSC_VIEWER_DEFAULT)</td></tr>
<tr class="separator:ad127fd1b40ab452473f96cc298694528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeba561ab61b88e8e539811c7d027d666"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#aeba561ab61b88e8e539811c7d027d666">print</a> (std::ostream &amp;out, const <a class="el" href="classbool.html">bool</a> alternative_output=false) const </td></tr>
<tr class="separator:aeba561ab61b88e8e539811c7d027d666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada1faf78188cc004e37f434b0dee3b73"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#ada1faf78188cc004e37f434b0dee3b73">memory_consumption</a> () const </td></tr>
<tr class="separator:ada1faf78188cc004e37f434b0dee3b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac259b4fe62daef327601fc164bea599d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#ac259b4fe62daef327601fc164bea599d">DeclException1</a> (ExcPETScError, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;An error with error number &quot;&lt;&lt; arg1&lt;&lt; &quot; occurred while calling a PETSc function&quot;)</td></tr>
<tr class="separator:ac259b4fe62daef327601fc164bea599d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd31cbb4b540e89923f4bc6a5076ca61"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#abd31cbb4b540e89923f4bc6a5076ca61">DeclException0</a> (ExcSourceEqualsDestination)</td></tr>
<tr class="separator:abd31cbb4b540e89923f4bc6a5076ca61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af59cfefb39923e02ba470989f13478af"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#af59cfefb39923e02ba470989f13478af">DeclException2</a> (ExcWrongMode, <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;You tried to do a &quot;&lt;&lt; (arg1==1?&quot;'set'&quot;:(arg1==2?&quot;'add'&quot;:&quot;???&quot;))&lt;&lt; &quot; operation but the <a class="el" href="classPETScWrappers_1_1MatrixBase.html#abfce46e53089351cc7fe6b9ea44e167f">matrix</a> is currently in &quot;&lt;&lt; (arg2==1?&quot;'set'&quot;:(arg2==2?&quot;'add'&quot;:&quot;???&quot;))&lt;&lt; &quot; mode. You first have to call '<a class="el" href="classPETScWrappers_1_1MatrixBase.html#a915064dcbbb9ad4b442dbe5c5549cf80">compress</a>()'.&quot;)</td></tr>
<tr class="separator:af59cfefb39923e02ba470989f13478af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSubscriptor"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSubscriptor')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSubscriptor.html">Subscriptor</a></td></tr>
<tr class="memitem:ae5541017c0966b0af345db75895106f2 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#ae5541017c0966b0af345db75895106f2">Subscriptor</a> ()</td></tr>
<tr class="separator:ae5541017c0966b0af345db75895106f2 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367fce3122075f05f168d14f114b4c65 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a367fce3122075f05f168d14f114b4c65">Subscriptor</a> (const <a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;)</td></tr>
<tr class="separator:a367fce3122075f05f168d14f114b4c65 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c6c557e06110d2127fa6459119e94af inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a6c6c557e06110d2127fa6459119e94af">~Subscriptor</a> ()</td></tr>
<tr class="separator:a6c6c557e06110d2127fa6459119e94af inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24ee69d4b3cf9690d1208b2443cbbb80 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a24ee69d4b3cf9690d1208b2443cbbb80">operator=</a> (const <a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;)</td></tr>
<tr class="separator:a24ee69d4b3cf9690d1208b2443cbbb80 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3422499827ecd52f1d12d65eb6cc3125 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a3422499827ecd52f1d12d65eb6cc3125">subscribe</a> (const char *identifier=0) const </td></tr>
<tr class="separator:a3422499827ecd52f1d12d65eb6cc3125 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b4839b1cffc18781144ede1744b35ea inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a2b4839b1cffc18781144ede1744b35ea">unsubscribe</a> (const char *identifier=0) const </td></tr>
<tr class="separator:a2b4839b1cffc18781144ede1744b35ea inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b45274c8e1936bff024df01d618e86f inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a7b45274c8e1936bff024df01d618e86f">n_subscriptions</a> () const </td></tr>
<tr class="separator:a7b45274c8e1936bff024df01d618e86f inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbbc5f845063b1f23223b7ac96e89e13 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#adbbc5f845063b1f23223b7ac96e89e13">list_subscribers</a> () const </td></tr>
<tr class="separator:adbbc5f845063b1f23223b7ac96e89e13 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2f0251d20c6a5295024de3b2e9b4359 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac2f0251d20c6a5295024de3b2e9b4359">DeclException3</a> (ExcInUse, <a class="el" href="classint.html">int</a>, char *, std::string &amp;,&lt;&lt; &quot;Object of class &quot;&lt;&lt; arg2&lt;&lt; &quot; is still used by &quot;&lt;&lt; arg1&lt;&lt; &quot; other objects.\n&quot;&lt;&lt; &quot;(Additional information: &quot;&lt;&lt; arg3&lt;&lt; &quot;)\n&quot;&lt;&lt; &quot;Note the entry in the Frequently Asked Questions of &quot;&lt;&lt; &quot;deal.II (linked to from http://www.dealii.org/) for &quot;&lt;&lt; &quot;more information on what this error means.&quot;)</td></tr>
<tr class="separator:gac2f0251d20c6a5295024de3b2e9b4359 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e000d9ce953da6afe4bbbaca4397344 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga9e000d9ce953da6afe4bbbaca4397344">DeclException2</a> (ExcNoSubscriber, char *, char *,&lt;&lt; &quot;No subscriber with identifier \&quot;&quot;&lt;&lt; arg2&lt;&lt; &quot;\&quot; did <a class="el" href="classSubscriptor.html#a3422499827ecd52f1d12d65eb6cc3125">subscribe</a> to this object of class &quot;&lt;&lt; arg1)</td></tr>
<tr class="separator:ga9e000d9ce953da6afe4bbbaca4397344 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38 inherit pub_methods_classSubscriptor"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38 inherit pub_methods_classSubscriptor"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:a68efd17a8330ab676d9cd711029b0f38 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ac69aa69edd57e14e08ba06b93ac1fe59"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#ac69aa69edd57e14e08ba06b93ac1fe59">prepare_action</a> (const LastAction::Values new_action)</td></tr>
<tr class="separator:ac69aa69edd57e14e08ba06b93ac1fe59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6e49d52a74cc86386a9aff01fa88c74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#aa6e49d52a74cc86386a9aff01fa88c74">prepare_add</a> ()</td></tr>
<tr class="separator:aa6e49d52a74cc86386a9aff01fa88c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d1b00916f856722282dcd9abb408581"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a9d1b00916f856722282dcd9abb408581">prepare_set</a> ()</td></tr>
<tr class="separator:a9d1b00916f856722282dcd9abb408581"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:abfce46e53089351cc7fe6b9ea44e167f"><td class="memItemLeft" align="right" valign="top">Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#abfce46e53089351cc7fe6b9ea44e167f">matrix</a></td></tr>
<tr class="separator:abfce46e53089351cc7fe6b9ea44e167f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad517ed5d8147c48867f54a59cfe86991"><td class="memItemLeft" align="right" valign="top">LastAction::Values&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#ad517ed5d8147c48867f54a59cfe86991">last_action</a></td></tr>
<tr class="separator:ad517ed5d8147c48867f54a59cfe86991"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ac9d0bef234b3bee00f709ae9506c4b78"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#ac9d0bef234b3bee00f709ae9506c4b78">MatrixBase</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp;)</td></tr>
<tr class="separator:ac9d0bef234b3bee00f709ae9506c4b78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7066ca270f211ac404fa88310535f706"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a7066ca270f211ac404fa88310535f706">operator=</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp;)</td></tr>
<tr class="separator:a7066ca270f211ac404fa88310535f706"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:aa0f173897e0d5d926636e85aa68c7286"><td class="memItemLeft" align="right" valign="top">std::vector&lt; PetscInt &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#aa0f173897e0d5d926636e85aa68c7286">column_indices</a></td></tr>
<tr class="separator:aa0f173897e0d5d926636e85aa68c7286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a289dc1463501c97a48127414ce5ee1ac"><td class="memItemLeft" align="right" valign="top">std::vector&lt; PetscScalar &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a289dc1463501c97a48127414ce5ee1ac">column_values</a></td></tr>
<tr class="separator:a289dc1463501c97a48127414ce5ee1ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:aad4d4720fcda9813b7fdcd3f0cb04ac6"><td class="memTemplParams" colspan="2">template&lt;class &gt; </td></tr>
<tr class="memitem:aad4d4720fcda9813b7fdcd3f0cb04ac6"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#aad4d4720fcda9813b7fdcd3f0cb04ac6">::BlockMatrixBase</a></td></tr>
<tr class="separator:aad4d4720fcda9813b7fdcd3f0cb04ac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Base class for all matrix classes that are implemented on top of the PETSc matrix types. Since in PETSc all matrix types (i.e. sequential and parallel, sparse, blocked, etc.) are built by filling the contents of an abstract object that is only referenced through a pointer of a type that is independent of the actual matrix type, we can implement almost all functionality of matrices in this base class. Derived classes will then only have to provide the functionality to create one or the other kind of matrix.</p>
<p>The interface of this class is modeled after the existing <a class="el" href="classPETScWrappers_1_1SparseMatrix.html">SparseMatrix</a> class in deal.II. It has almost the same member functions, and is often exchangable. However, since PETSc only supports a single scalar type (either double, float, or a complex data type), it is not templated, and only works with whatever your PETSc installation has defined the data type PetscScalar to.</p>
<p>Note that PETSc only guarantees that operations do what you expect if the functions <code>MatAssemblyBegin</code> and <code>MatAssemblyEnd</code> have been called after matrix assembly. Therefore, you need to call <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a8009bfff8d1f0c5bf2f937fe432cc07d">SparseMatrix::compress()</a> before you actually use the matrix. This also calls <code>MatCompress</code> that compresses the storage format for sparse matrices by discarding unused elements. PETSc allows to continue with assembling the matrix after calls to these functions, but since there are no more free entries available after that any more, it is better to only call <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a8009bfff8d1f0c5bf2f937fe432cc07d">SparseMatrix::compress()</a> once at the end of the assembly stage and before the matrix is actively used.</p>
<dl class="section author"><dt>Author</dt><dd>Wolfgang Bangerth, 2004 </dd></dl>

<p>Definition at line <a class="el" href="petsc__matrix__base_8h_source.html#l00306">306</a> of file <a class="el" href="petsc__matrix__base_8h_source.html">petsc_matrix_base.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a9daaa67d19e61e1f59135e31b6002820"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classPETScWrappers_1_1MatrixIterators_1_1const__iterator.html">MatrixIterators::const_iterator</a> <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a9daaa67d19e61e1f59135e31b6002820">PETScWrappers::MatrixBase::const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare a typedef for the iterator class. </p>

<p>Definition at line <a class="el" href="petsc__matrix__base_8h_source.html#l00313">313</a> of file <a class="el" href="petsc__matrix__base_8h_source.html">petsc_matrix_base.h</a>.</p>

</div>
</div>
<a class="anchor" id="a02115578620b6df0638b8754bad6aaaa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">PETScWrappers::MatrixBase::size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare type for container size. </p>

<p>Definition at line <a class="el" href="petsc__matrix__base_8h_source.html#l00318">318</a> of file <a class="el" href="petsc__matrix__base_8h_source.html">petsc_matrix_base.h</a>.</p>

</div>
</div>
<a class="anchor" id="af69f9f200e7a90df0c74bd9a96bb9cd8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef PetscScalar <a class="el" href="classPETScWrappers_1_1MatrixBase.html#af69f9f200e7a90df0c74bd9a96bb9cd8">PETScWrappers::MatrixBase::value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare a typedef in analogy to all the other container classes. </p>

<p>Definition at line <a class="el" href="petsc__matrix__base_8h_source.html#l00324">324</a> of file <a class="el" href="petsc__matrix__base_8h_source.html">petsc_matrix_base.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="afe8c5db4389d2eb35ea78e1b2db6c041"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PETScWrappers::MatrixBase::MatrixBase </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default constructor. </p>

</div>
</div>
<a class="anchor" id="aacca3ef8ca7e0c094407fb7a66d3a7f2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PETScWrappers::MatrixBase::~MatrixBase </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor. Made virtual so that one can use pointers to this class. </p>

</div>
</div>
<a class="anchor" id="ac9d0bef234b3bee00f709ae9506c4b78"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PETScWrappers::MatrixBase::MatrixBase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>purposefully not implemented </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a456bd309a8f32efc7e25c02cf3afa80e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a>&amp; PETScWrappers::MatrixBase::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#af69f9f200e7a90df0c74bd9a96bb9cd8">value_type</a>&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This operator assigns a scalar to a matrix. Since this does usually not make much sense (should we set all matrix entries to this value? Only the nonzero entries of the sparsity pattern?), this operation is only allowed if the actual value to be assigned is zero. This operator only exists to allow for the obvious notation <code>matrix=0</code>, which sets all elements of the matrix to zero, but keeps the sparsity pattern previously used. </p>

</div>
</div>
<a class="anchor" id="a1b895d26bc6c0a0cf96d37d00e5853c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Release all memory and return to a state just like after having called the default constructor. </p>

</div>
</div>
<a class="anchor" id="af5067751068b7290030fe97cc8cadd02"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscScalar&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the element (<em>i,j</em>) to <code>value</code>.</p>
<p>If the present object (from a derived class of this one) happens to be a sparse matrix, then this function adds a new entry to the matrix if it didn't exist before, very much in contrast to the <a class="el" href="classPETScWrappers_1_1SparseMatrix.html">SparseMatrix</a> class which throws an error if the entry does not exist. If <code>value</code> is not a finite number an exception is thrown. </p>

</div>
</div>
<a class="anchor" id="af2a6e591d33f2af5e44a20c8b3e30943"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::set </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1FullMatrix.html">FullMatrix</a>&lt; PetscScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>full_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set all elements given in a <a class="el" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> into the sparse matrix locations given by <code>indices</code>. In other words, this function writes the elements in <code>full_matrix</code> into the calling matrix, using the local-to-global indexing specified by <code>indices</code> for both the rows and the columns of the matrix. This function assumes a quadratic sparse matrix and a quadratic full_matrix, the usual situation in FE calculations.</p>
<p>If the present object (from a derived class of this one) happens to be a sparse matrix, then this function adds some new entries to the matrix if they didn't exist before, very much in contrast to the <a class="el" href="classPETScWrappers_1_1SparseMatrix.html">SparseMatrix</a> class which throws an error if the entry does not exist.</p>
<p>The optional parameter <code>elide_zero_values</code> can be used to specify whether zero values should be inserted anyway or they should be filtered away. The default value is <code>false</code>, i.e., even zero values are inserted/replaced. </p>

</div>
</div>
<a class="anchor" id="a90d04e83f54969c8c504da62bdee60a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::set </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1FullMatrix.html">FullMatrix</a>&lt; PetscScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>full_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same function as before, but now including the possibility to use rectangular full_matrices and different local-to-global indexing on rows and columns, respectively. </p>

</div>
</div>
<a class="anchor" id="abc988c43c687b2af0b7e4352def7f19b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; PetscScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set several elements in the specified row of the matrix with column indices as given by <code>col_indices</code> to the respective value.</p>
<p>If the present object (from a derived class of this one) happens to be a sparse matrix, then this function adds some new entries to the matrix if they didn't exist before, very much in contrast to the <a class="el" href="classPETScWrappers_1_1SparseMatrix.html">SparseMatrix</a> class which throws an error if the entry does not exist.</p>
<p>The optional parameter <code>elide_zero_values</code> can be used to specify whether zero values should be inserted anyway or they should be filtered away. The default value is <code>false</code>, i.e., even zero values are inserted/replaced. </p>

</div>
</div>
<a class="anchor" id="ae9fe7cc7dd404261b63b7ee651233de1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a>&#160;</td>
          <td class="paramname"><em>n_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> *&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscScalar *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set several elements to values given by <code>values</code> in a given row in columns given by col_indices into the sparse matrix.</p>
<p>If the present object (from a derived class of this one) happens to be a sparse matrix, then this function adds some new entries to the matrix if they didn't exist before, very much in contrast to the <a class="el" href="classPETScWrappers_1_1SparseMatrix.html">SparseMatrix</a> class which throws an error if the entry does not exist.</p>
<p>The optional parameter <code>elide_zero_values</code> can be used to specify whether zero values should be inserted anyway or they should be filtered away. The default value is <code>false</code>, i.e., even zero values are inserted/replaced. </p>

</div>
</div>
<a class="anchor" id="a017ad4b1e0e18954db42d489e91ed0bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscScalar&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add <code>value</code> to the element (<em>i,j</em>).</p>
<p>If the present object (from a derived class of this one) happens to be a sparse matrix, then this function adds a new entry to the matrix if it didn't exist before, very much in contrast to the <a class="el" href="classPETScWrappers_1_1SparseMatrix.html">SparseMatrix</a> class which throws an error if the entry does not exist. If <code>value</code> is not a finite number an exception is thrown. </p>

</div>
</div>
<a class="anchor" id="a97b079c5bf7843592a347a9874752eef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::add </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1FullMatrix.html">FullMatrix</a>&lt; PetscScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>full_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add all elements given in a <a class="el" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> into sparse matrix locations given by <code>indices</code>. In other words, this function adds the elements in <code>full_matrix</code> to the respective entries in calling matrix, using the local-to-global indexing specified by <code>indices</code> for both the rows and the columns of the matrix. This function assumes a quadratic sparse matrix and a quadratic full_matrix, the usual situation in FE calculations.</p>
<p>If the present object (from a derived class of this one) happens to be a sparse matrix, then this function adds some new entries to the matrix if they didn't exist before, very much in contrast to the <a class="el" href="classPETScWrappers_1_1SparseMatrix.html">SparseMatrix</a> class which throws an error if the entry does not exist.</p>
<p>The optional parameter <code>elide_zero_values</code> can be used to specify whether zero values should be added anyway or these should be filtered away and only non-zero data is added. The default value is <code>true</code>, i.e., zero values won't be added into the matrix. </p>

</div>
</div>
<a class="anchor" id="a068368a605f2661042e104f0ad3eef47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::add </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1FullMatrix.html">FullMatrix</a>&lt; PetscScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>full_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same function as before, but now including the possibility to use rectangular full_matrices and different local-to-global indexing on rows and columns, respectively. </p>

</div>
</div>
<a class="anchor" id="a8298c20ffaf1ba83c286e119fd53e7d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; PetscScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set several elements in the specified row of the matrix with column indices as given by <code>col_indices</code> to the respective value.</p>
<p>If the present object (from a derived class of this one) happens to be a sparse matrix, then this function adds some new entries to the matrix if they didn't exist before, very much in contrast to the <a class="el" href="classPETScWrappers_1_1SparseMatrix.html">SparseMatrix</a> class which throws an error if the entry does not exist.</p>
<p>The optional parameter <code>elide_zero_values</code> can be used to specify whether zero values should be added anyway or these should be filtered away and only non-zero data is added. The default value is <code>true</code>, i.e., zero values won't be added into the matrix. </p>

</div>
</div>
<a class="anchor" id="abec5dd7bf11e94aeeeca18e94576c06e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a>&#160;</td>
          <td class="paramname"><em>n_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> *&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscScalar *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>col_indices_are_sorted</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add an array of values given by <code>values</code> in the given global matrix row at columns specified by col_indices in the sparse matrix.</p>
<p>If the present object (from a derived class of this one) happens to be a sparse matrix, then this function adds some new entries to the matrix if they didn't exist before, very much in contrast to the <a class="el" href="classPETScWrappers_1_1SparseMatrix.html">SparseMatrix</a> class which throws an error if the entry does not exist.</p>
<p>The optional parameter <code>elide_zero_values</code> can be used to specify whether zero values should be added anyway or these should be filtered away and only non-zero data is added. The default value is <code>true</code>, i.e., zero values won't be added into the matrix. </p>

</div>
</div>
<a class="anchor" id="af918fe8858fea210e01de289340c2468"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::clear_row </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscScalar&#160;</td>
          <td class="paramname"><em>new_diag_value</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove all elements from this <code>row</code> by setting them to zero. The function does not modify the number of allocated nonzero entries, it only sets some entries to zero. It may drop them from the sparsity pattern, though (but retains the allocated memory in case new entries are again added later).</p>
<p>This operation is used in eliminating constraints (e.g. due to hanging nodes) and makes sure that we can write this modification to the matrix without having to read entries (such as the locations of non-zero elements) from it &ndash; without this operation, removing constraints on parallel matrices is a rather complicated procedure.</p>
<p>The second parameter can be used to set the diagonal entry of this row to a value different from zero. The default is to set it to zero. </p>

</div>
</div>
<a class="anchor" id="a25c2d67d301ec5cb4181b071168a6783"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::clear_rows </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscScalar&#160;</td>
          <td class="paramname"><em>new_diag_value</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as <a class="el" href="classPETScWrappers_1_1MatrixBase.html#af918fe8858fea210e01de289340c2468">clear_row()</a>, except that it works on a number of rows at once.</p>
<p>The second parameter can be used to set the diagonal entries of all cleared rows to something different from zero. Note that all of these diagonal entries get the same value &ndash; if you want different values for the diagonal entries, you have to set them by hand. </p>

</div>
</div>
<a class="anchor" id="a915064dcbbb9ad4b442dbe5c5549cf80"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::compress </td>
          <td>(</td>
          <td class="paramtype">::VectorOperation::values&#160;</td>
          <td class="paramname"><em>operation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>PETSc matrices store their own sparsity patterns. So, in analogy to our own <a class="el" href="classSparsityPattern.html">SparsityPattern</a> class, this function compresses the sparsity pattern and allows the resulting matrix to be used in all other operations where before only assembly functions were allowed. This function must therefore be called once you have assembled the matrix.</p>
<p>See <a class="el" href="DEALGlossary.html#GlossCompress">Compressing distributed objects</a> for more information. more information. </p>

</div>
</div>
<a class="anchor" id="a8009bfff8d1f0c5bf2f937fe432cc07d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::compress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000092">Deprecated:</a></b></dt><dd>: use <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a8009bfff8d1f0c5bf2f937fe432cc07d">compress()</a> with <a class="el" href="structVectorOperation.html">VectorOperation</a> instead. </dd></dl>

</div>
</div>
<a class="anchor" id="aade3f2e65a4577eb8c0e3555f89d57c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscScalar PETScWrappers::MatrixBase::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the value of the entry (<em>i,j</em>). This may be an expensive operation and you should always take care where to call this function. In contrast to the respective function in the <code><a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a></code> class, we don't throw an exception if the respective entry doesn't exist in the sparsity pattern of this class, since PETSc does not transmit this information.</p>
<p>This function is therefore exactly equivalent to the <code><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a22984c60a5fe9068660fabd40a5ce53d">el()</a></code> function. </p>

</div>
</div>
<a class="anchor" id="a22984c60a5fe9068660fabd40a5ce53d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscScalar PETScWrappers::MatrixBase::el </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the value of the matrix entry (<em>i,j</em>). If this entry does not exist in the sparsity pattern, then zero is returned. While this may be convenient in some cases, note that it is simple to write algorithms that are slow compared to an optimal solution, since the sparsity of the matrix is not used. </p>

</div>
</div>
<a class="anchor" id="a95933bbb4071c848a8b92d4485036faa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscScalar PETScWrappers::MatrixBase::diag_element </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the main diagonal element in the <em>i</em>th row. This function throws an error if the matrix is not quadratic.</p>
<p>Since we do not have direct access to the underlying data structure, this function is no faster than the elementwise access using the <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a22984c60a5fe9068660fabd40a5ce53d">el()</a> function. However, we provide this function for compatibility with the <a class="el" href="classPETScWrappers_1_1SparseMatrix.html">SparseMatrix</a> class. </p>

</div>
</div>
<a class="anchor" id="a160bb716f3c1b1ae61a2236202bc1548"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> PETScWrappers::MatrixBase::m </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of rows in this matrix. </p>

</div>
</div>
<a class="anchor" id="a0b6f48b837cb76abd399b88c1b403511"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> PETScWrappers::MatrixBase::n </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of columns in this matrix. </p>

</div>
</div>
<a class="anchor" id="af999bbdae2681f194851fd6324339b9b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> PETScWrappers::MatrixBase::local_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the local dimension of the matrix, i.e. the number of rows stored on the present <a class="el" href="namespacePETScWrappers_1_1MPI.html">MPI</a> process. For sequential matrices, this number is the same as <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a160bb716f3c1b1ae61a2236202bc1548">m()</a>, but for parallel matrices it may be smaller.</p>
<p>To figure out which elements exactly are stored locally, use <a class="el" href="classPETScWrappers_1_1MatrixBase.html#ab423cd9ac2486652bc25f454203e3a8d">local_range()</a>. </p>

</div>
</div>
<a class="anchor" id="ab423cd9ac2486652bc25f454203e3a8d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a>, <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a>&gt; PETScWrappers::MatrixBase::local_range </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a pair of indices indicating which rows of this matrix are stored locally. The first number is the index of the first row stored, the second the index of the one past the last one that is stored locally. If this is a sequential matrix, then the result will be the pair (0,<a class="el" href="classPETScWrappers_1_1MatrixBase.html#a160bb716f3c1b1ae61a2236202bc1548">m()</a>), otherwise it will be a pair (i,i+n), where <code>n=<a class="el" href="classPETScWrappers_1_1MatrixBase.html#af999bbdae2681f194851fd6324339b9b">local_size()</a></code>. </p>

</div>
</div>
<a class="anchor" id="a3b7add56ba269c8bb28bdfd84ae01bcb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> PETScWrappers::MatrixBase::in_local_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether <code>index</code> is in the local range or not, see also <a class="el" href="classPETScWrappers_1_1MatrixBase.html#ab423cd9ac2486652bc25f454203e3a8d">local_range()</a>. </p>

</div>
</div>
<a class="anchor" id="ae1aadd5aebcdc166b840df3430a23606"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const MPI_Comm&amp; PETScWrappers::MatrixBase::get_mpi_communicator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a reference to the <a class="el" href="namespacePETScWrappers_1_1MPI.html">MPI</a> communicator object in use with this matrix. This function has to be implemented in derived classes. </p>

<p>Implemented in <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html#a41433e57cb4dd5520bf1c3f761f53e81">PETScWrappers::MPI::SparseMatrix</a>, <a class="el" href="classPETScWrappers_1_1SparseMatrix.html#aa35a78a5114f6ac1b92cf7cc0eea143a">PETScWrappers::SparseMatrix</a>, <a class="el" href="classPETScWrappers_1_1MatrixFree.html#aaa8f5737535e3dbef2c3609614628bdb">PETScWrappers::MatrixFree</a>, and <a class="el" href="classPETScWrappers_1_1FullMatrix.html#ab89323889fd9cac9a6051a8f6cb257a5">PETScWrappers::FullMatrix</a>.</p>

</div>
</div>
<a class="anchor" id="ae25dabe0da4df7a6fb304aab79b2229c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> PETScWrappers::MatrixBase::n_nonzero_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of nonzero elements of this matrix. Actually, it returns the number of entries in the sparsity pattern; if any of the entries should happen to be zero, it is counted anyway. </p>

</div>
</div>
<a class="anchor" id="a043c524171974cccf7d3a4d2083e283c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> PETScWrappers::MatrixBase::row_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of entries in a specific row. </p>

</div>
</div>
<a class="anchor" id="a37269099033157d4672084019cd1cdd8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscReal PETScWrappers::MatrixBase::l1_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the l1-norm of the matrix, that is <img class="formulaInl" alt="$|M|_1=max_{all columns j}\sum_{all rows i} |M_ij|$" src="form_357.png"/>, (max. sum of columns). This is the natural matrix norm that is compatible to the l1-norm for vectors, i.e. <img class="formulaInl" alt="$|Mv|_1\leq |M|_1 |v|_1$" src="form_314.png"/>. (cf. Haemmerlin-Hoffmann: Numerische Mathematik) </p>

</div>
</div>
<a class="anchor" id="a7c7c4a43d023399a418f48f405f6b353"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscReal PETScWrappers::MatrixBase::linfty_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the linfty-norm of the matrix, that is <img class="formulaInl" alt="$|M|_infty=max_{all rows i}\sum_{all columns j} |M_ij|$" src="form_358.png"/>, (max. sum of rows). This is the natural matrix norm that is compatible to the linfty-norm of vectors, i.e. <img class="formulaInl" alt="$|Mv|_infty \leq |M|_infty |v|_infty$" src="form_359.png"/>. (cf. Haemmerlin-Hoffmann: Numerische Mathematik) </p>

</div>
</div>
<a class="anchor" id="a1784d8b3dd267cc2baf9de49cb20ee26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscReal PETScWrappers::MatrixBase::frobenius_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the frobenius norm of the matrix, i.e. the square root of the sum of squares of all entries in the matrix. </p>

</div>
</div>
<a class="anchor" id="ad6384d2f86acd571191846e2be0c36c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscScalar PETScWrappers::MatrixBase::matrix_norm_square </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the square of the norm of the vector <img class="formulaInl" alt="$v$" src="form_292.png"/> with respect to the norm induced by this matrix, i.e. <img class="formulaInl" alt="$\left(v,Mv\right)$" src="form_293.png"/>. This is useful, e.g. in the finite element context, where the <img class="formulaInl" alt="$L_2$" src="form_294.png"/> norm of a function equals the matrix norm with respect to the mass matrix of the vector representing the nodal values of the finite element function.</p>
<p>Obviously, the matrix needs to be quadratic for this operation.</p>
<p>The implementation of this function is not as efficient as the one in the <code><a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a></code> class used in deal.II (i.e. the original one, not the PETSc wrapper class) since PETSc doesn't support this operation and needs a temporary vector.</p>
<p>Note that if the current object represents a parallel distributed matrix (of type <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">PETScWrappers::MPI::SparseMatrix</a>), then the given vector has to be a distributed vector as well. Conversely, if the matrix is not distributed, then neither may the vector be. </p>

</div>
</div>
<a class="anchor" id="a5bc3c46020d6e6d7b30b15240ebc3721"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscScalar PETScWrappers::MatrixBase::matrix_scalar_product </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the matrix scalar product <img class="formulaInl" alt="$\left(u,Mv\right)$" src="form_295.png"/>.</p>
<p>The implementation of this function is not as efficient as the one in the <code><a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a></code> class used in deal.II (i.e. the original one, not the PETSc wrapper class) since PETSc doesn't support this operation and needs a temporary vector.</p>
<p>Note that if the current object represents a parallel distributed matrix (of type <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">PETScWrappers::MPI::SparseMatrix</a>), then both vectors have to be distributed vectors as well. Conversely, if the matrix is not distributed, then neither of the vectors may be. </p>

</div>
</div>
<a class="anchor" id="a2fe8d5b551795ecf72ab341d761f6286"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a>&amp; PETScWrappers::MatrixBase::operator*= </td>
          <td>(</td>
          <td class="paramtype">const PetscScalar&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiply the entire matrix by a fixed factor. </p>

</div>
</div>
<a class="anchor" id="a93432e7f384d42eb0790e4911cf2b0fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a>&amp; PETScWrappers::MatrixBase::operator/= </td>
          <td>(</td>
          <td class="paramtype">const PetscScalar&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Divide the entire matrix by a fixed factor. </p>

</div>
</div>
<a class="anchor" id="a4ebcb9648709b8ccb058b72214b8fdb8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a>&amp; PETScWrappers::MatrixBase::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscScalar&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add the matrix <code>other</code> scaled by the factor <code>factor</code> to the current matrix. </p>

</div>
</div>
<a class="anchor" id="abfe2eed88867f29534b2779a972a7c68"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::vmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Matrix-vector multiplication: let <em>dst = M*src</em> with <em>M</em> being this matrix.</p>
<p>Source and destination must not be the same vector.</p>
<p>Note that if the current object represents a parallel distributed matrix (of type <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">PETScWrappers::MPI::SparseMatrix</a>), then both vectors have to be distributed vectors as well. Conversely, if the matrix is not distributed, then neither of the vectors may be. </p>

</div>
</div>
<a class="anchor" id="af59aa059096e7a99492fb3c5a14ad9ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::Tvmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Matrix-vector multiplication: let <em>dst = M<sup>T</sup>*src</em> with <em>M</em> being this matrix. This function does the same as <a class="el" href="classPETScWrappers_1_1MatrixBase.html#abfe2eed88867f29534b2779a972a7c68">vmult()</a> but takes the transposed matrix.</p>
<p>Source and destination must not be the same vector.</p>
<p>Note that if the current object represents a parallel distributed matrix (of type <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">PETScWrappers::MPI::SparseMatrix</a>), then both vectors have to be distributed vectors as well. Conversely, if the matrix is not distributed, then neither of the vectors may be. </p>

</div>
</div>
<a class="anchor" id="a2590978107e33f54baf5b5f88c0c1353"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::vmult_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adding Matrix-vector multiplication. Add <em>M*src</em> on <em>dst</em> with <em>M</em> being this matrix.</p>
<p>Source and destination must not be the same vector.</p>
<p>Note that if the current object represents a parallel distributed matrix (of type <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">PETScWrappers::MPI::SparseMatrix</a>), then both vectors have to be distributed vectors as well. Conversely, if the matrix is not distributed, then neither of the vectors may be. </p>

</div>
</div>
<a class="anchor" id="a8b2bb8515088830246aa50cab7fd8ede"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::Tvmult_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adding Matrix-vector multiplication. Add <em>M<sup>T</sup>*src</em> to <em>dst</em> with <em>M</em> being this matrix. This function does the same as <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a2590978107e33f54baf5b5f88c0c1353">vmult_add()</a> but takes the transposed matrix.</p>
<p>Source and destination must not be the same vector.</p>
<p>Note that if the current object represents a parallel distributed matrix (of type <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">PETScWrappers::MPI::SparseMatrix</a>), then both vectors have to be distributed vectors as well. Conversely, if the matrix is not distributed, then neither of the vectors may be. </p>

</div>
</div>
<a class="anchor" id="ab8d48930fe206963c8af4d1aa1535f74"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscScalar PETScWrappers::MatrixBase::residual </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the residual of an equation <em>Mx=b</em>, where the residual is defined to be <em>r=b-Mx</em>. Write the residual into <code>dst</code>. The <em>l<sub>2</sub></em> norm of the residual vector is returned.</p>
<p>Source <em>x</em> and destination <em>dst</em> must not be the same vector.</p>
<p>Note that if the current object represents a parallel distributed matrix (of type <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">PETScWrappers::MPI::SparseMatrix</a>), then all vectors have to be distributed vectors as well. Conversely, if the matrix is not distributed, then neither of the vectors may be. </p>

</div>
</div>
<a class="anchor" id="a4de878181eb3b3ca47fc103acc906192"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a9daaa67d19e61e1f59135e31b6002820">const_iterator</a> PETScWrappers::MatrixBase::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>STL-like iterator with the first entry. </p>

</div>
</div>
<a class="anchor" id="ac80404c8c8e761537bbaa3058163eba7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a9daaa67d19e61e1f59135e31b6002820">const_iterator</a> PETScWrappers::MatrixBase::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Final iterator. </p>

</div>
</div>
<a class="anchor" id="a6ae944890718e1c2d3b0822a49535f3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a9daaa67d19e61e1f59135e31b6002820">const_iterator</a> PETScWrappers::MatrixBase::begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a>&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>STL-like iterator with the first entry of row <code>r</code>.</p>
<p>Note that if the given row is empty, i.e. does not contain any nonzero entries, then the iterator returned by this function equals <code>end(r)</code>. Note also that the iterator may not be dereferencable in that case. </p>

</div>
</div>
<a class="anchor" id="aeb280e9cca362081748098cf6381efa3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a9daaa67d19e61e1f59135e31b6002820">const_iterator</a> PETScWrappers::MatrixBase::end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a>&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Final iterator of row <code>r</code>. It points to the first element past the end of line <code>r</code>, or past the end of the entire sparsity pattern.</p>
<p>Note that the end iterator is not necessarily dereferencable. This is in particular the case if it is the end iterator for the last row of a matrix. </p>

</div>
</div>
<a class="anchor" id="a475d3b2788947c60c18368c5136b118c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PETScWrappers::MatrixBase::operator Mat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Conversion operator to gain access to the underlying PETSc type. If you do this, you cut this class off some information it may need, so this conversion operator should only be used if you know what you do. In particular, it should only be used for read-only operations into the matrix. </p>

</div>
</div>
<a class="anchor" id="aacd76b6ce3247735964836a82eedff6d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::transpose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make an in-place transpose of a matrix. </p>

</div>
</div>
<a class="anchor" id="a4a1057a35382b7c328e6c85b0f5ab35e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscBool PETScWrappers::MatrixBase::is_symmetric </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>1.e-12</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test whether a matrix is symmetric. Default tolerance is <img class="formulaInl" alt="$1000\times32$" src="form_379.png"/>-bit machine precision. </p>

</div>
</div>
<a class="anchor" id="a9f2f6b575f15d540cf10688b30d09941"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscBool PETScWrappers::MatrixBase::is_hermitian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>1.e-12</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test whether a matrix is Hermitian, i.e. it is the complex conjugate of its transpose. Default tolerance is <img class="formulaInl" alt="$1000\times32$" src="form_379.png"/>-bit machine precision. </p>

</div>
</div>
<a class="anchor" id="ad127fd1b40ab452473f96cc298694528"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::write_ascii </td>
          <td>(</td>
          <td class="paramtype">const PetscViewerFormat&#160;</td>
          <td class="paramname"><em>format</em> = <code>PETSC_VIEWER_DEFAULT</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints the PETSc matrix object values using PETSc internal matrix viewer function <code>MatView</code>. The default format prints the non-zero matrix elements. For other valid view formats, consult <a href="http://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/Mat/MatView.html">http://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/Mat/MatView.html</a> </p>

</div>
</div>
<a class="anchor" id="aeba561ab61b88e8e539811c7d027d666"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>alternative_output</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>print command, similar to write_ascii, but the same format as produced by Trilinos </p>

</div>
</div>
<a class="anchor" id="ada1faf78188cc004e37f434b0dee3b73"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t PETScWrappers::MatrixBase::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number bytes consumed by this matrix on this CPU. </p>

</div>
</div>
<a class="anchor" id="ac259b4fe62daef327601fc164bea599d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PETScWrappers::MatrixBase::DeclException1 </td>
          <td>(</td>
          <td class="paramtype">ExcPETScError&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;An error with error number &quot;&lt;&lt; arg1&lt;&lt; &quot; occurred while calling a PETSc function&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exception </p>

</div>
</div>
<a class="anchor" id="abd31cbb4b540e89923f4bc6a5076ca61"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PETScWrappers::MatrixBase::DeclException0 </td>
          <td>(</td>
          <td class="paramtype">ExcSourceEqualsDestination&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exception </p>

</div>
</div>
<a class="anchor" id="af59cfefb39923e02ba470989f13478af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PETScWrappers::MatrixBase::DeclException2 </td>
          <td>(</td>
          <td class="paramtype">ExcWrongMode&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;You tried to do a &quot;&lt;&lt; (arg1==1?&quot;'set'&quot;:(arg1==2?&quot;'add'&quot;:&quot;???&quot;))&lt;&lt; &quot; operation but the <a class="el" href="classPETScWrappers_1_1MatrixBase.html#abfce46e53089351cc7fe6b9ea44e167f">matrix</a> is currently in &quot;&lt;&lt; (arg2==1?&quot;'set'&quot;:(arg2==2?&quot;'add'&quot;:&quot;???&quot;))&lt;&lt; &quot; mode. You first have to call '<a class="el" href="classPETScWrappers_1_1MatrixBase.html#a915064dcbbb9ad4b442dbe5c5549cf80">compress</a>()'.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exception. </p>

</div>
</div>
<a class="anchor" id="ac69aa69edd57e14e08ba06b93ac1fe59"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::prepare_action </td>
          <td>(</td>
          <td class="paramtype">const LastAction::Values&#160;</td>
          <td class="paramname"><em>new_action</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Ensure that the add/set mode that is required for actions following this call is compatible with the current mode. Should be called from all internal functions accessing matrix elements. </p>

</div>
</div>
<a class="anchor" id="aa6e49d52a74cc86386a9aff01fa88c74"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::prepare_add </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For some matrix storage formats, in particular for the PETSc distributed blockmatrices, set and add operations on individual elements can not be freely mixed. Rather, one has to synchronize operations when one wants to switch from setting elements to adding to elements. <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a> automatically synchronizes the access by calling this helper function for each block. This function ensures that the matrix is in a state that allows adding elements; if it previously already was in this state, the function does nothing. </p>

</div>
</div>
<a class="anchor" id="a9d1b00916f856722282dcd9abb408581"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::prepare_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as <a class="el" href="classPETScWrappers_1_1MatrixBase.html#aa6e49d52a74cc86386a9aff01fa88c74">prepare_add()</a> but prepare the matrix for setting elements if the representation of elements in this class requires such an operation. </p>

</div>
</div>
<a class="anchor" id="a7066ca270f211ac404fa88310535f706"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a>&amp; PETScWrappers::MatrixBase::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>purposefully not implemented </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="aad4d4720fcda9813b7fdcd3f0cb04ac6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class ::<a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>To allow calling protected <a class="el" href="classPETScWrappers_1_1MatrixBase.html#aa6e49d52a74cc86386a9aff01fa88c74">prepare_add()</a> and <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a9d1b00916f856722282dcd9abb408581">prepare_set()</a>. </p>

<p>Definition at line <a class="el" href="petsc__matrix__base_8h_source.html#l01346">1346</a> of file <a class="el" href="petsc__matrix__base_8h_source.html">petsc_matrix_base.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="abfce46e53089351cc7fe6b9ea44e167f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Mat PETScWrappers::MatrixBase::matrix</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A generic matrix object in PETSc. The actual type, a sparse matrix, is set in the constructor. </p>

<p>Definition at line <a class="el" href="petsc__matrix__base_8h_source.html#l01233">1233</a> of file <a class="el" href="petsc__matrix__base_8h_source.html">petsc_matrix_base.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad517ed5d8147c48867f54a59cfe86991"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LastAction::Values PETScWrappers::MatrixBase::last_action</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Store whether the last action was a write or add operation. </p>

<p>Definition at line <a class="el" href="petsc__matrix__base_8h_source.html#l01265">1265</a> of file <a class="el" href="petsc__matrix__base_8h_source.html">petsc_matrix_base.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa0f173897e0d5d926636e85aa68c7286"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;PetscInt&gt; PETScWrappers::MatrixBase::column_indices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>An internal array of integer values that is used to store the column indices when adding/inserting local data into the (large) sparse matrix. </p>

<p>Definition at line <a class="el" href="petsc__matrix__base_8h_source.html#l01329">1329</a> of file <a class="el" href="petsc__matrix__base_8h_source.html">petsc_matrix_base.h</a>.</p>

</div>
</div>
<a class="anchor" id="a289dc1463501c97a48127414ce5ee1ac"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;PetscScalar&gt; PETScWrappers::MatrixBase::column_values</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>An internal array of double values that is used to store the column indices when adding/inserting local data into the (large) sparse matrix. </p>

<p>Definition at line <a class="el" href="petsc__matrix__base_8h_source.html#l01338">1338</a> of file <a class="el" href="petsc__matrix__base_8h_source.html">petsc_matrix_base.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/deal.II/lac/<a class="el" href="petsc__matrix__base_8h_source.html">petsc_matrix_base.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jan 27 2014 15:27:25 for The deal.II Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
