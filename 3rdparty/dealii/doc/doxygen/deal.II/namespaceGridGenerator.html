<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>The deal.II Library: GridGenerator Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="http://www.dealii.org/deal.ico"></link>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2014 by the deal.II authors"></meta>
<meta name="deal.II-version" content="8.1.0"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 8.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">GridGenerator Namespace Reference<div class="ingroups"><a class="el" href="group__grid.html">Grid classes</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a7149c59cefa805a132177cfa6cb953bd"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a7149c59cefa805a132177cfa6cb953bd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a7149c59cefa805a132177cfa6cb953bd">hyper_cube</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const <a class="el" href="classdouble.html">double</a> left=0., const <a class="el" href="classdouble.html">double</a> right=1.)</td></tr>
<tr class="separator:a7149c59cefa805a132177cfa6cb953bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04d1e5978caaab591d34afa63a7eeb42"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a04d1e5978caaab591d34afa63a7eeb42"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a04d1e5978caaab591d34afa63a7eeb42">subdivided_hyper_cube</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const unsigned <a class="el" href="classint.html">int</a> repetitions, const <a class="el" href="classdouble.html">double</a> left=0., const <a class="el" href="classdouble.html">double</a> right=1.)</td></tr>
<tr class="separator:a04d1e5978caaab591d34afa63a7eeb42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fc0f35afac564a4f82846b84da49d2b"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a4fc0f35afac564a4f82846b84da49d2b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a4fc0f35afac564a4f82846b84da49d2b">hyper_rectangle</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p1, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p2, const <a class="el" href="classbool.html">bool</a> colorize=false)</td></tr>
<tr class="separator:a4fc0f35afac564a4f82846b84da49d2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8e2bc6fb2f81859c64c444c51751a2a"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:ad8e2bc6fb2f81859c64c444c51751a2a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#ad8e2bc6fb2f81859c64c444c51751a2a">subdivided_hyper_rectangle</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;repetitions, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p1, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p2, const <a class="el" href="classbool.html">bool</a> colorize=false)</td></tr>
<tr class="separator:ad8e2bc6fb2f81859c64c444c51751a2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5c5348fc84c98a9c06081972558a9a9"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:ab5c5348fc84c98a9c06081972558a9a9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#ab5c5348fc84c98a9c06081972558a9a9">subdivided_hyper_rectangle</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const std::vector&lt; std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt; &amp;step_sizes, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p_1, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p_2, const <a class="el" href="classbool.html">bool</a> colorize)</td></tr>
<tr class="separator:ab5c5348fc84c98a9c06081972558a9a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab96bbbe1d7cd1a894dcc038028a9684a"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:ab96bbbe1d7cd1a894dcc038028a9684a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#ab96bbbe1d7cd1a894dcc038028a9684a">subdivided_hyper_rectangle</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const std::vector&lt; std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt; &amp;spacing, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, const <a class="el" href="classTable.html">Table</a>&lt; dim, <a class="el" href="namespacetypes.html#a7ec62ce920d2700c16ec6cf457d0c0aa">types::material_id</a> &gt; &amp;material_id, const <a class="el" href="classbool.html">bool</a> colorize=false)</td></tr>
<tr class="separator:ab96bbbe1d7cd1a894dcc038028a9684a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05e208508c942b9783d0a65429e7d678"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a05e208508c942b9783d0a65429e7d678"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a05e208508c942b9783d0a65429e7d678">parallelogram</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; corners[dim], const <a class="el" href="classbool.html">bool</a> colorize=false)</td></tr>
<tr class="separator:a05e208508c942b9783d0a65429e7d678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae961b4b5fe56517f4df0c9ddd3daaf59"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:ae961b4b5fe56517f4df0c9ddd3daaf59"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#ae961b4b5fe56517f4df0c9ddd3daaf59">parallelogram</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim &gt; &amp;corners, const <a class="el" href="classbool.html">bool</a> colorize=false) <a class="el" href="group__Sparsity.html#ga0849dabf81f46d4d964e251c286784dd">DEAL_II_DEPRECATED</a></td></tr>
<tr class="separator:ae961b4b5fe56517f4df0c9ddd3daaf59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a016c6b55bcadf6596001a1e232a8faad"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a016c6b55bcadf6596001a1e232a8faad"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a016c6b55bcadf6596001a1e232a8faad">parallelepiped</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;(&amp;corners)[dim], const <a class="el" href="classbool.html">bool</a> colorize=false)</td></tr>
<tr class="separator:a016c6b55bcadf6596001a1e232a8faad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91269092ac149bdc6df9baabad785d02"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a91269092ac149bdc6df9baabad785d02"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a91269092ac149bdc6df9baabad785d02">subdivided_parallelepiped</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const unsigned <a class="el" href="classint.html">int</a> n_subdivisions, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;(&amp;corners)[dim], const <a class="el" href="classbool.html">bool</a> colorize=false)</td></tr>
<tr class="separator:a91269092ac149bdc6df9baabad785d02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a344cfa8d6ac9726d6898841440f02d84"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a344cfa8d6ac9726d6898841440f02d84"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a344cfa8d6ac9726d6898841440f02d84">subdivided_parallelepiped</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const unsigned <a class="el" href="classint.html">int</a>(n_subdivisions)[dim], const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;(&amp;corners)[dim], const <a class="el" href="classbool.html">bool</a> colorize=false)</td></tr>
<tr class="separator:a344cfa8d6ac9726d6898841440f02d84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c537aebe22842ec22de2c8b5c545896"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a2c537aebe22842ec22de2c8b5c545896"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a2c537aebe22842ec22de2c8b5c545896">enclosed_hyper_cube</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const <a class="el" href="classdouble.html">double</a> left=0., const <a class="el" href="classdouble.html">double</a> right=1., const <a class="el" href="classdouble.html">double</a> thickness=1., const <a class="el" href="classbool.html">bool</a> colorize=false)</td></tr>
<tr class="separator:a2c537aebe22842ec22de2c8b5c545896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a81f736ef95164a9d9bf0f844ac682b"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a0a81f736ef95164a9d9bf0f844ac682b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a0a81f736ef95164a9d9bf0f844ac682b">hyper_ball</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;center=<a class="el" href="classPoint.html">Point</a>&lt; dim &gt;(), const <a class="el" href="classdouble.html">double</a> radius=1.)</td></tr>
<tr class="separator:a0a81f736ef95164a9d9bf0f844ac682b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af218d0939daf0732e3b507a27ea5d8e3"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:af218d0939daf0732e3b507a27ea5d8e3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#af218d0939daf0732e3b507a27ea5d8e3">half_hyper_ball</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;center=<a class="el" href="classPoint.html">Point</a>&lt; dim &gt;(), const <a class="el" href="classdouble.html">double</a> radius=1.)</td></tr>
<tr class="separator:af218d0939daf0732e3b507a27ea5d8e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cdda7b4a76d509af7d1a8dc1320ddb0"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a5cdda7b4a76d509af7d1a8dc1320ddb0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a5cdda7b4a76d509af7d1a8dc1320ddb0">cylinder</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const <a class="el" href="classdouble.html">double</a> radius=1., const <a class="el" href="classdouble.html">double</a> half_length=1.)</td></tr>
<tr class="separator:a5cdda7b4a76d509af7d1a8dc1320ddb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae63c93351f77276c20de07c91d3c1e48"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:ae63c93351f77276c20de07c91d3c1e48"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#ae63c93351f77276c20de07c91d3c1e48">truncated_cone</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const <a class="el" href="classdouble.html">double</a> radius_0=1.0, const <a class="el" href="classdouble.html">double</a> radius_1=0.5, const <a class="el" href="classdouble.html">double</a> half_length=1.0)</td></tr>
<tr class="separator:ae63c93351f77276c20de07c91d3c1e48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6909eec7b1bee57374d52a9dfe240d57"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a6909eec7b1bee57374d52a9dfe240d57"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a6909eec7b1bee57374d52a9dfe240d57">hyper_L</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const <a class="el" href="classdouble.html">double</a> left=-1., const <a class="el" href="classdouble.html">double</a> right=1.)</td></tr>
<tr class="separator:a6909eec7b1bee57374d52a9dfe240d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5114625911496e4f51758fe00562a14a"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a5114625911496e4f51758fe00562a14a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a5114625911496e4f51758fe00562a14a">hyper_cube_slit</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const <a class="el" href="classdouble.html">double</a> left=0., const <a class="el" href="classdouble.html">double</a> right=1., const <a class="el" href="classbool.html">bool</a> colorize=false)</td></tr>
<tr class="separator:a5114625911496e4f51758fe00562a14a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad85de345ccd86a53e63746709c8e1dfc"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:ad85de345ccd86a53e63746709c8e1dfc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">hyper_shell</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;center, const <a class="el" href="classdouble.html">double</a> inner_radius, const <a class="el" href="classdouble.html">double</a> outer_radius, const unsigned <a class="el" href="classint.html">int</a> n_cells=0, <a class="el" href="classbool.html">bool</a> colorize=false)</td></tr>
<tr class="separator:ad85de345ccd86a53e63746709c8e1dfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f31aa1d176dd99c2183efdb4b9cb5f5"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a6f31aa1d176dd99c2183efdb4b9cb5f5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a6f31aa1d176dd99c2183efdb4b9cb5f5">half_hyper_shell</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;center, const <a class="el" href="classdouble.html">double</a> inner_radius, const <a class="el" href="classdouble.html">double</a> outer_radius, const unsigned <a class="el" href="classint.html">int</a> n_cells=0, const <a class="el" href="classbool.html">bool</a> colorize=false)</td></tr>
<tr class="separator:a6f31aa1d176dd99c2183efdb4b9cb5f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd7c51b0e8032db65db9a5ff73ccca50"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:acd7c51b0e8032db65db9a5ff73ccca50"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#acd7c51b0e8032db65db9a5ff73ccca50">quarter_hyper_shell</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;center, const <a class="el" href="classdouble.html">double</a> inner_radius, const <a class="el" href="classdouble.html">double</a> outer_radius, const unsigned <a class="el" href="classint.html">int</a> n_cells=0, const <a class="el" href="classbool.html">bool</a> colorize=false)</td></tr>
<tr class="separator:acd7c51b0e8032db65db9a5ff73ccca50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a760789a93b1e0fe7f5c2675c31b6f14f"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a760789a93b1e0fe7f5c2675c31b6f14f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a760789a93b1e0fe7f5c2675c31b6f14f">cylinder_shell</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const <a class="el" href="classdouble.html">double</a> length, const <a class="el" href="classdouble.html">double</a> inner_radius, const <a class="el" href="classdouble.html">double</a> outer_radius, const unsigned <a class="el" href="classint.html">int</a> n_radial_cells=0, const unsigned <a class="el" href="classint.html">int</a> n_axial_cells=0)</td></tr>
<tr class="separator:a760789a93b1e0fe7f5c2675c31b6f14f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71cf8f32c898246be99b1130bf05704b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a71cf8f32c898246be99b1130bf05704b">torus</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, 3 &gt; &amp;tria, const <a class="el" href="classdouble.html">double</a> R, const <a class="el" href="classdouble.html">double</a> r)</td></tr>
<tr class="separator:a71cf8f32c898246be99b1130bf05704b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0667f3dcd9ecc8cab8c74f0b55ababd2"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a0667f3dcd9ecc8cab8c74f0b55ababd2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a0667f3dcd9ecc8cab8c74f0b55ababd2">hyper_cube_with_cylindrical_hole</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;triangulation, const <a class="el" href="classdouble.html">double</a> inner_radius=.25, const <a class="el" href="classdouble.html">double</a> outer_radius=.5, const <a class="el" href="classdouble.html">double</a> L=.5, const unsigned <a class="el" href="classint.html">int</a> repetition=1, const <a class="el" href="classbool.html">bool</a> colorize=false)</td></tr>
<tr class="separator:a0667f3dcd9ecc8cab8c74f0b55ababd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a626225354aa3f249f64dc67319e34bf8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a626225354aa3f249f64dc67319e34bf8">moebius</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; 3, 3 &gt; &amp;tria, const unsigned <a class="el" href="classint.html">int</a> n_cells, const unsigned <a class="el" href="classint.html">int</a> n_rotations, const <a class="el" href="classdouble.html">double</a> R, const <a class="el" href="classdouble.html">double</a> r)</td></tr>
<tr class="separator:a626225354aa3f249f64dc67319e34bf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dace8884c1510160d7b6cbb313523e9"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a0dace8884c1510160d7b6cbb313523e9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a0dace8884c1510160d7b6cbb313523e9">merge_triangulations</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;triangulation_1, const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;triangulation_2, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;result)</td></tr>
<tr class="separator:a0dace8884c1510160d7b6cbb313523e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add67475b53b365d65a3fe3eb6f156fa9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#add67475b53b365d65a3fe3eb6f156fa9">extrude_triangulation</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, 2 &gt; &amp;input, const unsigned <a class="el" href="classint.html">int</a> n_slices, const <a class="el" href="classdouble.html">double</a> height, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 3, 3 &gt; &amp;result)</td></tr>
<tr class="separator:add67475b53b365d65a3fe3eb6f156fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6e361889084431ea3059f5f3029c1de"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:ad6e361889084431ea3059f5f3029c1de"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#ad6e361889084431ea3059f5f3029c1de">laplace_transformation</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const std::map&lt; unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;new_points) <a class="el" href="group__Sparsity.html#ga0849dabf81f46d4d964e251c286784dd">DEAL_II_DEPRECATED</a></td></tr>
<tr class="separator:ad6e361889084431ea3059f5f3029c1de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7b4805db66d34e56837dfef047f7fe0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#ad7b4805db66d34e56837dfef047f7fe0">DeclException0</a> (ExcInvalidRadii)</td></tr>
<tr class="separator:ad7b4805db66d34e56837dfef047f7fe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb2334f33e83f0937aa82a9522d03b1b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#aeb2334f33e83f0937aa82a9522d03b1b">DeclException1</a> (ExcInvalidRepetitions, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;The number of repetitions &quot;&lt;&lt; arg1&lt;&lt; &quot; must be &gt;=1.&quot;)</td></tr>
<tr class="separator:aeb2334f33e83f0937aa82a9522d03b1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2ed776e338368bc7330b58182388673"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#ab2ed776e338368bc7330b58182388673">DeclException1</a> (ExcInvalidRepetitionsDimension, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;The vector of repetitions  must have &quot;&lt;&lt; arg1&lt;&lt;&quot; elements.&quot;)</td></tr>
<tr class="separator:ab2ed776e338368bc7330b58182388673"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This namespace provides a collection of functions for generating triangulations for some basic geometries.</p>
<p>Some of these functions receive a flag <code>colorize</code>. If this is set, parts of the boundary receive different boundary indicators (<a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">GlossBoundaryIndicator</a>), allowing them to be distinguished for the purpose of attaching geometry objects and evaluating different boundary conditions.</p>
<p>This namespace also provides a function <a class="el" href="namespaceGridGenerator.html#ad6e361889084431ea3059f5f3029c1de">GridGenerator::laplace_transformation</a> that smoothly transforms a domain into another one. This can be used to transform basic geometries to more complicated ones, like a shell to a grid of an airfoil, for example. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a7149c59cefa805a132177cfa6cb953bd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::hyper_cube </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>left</em> = <code>0.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>right</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the given triangulation with a hypercube (line in 1D, square in 2D, etc) consisting of exactly one cell. The hypercube volume is the tensor product interval <em>[left,right]<sup>dim</sup></em> in the present number of dimensions, where the limits are given as arguments. They default to zero and unity, then producing the unit hypercube. All boundary indicators are set to zero ("not colorized") for 2d and 3d. In 1d the indicators are colorized, see <a class="el" href="namespaceGridGenerator.html#a4fc0f35afac564a4f82846b84da49d2b">hyper_rectangle()</a>.</p>
<div class="image">
<img src="hyper_cubes.png" alt="hyper_cubes.png"/>
</div>
<p>See also <a class="el" href="namespaceGridGenerator.html#a04d1e5978caaab591d34afa63a7eeb42">subdivided_hyper_cube()</a> for a coarse mesh consisting of several cells. See <a class="el" href="namespaceGridGenerator.html#a4fc0f35afac564a4f82846b84da49d2b">hyper_rectangle()</a>, if different lengths in different ordinate directions are required.</p>
<dl class="section note"><dt>Note</dt><dd>The triangulation needs to be void upon calling this function. </dd></dl>

</div>
</div>
<a class="anchor" id="a04d1e5978caaab591d34afa63a7eeb42"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::subdivided_hyper_cube </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>repetitions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>left</em> = <code>0.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>right</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as <a class="el" href="namespaceGridGenerator.html#a7149c59cefa805a132177cfa6cb953bd">hyper_cube()</a>, but with the difference that not only one cell is created but each coordinate direction is subdivided into <code>repetitions</code> cells. Thus, the number of cells filling the given volume is <code>repetitions<sup>dim</sup></code>.</p>
<p>If spacedim=dim+1 the same mesh as in the case spacedim=dim is created, but the vertices have an additional coordinate =0. So, if dim=1 one obtains line along the x axis in the xy plane, and if dim=3 one obtains a square in lying in the xy plane in 3d space.</p>
<dl class="section note"><dt>Note</dt><dd>The triangulation needs to be void upon calling this function. </dd></dl>

</div>
</div>
<a class="anchor" id="a4fc0f35afac564a4f82846b84da49d2b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::hyper_rectangle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>colorize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a coordinate-parallel brick from the two diagonally opposite corner points <code>p1</code> and <code>p2</code>.</p>
<p>If the <code>colorize</code> flag is set, the <code>boundary_indicators</code> of the surfaces are assigned, such that the lower one in <code>x-direction</code> is 0, the upper one is 1. The indicators for the surfaces in <code>y-direction</code> are 2 and 3, the ones for <code>z</code> are 4 and 5. Additionally, material ids are assigned to the cells according to the octant their center is in: being in the right half plane for any coordinate direction <em>x<sub>i</sub></em> adds 2<sup>i</sup>. For instance, the center point (1,-1,1) yields a material id 5.</p>
<dl class="section note"><dt>Note</dt><dd>The triangulation needs to be void upon calling this function. </dd></dl>

</div>
</div>
<a class="anchor" id="ad8e2bc6fb2f81859c64c444c51751a2a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::subdivided_hyper_rectangle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>repetitions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>colorize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a coordinate-parallel parallelepiped from the two diagonally opposite corner points <code>p1</code> and <code>p2</code>. In dimension <code>i</code>, <code>repetitions[i]</code> cells are generated.</p>
<p>To get cells with an aspect ratio different from that of the domain, use different numbers of subdivisions in different coordinate directions. The minimum number of subdivisions in each direction is 1. <code>repetitions</code> is a list of integers denoting the number of subdivisions in each coordinate direction.</p>
<p>If the <code>colorize</code> flag is set, the <code>boundary_indicators</code> of the surfaces are assigned, such that the lower one in <code>x-direction</code> is 0, the upper one is 1 (the left and the right vertical face). The indicators for the surfaces in <code>y-direction</code> are 2 and 3, the ones for <code>z</code> are 4 and 5. Additionally, material ids are assigned to the cells according to the octant their center is in: being in the right half plane for any coordinate direction <em>x<sub>i</sub></em> adds 2<sup>i</sup>. For instance, the center point (1,-1,1) yields a material id 5 (this means that in 2d only material ids 0,1,2,3 are assigned independent from the number of repetitions).</p>
<p>Note that the <code>colorize</code> flag is ignored in 1d and is assumed to always be true. That means the boundary indicator is 0 on the left and 1 on the right. See <a class="el" href="step_15.html">step-15</a> for details.</p>
<dl class="section note"><dt>Note</dt><dd>The triangulation needs to be void upon calling this function.</dd>
<dd>
For an example of the use of this function see the <a class="el" href="step_28.html">step-28</a> tutorial program. </dd></dl>

</div>
</div>
<a class="anchor" id="ab5c5348fc84c98a9c06081972558a9a9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::subdivided_hyper_rectangle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>step_sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>colorize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like the previous function. However, here the second argument does not denote the number of subdivisions in each coordinate direction, but a sequence of step sizes for each coordinate direction. The domain will therefore be subdivided into <code>step_sizes[i].size()</code> cells in coordinate direction <code>i</code>, with widths <code>step_sizes[i][j]</code> for the <code>j</code>th cell.</p>
<p>This function is therefore the right one to generate graded meshes where cells are concentrated in certain areas, rather than a uniformly subdivided mesh as the previous function generates.</p>
<p>The step sizes have to add up to the dimensions of the hyper rectangle specified by the points <code>p1</code> and <code>p2</code>. </p>

</div>
</div>
<a class="anchor" id="ab96bbbe1d7cd1a894dcc038028a9684a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::subdivided_hyper_rectangle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>spacing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTable.html">Table</a>&lt; dim, <a class="el" href="namespacetypes.html#a7ec62ce920d2700c16ec6cf457d0c0aa">types::material_id</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>material_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>colorize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like the previous function, but with the following twist: the <code>material_id</code> argument is a dim-dimensional array that, for each cell, indicates which material_id should be set. In addition, and this is the major new functionality, if the material_id of a cell is <code>(unsigned char)(-1)</code>, then that cell is deleted from the triangulation, i.e. the domain will have a void there. </p>

</div>
</div>
<a class="anchor" id="a05e208508c942b9783d0a65429e7d678"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::parallelogram </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&#160;</td>
          <td class="paramname"><em>corners</em>[dim], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>colorize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A parallelogram. The first corner point is the origin. The <code>dim</code> adjacent points are the ones given in the second argument and the fourth point will be the sum of these two vectors. Colorizing is done in the same way as in <a class="el" href="namespaceGridGenerator.html#a4fc0f35afac564a4f82846b84da49d2b">hyper_rectangle()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This function is implemented in 2d only.</dd>
<dd>
The triangulation needs to be void upon calling this function. </dd></dl>

</div>
</div>
<a class="anchor" id="ae961b4b5fe56517f4df0c9ddd3daaf59"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::parallelogram </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>corners</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>colorize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000178">Deprecated:</a></b></dt><dd>Use the other function of same name. </dd></dl>

</div>
</div>
<a class="anchor" id="a016c6b55bcadf6596001a1e232a8faad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::parallelepiped </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;(&amp;)&#160;</td>
          <td class="paramname"><em>corners</em>[dim], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>colorize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A parallelepiped. The first corner point is the origin. The <code>dim</code> adjacent points are vectors describing the edges of the parallelepiped with respect to the origin. Additional points are sums of these dim vectors. Colorizing is done according to <a class="el" href="namespaceGridGenerator.html#a4fc0f35afac564a4f82846b84da49d2b">hyper_rectangle()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This function silently reorders the vertices on the cells to lexiographic ordering (see <code>GridReordering::reorder_grid</code>). In other words, if reodering of the vertices does occur, the ordering of vertices in the array of <code>corners</code> will no longer refer to the same triangulation.</dd>
<dd>
The triangulation needs to be void upon calling this function. </dd></dl>

</div>
</div>
<a class="anchor" id="a91269092ac149bdc6df9baabad785d02"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::subdivided_parallelepiped </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_subdivisions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;(&amp;)&#160;</td>
          <td class="paramname"><em>corners</em>[dim], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>colorize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A subdivided parallelepiped. The first corner point is the origin. The <code>dim</code> adjacent points are vectors describing the edges of the parallelepiped with respect to the origin. Additional points are sums of these dim vectors. The variable <code>n_subdivisions</code> designates the number of subdivisions in each of the <code>dim</code> directions. Colorizing is done according to <a class="el" href="namespaceGridGenerator.html#a4fc0f35afac564a4f82846b84da49d2b">hyper_rectangle()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>The triangulation needs to be void upon calling this function. </dd></dl>

</div>
</div>
<a class="anchor" id="a344cfa8d6ac9726d6898841440f02d84"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::subdivided_parallelepiped </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &#160;</td>
          <td class="paramname"><em>int</em>(n_subdivisions)[dim], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;(&amp;)&#160;</td>
          <td class="paramname"><em>corners</em>[dim], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>colorize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A subdivided parallelepiped, ie. the same as above, but where the number of subdivisions in each of the <code>dim</code> directions may vary. Colorizing is done according to <a class="el" href="namespaceGridGenerator.html#a4fc0f35afac564a4f82846b84da49d2b">hyper_rectangle()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>The triangulation needs to be void upon calling this function. </dd></dl>

</div>
</div>
<a class="anchor" id="a2c537aebe22842ec22de2c8b5c545896"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::enclosed_hyper_cube </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>left</em> = <code>0.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>right</em> = <code>1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>thickness</em> = <code>1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>colorize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Hypercube with a layer of hypercubes around it. The first two parameters give the lower and upper bound of the inner hypercube in all coordinate directions. <code>thickness</code> marks the size of the layer cells.</p>
<p>If the flag colorize is set, the outer cells get material id's according to the following scheme: extending over the inner cube in (+/-) x-direction: 1/2. In y-direction 4/8, in z-direction 16/32. The cells at corners and edges (3d) get these values bitwise or'd.</p>
<p>Presently only available in 2d and 3d.</p>
<dl class="section note"><dt>Note</dt><dd>The triangulation needs to be void upon calling this function. </dd></dl>

</div>
</div>
<a class="anchor" id="a0a81f736ef95164a9d9bf0f844ac682b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::hyper_ball </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>center</em> = <code><a class="el" href="classPoint.html">Point</a>&lt;&#160;dim&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>radius</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the given triangulation with a hyperball, i.e. a circle or a ball around <code>center</code> with given <code>radius</code>.</p>
<p>In order to avoid degenerate cells at the boundaries, the circle is triangulated by five cells, the ball by seven cells. The diameter of the center cell is chosen so that the aspect ratio of the boundary cells after one refinement is optimized.</p>
<p>This function is declared to exist for triangulations of all space dimensions, but throws an error if called in 1d.</p>
<dl class="section note"><dt>Note</dt><dd>The triangulation needs to be void upon calling this function. </dd></dl>

</div>
</div>
<a class="anchor" id="af218d0939daf0732e3b507a27ea5d8e3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::half_hyper_ball </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>center</em> = <code><a class="el" href="classPoint.html">Point</a>&lt;&#160;dim&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>radius</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This class produces a half hyper-ball around <code>center</code>, which contains four elements in 2d and 6 in 3d. The cut plane is perpendicular to the <em>x</em>-axis.</p>
<p>The boundary indicators for the final triangulation are 0 for the curved boundary and 1 for the cut plane.</p>
<p>The appropriate boundary class is <a class="el" href="classHalfHyperBallBoundary.html">HalfHyperBallBoundary</a>, or <a class="el" href="classHyperBallBoundary.html">HyperBallBoundary</a>.</p>
<dl class="section note"><dt>Note</dt><dd>The triangulation needs to be void upon calling this function. </dd></dl>

</div>
</div>
<a class="anchor" id="a5cdda7b4a76d509af7d1a8dc1320ddb0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::cylinder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>radius</em> = <code>1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>half_length</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a cylinder around the x-axis. The cylinder extends from <code>x=-half_length</code> to <code>x=+half_length</code> and its projection into the <code>yz-plane</code> is a circle of radius <code>radius</code>.</p>
<p>In two dimensions, the cylinder is a rectangle from <code>x=-half_length</code> to <code>x=+half_length</code> and from <code>y=-radius</code> to <code>y=radius</code>.</p>
<p>The boundaries are colored according to the following scheme: 0 for the hull of the cylinder, 1 for the left hand face and 2 for the right hand face.</p>
<dl class="section note"><dt>Note</dt><dd>The triangulation needs to be void upon calling this function. </dd></dl>

</div>
</div>
<a class="anchor" id="ae63c93351f77276c20de07c91d3c1e48"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::truncated_cone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>radius_0</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>radius_1</em> = <code>0.5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>half_length</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a cutted cone around the x-axis. The cone extends from <code>x=-half_length</code> to <code>x=half_length</code> and its projection into the <code>yz-plane</code> is a circle of radius <code>radius_0</code> at <code>x=-half_length</code> and a circle of radius <code>radius_1</code> at <code>x=+half_length</code>. In between the radius is linearly decreasing.</p>
<p>In two dimensions, the cone is a trapezoid from <code>x=-half_length</code> to <code>x=+half_length</code> and from <code>y=-radius_0</code> to <code>y=radius_0</code> at <code>x=-half_length</code> and from <code>y=-radius_1</code> to <code>y=radius_1</code> at <code>x=+half_length</code>. In between the range of <code>y</code> is linearly decreasing.</p>
<p>The boundaries are colored according to the following scheme: 0 for the hull of the cone, 1 for the left hand face and 2 for the right hand face.</p>
<p>An example of use can be found in the documentation of the <a class="el" href="classConeBoundary.html">ConeBoundary</a> class, with which you probably want to associate boundary indicator 0 (the hull of the cone).</p>
<dl class="section note"><dt>Note</dt><dd>The triangulation needs to be void upon calling this function.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Markus B&uuml;rg, 2009 </dd></dl>

</div>
</div>
<a class="anchor" id="a6909eec7b1bee57374d52a9dfe240d57"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::hyper_L </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>left</em> = <code>-1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>right</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the given triangulation with a hyper-L consisting of exactly <code>2^dim-1</code> cells. It produces the hypercube with the interval [<em>left,right</em>] without the hypercube made out of the interval [<em>(a+b)/2,b</em>].</p>
<div class="image">
<img src="hyper_l.png" alt="hyper_l.png"/>
</div>
<p>The triangulation needs to be void upon calling this function.</p>
<p>This function is declared to exist for triangulations of all space dimensions, but throws an error if called in 1d.</p>
<dl class="section note"><dt>Note</dt><dd>The triangulation needs to be void upon calling this function. </dd></dl>

</div>
</div>
<a class="anchor" id="a5114625911496e4f51758fe00562a14a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::hyper_cube_slit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>left</em> = <code>0.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>right</em> = <code>1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>colorize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the given <a class="el" href="classTriangulation.html">Triangulation</a> with a hypercube with a slit. In each coordinate direction, the hypercube extends from <code>left</code> to <code>right</code>.</p>
<p>In 2d, the split goes in vertical direction from <code>x=(left+right)/2, y=left</code> to the center of the square at <code>x=y=(left+right)/2</code>.</p>
<p>In 3d, the 2d domain is just extended in the <em>z</em>-direction, such that a plane cuts the lower half of a rectangle in two.</p>
<p>This function is declared to exist for triangulations of all space dimensions, but throws an error if called in 1d.</p>
<dl class="section note"><dt>Note</dt><dd>The triangulation needs to be void upon calling this function. </dd></dl>

</div>
</div>
<a class="anchor" id="ad85de345ccd86a53e63746709c8e1dfc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::hyper_shell </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>inner_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>outer_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_cells</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>colorize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Produce a hyper-shell, the region between two spheres around <code>center</code>, with given <code>inner_radius</code> and <code>outer_radius</code>. The number <code>n_cells</code> indicates the number of cells of the resulting triangulation, i.e., how many cells form the ring (in 2d) or the shell (in 3d).</p>
<p>If the flag <code>colorize</code> is <code>true</code>, then the outer boundary will have the indicator 1, while the inner boundary has id zero. If the flag is <code>false</code>, both have indicator zero.</p>
<p>In 2D, the number <code>n_cells</code> of elements for this initial triangulation can be chosen arbitrarily. If the number of initial cells is zero (as is the default), then it is computed adaptively such that the resulting elements have the least aspect ratio.</p>
<p>In 3D, only two different numbers are meaningful, 6 for a surface based on a hexahedron (i.e. 6 panels on the inner sphere extruded in radial direction to form 6 cells) and 12 for the rhombic dodecahedron. These give rise to the following meshes upon one refinement:</p>
<div class="image">
<img src="hypershell3d-6.png" alt="hypershell3d-6.png"/>
</div>
 <div class="image">
<img src="hypershell3d-12.png" alt="hypershell3d-12.png"/>
</div>
<p>Neither of these meshes is particularly good since one ends up with poorly shaped cells at the inner edge upon refinement. For example, this is the middle plane of the mesh for the <code>n_cells=6</code>:</p>
<div class="image">
<img src="hyper_shell_6_cross_plane.png" alt="hyper_shell_6_cross_plane.png"/>
</div>
<p>The mesh generated with <code>n_cells=6</code> is better but still not good. As a consequence, you may also specify <code>n_cells=96</code> as a third option. The mesh generated in this way is based on a once refined version of the one with <code>n_cells=12</code>, where all internal nodes are re-placed along a shell somewhere between the inner and outer boundary of the domain. The following two images compare half of the hyper shell for <code>n_cells=12</code> and <code>n_cells=96</code> (note that the doubled radial lines on the cross section are artifacts of the visualization):</p>
<div class="image">
<img src="hyper_shell_12_cut.png" alt="hyper_shell_12_cut.png"/>
</div>
 <div class="image">
<img src="hyper_shell_96_cut.png" alt="hyper_shell_96_cut.png"/>
</div>
<dl class="section note"><dt>Note</dt><dd>This function is declared to exist for triangulations of all space dimensions, but throws an error if called in 1d.</dd>
<dd>
The triangulation needs to be void upon calling this function. </dd></dl>

</div>
</div>
<a class="anchor" id="a6f31aa1d176dd99c2183efdb4b9cb5f5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::half_hyper_shell </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>inner_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>outer_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_cells</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>colorize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Produce a half hyper-shell, i.e. the space between two circles in two space dimensions and the region between two spheres in 3d, with given inner and outer radius and a given number of elements for this initial triangulation. However, opposed to the previous function, it does not produce a whole shell, but only one half of it, namely that part for which the first component is restricted to non-negative values. The purpose of this class is to enable computations for solutions which have rotational symmetry, in which case the half shell in 2d represents a shell in 3d.</p>
<p>If the number of initial cells is zero (as is the default), then it is computed adaptively such that the resulting elements have the least aspect ratio.</p>
<p>If colorize is set to true, the inner, outer, left, and right boundary get indicator 0, 1, 2, and 3, respectively. Otherwise all indicators are set to 0.</p>
<dl class="section note"><dt>Note</dt><dd>The triangulation needs to be void upon calling this function. </dd></dl>

</div>
</div>
<a class="anchor" id="acd7c51b0e8032db65db9a5ff73ccca50"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::quarter_hyper_shell </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>inner_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>outer_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_cells</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>colorize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Produce a domain that is the intersection between a hyper-shell with given inner and outer radius, i.e. the space between two circles in two space dimensions and the region between two spheres in 3d, and the positive quadrant (in 2d) or octant (in 3d). In 2d, this is indeed a quarter of the full annulus, while the function is a misnomer in 3d because there the domain is not a quarter but one eighth of the full shell.</p>
<p>If the number of initial cells is zero (as is the default), then it is computed adaptively such that the resulting elements have the least aspect ratio in 2d.</p>
<p>If colorize is set to true, the inner, outer, left, and right boundary get indicator 0, 1, 2, and 3 in 2d, respectively. Otherwise all indicators are set to 0. In 3d indicator 2 is at the face x=0, 3 at y=0, 4 at z=0.</p>
<dl class="section note"><dt>Note</dt><dd>The triangulation needs to be void upon calling this function. </dd></dl>

</div>
</div>
<a class="anchor" id="a760789a93b1e0fe7f5c2675c31b6f14f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::cylinder_shell </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>inner_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>outer_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_radial_cells</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_axial_cells</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Produce a domain that is the space between two cylinders in 3d, with given length, inner and outer radius and a given number of elements for this initial triangulation. If <code>n_radial_cells</code> is zero (as is the default), then it is computed adaptively such that the resulting elements have the least aspect ratio. The same holds for <code>n_axial_cells</code>.</p>
<dl class="section note"><dt>Note</dt><dd>Although this function is declared as a template, it does not make sense in 1D and 2D.</dd>
<dd>
The triangulation needs to be void upon calling this function. </dd></dl>

</div>
</div>
<a class="anchor" id="a71cf8f32c898246be99b1130bf05704b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::torus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Produce the surface meshing of the torus. The axis of the torus is the <img class="formulaInl" alt="$y$" src="form_10.png"/>-axis while the plane of the torus is the <img class="formulaInl" alt="$x$" src="form_9.png"/>- <img class="formulaInl" alt="$z$" src="form_11.png"/> plane. The boundary of this object can be described by the <a class="el" href="classTorusBoundary.html">TorusBoundary</a> class.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tria</td><td>The triangulation to be filled.</td></tr>
    <tr><td class="paramname">R</td><td>The radius of the circle, which forms the middle line of the torus containing the loop of cells. Must be greater than <code>r</code>.</td></tr>
    <tr><td class="paramname">r</td><td>The inner radius of the torus. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0667f3dcd9ecc8cab8c74f0b55ababd2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::hyper_cube_with_cylindrical_hole </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>inner_radius</em> = <code>.25</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>outer_radius</em> = <code>.5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>L</em> = <code>.5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>repetition</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>colorize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This class produces a square on the <em>xy</em>-plane with a circular hole in the middle. Square and circle are centered at the origin. In 3d, this geometry is extruded in <img class="formulaInl" alt="$z$" src="form_11.png"/> direction to the interval <img class="formulaInl" alt="$[0,L]$" src="form_682.png"/>.</p>
<div class="image">
<img src="cubes_hole.png" alt="cubes_hole.png"/>
</div>
<p>It is implemented in 2d and 3d, and takes the following arguments:</p>
<ul>
<li><code>inner_radius:</code> radius of the internal hole </li>
<li><code>outer_radius:</code> half of the edge length of the square </li>
<li><code>L:</code> extension in <code>z-direction</code> (only used in 3d) </li>
<li><code>repetitions:</code> number of subdivisions along the <code>z-direction</code> </li>
<li><code>colorize:</code> whether to assign different boundary indicators to different faces. The colors are given in lexicographic ordering for the flat faces (0 to 3 in 2d, 0 to 5 in 3d) plus the curved hole (4 in 2d, and 6 in 3d). If <code>colorize</code> is set to false, then flat faces get the number 0 and the hole gets number 1. </li>
</ul>

</div>
</div>
<a class="anchor" id="a626225354aa3f249f64dc67319e34bf8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::moebius </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; 3, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_rotations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Produce a ring of cells in 3D that is cut open, twisted and glued together again. This results in a kind of moebius-loop.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tria</td><td>The triangulation to be worked on. </td></tr>
    <tr><td class="paramname">n_cells</td><td>The number of cells in the loop. Must be greater than 4. </td></tr>
    <tr><td class="paramname">n_rotations</td><td>The number of rotations (Pi/2 each) to be performed before glueing the loop together. </td></tr>
    <tr><td class="paramname">R</td><td>The radius of the circle, which forms the middle line of the torus containing the loop of cells. Must be greater than <code>r</code>. </td></tr>
    <tr><td class="paramname">r</td><td>The radius of the cylinder bend together as loop. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0dace8884c1510160d7b6cbb313523e9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::merge_triangulations </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation_2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given the two triangulations specified as the first two arguments, create the triangulation that contains the cells of both triangulation and store it in the third parameter. Previous content of <code>result</code> will be deleted.</p>
<p>This function is most often used to compose meshes for more complicated geometries if the geometry can be composed of simpler parts for which functions exist to generate coarse meshes. For example, the channel mesh used in <a class="el" href="step_35.html">step-35</a> could in principle be created using a mesh created by the <a class="el" href="namespaceGridGenerator.html#a0667f3dcd9ecc8cab8c74f0b55ababd2">GridGenerator::hyper_cube_with_cylindrical_hole</a> function and several rectangles, and merging them using the current function. The rectangles will have to be translated to the right for this, a task that can be done using the <a class="el" href="namespaceGridTools.html#afaba24ff634583cda857085e03e3458b">GridTools::shift</a> function (other tools to transform individual mesh building blocks are <a class="el" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">GridTools::transform</a>, <a class="el" href="namespaceGridTools.html#aa7ea00f2009014a52520c05beadc78b6">GridTools::rotate</a>, and <a class="el" href="namespaceGridTools.html#a0967563badadd81f77f62622dd8bc2cd">GridTools::scale</a>).</p>
<dl class="section note"><dt>Note</dt><dd>The two input triangulations must be coarse meshes that have no refined cells.</dd>
<dd>
The function copies the material ids of the cells of the two input triangulations into the output triangulation but it currently makes no attempt to do the same for boundary ids. In other words, if the two coarse meshes have anything but the default boundary indicators, then you will currently have to set boundary indicators again by hand in the output triangulation.</dd>
<dd>
For a related operation on refined meshes when both meshes are derived from the same coarse mesh, see <a class="el" href="namespaceGridTools.html#a067c348e5c274041eb2bacb4184b2746">GridTools::create_union_triangulation</a> . </dd></dl>

</div>
</div>
<a class="anchor" id="add67475b53b365d65a3fe3eb6f156fa9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::extrude_triangulation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_slices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; 3, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Take a 2d <a class="el" href="classTriangulation.html">Triangulation</a> that is being extruded in z direction by the total height of <code>height</code> using <code>n_slices</code> slices (minimum is 2). The boundary indicators of the faces of <code>input</code> are going to be assigned to the corresponding side walls in z direction. The bottom and top get the next two free boundary indicators. </p>

</div>
</div>
<a class="anchor" id="ad6e361889084431ea3059f5f3029c1de"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::laplace_transformation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function transformes the <code><a class="el" href="classTriangulation.html">Triangulation</a></code> <code>tria</code> smoothly to a domain that is described by the boundary points in the map <code>new_points</code>. This map maps the point indices to the boundary points in the transformed domain.</p>
<p>Note, that the <code><a class="el" href="classTriangulation.html">Triangulation</a></code> is changed in-place, therefore you don't need to keep two triangulations, but the given triangulation is changed (overwritten).</p>
<p>In 1d, this function is not currently implemented.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000179">Deprecated:</a></b></dt><dd>This function has been moved to <a class="el" href="namespaceGridTools.html#ad6e5968b4507495a77d200e958c496c6">GridTools::laplace_transform</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad7b4805db66d34e56837dfef047f7fe0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GridGenerator::DeclException0 </td>
          <td>(</td>
          <td class="paramtype">ExcInvalidRadii&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exception </p>

</div>
</div>
<a class="anchor" id="aeb2334f33e83f0937aa82a9522d03b1b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GridGenerator::DeclException1 </td>
          <td>(</td>
          <td class="paramtype">ExcInvalidRepetitions&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;The number of repetitions &quot;&lt;&lt; arg1&lt;&lt; &quot; must be &gt;=1.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exception </p>

</div>
</div>
<a class="anchor" id="ab2ed776e338368bc7330b58182388673"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GridGenerator::DeclException1 </td>
          <td>(</td>
          <td class="paramtype">ExcInvalidRepetitionsDimension&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;The vector of repetitions must have &quot;&lt;&lt; arg1&lt;&lt;&quot; elements.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exception </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jan 27 2014 15:27:23 for The deal.II Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
