<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>The deal.II Library: The step-16 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="http://www.dealii.org/deal.ico"></link>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2014 by the deal.II authors"></meta>
<meta name="deal.II-version" content="8.1.0"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 8.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The step-16 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Thetestcase">The testcase</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#ThecodeLaplaceProblemcodeclasstemplate">The <code>LaplaceProblem</code> class template</a>
        <li><a href="#Nonconstantcoefficients">Nonconstant coefficients</a>
        <li><a href="#ThecodeLaplaceProblemcodeclassimplementation">The <code>LaplaceProblem</code> class implementation</a>
      <ul>
        <li><a href="#LaplaceProblemLaplaceProblem">LaplaceProblem::LaplaceProblem</a>
        <li><a href="#LaplaceProblemsetup_system">LaplaceProblem::setup_system</a>
        <li><a href="#LaplaceProblemassemble_system">LaplaceProblem::assemble_system</a>
        <li><a href="#LaplaceProblemassemble_multigrid">LaplaceProblem::assemble_multigrid</a>
        <li><a href="#LaplaceProblemsolve">LaplaceProblem::solve</a>
        <li><a href="#Postprocessing">Postprocessing</a>
        <li><a href="#LaplaceProblemrun">LaplaceProblem::run</a>
      </ul>
        <li><a href="#Themainfunction">The main() function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Possibleextensions"> Possible extensions </a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <br/>
</p>
<p><em>This program has evolved from a version originally written by Guido Kanschat in 2003. It has undergone significant revisions by B&auml;rbel Janssen, Guido Kanschat and Wolfgang Bangerth in 2009 and 2010 to demonstrate multigrid algorithms on adaptively refined meshes. </em></p>
<p><a class="anchor" id="Intro"></a> <a class="anchor" id="Introduction"></a></p>
<h1>Introduction</h1>
<p>This example shows the basic usage of the multilevel functions in deal.II. It solves the same problem as used in <a class="el" href="step_6.html">step-6</a>, but demonstrating the things one has to provide when using multigrid as a preconditioner. In particular, this requires that we define a hierarchy of levels, provide transfer operators from one level to the next and back, and provide representations of the Laplace operator on each level.</p>
<p>In order to allow sufficient flexibility in conjunction with systems of differential equations and block preconditioners, quite a few different objects have to be created before starting the multilevel method, although most of what needs to be done is provided by deal.II itself. These are </p>
<ul>
<li>
An the object handling transfer between grids; we use the <a class="el" href="classMGTransferPrebuilt.html">MGTransferPrebuilt</a> class for this that does almost all of the work inside the library. </li>
<li>
The solver on the coarsest level; here, we use <a class="el" href="classMGCoarseGridHouseholder.html">MGCoarseGridHouseholder</a>. </li>
<li>
The smoother on all other levels, which in our case will be the <a class="el" href="classMGSmootherRelaxation.html">MGSmootherRelaxation</a> class using SOR as the underlying method </li>
<li>
And <a class="el" href="classMGMatrix.html">MGMatrix</a>, a class having a special level multiplication, i.e. we basically store one matrix per grid level and allow multiplication with it. </li>
</ul>
<p>Most of these objects will only be needed inside the function that actually solves the linear system. There, these objects are combined in an object of type <a class="el" href="classMultigrid.html">Multigrid</a>, containing the implementation of the V-cycle, which is in turn used by the preconditioner <a class="el" href="classPreconditionMG.html">PreconditionMG</a>, ready for plug-in into a linear solver of the LAC library.</p>
<p>The multilevel method in deal.II follows in many respects the outlines of the various publications by James Bramble, Joseph Pasciak and Jinchao Xu (i.e. the "BPX" framework). In order to understand many of the options, a rough familiarity with their work is quite helpful.</p>
<p>However, in comparison to this framework, the implementation in deal.II has to take into account the fact that we want to solve linear systems on adaptively refined meshes. This leads to the complication that it isn't quite as clear any more what exactly a "level" in a multilevel hierarchy of a mesh is. The following image shows what we consider to be a "level":</p>
<div class="image">
<img src="hanging_nodes.png" alt="hanging_nodes.png"/>
</div>
<p>In other words, the fine level in this mesh consists only of the degrees of freedom that are defined on the refined cells, but does not extend to that part of the domain that is not refined. While this guarantees that the overall effort grows as <img class="formulaInl" alt="${\cal O}(N)$" src="form_138.png"/> as necessary for optimal multigrid complexity, it leads to problems when defining where to smooth and what boundary conditions to pose for the operators defined on individual levels if the level boundary is not an external boundary. These questions are discussed in detail in the <a class="el" href="DEALGlossary.html#mg_paper">Multigrid paper by Janssen and Kanschat</a> that describes the implementation in deal.II.</p>
<p><a class="anchor" id="Thetestcase"></a></p>
<h3>The testcase</h3>
<p>The problem we solve here is exactly the same as in <a class="el" href="step_6.html">step-6</a>, the only difference being the solver we use here. You may want to look there for a definition of what we solve, right hand side and boundary conditions. Obviously, the program would also work if we changed the geometry and other pieces of data that defines this particular problem.</p>
<p>The things that are new are all those parts that concern the multigrid. In particular, this includes the following members of the main class:</p>
<ul>
<li><code>LaplaceProblem::mg_dof_handler</code></li>
<li><code>LaplaceProblem::mg_sparsity</code></li>
<li><code>LaplaceProblem::mg_matrices</code></li>
<li><code>LaplaceProblem::mg_interface_matrices_up</code></li>
<li><code>LaplaceProblem::assemble_multigrid ()</code></li>
<li><code>LaplaceProblem::solve ()</code> Take a look at these functions. <a class="anchor" id="CommProg"></a> <h1>The commented program</h1>
</li>
</ul>
<p>As discussed in the introduction, most of this program is copied almost verbatim from <a class="el" href="step_6.html">step-6</a>, which itself is only a slight modification of <a class="el" href="step_5.html">step-5</a>. Consequently, a significant part of this program is not new if you've read all the material up to <a class="el" href="step_6.html">step-6</a>, and we won't comment on that part of the functionality that is unchanged. Rather, we will focus on those aspects of the program that have to do with the multigrid functionality which forms the new aspect of this tutorial program.</p>
<p><a class="anchor" id="Includefiles"></a> </p>
<h3>Include files</h3>
<p>Again, the first few include files are already known, so we won't comment on them:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/base/quadrature_lib.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/base/function.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/base/logstream.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/base/utilities.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/lac/constraint_matrix.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/lac/vector.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/lac/full_matrix.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/lac/sparse_matrix.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/lac/solver_cg.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/lac/precondition.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_accessor.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_iterator.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_generator.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_refinement.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_boundary_lib.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_accessor.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_tools.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_q.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_values.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/vector_tools.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/data_out.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/error_estimator.h&gt;</span></div>
</div><!-- fragment --><p>These, now, are the include necessary for the multilevel methods. The first two declare classes that allow us to enumerate degrees of freedom not only on the finest mesh level, but also on intermediate levels (that's what the <a class="el" href="classMGDoFHandler.html">MGDoFHandler</a> class does) as well as allow to access this information (iterators and accessors over these cells).</p>
<p>The rest of the include files deals with the mechanics of multigrid as a linear operator (solver or preconditioner).</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/multigrid/mg_dof_handler.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/multigrid/mg_constrained_dofs.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/multigrid/multigrid.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/multigrid/mg_transfer.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/multigrid/mg_tools.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/multigrid/mg_coarse.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/multigrid/mg_smoother.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/multigrid/mg_matrix.h&gt;</span></div>
</div><!-- fragment --><p>This is C++:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div>
</div><!-- fragment --><p>The last step is as in all previous programs:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Step16</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">using namespace </span>dealii;</div>
</div><!-- fragment --><p><a class="anchor" id="ThecodeLaplaceProblemcodeclasstemplate"></a> </p>
<h3>The <code>LaplaceProblem</code> class template</h3>
<p>This main class is basically the same class as in <a class="el" href="step_6.html">step-6</a>. As far as member functions is concerned, the only addition is the <code>assemble_multigrid</code> function that assembles the matrices that correspond to the discrete operators on intermediate levels:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keyword">class </span>LaplaceProblem</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  LaplaceProblem (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree);</div>
<div class="line">  <span class="keywordtype">void</span> run ();</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keywordtype">void</span> setup_system ();</div>
<div class="line">  <span class="keywordtype">void</span> assemble_system ();</div>
<div class="line">  <span class="keywordtype">void</span> assemble_multigrid ();</div>
<div class="line">  <span class="keywordtype">void</span> solve ();</div>
<div class="line">  <span class="keywordtype">void</span> refine_grid ();</div>
<div class="line">  <span class="keywordtype">void</span> output_results (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle) <span class="keyword">const</span>;</div>
<div class="line"></div>
<div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a>   triangulation;</div>
<div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>            fe;</div>
<div class="line">  <a class="code" href="classMGDoFHandler.html">MGDoFHandler&lt;dim&gt;</a>    mg_dof_handler;</div>
<div class="line"></div>
<div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div>
<div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div>
</div><!-- fragment --><p>We need an additional object for the hanging nodes constraints. They are handed to the transfer object in the multigrid. Since we call a compress inside the multigrid these constraints are not allowed to be inhomogeneous so we store them in different <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> objects.</p>
<div class="fragment"><div class="line"><a class="code" href="classConstraintMatrix.html">ConstraintMatrix</a>     hanging_node_constraints;</div>
<div class="line"><a class="code" href="classConstraintMatrix.html">ConstraintMatrix</a>     constraints;</div>
<div class="line"></div>
<div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a>       solution;</div>
<div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a>       system_rhs;</div>
<div class="line"></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree;</div>
</div><!-- fragment --><p>The following four objects are the only additional member variables, compared to <a class="el" href="step_6.html">step-6</a>. The first three represent the operators that act on individual levels of the multilevel hierarchy, rather than on the finest mesh as do the objects above while the last object stores information about the boundary indices on each level and information about indices lying on a refinement edge between two different refinement levels.</p>
<p>To facilitate having objects on each level of a multilevel hierarchy, deal.II has the <a class="el" href="classMGLevelObject.html">MGLevelObject</a> class template that provides storage for objects on each level. What we need here are matrices on each level, which implies that we also need sparsity patterns on each level. As outlined in the <a class="el" href="DEALGlossary.html#mg_paper">mg_paper</a>, the operators (matrices) that we need are actually twofold: one on the interior of each level, and one at the interface between each level and that part of the domain where the mesh is coarser. In fact, we will need the latter in two versions: for the direction from coarse to fine mesh and from fine to coarse. Fortunately, however, we here have a self-adjoint problem for which one of these is the transpose of the other, and so we only have to build one; we choose the one from coarse to fine.</p>
<div class="fragment"><div class="line">  <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparsityPattern&gt;</a>       mg_sparsity_patterns;</div>
<div class="line">  <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparseMatrix&lt;double&gt;</a> &gt; mg_matrices;</div>
<div class="line">  <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparseMatrix&lt;double&gt;</a> &gt; mg_interface_matrices;</div>
<div class="line">  <a class="code" href="classMGConstrainedDoFs.html">MGConstrainedDoFs</a>                    mg_constrained_dofs;</div>
<div class="line">};</div>
</div><!-- fragment --><p><a class="anchor" id="Nonconstantcoefficients"></a> </p>
<h3>Nonconstant coefficients</h3>
<p>The implementation of nonconstant coefficients is copied verbatim from <a class="el" href="step_5.html">step-5</a> and <a class="el" href="step_6.html">step-6</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keyword">class </span>Coefficient : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  Coefficient () : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;() {}</div>
<div class="line"></div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#a9783cc12b6b205d4019379b0cc6f3956">value</a> (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>   &amp;p,</div>
<div class="line">                        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  component = 0) <span class="keyword">const</span>;</div>
<div class="line"></div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classFunction.html#af6f1aceeeb499ff07d828df250f4f3b2">value_list</a> (<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &gt; &amp;points,</div>
<div class="line">                           std::vector&lt;double&gt;            &amp;values,</div>
<div class="line">                           <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>              component = 0) <span class="keyword">const</span>;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">double</span> Coefficient&lt;dim&gt;::value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div>
<div class="line">                                <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  <span class="keywordflow">if</span> (p.<a class="code" href="classPoint.html#ad46f55479010282e242b1d8e427285e8">square</a>() &lt; 0.5*0.5)</div>
<div class="line">    <span class="keywordflow">return</span> 20;</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">    <span class="keywordflow">return</span> 1;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> Coefficient&lt;dim&gt;::value_list (<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &gt; &amp;points,</div>
<div class="line">                                   std::vector&lt;double&gt;            &amp;values,</div>
<div class="line">                                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>              component)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_points = points.size();</div>
<div class="line"></div>
<div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (values.size() == n_points,</div>
<div class="line">          <a class="code" href="group__Exceptions.html#ga325fd73751a9373f1b901962daeb2ea7">ExcDimensionMismatch</a> (values.size(), n_points));</div>
<div class="line"></div>
<div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (component == 0,</div>
<div class="line">          <a class="code" href="group__Exceptions.html#ga3f3f87a5613ac8b4e64ecd458dea8e9b">ExcIndexRange</a> (component, 0, 1));</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;n_points; ++i)</div>
<div class="line">    values[i] = Coefficient&lt;dim&gt;::value (points[i]);</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="ThecodeLaplaceProblemcodeclassimplementation"></a> </p>
<h3>The <code>LaplaceProblem</code> class implementation</h3>
<p><a class="anchor" id="LaplaceProblemLaplaceProblem"></a> </p>
<h4>LaplaceProblem::LaplaceProblem</h4>
<p>The constructor is left mostly unchanged. We take the polynomial degree of the finite elements to be used as a constructor argument and store it in a member variable.</p>
<p>By convention, all adaptively refined triangulations in deal.II never change by more than one level across a face between cells. For our multigrid algorithms, however, we need a slightly stricter guarantee, namely that the mesh also does not change by more than refinement level across vertices that might connect two cells. In other words, we must prevent the following situation:</p>
<div class="image">
<img src="limit_level_difference_at_vertices.png" alt="limit_level_difference_at_vertices.png"/>
</div>
<p>This is achieved by passing the <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeaa2ab57e4f7b1633f26092ae861ea3bfc">Triangulation::limit_level_difference_at_vertices</a> flag to the constructor of the triangulation class.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">LaplaceProblem&lt;dim&gt;::LaplaceProblem (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree)</div>
<div class="line">  :</div>
<div class="line">  triangulation (<a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::</div>
<div class="line">                 limit_level_difference_at_vertices),</div>
<div class="line">  fe (degree),</div>
<div class="line">  mg_dof_handler (triangulation),</div>
<div class="line">  degree(degree)</div>
<div class="line">{}</div>
</div><!-- fragment --><p><a class="anchor" id="LaplaceProblemsetup_system"></a> </p>
<h4>LaplaceProblem::setup_system</h4>
<p>The following function extends what the corresponding one in <a class="el" href="step_6.html">step-6</a> did. The top part, apart from the additional output, does the same:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::setup_system ()</div>
<div class="line">{</div>
<div class="line">  mg_dof_handler.distribute_dofs (fe);</div>
</div><!-- fragment --><p>Here we output not only the degrees of freedom on the finest level, but also in the multilevel structure</p>
<div class="fragment"><div class="line">deallog &lt;&lt; <span class="stringliteral">&quot;Number of degrees of freedom: &quot;</span></div>
<div class="line">        &lt;&lt; mg_dof_handler.n_dofs();</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> l=0; l&lt;triangulation.<a class="code" href="classTriangulation.html#ad966e087386ee0330371ebd73f2cfe99">n_levels</a>(); ++l)</div>
<div class="line">  deallog &lt;&lt; <span class="stringliteral">&quot;   &quot;</span> &lt;&lt; <span class="charliteral">&#39;L&#39;</span> &lt;&lt; l &lt;&lt; <span class="stringliteral">&quot;: &quot;</span></div>
<div class="line">          &lt;&lt; mg_dof_handler.n_dofs(l);</div>
<div class="line">deallog  &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line">sparsity_pattern.<a class="code" href="classSparsityPattern.html#aeb0b103258aaa649939e1610f5a1ca8e">reinit</a> (mg_dof_handler.n_dofs(),</div>
<div class="line">                         mg_dof_handler.n_dofs(),</div>
<div class="line">                         mg_dof_handler.max_couplings_between_dofs());</div>
<div class="line"><a class="code" href="group__constraints.html#gab627b1d4845c9526521dbd1be83469dc">DoFTools::make_sparsity_pattern</a> (mg_dof_handler, sparsity_pattern);</div>
<div class="line"></div>
<div class="line">solution.<a class="code" href="classVector.html#ac3adfcf8cf35943558fc27ef989b7263">reinit</a> (mg_dof_handler.n_dofs());</div>
<div class="line">system_rhs.<a class="code" href="classBlockVector.html#a4caa9be7a7053fd6ae9fac1da74e564b">reinit</a> (mg_dof_handler.n_dofs());</div>
</div><!-- fragment --><p>But it starts to be a wee bit different here, although this still doesn't have anything to do with multigrid methods. <a class="el" href="step_6.html">step-6</a> took care of boundary values and hanging nodes in a separate step after assembling the global matrix from local contributions. This works, but the same can be done in a slightly simpler way if we already take care of these constraints at the time of copying local contributions into the global matrix. To this end, we here do not just compute the constraints do to hanging nodes, but also due to zero boundary conditions. We will use this set of constraints later on to help us copy local contributions correctly into the global linear system right away, without the need for a later clean-up stage:</p>
<div class="fragment"><div class="line">constraints.<a class="code" href="classConstraintMatrix.html#a24120d0331183f9a63cbe41493a19f6b">clear</a> ();</div>
<div class="line">hanging_node_constraints.clear ();</div>
<div class="line"><a class="code" href="group__constraints.html#gabe9d21d4bb33ce556a6e6e80c2bf4b41">DoFTools::make_hanging_node_constraints</a> (mg_dof_handler, hanging_node_constraints);</div>
<div class="line"><a class="code" href="group__constraints.html#gabe9d21d4bb33ce556a6e6e80c2bf4b41">DoFTools::make_hanging_node_constraints</a> (mg_dof_handler, constraints);</div>
<div class="line"></div>
<div class="line"><span class="keyword">typename</span> <a class="code" href="structFunctionMap.html#aa286a6c5e13045f84faabfd7170b1c48">FunctionMap&lt;dim&gt;::type</a>      dirichlet_boundary;</div>
<div class="line"><a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a>                    homogeneous_dirichlet_bc (1);</div>
<div class="line">dirichlet_boundary[0] = &amp;homogeneous_dirichlet_bc;</div>
<div class="line"><a class="code" href="namespaceVectorTools.html#a199f38e07822b47e5b5957c21ce35d1b">VectorTools::interpolate_boundary_values</a> (<span class="keyword">static_cast&lt;</span><span class="keyword">const </span><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>&amp;<span class="keyword">&gt;</span>(mg_dof_handler),</div>
<div class="line">                                          dirichlet_boundary,</div>
<div class="line">                                          constraints);</div>
<div class="line">constraints.<a class="code" href="classConstraintMatrix.html#a8056d07faa2a7ed3f158c1b42d56abc8">close</a> ();</div>
<div class="line">hanging_node_constraints.close ();</div>
<div class="line">constraints.<a class="code" href="classConstraintMatrix.html#a66337316e8fbbc786c9f0383d085ab01">condense</a> (sparsity_pattern);</div>
<div class="line">sparsity_pattern.<a class="code" href="classSparsityPattern.html#ad15d36e4bfe7c97b55d155541e723284">compress</a>();</div>
<div class="line">system_matrix.reinit (sparsity_pattern);</div>
</div><!-- fragment --><p>The multigrid constraints have to be initialized. They need to know about the boundary values as well, so we pass the <code>dirichlet_boundary</code> here as well.</p>
<div class="fragment"><div class="line">mg_constrained_dofs.clear();</div>
<div class="line">mg_constrained_dofs.initialize(mg_dof_handler, dirichlet_boundary);</div>
</div><!-- fragment --><p>Now for the things that concern the multigrid data structures. First, we resize the multilevel objects to hold matrices and sparsity patterns for every level. The coarse level is zero (this is mandatory right now but may change in a future revision). Note that these functions take a complete, inclusive range here (not a starting index and size), so the finest level is <code>n_levels-1</code>. We first have to resize the container holding the <a class="el" href="classSparseMatrix.html">SparseMatrix</a> classes, since they have to release their <a class="el" href="classSparsityPattern.html">SparsityPattern</a> before the can be destroyed upon resizing.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_levels = triangulation.<a class="code" href="classTriangulation.html#ad966e087386ee0330371ebd73f2cfe99">n_levels</a>();</div>
<div class="line"></div>
<div class="line">mg_interface_matrices.resize(0, n_levels-1);</div>
<div class="line">mg_interface_matrices.clear ();</div>
<div class="line">mg_matrices.resize(0, n_levels-1);</div>
<div class="line">mg_matrices.clear ();</div>
<div class="line">mg_sparsity_patterns.resize(0, n_levels-1);</div>
</div><!-- fragment --><p>Now, we have to provide a matrix on each level. To this end, we first use the <a class="el" href="namespaceMGTools.html#a579c0c8095694da9c3f588559ba233d0">MGTools::make_sparsity_pattern</a> function to first generate a preliminary compressed sparsity pattern on each level (see the <a class="el" href="group__Sparsity.html">Sparsity patterns</a> module for more information on this topic) and then copy it over to the one we really want. The next step is to initialize both kinds of level matrices with these sparsity patterns.</p>
<p>It may be worth pointing out that the interface matrices only have entries for degrees of freedom that sit at or next to the interface between coarser and finer levels of the mesh. They are therefore even sparser than the matrices on the individual levels of our multigrid hierarchy. If we were more concerned about memory usage (and possibly the speed with which we can multiply with these matrices), we should use separate and different sparsity patterns for these two kinds of matrices.</p>
<div class="fragment"><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level=0; level&lt;n_levels; ++level)</div>
<div class="line">    {</div>
<div class="line">      <a class="code" href="classCompressedSparsityPattern.html">CompressedSparsityPattern</a> csp;</div>
<div class="line">      csp.<a class="code" href="classCompressedSparsityPattern.html#adc9c1431ad5bb05efff17da64b49d40f">reinit</a>(mg_dof_handler.n_dofs(level),</div>
<div class="line">                 mg_dof_handler.n_dofs(level));</div>
<div class="line">      <a class="code" href="namespaceMGTools.html#a579c0c8095694da9c3f588559ba233d0">MGTools::make_sparsity_pattern</a>(mg_dof_handler, csp, level);</div>
<div class="line"></div>
<div class="line">      mg_sparsity_patterns[level].copy_from (csp);</div>
<div class="line"></div>
<div class="line">      mg_matrices[level].reinit(mg_sparsity_patterns[level]);</div>
<div class="line">      mg_interface_matrices[level].reinit(mg_sparsity_patterns[level]);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="LaplaceProblemassemble_system"></a> </p>
<h4>LaplaceProblem::assemble_system</h4>
<p>The following function assembles the linear system on the finest level of the mesh. It is almost exactly the same as in <a class="el" href="step_6.html">step-6</a>, with the exception that we don't eliminate hanging nodes and boundary values after assembling, but while copying local contributions into the global matrix. This is not only simpler but also more efficient for large problems.</p>
<p>This latter trick is something that only found its way into deal.II over time and wasn't used in the initial version of this tutorial program. There is, however, a discussion of this function in the introduction of <a class="el" href="step_27.html">step-27</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::assemble_system ()</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>  quadrature_formula(degree+1);</div>
<div class="line"></div>
<div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values (fe, quadrature_formula,</div>
<div class="line">                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>    |  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div>
<div class="line">                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>  |  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div>
<div class="line"></div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   dofs_per_cell = fe.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>;</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#a4d64837b1d374e9c46f07af8f094b29b">size</a>();</div>
<div class="line"></div>
<div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>   cell_matrix (dofs_per_cell, dofs_per_cell);</div>
<div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       cell_rhs (dofs_per_cell);</div>
<div class="line"></div>
<div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices (dofs_per_cell);</div>
<div class="line"></div>
<div class="line">  <span class="keyword">const</span> Coefficient&lt;dim&gt; coefficient;</div>
<div class="line">  std::vector&lt;double&gt;    coefficient_values (n_q_points);</div>
<div class="line"></div>
<div class="line">  <span class="keyword">typename</span> MGDoFHandler&lt;dim&gt;::active_cell_iterator</div>
<div class="line">  cell = mg_dof_handler.<a class="code" href="classDoFHandler.html#a6f2aa9c61385cbb749ed3d2e7bfe3de1">begin_active</a>(),</div>
<div class="line">  endc = mg_dof_handler.end();</div>
<div class="line">  <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div>
<div class="line">    {</div>
<div class="line">      cell_matrix = 0;</div>
<div class="line">      cell_rhs = 0;</div>
<div class="line"></div>
<div class="line">      fe_values.<a class="code" href="classFEValues.html#afde502903642c57ade24dfcebf5c1650">reinit</a> (cell);</div>
<div class="line"></div>
<div class="line">      coefficient.value_list (fe_values.<a class="code" href="classFEValuesBase.html#a5f8732ebe2d3c6746f6de26a79cb1e45">get_quadrature_points</a>(),</div>
<div class="line">                              coefficient_values);</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point=0; q_point&lt;n_q_points; ++q_point)</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div>
<div class="line">          {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div>
<div class="line">              cell_matrix(i,j) += (coefficient_values[q_point] *</div>
<div class="line">                                   fe_values.<a class="code" href="classFEValuesBase.html#ac4cee7628c2903a89c5c399fddeb00a5">shape_grad</a>(i,q_point) *</div>
<div class="line">                                   fe_values.<a class="code" href="classFEValuesBase.html#ac4cee7628c2903a89c5c399fddeb00a5">shape_grad</a>(j,q_point) *</div>
<div class="line">                                   fe_values.<a class="code" href="classFEValuesBase.html#ad097580a2f71878695096cc73b271b9d">JxW</a>(q_point));</div>
<div class="line"></div>
<div class="line">            cell_rhs(i) += (fe_values.<a class="code" href="classFEValuesBase.html#abe4de48ff59778bb82a0ec13037804aa">shape_value</a>(i,q_point) *</div>
<div class="line">                            1.0 *</div>
<div class="line">                            fe_values.<a class="code" href="classFEValuesBase.html#ad097580a2f71878695096cc73b271b9d">JxW</a>(q_point));</div>
<div class="line">          }</div>
<div class="line"></div>
<div class="line">      cell-&gt;get_dof_indices (local_dof_indices);</div>
<div class="line">      constraints.<a class="code" href="classConstraintMatrix.html#aa9f3612a8fc51eafa34252bb436e8ae4">distribute_local_to_global</a> (cell_matrix, cell_rhs,</div>
<div class="line">                                              local_dof_indices,</div>
<div class="line">                                              system_matrix, system_rhs);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="LaplaceProblemassemble_multigrid"></a> </p>
<h4>LaplaceProblem::assemble_multigrid</h4>
<p>The next function is the one that builds the linear operators (matrices) that define the multigrid method on each level of the mesh. The integration core is the same as above, but the loop below will go over all existing cells instead of just the active ones, and the results must be entered into the correct matrix. Note also that since we only do multilevel preconditioning, no right-hand side needs to be assembled here.</p>
<p>Before we go there, however, we have to take care of a significant amount of book keeping:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::assemble_multigrid ()</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>  quadrature_formula(1+degree);</div>
<div class="line"></div>
<div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values (fe, quadrature_formula,</div>
<div class="line">                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>   | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div>
<div class="line">                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div>
<div class="line"></div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   dofs_per_cell   = fe.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>;</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   n_q_points      = quadrature_formula.<a class="code" href="classQuadrature.html#a4d64837b1d374e9c46f07af8f094b29b">size</a>();</div>
<div class="line"></div>
<div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>   cell_matrix (dofs_per_cell, dofs_per_cell);</div>
<div class="line"></div>
<div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices (dofs_per_cell);</div>
<div class="line"></div>
<div class="line">  <span class="keyword">const</span> Coefficient&lt;dim&gt; coefficient;</div>
<div class="line">  std::vector&lt;double&gt;    coefficient_values (n_q_points);</div>
</div><!-- fragment --><p>Next a few things that are specific to building the multigrid data structures (since we only need them in the current function, rather than also elsewhere, we build them here instead of the <code>setup_system</code> function). Some of the following may be a bit obscure if you're not familiar with the algorithm actually implemented in deal.II to support multilevel algorithms on adaptive meshes; if some of the things below seem strange, take a look at the <a class="el" href="DEALGlossary.html#mg_paper">mg_paper</a>.</p>
<p>Our first job is to identify those degrees of freedom on each level that are located on interfaces between adaptively refined levels, and those that lie on the interface but also on the exterior boundary of the domain. As in many other parts of the library, we do this by using Boolean masks, i.e. vectors of Booleans each element of which indicates whether the corresponding degree of freedom index is an interface DoF or not. The <code>MGConstraints</code> already computed the information for us when we called initialize in <code>setup_system()</code>.</p>
<div class="fragment"><div class="line">std::vector&lt;std::vector&lt;bool&gt; &gt; interface_dofs</div>
<div class="line">  = mg_constrained_dofs.get_refinement_edge_indices ();</div>
<div class="line">std::vector&lt;std::vector&lt;bool&gt; &gt; boundary_interface_dofs</div>
<div class="line">  = mg_constrained_dofs.get_refinement_edge_boundary_indices ();</div>
</div><!-- fragment --><p>The indices just identified will later be used to decide where the assembled value has to be added into on each level. On the other hand, we also have to impose zero boundary conditions on the external boundary of each level. But this the <code>MGConstraints</code> knows. So we simply ask for them by calling <code>get_boundary_indices()</code>. The third step is to construct constraints on all those degrees of freedom: their value should be zero after each application of the level operators. To this end, we construct <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> objects for each level, and add to each of these constraints for each degree of freedom. Due to the way the <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> stores its data, the function to add a constraint on a single degree of freedom and force it to be zero is called Constraintmatrix::add_line(); doing so for several degrees of freedom at once can be done using Constraintmatrix::add_lines():</p>
<div class="fragment"><div class="line">std::vector&lt;ConstraintMatrix&gt; boundary_constraints (triangulation.<a class="code" href="classTriangulation.html#ad966e087386ee0330371ebd73f2cfe99">n_levels</a>());</div>
<div class="line">std::vector&lt;ConstraintMatrix&gt; boundary_interface_constraints (triangulation.<a class="code" href="classTriangulation.html#ad966e087386ee0330371ebd73f2cfe99">n_levels</a>());</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level=0; level&lt;triangulation.<a class="code" href="classTriangulation.html#ad966e087386ee0330371ebd73f2cfe99">n_levels</a>(); ++level)</div>
<div class="line">  {</div>
<div class="line">    boundary_constraints[level].add_lines (interface_dofs[level]);</div>
<div class="line">    boundary_constraints[level].add_lines (mg_constrained_dofs.get_boundary_indices()[level]);</div>
<div class="line">    boundary_constraints[level].close ();</div>
<div class="line"></div>
<div class="line">    boundary_interface_constraints[level]</div>
<div class="line">    .add_lines (boundary_interface_dofs[level]);</div>
<div class="line">    boundary_interface_constraints[level].close ();</div>
<div class="line">  }</div>
</div><!-- fragment --><p>Now that we're done with most of our preliminaries, let's start the integration loop. It looks mostly like the loop in <code>assemble_system</code>, with two exceptions: (i) we don't need a right hand side, and more significantly (ii) we don't just loop over all active cells, but in fact all cells, active or not. Consequently, the correct iterator to use is MGDoFHandler::cell_iterator rather than MGDoFHandler::active_cell_iterator. Let's go about it:</p>
<div class="fragment"><div class="line"><span class="keyword">typename</span> MGDoFHandler&lt;dim&gt;::cell_iterator cell = mg_dof_handler.<a class="code" href="classMGDoFHandler.html#a3c070825136093810f79af5996ad86f4">begin</a>(),</div>
<div class="line">                                          endc = mg_dof_handler.end();</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (; cell!=endc; ++cell)</div>
<div class="line">  {</div>
<div class="line">    cell_matrix = 0;</div>
<div class="line">    fe_values.<a class="code" href="classFEValues.html#afde502903642c57ade24dfcebf5c1650">reinit</a> (cell);</div>
<div class="line"></div>
<div class="line">    coefficient.value_list (fe_values.<a class="code" href="classFEValuesBase.html#a5f8732ebe2d3c6746f6de26a79cb1e45">get_quadrature_points</a>(),</div>
<div class="line">                            coefficient_values);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point=0; q_point&lt;n_q_points; ++q_point)</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div>
<div class="line">          cell_matrix(i,j) += (coefficient_values[q_point] *</div>
<div class="line">                               fe_values.<a class="code" href="classFEValuesBase.html#ac4cee7628c2903a89c5c399fddeb00a5">shape_grad</a>(i,q_point) *</div>
<div class="line">                               fe_values.<a class="code" href="classFEValuesBase.html#ac4cee7628c2903a89c5c399fddeb00a5">shape_grad</a>(j,q_point) *</div>
<div class="line">                               fe_values.<a class="code" href="classFEValuesBase.html#ad097580a2f71878695096cc73b271b9d">JxW</a>(q_point));</div>
</div><!-- fragment --><p>The rest of the assembly is again slightly different. This starts with a gotcha that is easily forgotten: The indices of global degrees of freedom we want here are the ones for current level, not for the global matrix. We therefore need the function MGDoFAccessorLLget_mg_dof_indices, not MGDoFAccessor::get_dof_indices as used in the assembly of the global system:</p>
<div class="fragment"><div class="line">cell-&gt;get_mg_dof_indices (local_dof_indices);</div>
</div><!-- fragment --><p>Next, we need to copy local contributions into the level objects. We can do this in the same way as in the global assembly, using a constraint object that takes care of constrained degrees (which here are only boundary nodes, as the individual levels have no hanging node constraints). Note that the <code>boundary_constraints</code> object makes sure that the level matrices contains no contributions from degrees of freedom at the interface between cells of different refinement level.</p>
<div class="fragment"><div class="line">boundary_constraints[cell-&gt;level()]</div>
<div class="line">.distribute_local_to_global (cell_matrix,</div>
<div class="line">                             local_dof_indices,</div>
<div class="line">                             mg_matrices[cell-&gt;level()]);</div>
</div><!-- fragment --><p>The next step is again slightly more obscure (but explained in the <a class="el" href="DEALGlossary.html#mg_paper">mg_paper</a>): We need the remainder of the operator that we just copied into the <code>mg_matrices</code> object, namely the part on the interface between cells at the current level and cells one level coarser. This matrix exists in two directions: for interior DoFs (index <img class="formulaInl" alt="$i$" src="form_77.png"/>) of the current level to those sitting on the interface (index <img class="formulaInl" alt="$j$" src="form_391.png"/>), and the other way around. Of course, since we have a symmetric operator, one of these matrices is the transpose of the other.</p>
<p>The way we assemble these matrices is as follows: since the are formed from parts of the local contributions, we first delete all those parts of the local contributions that we are not interested in, namely all those elements of the local matrix for which not <img class="formulaInl" alt="$i$" src="form_77.png"/> is an interface DoF and <img class="formulaInl" alt="$j$" src="form_391.png"/> is not. The result is one of the two matrices that we are interested in, and we then copy it into the <code>mg_interface_matrices</code> object. The <code>boundary_interface_constraints</code> object at the same time makes sure that we delete contributions from all degrees of freedom that are not only on the interface but also on the external boundary of the domain.</p>
<p>The last part to remember is how to get the other matrix. Since it is only the transpose, we will later (in the <code>solve()</code> function) be able to just pass the transpose matrix where necessary.</p>
<div class="fragment"><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div>
<div class="line">          <span class="keywordflow">if</span> ( !(interface_dofs[cell-&gt;level()][local_dof_indices[i]]==<span class="keyword">true</span> &amp;&amp;</div>
<div class="line">                 interface_dofs[cell-&gt;level()][local_dof_indices[j]]==<span class="keyword">false</span>))</div>
<div class="line">            cell_matrix(i,j) = 0;</div>
<div class="line"></div>
<div class="line">      boundary_interface_constraints[cell-&gt;level()]</div>
<div class="line">      .distribute_local_to_global (cell_matrix,</div>
<div class="line">                                   local_dof_indices,</div>
<div class="line">                                   mg_interface_matrices[cell-&gt;level()]);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="LaplaceProblemsolve"></a> </p>
<h4>LaplaceProblem::solve</h4>
<p>This is the other function that is significantly different in support of the multigrid solver (or, in fact, the preconditioner for which we use the multigrid method).</p>
<p>Let us start out by setting up two of the components of multilevel methods: transfer operators between levels, and a solver on the coarsest level. In finite element methods, the transfer operators are derived from the finite element function spaces involved and can often be computed in a generic way independent of the problem under consideration. In that case, we can use the <a class="el" href="classMGTransferPrebuilt.html">MGTransferPrebuilt</a> class that, given the constraints on the global level and an <a class="el" href="classMGDoFHandler.html">MGDoFHandler</a> object computes the matrices corresponding to these transfer operators.</p>
<p>The second part of the following lines deals with the coarse grid solver. Since our coarse grid is very coarse indeed, we decide for a direct solver (a <a class="el" href="classHouseholder.html">Householder</a> decomposition of the coarsest level matrix), even if its implementation is not particularly sophisticated. If our coarse mesh had many more cells than the five we have here, something better suited would obviously be necessary here.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::solve ()</div>
<div class="line">{</div>
</div><!-- fragment --><p>Create the object that deals with the transfer between different refinement levels. We need to pass it the hanging node constraints.</p>
<div class="fragment"><div class="line"><a class="code" href="classMGTransferPrebuilt.html">MGTransferPrebuilt&lt;Vector&lt;double&gt;</a> &gt; mg_transfer(hanging_node_constraints, mg_constrained_dofs);</div>
</div><!-- fragment --><p>Now the prolongation matrix has to be built. This matrix needs to take the boundary values on each level into account and needs to know about the indices at the refinement edges. The <code>MGConstraints</code> knows about that so pass it as an argument.</p>
<div class="fragment"><div class="line">mg_transfer.<a class="code" href="classMGTransferPrebuilt.html#a58e346481bd8a8a9994bb8b5d5d9772a">build_matrices</a>(mg_dof_handler);</div>
<div class="line"></div>
<div class="line"><a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> coarse_matrix;</div>
<div class="line">coarse_matrix.<a class="code" href="classFullMatrix.html#a365a27cf59b05800d7889d5fb28a1d93">copy_from</a> (mg_matrices[0]);</div>
<div class="line"><a class="code" href="classMGCoarseGridHouseholder.html">MGCoarseGridHouseholder&lt;&gt;</a> coarse_grid_solver;</div>
<div class="line">coarse_grid_solver.<a class="code" href="classMGCoarseGridHouseholder.html#a2790d07d059be92b2a7b608d1917e78e">initialize</a> (coarse_matrix);</div>
</div><!-- fragment --><p>The next component of a multilevel solver or preconditioner is that we need a smoother on each level. A common choice for this is to use the application of a relaxation method (such as the SOR, Jacobi or Richardson method) or a small number of iterations of a solver method (such as CG or GMRES). The <a class="el" href="classmg_1_1SmootherRelaxation.html">mg::SmootherRelaxation</a> and <a class="el" href="classMGSmootherPrecondition.html">MGSmootherPrecondition</a> classes provide support for these two kinds of smoothers. Here, we opt for the application of a single SOR iteration. To this end, we define an appropriate <code>typedef</code> and then setup a smoother object.</p>
<p>Since this smoother needs temporary vectors to store intermediate results, we need to provide a <a class="el" href="classVectorMemory.html">VectorMemory</a> object. Since these vectors will be reused over and over, the <a class="el" href="classGrowingVectorMemory.html">GrowingVectorMemory</a> is more time efficient than the <a class="el" href="classPrimitiveVectorMemory.html">PrimitiveVectorMemory</a> class in the current case.</p>
<p>The last step is to initialize the smoother object with our level matrices and to set some smoothing parameters. The <code>initialize()</code> function can optionally take additional arguments that will be passed to the smoother object on each level. In the current case for the SOR smoother, this could, for example, include a relaxation parameter. However, we here leave these at their default values. The call to <code>set_steps()</code> indicates that we will use two pre- and two post-smoothing steps on each level; to use a variable number of smoother steps on different levels, more options can be set in the constructor call to the <code>mg_smoother</code> object.</p>
<p>The last step results from the fact that we use the SOR method as a smoother - which is not symmetric - but we use the conjugate gradient iteration (which requires a symmetric preconditioner) below, we need to let the multilevel preconditioner make sure that we get a symmetric operator even for nonsymmetric smoothers:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="classPreconditionSOR.html">PreconditionSOR&lt;SparseMatrix&lt;double&gt;</a> &gt; Smoother;</div>
<div class="line"><a class="code" href="classmg_1_1SmootherRelaxation.html">mg::SmootherRelaxation&lt;Smoother, Vector&lt;double&gt;</a> &gt; mg_smoother;</div>
<div class="line">mg_smoother.<a class="code" href="classmg_1_1SmootherRelaxation.html#a2e4ccbaa2e9b7c09c464eec83eb1be9d">initialize</a>(mg_matrices);</div>
<div class="line">mg_smoother.<a class="code" href="classMGSmoother.html#a8604565dd6bc1eb73245e72089a467f3">set_steps</a>(2);</div>
<div class="line">mg_smoother.<a class="code" href="classMGSmoother.html#a6afa8e3892105c937145f4be8bed13fe">set_symmetric</a>(<span class="keyword">true</span>);</div>
</div><!-- fragment --><p>The next preparatory step is that we must wrap our level and interface matrices in an object having the required multiplication functions. We will create two objects for the interface objects going from coarse to fine and the other way around; the multigrid algorithm will later use the transpose operator for the latter operation, allowing us to initialize both up and down versions of the operator with the matrices we already built:</p>
<div class="fragment"><div class="line"><a class="code" href="classMGMatrix.html">MGMatrix&lt;&gt;</a> mg_matrix(&amp;mg_matrices);</div>
<div class="line"><a class="code" href="classMGMatrix.html">MGMatrix&lt;&gt;</a> mg_interface_up(&amp;mg_interface_matrices);</div>
<div class="line"><a class="code" href="classMGMatrix.html">MGMatrix&lt;&gt;</a> mg_interface_down(&amp;mg_interface_matrices);</div>
</div><!-- fragment --><p>Now, we are ready to set up the V-cycle operator and the multilevel preconditioner.</p>
<div class="fragment"><div class="line"><a class="code" href="classMultigrid.html">Multigrid&lt;Vector&lt;double&gt;</a> &gt; mg(mg_dof_handler,</div>
<div class="line">                              mg_matrix,</div>
<div class="line">                              coarse_grid_solver,</div>
<div class="line">                              mg_transfer,</div>
<div class="line">                              mg_smoother,</div>
<div class="line">                              mg_smoother);</div>
<div class="line">mg.set_edge_matrices(mg_interface_down, mg_interface_up);</div>
<div class="line"></div>
<div class="line"><a class="code" href="classPreconditionMG.html">PreconditionMG&lt;dim, Vector&lt;double&gt;</a>, <a class="code" href="classMGTransferPrebuilt.html">MGTransferPrebuilt&lt;Vector&lt;double&gt;</a> &gt; &gt;</div>
<div class="line">preconditioner(mg_dof_handler, mg, mg_transfer);</div>
</div><!-- fragment --><p>With all this together, we can finally get about solving the linear system in the usual way:</p>
<div class="fragment"><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a> solver_control (1000, 1e-12);</div>
<div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;&gt;</a>    cg (solver_control);</div>
<div class="line"></div>
<div class="line">  solution = 0;</div>
<div class="line"></div>
<div class="line">  cg.solve (system_matrix, solution, system_rhs,</div>
<div class="line">            preconditioner);</div>
<div class="line">  constraints.<a class="code" href="classConstraintMatrix.html#a7cf6b84c47aa32408f412ae769085bd6">distribute</a> (solution);</div>
<div class="line"></div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   &quot;</span> &lt;&lt; solver_control.last_step()</div>
<div class="line">            &lt;&lt; <span class="stringliteral">&quot; CG iterations needed to obtain convergence.&quot;</span></div>
<div class="line">            &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="Postprocessing"></a> </p>
<h4>Postprocessing</h4>
<p>The following two functions postprocess a solution once it is computed. In particular, the first one refines the mesh at the beginning of each cycle while the second one outputs results at the end of each such cycle. The functions are almost unchanged from those in <a class="el" href="step_6.html">step-6</a>, with the exception of two minor differences: The <a class="el" href="classKellyErrorEstimator.html#ae1f3149bcc7653baa5ef0a2ac88070b9">KellyErrorEstimator::estimate</a> function wants an argument of type <a class="el" href="classDoFHandler.html">DoFHandler</a>, not <a class="el" href="classMGDoFHandler.html">MGDoFHandler</a>, and so we have to cast from derived to base class; and we generate output in VTK format, to use the more modern visualization programs available today compared to those that were available when <a class="el" href="step_6.html">step-6</a> was written.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::refine_grid ()</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classVector.html">Vector&lt;float&gt;</a> estimated_error_per_cell (triangulation.<a class="code" href="classTriangulation.html#aa21f25016ce1b9d70d2003a128985870">n_active_cells</a>());</div>
<div class="line"></div>
<div class="line">  <a class="code" href="classKellyErrorEstimator.html#ae1f3149bcc7653baa5ef0a2ac88070b9">KellyErrorEstimator&lt;dim&gt;::estimate</a> (<span class="keyword">static_cast&lt;</span><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>&amp;<span class="keyword">&gt;</span>(mg_dof_handler),</div>
<div class="line">                                      <a class="code" href="classQGauss.html">QGauss&lt;dim-1&gt;</a>(3),</div>
<div class="line">                                      <span class="keyword">typename</span> <a class="code" href="structFunctionMap.html#aa286a6c5e13045f84faabfd7170b1c48">FunctionMap&lt;dim&gt;::type</a>(),</div>
<div class="line">                                      solution,</div>
<div class="line">                                      estimated_error_per_cell);</div>
<div class="line">  <a class="code" href="namespaceGridRefinement.html#a722dd0fd72533bf87367b0ec14e893e0">GridRefinement::refine_and_coarsen_fixed_number</a> (triangulation,</div>
<div class="line">                                                   estimated_error_per_cell,</div>
<div class="line">                                                   0.3, 0.03);</div>
<div class="line">  triangulation.<a class="code" href="classTriangulation.html#aaedd900205c1879d8d9ef6ffe7d1a554">execute_coarsening_and_refinement</a> ();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::output_results (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div>
<div class="line"></div>
<div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a5e63bad650805ce93cd74c6dc3b29b11">attach_dof_handler</a> (mg_dof_handler);</div>
<div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a59a6b70a4b909e0229a20487dd68cc43">add_data_vector</a> (solution, <span class="stringliteral">&quot;solution&quot;</span>);</div>
<div class="line">  data_out.<a class="code" href="classDataOut.html#ab3d44201acb97fba286a897452236b51">build_patches</a> ();</div>
<div class="line"></div>
<div class="line">  std::ostringstream filename;</div>
<div class="line">  filename &lt;&lt; <span class="stringliteral">&quot;solution-&quot;</span></div>
<div class="line">           &lt;&lt; cycle</div>
<div class="line">           &lt;&lt; <span class="stringliteral">&quot;.vtk&quot;</span>;</div>
<div class="line"></div>
<div class="line">  std::ofstream output (filename.str().c_str());</div>
<div class="line">  data_out.<a class="code" href="classDataOutInterface.html#ab43da05fc9809b3eec1436c4962f8d77">write_vtk</a> (output);</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="LaplaceProblemrun"></a> </p>
<h4>LaplaceProblem::run</h4>
<p>Like several of the functions above, this is almost exactly a copy of of the corresponding function in <a class="el" href="step_6.html">step-6</a>. The only difference is the call to <code>assemble_multigrid</code> that takes care of forming the matrices on every level that we need in the multigrid method.</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::run ()</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle=0; cycle&lt;8; ++cycle)</div>
<div class="line">      {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; <span class="charliteral">&#39;:&#39;</span> &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (cycle == 0)</div>
<div class="line">          {</div>
<div class="line">            <a class="code" href="namespaceGridGenerator.html#a0a81f736ef95164a9d9bf0f844ac682b">GridGenerator::hyper_ball</a> (triangulation);</div>
<div class="line"></div>
<div class="line">            <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classHyperBallBoundary.html">HyperBallBoundary&lt;dim&gt;</a> boundary;</div>
<div class="line">            triangulation.<a class="code" href="group__boundary.html#ga0509d862f0e07071dcff837bd58fd082">set_boundary</a> (0, boundary);</div>
<div class="line"></div>
<div class="line">            triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a> (1);</div>
<div class="line">          }</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">          refine_grid ();</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells:       &quot;</span></div>
<div class="line">                  &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#aa21f25016ce1b9d70d2003a128985870">n_active_cells</a>()</div>
<div class="line">                  &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line">        setup_system ();</div>
<div class="line"></div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span></div>
<div class="line">                  &lt;&lt; mg_dof_handler.n_dofs()</div>
<div class="line">                  &lt;&lt; <span class="stringliteral">&quot; (by level: &quot;</span>;</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level=0; level&lt;triangulation.<a class="code" href="classTriangulation.html#ad966e087386ee0330371ebd73f2cfe99">n_levels</a>(); ++level)</div>
<div class="line">          std::cout &lt;&lt; mg_dof_handler.n_dofs(level)</div>
<div class="line">                    &lt;&lt; (level == triangulation.<a class="code" href="classTriangulation.html#ad966e087386ee0330371ebd73f2cfe99">n_levels</a>()-1</div>
<div class="line">                        ? <span class="stringliteral">&quot;)&quot;</span> : <span class="stringliteral">&quot;, &quot;</span>);</div>
<div class="line">        std::cout &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line">        assemble_system ();</div>
<div class="line">        assemble_multigrid ();</div>
<div class="line"></div>
<div class="line">        solve ();</div>
<div class="line">        output_results (cycle);</div>
<div class="line">      }</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="Themainfunction"></a> </p>
<h3>The <a class="el" href="group__ParameterGui.html#ga0ddf1224851353fc92bfbff6f499fa97">main()</a> function</h3>
<p>This is again the same function as in <a class="el" href="step_6.html">step-6</a>:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code" href="group__ParameterGui.html#ga0ddf1224851353fc92bfbff6f499fa97">main</a> ()</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">try</span></div>
<div class="line">    {</div>
<div class="line">      <span class="keyword">using namespace </span>dealii;</div>
<div class="line">      <span class="keyword">using namespace </span>Step16;</div>
<div class="line"></div>
<div class="line">      deallog.<a class="code" href="classLogStream.html#a8028e970ad8388596d625ed463894e98">depth_console</a> (0);</div>
<div class="line"></div>
<div class="line">      LaplaceProblem&lt;2&gt; laplace_problem(1);</div>
<div class="line">      laplace_problem.run ();</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div>
<div class="line">    {</div>
<div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">catch</span> (...)</div>
<div class="line">    {</div>
<div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p> <a class="anchor" id="Results"></a></p>
<h1>Results</h1>
<p>The output that this program generates is, of course, the same as that of <a class="el" href="step_6.html">step-6</a>, so you may see there for more results. On the other hand, since no tutorial program is a good one unless it has at least one colorful picture, here is, again, the solution:</p>
<div class="image">
<img src="images/step-16.solution.png" />
</div>
 <p>When run, the output of this program is </p>
<pre>
Cycle 0:
   Number of active cells:       20
   Number of degrees of freedom: 25 (by level: 8, 25)
   7 CG iterations needed to obtain convergence.
Cycle 1:
   Number of active cells:       44
   Number of degrees of freedom: 57 (by level: 8, 25, 48)
   8 CG iterations needed to obtain convergence.
Cycle 2:
   Number of active cells:       92
   Number of degrees of freedom: 117 (by level: 8, 25, 80, 60)
   9 CG iterations needed to obtain convergence.
Cycle 3:
   Number of active cells:       188
   Number of degrees of freedom: 221 (by level: 8, 25, 80, 200)
   12 CG iterations needed to obtain convergence.
Cycle 4:
   Number of active cells:       416
   Number of degrees of freedom: 485 (by level: 8, 25, 89, 288, 280)
   13 CG iterations needed to obtain convergence.
Cycle 5:
   Number of active cells:       800
   Number of degrees of freedom: 925 (by level: 8, 25, 89, 288, 784, 132)
   14 CG iterations needed to obtain convergence.
Cycle 6:
   Number of active cells:       1628
   Number of degrees of freedom: 1865 (by level: 8, 25, 89, 304, 1000, 1164, 72)
   14 CG iterations needed to obtain convergence.
Cycle 7:
   Number of active cells:       3194
   Number of degrees of freedom: 3603 (by level: 8, 25, 89, 328, 1032, 2200, 1392)
   16 CG iterations needed to obtain convergence.
</pre><p> That's not perfect &mdash; we would have hoped for a constant number of iterations rather than one that increases as we get more and more degrees of freedom &mdash; but it is also not far away. The reason for this is easy enough to understand, however: since we have a strongly varying coefficient, the operators that we assembly by quadrature on the lower levels become worse and worse approximations of the operator on the finest level. Consequently, even if we had perfect solvers on the coarser levels, they would not be good preconditioners on the finest level. This theory is easily tested by comparing results when we use a constant coefficient: in that case, the number of iterations remains constant at 9 after the first three or four refinement steps.</p>
<p>We can also compare what this program produces with how <a class="el" href="step_5.html">step-5</a> performed. To solve the same problem as in <a class="el" href="step_5.html">step-5</a>, the only two changes that are necessary are (i) to replace the body of the function <code>LaplaceProblem::refine_grid</code> by a call to <code>triangulation.refine_global(1)</code>, and (ii) to use the same <a class="el" href="classSolverControl.html">SolverControl</a> object and tolerance as in <a class="el" href="step_5.html">step-5</a> &mdash; the rest of the program remains unchanged. In that case, here is how the solvers used in <a class="el" href="step_5.html">step-5</a> and the multigrid solver used in the current program compare: </p>
<table  align="center">
<tr>
<th>cells</th><th><a class="el" href="step_5.html">step-5</a></th><th><a class="el" href="step_16.html">step-16</a> </th></tr>
<tr>
<td>20 </td><td>13 </td><td>6  </td></tr>
<tr>
<td>80 </td><td>17 </td><td>7  </td></tr>
<tr>
<td>320 </td><td>29 </td><td>9  </td></tr>
<tr>
<td>1280 </td><td>51 </td><td>10  </td></tr>
<tr>
<td>5120 </td><td>94 </td><td>11  </td></tr>
<tr>
<td>20480</td><td>180</td><td>13 </td></tr>
</table>
<p>This isn't only fewer iterations than in <a class="el" href="step_5.html">step-5</a> (each of which is, however, much more expensive) but more importantly, the number of iterations also grows much more slowly under mesh refinement (again, it would be almost constant if the coefficient was constant rather than strongly varying as chosen here). This justifies the common observation that, whenever possible, multigrid methods should be used for second order problems.</p>
<p><a class="anchor" id="Possibleextensions"></a></p>
<h3>Possible extensions </h3>
<p>A close inspection of this program's performance shows that it is mostly dominated by matrix-vector operations. <a class="el" href="step_37.html">step-37</a> shows one way how this can be avoided by working with matrix-free methods.</p>
<p>Another avenue would be to use algebraic multigrid methods. The geometric multigrid method used here can at times be a bit awkward to implement because it needs all those additional data structures, and it becomes even more difficult if the program is to run in parallel on machines coupled through MPI, for example. In that case, it would be simpler if one could use a black-box preconditioner that uses some sort of multigrid hierarchy for good performance but can figure out level matrices and similar things out by itself. Algebraic multigrid methods do exactly this, and we will use them in <a class="el" href="step_31.html">step-31</a> for the solution of a Stokes problem. <a class="anchor" id="PlainProg"></a> </p>
<h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div>
<div class="line"><span class="comment"> * @f$Id: @ref step_16 &quot;step-16&quot;.cc 30526 2013-08-29 20:06:27Z felix.gruber @f$</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * Copyright (C) 2003 - 2013 by the deal.II authors</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div>
<div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div>
<div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div>
<div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div>
<div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE at</span></div>
<div class="line"><span class="comment"> * the top level of the deal.II distribution.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * Authors: Guido Kanschat, University of Heidelberg, 2003</span></div>
<div class="line"><span class="comment"> *          Baerbel Janssen, University of Heidelberg, 2010</span></div>
<div class="line"><span class="comment"> *          Wolfgang Bangerth, Texas A&amp;M University, 2010</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/base/quadrature_lib.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/base/function.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/base/logstream.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/base/utilities.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/lac/constraint_matrix.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/lac/vector.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/lac/full_matrix.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/lac/sparse_matrix.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/lac/solver_cg.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/lac/precondition.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_accessor.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_iterator.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_generator.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_refinement.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_boundary_lib.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_accessor.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_tools.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_q.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_values.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/vector_tools.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/data_out.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/error_estimator.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/multigrid/mg_dof_handler.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/multigrid/mg_constrained_dofs.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/multigrid/multigrid.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/multigrid/mg_transfer.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/multigrid/mg_tools.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/multigrid/mg_coarse.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/multigrid/mg_smoother.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/multigrid/mg_matrix.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span>Step16</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">using namespace </span>dealii;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keyword">class </span>LaplaceProblem</div>
<div class="line">  {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    LaplaceProblem (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree);</div>
<div class="line">    <span class="keywordtype">void</span> run ();</div>
<div class="line"></div>
<div class="line">  <span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">void</span> setup_system ();</div>
<div class="line">    <span class="keywordtype">void</span> assemble_system ();</div>
<div class="line">    <span class="keywordtype">void</span> assemble_multigrid ();</div>
<div class="line">    <span class="keywordtype">void</span> solve ();</div>
<div class="line">    <span class="keywordtype">void</span> refine_grid ();</div>
<div class="line">    <span class="keywordtype">void</span> output_results (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle) <span class="keyword">const</span>;</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a>   triangulation;</div>
<div class="line">    <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>            fe;</div>
<div class="line">    <a class="code" href="classMGDoFHandler.html">MGDoFHandler&lt;dim&gt;</a>    mg_dof_handler;</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div>
<div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classConstraintMatrix.html">ConstraintMatrix</a>     hanging_node_constraints;</div>
<div class="line">    <a class="code" href="classConstraintMatrix.html">ConstraintMatrix</a>     constraints;</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       solution;</div>
<div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       system_rhs;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree;</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparsityPattern&gt;</a>       mg_sparsity_patterns;</div>
<div class="line">    <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparseMatrix&lt;double&gt;</a> &gt; mg_matrices;</div>
<div class="line">    <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparseMatrix&lt;double&gt;</a> &gt; mg_interface_matrices;</div>
<div class="line">    <a class="code" href="classMGConstrainedDoFs.html">MGConstrainedDoFs</a>                    mg_constrained_dofs;</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keyword">class </span>Coefficient : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div>
<div class="line">  {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    Coefficient () : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;() {}</div>
<div class="line"></div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>   &amp;p,</div>
<div class="line">                          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  component = 0) <span class="keyword">const</span>;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> value_list (<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &gt; &amp;points,</div>
<div class="line">                             std::vector&lt;double&gt;            &amp;values,</div>
<div class="line">                             <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>              component = 0) <span class="keyword">const</span>;</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">double</span> Coefficient&lt;dim&gt;::value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div>
<div class="line">                                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <span class="keywordflow">if</span> (p.<a class="code" href="classPoint.html#ad46f55479010282e242b1d8e427285e8">square</a>() &lt; 0.5*0.5)</div>
<div class="line">      <span class="keywordflow">return</span> 20;</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">      <span class="keywordflow">return</span> 1;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> Coefficient&lt;dim&gt;::value_list (<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &gt; &amp;points,</div>
<div class="line">                                     std::vector&lt;double&gt;            &amp;values,</div>
<div class="line">                                     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>              component)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_points = points.size();</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (values.size() == n_points,</div>
<div class="line">            <a class="code" href="group__Exceptions.html#ga325fd73751a9373f1b901962daeb2ea7">ExcDimensionMismatch</a> (values.size(), n_points));</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (component == 0,</div>
<div class="line">            <a class="code" href="group__Exceptions.html#ga3f3f87a5613ac8b4e64ecd458dea8e9b">ExcIndexRange</a> (component, 0, 1));</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;n_points; ++i)</div>
<div class="line">      values[i] = Coefficient&lt;dim&gt;::value (points[i]);</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  LaplaceProblem&lt;dim&gt;::LaplaceProblem (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree)</div>
<div class="line">    :</div>
<div class="line">    triangulation (<a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::</div>
<div class="line">                   limit_level_difference_at_vertices),</div>
<div class="line">    fe (degree),</div>
<div class="line">    mg_dof_handler (triangulation),</div>
<div class="line">    degree(degree)</div>
<div class="line">  {}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::setup_system ()</div>
<div class="line">  {</div>
<div class="line">    mg_dof_handler.distribute_dofs (fe);</div>
<div class="line"></div>
<div class="line">    deallog &lt;&lt; <span class="stringliteral">&quot;Number of degrees of freedom: &quot;</span></div>
<div class="line">            &lt;&lt; mg_dof_handler.n_dofs();</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> l=0; l&lt;triangulation.<a class="code" href="classTriangulation.html#ad966e087386ee0330371ebd73f2cfe99">n_levels</a>(); ++l)</div>
<div class="line">      deallog &lt;&lt; <span class="stringliteral">&quot;   &quot;</span> &lt;&lt; <span class="charliteral">&#39;L&#39;</span> &lt;&lt; l &lt;&lt; <span class="stringliteral">&quot;: &quot;</span></div>
<div class="line">              &lt;&lt; mg_dof_handler.n_dofs(l);</div>
<div class="line">    deallog  &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line">    sparsity_pattern.<a class="code" href="classSparsityPattern.html#aeb0b103258aaa649939e1610f5a1ca8e">reinit</a> (mg_dof_handler.n_dofs(),</div>
<div class="line">                             mg_dof_handler.n_dofs(),</div>
<div class="line">                             mg_dof_handler.max_couplings_between_dofs());</div>
<div class="line">    <a class="code" href="group__constraints.html#gab627b1d4845c9526521dbd1be83469dc">DoFTools::make_sparsity_pattern</a> (mg_dof_handler, sparsity_pattern);</div>
<div class="line"></div>
<div class="line">    solution.<a class="code" href="classVector.html#ac3adfcf8cf35943558fc27ef989b7263">reinit</a> (mg_dof_handler.n_dofs());</div>
<div class="line">    system_rhs.<a class="code" href="classBlockVector.html#a4caa9be7a7053fd6ae9fac1da74e564b">reinit</a> (mg_dof_handler.n_dofs());</div>
<div class="line"></div>
<div class="line">    constraints.<a class="code" href="classConstraintMatrix.html#a24120d0331183f9a63cbe41493a19f6b">clear</a> ();</div>
<div class="line">    hanging_node_constraints.clear ();</div>
<div class="line">    <a class="code" href="group__constraints.html#gabe9d21d4bb33ce556a6e6e80c2bf4b41">DoFTools::make_hanging_node_constraints</a> (mg_dof_handler, hanging_node_constraints);</div>
<div class="line">    <a class="code" href="group__constraints.html#gabe9d21d4bb33ce556a6e6e80c2bf4b41">DoFTools::make_hanging_node_constraints</a> (mg_dof_handler, constraints);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">typename</span> <a class="code" href="structFunctionMap.html#aa286a6c5e13045f84faabfd7170b1c48">FunctionMap&lt;dim&gt;::type</a>      dirichlet_boundary;</div>
<div class="line">    <a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a>                    homogeneous_dirichlet_bc (1);</div>
<div class="line">    dirichlet_boundary[0] = &amp;homogeneous_dirichlet_bc;</div>
<div class="line">    <a class="code" href="namespaceVectorTools.html#a199f38e07822b47e5b5957c21ce35d1b">VectorTools::interpolate_boundary_values</a> (<span class="keyword">static_cast&lt;</span><span class="keyword">const </span><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>&amp;<span class="keyword">&gt;</span>(mg_dof_handler),</div>
<div class="line">                                              dirichlet_boundary,</div>
<div class="line">                                              constraints);</div>
<div class="line">    constraints.<a class="code" href="classConstraintMatrix.html#a8056d07faa2a7ed3f158c1b42d56abc8">close</a> ();</div>
<div class="line">    hanging_node_constraints.close ();</div>
<div class="line">    constraints.<a class="code" href="classConstraintMatrix.html#a66337316e8fbbc786c9f0383d085ab01">condense</a> (sparsity_pattern);</div>
<div class="line">    sparsity_pattern.<a class="code" href="classSparsityPattern.html#ad15d36e4bfe7c97b55d155541e723284">compress</a>();</div>
<div class="line">    system_matrix.reinit (sparsity_pattern);</div>
<div class="line"></div>
<div class="line">    mg_constrained_dofs.clear();</div>
<div class="line">    mg_constrained_dofs.initialize(mg_dof_handler, dirichlet_boundary);</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_levels = triangulation.<a class="code" href="classTriangulation.html#ad966e087386ee0330371ebd73f2cfe99">n_levels</a>();</div>
<div class="line"></div>
<div class="line">    mg_interface_matrices.resize(0, n_levels-1);</div>
<div class="line">    mg_interface_matrices.clear ();</div>
<div class="line">    mg_matrices.resize(0, n_levels-1);</div>
<div class="line">    mg_matrices.clear ();</div>
<div class="line">    mg_sparsity_patterns.resize(0, n_levels-1);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level=0; level&lt;n_levels; ++level)</div>
<div class="line">      {</div>
<div class="line">        <a class="code" href="classCompressedSparsityPattern.html">CompressedSparsityPattern</a> csp;</div>
<div class="line">        csp.<a class="code" href="classCompressedSparsityPattern.html#adc9c1431ad5bb05efff17da64b49d40f">reinit</a>(mg_dof_handler.n_dofs(level),</div>
<div class="line">                   mg_dof_handler.n_dofs(level));</div>
<div class="line">        <a class="code" href="namespaceMGTools.html#a579c0c8095694da9c3f588559ba233d0">MGTools::make_sparsity_pattern</a>(mg_dof_handler, csp, level);</div>
<div class="line"></div>
<div class="line">        mg_sparsity_patterns[level].copy_from (csp);</div>
<div class="line"></div>
<div class="line">        mg_matrices[level].reinit(mg_sparsity_patterns[level]);</div>
<div class="line">        mg_interface_matrices[level].reinit(mg_sparsity_patterns[level]);</div>
<div class="line">      }</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::assemble_system ()</div>
<div class="line">  {</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>  quadrature_formula(degree+1);</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values (fe, quadrature_formula,</div>
<div class="line">                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>    |  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div>
<div class="line">                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>  |  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   dofs_per_cell = fe.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#a4d64837b1d374e9c46f07af8f094b29b">size</a>();</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>   cell_matrix (dofs_per_cell, dofs_per_cell);</div>
<div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       cell_rhs (dofs_per_cell);</div>
<div class="line"></div>
<div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices (dofs_per_cell);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> Coefficient&lt;dim&gt; coefficient;</div>
<div class="line">    std::vector&lt;double&gt;    coefficient_values (n_q_points);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">typename</span> MGDoFHandler&lt;dim&gt;::active_cell_iterator</div>
<div class="line">    cell = mg_dof_handler.<a class="code" href="classDoFHandler.html#a6f2aa9c61385cbb749ed3d2e7bfe3de1">begin_active</a>(),</div>
<div class="line">    endc = mg_dof_handler.end();</div>
<div class="line">    <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div>
<div class="line">      {</div>
<div class="line">        cell_matrix = 0;</div>
<div class="line">        cell_rhs = 0;</div>
<div class="line"></div>
<div class="line">        fe_values.<a class="code" href="classFEValues.html#afde502903642c57ade24dfcebf5c1650">reinit</a> (cell);</div>
<div class="line"></div>
<div class="line">        coefficient.value_list (fe_values.<a class="code" href="classFEValuesBase.html#a5f8732ebe2d3c6746f6de26a79cb1e45">get_quadrature_points</a>(),</div>
<div class="line">                                coefficient_values);</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point=0; q_point&lt;n_q_points; ++q_point)</div>
<div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div>
<div class="line">            {</div>
<div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div>
<div class="line">                cell_matrix(i,j) += (coefficient_values[q_point] *</div>
<div class="line">                                     fe_values.<a class="code" href="classFEValuesBase.html#ac4cee7628c2903a89c5c399fddeb00a5">shape_grad</a>(i,q_point) *</div>
<div class="line">                                     fe_values.<a class="code" href="classFEValuesBase.html#ac4cee7628c2903a89c5c399fddeb00a5">shape_grad</a>(j,q_point) *</div>
<div class="line">                                     fe_values.<a class="code" href="classFEValuesBase.html#ad097580a2f71878695096cc73b271b9d">JxW</a>(q_point));</div>
<div class="line"></div>
<div class="line">              cell_rhs(i) += (fe_values.<a class="code" href="classFEValuesBase.html#abe4de48ff59778bb82a0ec13037804aa">shape_value</a>(i,q_point) *</div>
<div class="line">                              1.0 *</div>
<div class="line">                              fe_values.<a class="code" href="classFEValuesBase.html#ad097580a2f71878695096cc73b271b9d">JxW</a>(q_point));</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">        cell-&gt;get_dof_indices (local_dof_indices);</div>
<div class="line">        constraints.<a class="code" href="classConstraintMatrix.html#aa9f3612a8fc51eafa34252bb436e8ae4">distribute_local_to_global</a> (cell_matrix, cell_rhs,</div>
<div class="line">                                                local_dof_indices,</div>
<div class="line">                                                system_matrix, system_rhs);</div>
<div class="line">      }</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::assemble_multigrid ()</div>
<div class="line">  {</div>
<div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>  quadrature_formula(1+degree);</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values (fe, quadrature_formula,</div>
<div class="line">                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>   | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div>
<div class="line">                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   dofs_per_cell   = fe.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   n_q_points      = quadrature_formula.<a class="code" href="classQuadrature.html#a4d64837b1d374e9c46f07af8f094b29b">size</a>();</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>   cell_matrix (dofs_per_cell, dofs_per_cell);</div>
<div class="line"></div>
<div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices (dofs_per_cell);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> Coefficient&lt;dim&gt; coefficient;</div>
<div class="line">    std::vector&lt;double&gt;    coefficient_values (n_q_points);</div>
<div class="line"></div>
<div class="line">    std::vector&lt;std::vector&lt;bool&gt; &gt; interface_dofs</div>
<div class="line">      = mg_constrained_dofs.get_refinement_edge_indices ();</div>
<div class="line">    std::vector&lt;std::vector&lt;bool&gt; &gt; boundary_interface_dofs</div>
<div class="line">      = mg_constrained_dofs.get_refinement_edge_boundary_indices ();</div>
<div class="line"></div>
<div class="line">    std::vector&lt;ConstraintMatrix&gt; boundary_constraints (triangulation.<a class="code" href="classTriangulation.html#ad966e087386ee0330371ebd73f2cfe99">n_levels</a>());</div>
<div class="line">    std::vector&lt;ConstraintMatrix&gt; boundary_interface_constraints (triangulation.<a class="code" href="classTriangulation.html#ad966e087386ee0330371ebd73f2cfe99">n_levels</a>());</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level=0; level&lt;triangulation.<a class="code" href="classTriangulation.html#ad966e087386ee0330371ebd73f2cfe99">n_levels</a>(); ++level)</div>
<div class="line">      {</div>
<div class="line">        boundary_constraints[level].add_lines (interface_dofs[level]);</div>
<div class="line">        boundary_constraints[level].add_lines (mg_constrained_dofs.get_boundary_indices()[level]);</div>
<div class="line">        boundary_constraints[level].close ();</div>
<div class="line"></div>
<div class="line">        boundary_interface_constraints[level]</div>
<div class="line">        .add_lines (boundary_interface_dofs[level]);</div>
<div class="line">        boundary_interface_constraints[level].close ();</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">typename</span> MGDoFHandler&lt;dim&gt;::cell_iterator cell = mg_dof_handler.<a class="code" href="classMGDoFHandler.html#a3c070825136093810f79af5996ad86f4">begin</a>(),</div>
<div class="line">                                              endc = mg_dof_handler.end();</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div>
<div class="line">      {</div>
<div class="line">        cell_matrix = 0;</div>
<div class="line">        fe_values.<a class="code" href="classFEValues.html#afde502903642c57ade24dfcebf5c1650">reinit</a> (cell);</div>
<div class="line"></div>
<div class="line">        coefficient.value_list (fe_values.<a class="code" href="classFEValuesBase.html#a5f8732ebe2d3c6746f6de26a79cb1e45">get_quadrature_points</a>(),</div>
<div class="line">                                coefficient_values);</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point=0; q_point&lt;n_q_points; ++q_point)</div>
<div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div>
<div class="line">              cell_matrix(i,j) += (coefficient_values[q_point] *</div>
<div class="line">                                   fe_values.<a class="code" href="classFEValuesBase.html#ac4cee7628c2903a89c5c399fddeb00a5">shape_grad</a>(i,q_point) *</div>
<div class="line">                                   fe_values.<a class="code" href="classFEValuesBase.html#ac4cee7628c2903a89c5c399fddeb00a5">shape_grad</a>(j,q_point) *</div>
<div class="line">                                   fe_values.<a class="code" href="classFEValuesBase.html#ad097580a2f71878695096cc73b271b9d">JxW</a>(q_point));</div>
<div class="line"></div>
<div class="line">        cell-&gt;get_mg_dof_indices (local_dof_indices);</div>
<div class="line"></div>
<div class="line">        boundary_constraints[cell-&gt;level()]</div>
<div class="line">        .distribute_local_to_global (cell_matrix,</div>
<div class="line">                                     local_dof_indices,</div>
<div class="line">                                     mg_matrices[cell-&gt;level()]);</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div>
<div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div>
<div class="line">            <span class="keywordflow">if</span> ( !(interface_dofs[cell-&gt;level()][local_dof_indices[i]]==<span class="keyword">true</span> &amp;&amp;</div>
<div class="line">                   interface_dofs[cell-&gt;level()][local_dof_indices[j]]==<span class="keyword">false</span>))</div>
<div class="line">              cell_matrix(i,j) = 0;</div>
<div class="line"></div>
<div class="line">        boundary_interface_constraints[cell-&gt;level()]</div>
<div class="line">        .distribute_local_to_global (cell_matrix,</div>
<div class="line">                                     local_dof_indices,</div>
<div class="line">                                     mg_interface_matrices[cell-&gt;level()]);</div>
<div class="line">      }</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::solve ()</div>
<div class="line">  {</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classMGTransferPrebuilt.html">MGTransferPrebuilt&lt;Vector&lt;double&gt;</a> &gt; mg_transfer(hanging_node_constraints, mg_constrained_dofs);</div>
<div class="line">    mg_transfer.<a class="code" href="classMGTransferPrebuilt.html#a58e346481bd8a8a9994bb8b5d5d9772a">build_matrices</a>(mg_dof_handler);</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> coarse_matrix;</div>
<div class="line">    coarse_matrix.<a class="code" href="classFullMatrix.html#a365a27cf59b05800d7889d5fb28a1d93">copy_from</a> (mg_matrices[0]);</div>
<div class="line">    <a class="code" href="classMGCoarseGridHouseholder.html">MGCoarseGridHouseholder&lt;&gt;</a> coarse_grid_solver;</div>
<div class="line">    coarse_grid_solver.<a class="code" href="classMGCoarseGridHouseholder.html#a2790d07d059be92b2a7b608d1917e78e">initialize</a> (coarse_matrix);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">typedef</span> <a class="code" href="classPreconditionSOR.html">PreconditionSOR&lt;SparseMatrix&lt;double&gt;</a> &gt; Smoother;</div>
<div class="line">    <a class="code" href="classmg_1_1SmootherRelaxation.html">mg::SmootherRelaxation&lt;Smoother, Vector&lt;double&gt;</a> &gt; mg_smoother;</div>
<div class="line">    mg_smoother.<a class="code" href="classmg_1_1SmootherRelaxation.html#a2e4ccbaa2e9b7c09c464eec83eb1be9d">initialize</a>(mg_matrices);</div>
<div class="line">    mg_smoother.<a class="code" href="classMGSmoother.html#a8604565dd6bc1eb73245e72089a467f3">set_steps</a>(2);</div>
<div class="line">    mg_smoother.<a class="code" href="classMGSmoother.html#a6afa8e3892105c937145f4be8bed13fe">set_symmetric</a>(<span class="keyword">true</span>);</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classMGMatrix.html">MGMatrix&lt;&gt;</a> mg_matrix(&amp;mg_matrices);</div>
<div class="line">    <a class="code" href="classMGMatrix.html">MGMatrix&lt;&gt;</a> mg_interface_up(&amp;mg_interface_matrices);</div>
<div class="line">    <a class="code" href="classMGMatrix.html">MGMatrix&lt;&gt;</a> mg_interface_down(&amp;mg_interface_matrices);</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classMultigrid.html">Multigrid&lt;Vector&lt;double&gt;</a> &gt; mg(mg_dof_handler,</div>
<div class="line">                                  mg_matrix,</div>
<div class="line">                                  coarse_grid_solver,</div>
<div class="line">                                  mg_transfer,</div>
<div class="line">                                  mg_smoother,</div>
<div class="line">                                  mg_smoother);</div>
<div class="line">    mg.set_edge_matrices(mg_interface_down, mg_interface_up);</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classPreconditionMG.html">PreconditionMG&lt;dim, Vector&lt;double&gt;</a>, <a class="code" href="classMGTransferPrebuilt.html">MGTransferPrebuilt&lt;Vector&lt;double&gt;</a> &gt; &gt;</div>
<div class="line">    preconditioner(mg_dof_handler, mg, mg_transfer);</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a> solver_control (1000, 1e-12);</div>
<div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;&gt;</a>    cg (solver_control);</div>
<div class="line"></div>
<div class="line">    solution = 0;</div>
<div class="line"></div>
<div class="line">    cg.solve (system_matrix, solution, system_rhs,</div>
<div class="line">              preconditioner);</div>
<div class="line">    constraints.<a class="code" href="classConstraintMatrix.html#a7cf6b84c47aa32408f412ae769085bd6">distribute</a> (solution);</div>
<div class="line"></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   &quot;</span> &lt;&lt; solver_control.last_step()</div>
<div class="line">              &lt;&lt; <span class="stringliteral">&quot; CG iterations needed to obtain convergence.&quot;</span></div>
<div class="line">              &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::refine_grid ()</div>
<div class="line">  {</div>
<div class="line">    <a class="code" href="classVector.html">Vector&lt;float&gt;</a> estimated_error_per_cell (triangulation.<a class="code" href="classTriangulation.html#aa21f25016ce1b9d70d2003a128985870">n_active_cells</a>());</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classKellyErrorEstimator.html#ae1f3149bcc7653baa5ef0a2ac88070b9">KellyErrorEstimator&lt;dim&gt;::estimate</a> (<span class="keyword">static_cast&lt;</span><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>&amp;<span class="keyword">&gt;</span>(mg_dof_handler),</div>
<div class="line">                                        <a class="code" href="classQGauss.html">QGauss&lt;dim-1&gt;</a>(3),</div>
<div class="line">                                        <span class="keyword">typename</span> <a class="code" href="structFunctionMap.html#aa286a6c5e13045f84faabfd7170b1c48">FunctionMap&lt;dim&gt;::type</a>(),</div>
<div class="line">                                        solution,</div>
<div class="line">                                        estimated_error_per_cell);</div>
<div class="line">    <a class="code" href="namespaceGridRefinement.html#a722dd0fd72533bf87367b0ec14e893e0">GridRefinement::refine_and_coarsen_fixed_number</a> (triangulation,</div>
<div class="line">                                                     estimated_error_per_cell,</div>
<div class="line">                                                     0.3, 0.03);</div>
<div class="line">    triangulation.<a class="code" href="classTriangulation.html#aaedd900205c1879d8d9ef6ffe7d1a554">execute_coarsening_and_refinement</a> ();</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::output_results (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div>
<div class="line"></div>
<div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a5e63bad650805ce93cd74c6dc3b29b11">attach_dof_handler</a> (mg_dof_handler);</div>
<div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a59a6b70a4b909e0229a20487dd68cc43">add_data_vector</a> (solution, <span class="stringliteral">&quot;solution&quot;</span>);</div>
<div class="line">    data_out.<a class="code" href="classDataOut.html#ab3d44201acb97fba286a897452236b51">build_patches</a> ();</div>
<div class="line"></div>
<div class="line">    std::ostringstream filename;</div>
<div class="line">    filename &lt;&lt; <span class="stringliteral">&quot;solution-&quot;</span></div>
<div class="line">             &lt;&lt; cycle</div>
<div class="line">             &lt;&lt; <span class="stringliteral">&quot;.vtk&quot;</span>;</div>
<div class="line"></div>
<div class="line">    std::ofstream output (filename.str().c_str());</div>
<div class="line">    data_out.<a class="code" href="classDataOutInterface.html#ab43da05fc9809b3eec1436c4962f8d77">write_vtk</a> (output);</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::run ()</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle=0; cycle&lt;8; ++cycle)</div>
<div class="line">      {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; <span class="charliteral">&#39;:&#39;</span> &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (cycle == 0)</div>
<div class="line">          {</div>
<div class="line">            <a class="code" href="namespaceGridGenerator.html#a0a81f736ef95164a9d9bf0f844ac682b">GridGenerator::hyper_ball</a> (triangulation);</div>
<div class="line"></div>
<div class="line">            <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classHyperBallBoundary.html">HyperBallBoundary&lt;dim&gt;</a> boundary;</div>
<div class="line">            triangulation.<a class="code" href="group__boundary.html#ga0509d862f0e07071dcff837bd58fd082">set_boundary</a> (0, boundary);</div>
<div class="line"></div>
<div class="line">            triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a> (1);</div>
<div class="line">          }</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">          refine_grid ();</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells:       &quot;</span></div>
<div class="line">                  &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#aa21f25016ce1b9d70d2003a128985870">n_active_cells</a>()</div>
<div class="line">                  &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line">        setup_system ();</div>
<div class="line"></div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span></div>
<div class="line">                  &lt;&lt; mg_dof_handler.n_dofs()</div>
<div class="line">                  &lt;&lt; <span class="stringliteral">&quot; (by level: &quot;</span>;</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level=0; level&lt;triangulation.<a class="code" href="classTriangulation.html#ad966e087386ee0330371ebd73f2cfe99">n_levels</a>(); ++level)</div>
<div class="line">          std::cout &lt;&lt; mg_dof_handler.n_dofs(level)</div>
<div class="line">                    &lt;&lt; (level == triangulation.<a class="code" href="classTriangulation.html#ad966e087386ee0330371ebd73f2cfe99">n_levels</a>()-1</div>
<div class="line">                        ? <span class="stringliteral">&quot;)&quot;</span> : <span class="stringliteral">&quot;, &quot;</span>);</div>
<div class="line">        std::cout &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line">        assemble_system ();</div>
<div class="line">        assemble_multigrid ();</div>
<div class="line"></div>
<div class="line">        solve ();</div>
<div class="line">        output_results (cycle);</div>
<div class="line">      }</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> <a class="code" href="group__ParameterGui.html#ga0ddf1224851353fc92bfbff6f499fa97">main</a> ()</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">try</span></div>
<div class="line">    {</div>
<div class="line">      <span class="keyword">using namespace </span>dealii;</div>
<div class="line">      <span class="keyword">using namespace </span>Step16;</div>
<div class="line"></div>
<div class="line">      deallog.<a class="code" href="classLogStream.html#a8028e970ad8388596d625ed463894e98">depth_console</a> (0);</div>
<div class="line"></div>
<div class="line">      LaplaceProblem&lt;2&gt; laplace_problem(1);</div>
<div class="line">      laplace_problem.run ();</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div>
<div class="line">    {</div>
<div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">catch</span> (...)</div>
<div class="line">    {</div>
<div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jan 27 2014 15:26:58 for The deal.II Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
