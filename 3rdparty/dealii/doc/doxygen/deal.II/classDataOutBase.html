<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>The deal.II Library: DataOutBase Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="http://www.dealii.org/deal.ico"></link>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2014 by the deal.II authors"></meta>
<meta name="deal.II-version" content="8.1.0"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 8.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="classDataOutBase-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">DataOutBase Class Reference<div class="ingroups"><a class="el" href="group__output.html">Graphical output</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="data__out__base_8h_source.html">data_out_base.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for DataOutBase:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classDataOutBase__inherit__graph.svg" width="1755" height="464"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutBase_1_1DataOutFilter.html">DataOutFilter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDataOutBase_1_1DataOutFilterFlags.html">DataOutFilterFlags</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDataOutBase_1_1Deal__II__IntermediateFlags.html">Deal_II_IntermediateFlags</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDataOutBase_1_1DXFlags.html">DXFlags</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutBase_1_1EpsCell2d.html">EpsCell2d</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDataOutBase_1_1EpsFlags.html">EpsFlags</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDataOutBase_1_1GmvFlags.html">GmvFlags</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDataOutBase_1_1GnuplotFlags.html">GnuplotFlags</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDataOutBase_1_1Patch.html">Patch</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDataOutBase_1_1PovrayFlags.html">PovrayFlags</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutBase_1_1SvgCell.html">SvgCell</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDataOutBase_1_1SvgFlags.html">SvgFlags</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDataOutBase_1_1TecplotFlags.html">TecplotFlags</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDataOutBase_1_1UcdFlags.html">UcdFlags</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDataOutBase_1_1VtkFlags.html">VtkFlags</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aa3cbced9f1d4ae661f13018f4c980aa1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1">OutputFormat</a> { <br/>
&#160;&#160;<a class="el" href="classDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1aaca645a9a5b8782ed6dff8ef6b809e07">default_format</a>, 
<a class="el" href="classDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1aa6f1f99c613aeb81b8d8e598b5567ce1">none</a>, 
<a class="el" href="classDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1af54db6e70b60a249b36f803d0657b39e">dx</a>, 
<a class="el" href="classDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1a1a420a2edb82acdd6e8e214f2ed97721">ucd</a>, 
<br/>
&#160;&#160;<a class="el" href="classDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1a025233c1a8124e5521952c7c7cd78df1">gnuplot</a>, 
<a class="el" href="classDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1a74aee841ac4d429a660bbd1bfee6f298">povray</a>, 
<a class="el" href="classDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1acf35b7afd6a85044d32320355fbaabfe">eps</a>, 
<a class="el" href="classDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1a958eea3b2724c76d1c1ff20d69f7da4e">gmv</a>, 
<br/>
&#160;&#160;<a class="el" href="classDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1a8c187cd13581e59b34d71645276a550c">tecplot</a>, 
<a class="el" href="classDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1a9b83a7bdbd793467207e0a8f151e15e0">tecplot_binary</a>, 
<a class="el" href="classDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1ac41fd26a6a54c90d0d2062d859b8facf">vtk</a>, 
<a class="el" href="classDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1acff6079f78795530409873a79263ad7e">vtu</a>, 
<br/>
&#160;&#160;<a class="el" href="classDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1ad512d1f704c4b56b7bf99e3f81ebc06f">svg</a>, 
<a class="el" href="classDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1ab9c7fdc67b488efaf1b27b02985a40fb">deal_II_intermediate</a>, 
<a class="el" href="classDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1af7b5982bac28c91f885940695ca47542">hdf5</a>
<br/>
 }</td></tr>
<tr class="separator:aa3cbced9f1d4ae661f13018f4c980aa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ga701d6ede4eb8573fb03722aeb60e07c9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga701d6ede4eb8573fb03722aeb60e07c9">DeclException2</a> (ExcInvalidDatasetSize, <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;The number of points in this data set is &quot;&lt;&lt; arg1&lt;&lt; &quot;, but we expected &quot;&lt;&lt; arg2&lt;&lt; &quot; in each space direction.&quot;)</td></tr>
<tr class="separator:ga701d6ede4eb8573fb03722aeb60e07c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92d4151005c7e9de9f503252a9933ee3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga92d4151005c7e9de9f503252a9933ee3">DeclException0</a> (ExcNoPatches)</td></tr>
<tr class="separator:ga92d4151005c7e9de9f503252a9933ee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8db1d6053fc0f8034040f9e95b8ef5f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gad8db1d6053fc0f8034040f9e95b8ef5f">DeclException0</a> (ExcTecplotAPIError)</td></tr>
<tr class="separator:gad8db1d6053fc0f8034040f9e95b8ef5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c142e99ad85e7d80aaa949f02af4175"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga3c142e99ad85e7d80aaa949f02af4175">DeclException1</a> (ExcErrorOpeningTecplotFile, char *,&lt;&lt; &quot;There was an error opening Tecplot file &quot;&lt;&lt; arg1&lt;&lt; &quot; for output&quot;)</td></tr>
<tr class="separator:ga3c142e99ad85e7d80aaa949f02af4175"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a473ac0a368162c07135934c7d0c1d2cb"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a473ac0a368162c07135934c7d0c1d2cb"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDataOutBase.html#a473ac0a368162c07135934c7d0c1d2cb">write_dx</a> (const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt; &gt; &amp;patches, const std::vector&lt; std::string &gt; &amp;data_names, const std::vector&lt; std_cxx1x::tuple&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>, std::string &gt; &gt; &amp;vector_data_ranges, const <a class="el" href="structDataOutBase_1_1DXFlags.html">DXFlags</a> &amp;flags, std::ostream &amp;out)</td></tr>
<tr class="separator:a473ac0a368162c07135934c7d0c1d2cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75dd1bbf8e69bfa61048f4faad37aae2"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a75dd1bbf8e69bfa61048f4faad37aae2"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDataOutBase.html#a75dd1bbf8e69bfa61048f4faad37aae2">write_eps</a> (const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt; &gt; &amp;patches, const std::vector&lt; std::string &gt; &amp;data_names, const std::vector&lt; std_cxx1x::tuple&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>, std::string &gt; &gt; &amp;vector_data_ranges, const <a class="el" href="structDataOutBase_1_1EpsFlags.html">EpsFlags</a> &amp;flags, std::ostream &amp;out)</td></tr>
<tr class="separator:a75dd1bbf8e69bfa61048f4faad37aae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7ea4056dc818119998197b57ab29ee0"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:af7ea4056dc818119998197b57ab29ee0"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDataOutBase.html#af7ea4056dc818119998197b57ab29ee0">write_gmv</a> (const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt; &gt; &amp;patches, const std::vector&lt; std::string &gt; &amp;data_names, const std::vector&lt; std_cxx1x::tuple&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>, std::string &gt; &gt; &amp;vector_data_ranges, const <a class="el" href="structDataOutBase_1_1GmvFlags.html">GmvFlags</a> &amp;flags, std::ostream &amp;out)</td></tr>
<tr class="separator:af7ea4056dc818119998197b57ab29ee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e5435b971e7a342ef0040df0992d5cd"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a4e5435b971e7a342ef0040df0992d5cd"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDataOutBase.html#a4e5435b971e7a342ef0040df0992d5cd">write_gnuplot</a> (const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt; &gt; &amp;patches, const std::vector&lt; std::string &gt; &amp;data_names, const std::vector&lt; std_cxx1x::tuple&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>, std::string &gt; &gt; &amp;vector_data_ranges, const <a class="el" href="structDataOutBase_1_1GnuplotFlags.html">GnuplotFlags</a> &amp;flags, std::ostream &amp;out)</td></tr>
<tr class="separator:a4e5435b971e7a342ef0040df0992d5cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff66fc3b49a9130d45808721f16eac98"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:aff66fc3b49a9130d45808721f16eac98"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDataOutBase.html#aff66fc3b49a9130d45808721f16eac98">write_povray</a> (const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt; &gt; &amp;patches, const std::vector&lt; std::string &gt; &amp;data_names, const std::vector&lt; std_cxx1x::tuple&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>, std::string &gt; &gt; &amp;vector_data_ranges, const <a class="el" href="structDataOutBase_1_1PovrayFlags.html">PovrayFlags</a> &amp;flags, std::ostream &amp;out)</td></tr>
<tr class="separator:aff66fc3b49a9130d45808721f16eac98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a881b231c2909953ff1882d374e98f66f"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a881b231c2909953ff1882d374e98f66f"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDataOutBase.html#a881b231c2909953ff1882d374e98f66f">write_tecplot</a> (const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt; &gt; &amp;patches, const std::vector&lt; std::string &gt; &amp;data_names, const std::vector&lt; std_cxx1x::tuple&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>, std::string &gt; &gt; &amp;vector_data_ranges, const <a class="el" href="structDataOutBase_1_1TecplotFlags.html">TecplotFlags</a> &amp;flags, std::ostream &amp;out)</td></tr>
<tr class="separator:a881b231c2909953ff1882d374e98f66f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a922a99bd5d401fecf6592cf42a3b638e"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a922a99bd5d401fecf6592cf42a3b638e"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDataOutBase.html#a922a99bd5d401fecf6592cf42a3b638e">write_tecplot_binary</a> (const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt; &gt; &amp;patches, const std::vector&lt; std::string &gt; &amp;data_names, const std::vector&lt; std_cxx1x::tuple&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>, std::string &gt; &gt; &amp;vector_data_ranges, const <a class="el" href="structDataOutBase_1_1TecplotFlags.html">TecplotFlags</a> &amp;flags, std::ostream &amp;out)</td></tr>
<tr class="separator:a922a99bd5d401fecf6592cf42a3b638e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1001da1aae0925adf22db3acab3ae53f"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a1001da1aae0925adf22db3acab3ae53f"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDataOutBase.html#a1001da1aae0925adf22db3acab3ae53f">write_ucd</a> (const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt; &gt; &amp;patches, const std::vector&lt; std::string &gt; &amp;data_names, const std::vector&lt; std_cxx1x::tuple&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>, std::string &gt; &gt; &amp;vector_data_ranges, const <a class="el" href="structDataOutBase_1_1UcdFlags.html">UcdFlags</a> &amp;flags, std::ostream &amp;out)</td></tr>
<tr class="separator:a1001da1aae0925adf22db3acab3ae53f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af046f700b34e45c5bee967c1ed4e202b"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:af046f700b34e45c5bee967c1ed4e202b"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDataOutBase.html#af046f700b34e45c5bee967c1ed4e202b">write_vtk</a> (const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt; &gt; &amp;patches, const std::vector&lt; std::string &gt; &amp;data_names, const std::vector&lt; std_cxx1x::tuple&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>, std::string &gt; &gt; &amp;vector_data_ranges, const <a class="el" href="structDataOutBase_1_1VtkFlags.html">VtkFlags</a> &amp;flags, std::ostream &amp;out)</td></tr>
<tr class="separator:af046f700b34e45c5bee967c1ed4e202b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b996bd158c560e1cd02d13e369fb7a1"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a6b996bd158c560e1cd02d13e369fb7a1"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDataOutBase.html#a6b996bd158c560e1cd02d13e369fb7a1">write_vtu</a> (const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt; &gt; &amp;patches, const std::vector&lt; std::string &gt; &amp;data_names, const std::vector&lt; std_cxx1x::tuple&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>, std::string &gt; &gt; &amp;vector_data_ranges, const <a class="el" href="structDataOutBase_1_1VtkFlags.html">VtkFlags</a> &amp;flags, std::ostream &amp;out)</td></tr>
<tr class="separator:a6b996bd158c560e1cd02d13e369fb7a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f6aea17753b0958caee64834f78999a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutBase.html#a8f6aea17753b0958caee64834f78999a">write_vtu_header</a> (std::ostream &amp;out, const <a class="el" href="structDataOutBase_1_1VtkFlags.html">VtkFlags</a> &amp;flags)</td></tr>
<tr class="separator:a8f6aea17753b0958caee64834f78999a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6a3748f848775d4742b1f538e055091"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutBase.html#ac6a3748f848775d4742b1f538e055091">write_vtu_footer</a> (std::ostream &amp;out)</td></tr>
<tr class="separator:ac6a3748f848775d4742b1f538e055091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53050da07d33c6d10cb467d61f4946c6"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a53050da07d33c6d10cb467d61f4946c6"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDataOutBase.html#a53050da07d33c6d10cb467d61f4946c6">write_vtu_main</a> (const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt; &gt; &amp;patches, const std::vector&lt; std::string &gt; &amp;data_names, const std::vector&lt; std_cxx1x::tuple&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>, std::string &gt; &gt; &amp;vector_data_ranges, const <a class="el" href="structDataOutBase_1_1VtkFlags.html">VtkFlags</a> &amp;flags, std::ostream &amp;out)</td></tr>
<tr class="separator:a53050da07d33c6d10cb467d61f4946c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64581e953d029519c308ff5ea5bd9123"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a64581e953d029519c308ff5ea5bd9123"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDataOutBase.html#a64581e953d029519c308ff5ea5bd9123">write_svg</a> (const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt; &gt; &amp;patches, const std::vector&lt; std::string &gt; &amp;data_names, const std::vector&lt; std_cxx1x::tuple&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>, std::string &gt; &gt; &amp;vector_data_ranges, const <a class="el" href="structDataOutBase_1_1SvgFlags.html">SvgFlags</a> &amp;flags, std::ostream &amp;out)</td></tr>
<tr class="separator:a64581e953d029519c308ff5ea5bd9123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac4bd3488253d6a9321aed165ce4e6e8"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:aac4bd3488253d6a9321aed165ce4e6e8"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDataOutBase.html#aac4bd3488253d6a9321aed165ce4e6e8">write_deal_II_intermediate</a> (const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt; &gt; &amp;patches, const std::vector&lt; std::string &gt; &amp;data_names, const std::vector&lt; std_cxx1x::tuple&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>, std::string &gt; &gt; &amp;vector_data_ranges, const <a class="el" href="structDataOutBase_1_1Deal__II__IntermediateFlags.html">Deal_II_IntermediateFlags</a> &amp;flags, std::ostream &amp;out)</td></tr>
<tr class="separator:aac4bd3488253d6a9321aed165ce4e6e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf4705279f86cbfff11a523c7e903008"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:adf4705279f86cbfff11a523c7e903008"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDataOutBase.html#adf4705279f86cbfff11a523c7e903008">write_hdf5_parallel</a> (const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt; &gt; &amp;patches, const <a class="el" href="classDataOutBase_1_1DataOutFilter.html">DataOutFilter</a> &amp;data_filter, const std::string &amp;filename, MPI_Comm comm)</td></tr>
<tr class="separator:adf4705279f86cbfff11a523c7e903008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e24d8498a8542e3b1be3d24f1a75ae4"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a5e24d8498a8542e3b1be3d24f1a75ae4"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDataOutBase.html#a5e24d8498a8542e3b1be3d24f1a75ae4">write_hdf5_parallel</a> (const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt; &gt; &amp;patches, const <a class="el" href="classDataOutBase_1_1DataOutFilter.html">DataOutFilter</a> &amp;data_filter, const <a class="el" href="classbool.html">bool</a> write_mesh_file, const std::string &amp;mesh_filename, const std::string &amp;solution_filename, MPI_Comm comm)</td></tr>
<tr class="separator:a5e24d8498a8542e3b1be3d24f1a75ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46148b2ffd978c31d960961004778200"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a46148b2ffd978c31d960961004778200"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDataOutBase.html#a46148b2ffd978c31d960961004778200">write_filtered_data</a> (const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt; &gt; &amp;patches, const std::vector&lt; std::string &gt; &amp;data_names, const std::vector&lt; std_cxx1x::tuple&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>, std::string &gt; &gt; &amp;vector_data_ranges, <a class="el" href="classDataOutBase_1_1DataOutFilter.html">DataOutFilter</a> &amp;filtered_data)</td></tr>
<tr class="separator:a46148b2ffd978c31d960961004778200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19cc8f9c1709149a34dd350290513592"><td class="memItemLeft" align="right" valign="top">static std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, <br class="typebreak"/>
unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutBase.html#a19cc8f9c1709149a34dd350290513592">determine_intermediate_format_dimensions</a> (std::istream &amp;input)</td></tr>
<tr class="separator:a19cc8f9c1709149a34dd350290513592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c3ba5b0ee6f2aa1d99235d3ecee12dc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1">OutputFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutBase.html#a7c3ba5b0ee6f2aa1d99235d3ecee12dc">parse_output_format</a> (const std::string &amp;format_name)</td></tr>
<tr class="separator:a7c3ba5b0ee6f2aa1d99235d3ecee12dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25ef0b2156ecc21a658b1153530ea8b2"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutBase.html#a25ef0b2156ecc21a658b1153530ea8b2">get_output_format_names</a> ()</td></tr>
<tr class="separator:a25ef0b2156ecc21a658b1153530ea8b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8326a026d08fcef45d76c14f0c54396b"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutBase.html#a8326a026d08fcef45d76c14f0c54396b">default_suffix</a> (const <a class="el" href="classDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1">OutputFormat</a> output_format)</td></tr>
<tr class="separator:a8326a026d08fcef45d76c14f0c54396b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb4a968caedd8f0caa89925a165e0cdf"><td class="memItemLeft" align="right" valign="top">static std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutBase.html#abb4a968caedd8f0caa89925a165e0cdf">memory_consumption</a> ()</td></tr>
<tr class="separator:abb4a968caedd8f0caa89925a165e0cdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:acd44f1120ddff471fcce767a255dd9e5"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename STREAM &gt; </td></tr>
<tr class="memitem:acd44f1120ddff471fcce767a255dd9e5"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDataOutBase.html#acd44f1120ddff471fcce767a255dd9e5">write_nodes</a> (const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt; &gt; &amp;patches, STREAM &amp;out)</td></tr>
<tr class="separator:acd44f1120ddff471fcce767a255dd9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4618130ae0a33acd3274800c3ce5d946"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename STREAM &gt; </td></tr>
<tr class="memitem:a4618130ae0a33acd3274800c3ce5d946"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDataOutBase.html#a4618130ae0a33acd3274800c3ce5d946">write_cells</a> (const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt; &gt; &amp;patches, STREAM &amp;out)</td></tr>
<tr class="separator:a4618130ae0a33acd3274800c3ce5d946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af41edc2aabf16c0723892e9f48bef281"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, class STREAM &gt; </td></tr>
<tr class="memitem:af41edc2aabf16c0723892e9f48bef281"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDataOutBase.html#af41edc2aabf16c0723892e9f48bef281">write_data</a> (const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt; &gt; &amp;patches, const unsigned <a class="el" href="classint.html">int</a> n_data_sets, const <a class="el" href="classbool.html">bool</a> double_precision, STREAM &amp;out)</td></tr>
<tr class="separator:af41edc2aabf16c0723892e9f48bef281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a630429272938e9c1f79d609b6f9fc431"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classPoint.html">Point</a>&lt; 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutBase.html#a630429272938e9c1f79d609b6f9fc431">svg_project_point</a> (<a class="el" href="classPoint.html">Point</a>&lt; 3 &gt; point, <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt; camera_position, <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt; camera_direction, <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt; camera_horizontal, float camera_focus)</td></tr>
<tr class="separator:a630429272938e9c1f79d609b6f9fc431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad08657a80ea6f827777c69b0f90c129c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classPoint.html">Point</a>&lt; 6 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutBase.html#ad08657a80ea6f827777c69b0f90c129c">svg_get_gradient_parameters</a> (<a class="el" href="classPoint.html">Point</a>&lt; 3 &gt; points[])</td></tr>
<tr class="separator:ad08657a80ea6f827777c69b0f90c129c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08c97ec37b1acefbe0693fc034c5758e"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a08c97ec37b1acefbe0693fc034c5758e"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDataOutBase.html#a08c97ec37b1acefbe0693fc034c5758e">write_gmv_reorder_data_vectors</a> (const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt; &gt; &amp;patches, <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="classdouble.html">double</a> &gt; &amp;data_vectors)</td></tr>
<tr class="separator:a08c97ec37b1acefbe0693fc034c5758e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This is a base class for output of data on meshes of very general form. Output data is expected as a set of <code>patches</code> and written to the output stream in the format expected by the visualization tool. For a list of output formats, check the enumeration <a class="el" href="classDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1">OutputFormat</a>. For each format listed there, this class contains a function <code>write_format</code>, writing the output. Refer to the documentation of those functions for details on a certain format.</p>
<h3>Structure of the output data</h3>
<p>Data is not written with the deal.II mesh structure. Instead, it relies on a set of <code>patches</code> created by a derived class (for example the <a class="el" href="classDataOut.html">DataOut</a>, <a class="el" href="classDataOutStack.html">DataOutStack</a>, <a class="el" href="classDataOutFaces.html">DataOutFaces</a>, <a class="el" href="classDataOutRotation.html">DataOutRotation</a>, or <a class="el" href="classMatrixOut.html">MatrixOut</a> classes). Each <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a> describes a single logical cell of a mesh, possibly subdivided a number of times to represent higher order polynomials defined on this cell. To this end, a patch consists of a <code>dim</code>-dimensional regular grid with the same number of grid points in each direction. In the simplest case it may consist of the corner points of a single mesh cell. For each point of this local grid, the <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a> contains an arbitrary number of data values, though the number of data sets must be the same for each point on each patch.</p>
<p>By offering this interface to the different output formats, it is simple to extend this class to new formats without depending on such things as actual triangulations and handling of data vectors. These things shall be provided by derived class which have a user callable interface then.</p>
<p>Inside each patch, the data is organized in the usual lexicographical order, <em>x</em> running fastest, then <em>y</em> and <em>z</em>. Nodes are stored in this order and cells as well. Each cell in 3D is stored such that the front face is in the <em>xz</em>-plane. In order to enhance intellegibility of this concept, the following two sections are kept from a previous version of this documentation.</p>
<h4>Patches</h4>
<p>Grids can be thought of as a collection of cells; if you want to write out data on such a grid, you can do so by writing them one cell at a time. The functions in this class therefore take a list of objects describing the data on one cell each. This data for each cell usually consists of a list of vertices for this cell, and a list of data values (for example solution data, error information, etc) at each of these vertices.</p>
<p>In some cases, this interface to a cell is too restricted, however. For example, you may have higher order elements and printing the values at the vertices only is not enough. For this reason, we not only provide writing the data on the vertices only, but the data is organizes as a tensor product grid on each cell. The parameter <code>n_subdivision</code>, which is given for each patch separately, denotes how often the cell is to be divided for output; for example, <code>n_subdivisions==1</code> yields no subdivision of the cell, <code>n_subdivisions==2</code> will produce a grid of 3 times 3 points in two spatial dimensions and 3 times 3 times 3 points in three dimensions, <code>n_subdivisions==3</code> will yield 4 times 4 (times 4) points, etc. The actual location of these points on the patch will be computed by a multilinear transformation from the vertices given for this patch.</p>
<p>For cells at the boundary, a mapping might be used to calculate the position of the inner points. In that case the coordinates are stored inside the <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>, as they cannot be easily recovered otherwise.</p>
<p>Given these comments, the actual data to be printed on this patch of points consists of several data sets each of which has a value at each of the patch points. For example with <code>n_subdivisions==2</code> in two space dimensions, each data set has to provide nine values, and since the patch is to be printed as a tensor product (or its transformation to the real space cell), its values are to be ordered like <em>(x0,y0) (x0,y1) (x0,y2) (x1,y0) (x1,y1) (x1,y2) (x2,y0) (x2,y1) (x2,y2)</em>, i.e. the z-coordinate runs fastest, then the y-coordinate, then x (if there are that many space directions).</p>
<h4>Generalized patches</h4>
<p>In general, the patches as explained above might be too restricted. For example, one might want to draw only the outer faces of a domain in a three-dimensional computation, if one is not interested in what happens inside. Then, the objects that should be drawn are two-dimensional in a three-dimensional world. The <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a> class and associated output functions handle these cases. The <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a> class therefore takes two template parameters, the first, named <code>dim</code> denoting the dimension of the object (in the above example, this would be two), while the second, named <code>spacedim</code>, denotes the dimension of the embedding space (this would be three). The corner points of a patch have the dimension of the space, while their number is determined by the dimension of the patch. By default, the second template parameter has the same value as the first, which would correspond to outputting a cell, rather than a face or something else.</p>
<h3>DataOutBaseInterface</h3>
<p>This class has an interface that is not usually called by a user directly; also, it consists of <code>static</code> functions only. Usually, derived classes will inherit this class <code>protected</code> to hide this interface to the users of thes classes.</p>
<p>The interface of this class basically consists of the declaration of a data type describing a patch and a bunch of functions taking a list of patches and writing them in one format or other to the stream. It is in the responsibility of the derived classes to provide this list of patches. In addition to the list of patches, a name for each data set may be given.</p>
<h3>Querying interface</h3>
<p>This class also provides a few functions (<a class="el" href="classDataOutBase.html#a7c3ba5b0ee6f2aa1d99235d3ecee12dc">parse_output_format()</a>, <a class="el" href="classDataOutBase.html#a25ef0b2156ecc21a658b1153530ea8b2">get_output_format_names()</a>, <a class="el" href="classDataOutBase.html#a8326a026d08fcef45d76c14f0c54396b">default_suffix()</a>) that can be used to query which output formats this class supports. The provide a list of names for all the formats we can output, parse a string and return an enum indicating each format, and provide a way to convert a value of this enum into the usual suffix used for files of that name. Using these functions, one can entirely free applications from knowledge which formats the library presently allows to output; several of the example programs show how to do this.</p>
<h3>Output parameters</h3>
<p>All functions take a parameter which is a structure of type <code>XFlags</code>, where <code>X</code> is the name of the output format. To find out what flags are presently supported, read the documentation of the different structures.</p>
<p>Note that usually the output formats used for scientific visualization programs have no or very few parameters (apart from some compatibility flags) because there the actual appearance of output is determined using the visualization program and the files produced by this class store more or less only raw data.</p>
<p>The direct output formats, like Postscript or Povray need to be given a lot more parameters, though, since there the output file has to contain all details of the viewpoint, light source, etc.</p>
<h3>Writing backends</h3>
<p>An abstraction layer has been introduced to facilitate coding backends for additional visualization tools. It is applicable for data formats separating the information into a field of vertices, a field of connection information for the grid cells and data fields.</p>
<p>For each of these fields, output functions are implemented, namely <a class="el" href="classDataOutBase.html#acd44f1120ddff471fcce767a255dd9e5">write_nodes()</a>, <a class="el" href="classDataOutBase.html#a4618130ae0a33acd3274800c3ce5d946">write_cells()</a> and <a class="el" href="classDataOutBase.html#af41edc2aabf16c0723892e9f48bef281">write_data()</a>. In order to use these functions, a format specific output stream must be written, following the examples of DXStream, GmvStream, VtkStream and so on, implemented in the .cc file.</p>
<p>In this framework, the implementation of a new output format is reduced to writing the section headers and the new output stream class for writing a single mesh object.</p>
<h3>Credits</h3>
<ul>
<li>
<p class="startli">EPS output based on an earlier implementation by Stefan Nauber for the old <a class="el" href="classDataOut.html">DataOut</a> class</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Povray output by Thomas Richter</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Tecplot output by Benjamin Shelton Kirk</p>
<p class="endli"></p>
</li>
</ul>
<dl class="section author"><dt>Author</dt><dd>Wolfgang Bangerth, Guido Kanschat 1999, 2000, 2001, 2002, 2005, 2006. </dd></dl>

<p>Definition at line <a class="el" href="data__out__base_8h_source.html#l00219">219</a> of file <a class="el" href="data__out__base_8h_source.html">data_out_base.h</a>.</p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="aa3cbced9f1d4ae661f13018f4c980aa1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1">DataOutBase::OutputFormat</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Provide a data type specifying the presently supported output formats. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="aa3cbced9f1d4ae661f13018f4c980aa1aaca645a9a5b8782ed6dff8ef6b809e07"></a>default_format&#160;</td><td class="fielddoc">
<p>Use the format already stored in the object. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aa3cbced9f1d4ae661f13018f4c980aa1aa6f1f99c613aeb81b8d8e598b5567ce1"></a>none&#160;</td><td class="fielddoc">
<p>Do not write any output. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aa3cbced9f1d4ae661f13018f4c980aa1af54db6e70b60a249b36f803d0657b39e"></a>dx&#160;</td><td class="fielddoc">
<p>Output for OpenDX. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aa3cbced9f1d4ae661f13018f4c980aa1a1a420a2edb82acdd6e8e214f2ed97721"></a>ucd&#160;</td><td class="fielddoc">
<p>Output in the UCD format for AVS. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aa3cbced9f1d4ae661f13018f4c980aa1a025233c1a8124e5521952c7c7cd78df1"></a>gnuplot&#160;</td><td class="fielddoc">
<p>Output for the Gnuplot tool. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aa3cbced9f1d4ae661f13018f4c980aa1a74aee841ac4d429a660bbd1bfee6f298"></a>povray&#160;</td><td class="fielddoc">
<p>Output for the Povray raytracer. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aa3cbced9f1d4ae661f13018f4c980aa1acf35b7afd6a85044d32320355fbaabfe"></a>eps&#160;</td><td class="fielddoc">
<p>Output in encapsulated PostScript. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aa3cbced9f1d4ae661f13018f4c980aa1a958eea3b2724c76d1c1ff20d69f7da4e"></a>gmv&#160;</td><td class="fielddoc">
<p>Output for GMV. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aa3cbced9f1d4ae661f13018f4c980aa1a8c187cd13581e59b34d71645276a550c"></a>tecplot&#160;</td><td class="fielddoc">
<p>Output for Tecplot in text format. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aa3cbced9f1d4ae661f13018f4c980aa1a9b83a7bdbd793467207e0a8f151e15e0"></a>tecplot_binary&#160;</td><td class="fielddoc">
<p>Output for Tecplot in binary format. Faster and smaller than text format. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aa3cbced9f1d4ae661f13018f4c980aa1ac41fd26a6a54c90d0d2062d859b8facf"></a>vtk&#160;</td><td class="fielddoc">
<p>Output in VTK format. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aa3cbced9f1d4ae661f13018f4c980aa1acff6079f78795530409873a79263ad7e"></a>vtu&#160;</td><td class="fielddoc">
<p>Output in VTK format. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aa3cbced9f1d4ae661f13018f4c980aa1ad512d1f704c4b56b7bf99e3f81ebc06f"></a>svg&#160;</td><td class="fielddoc">
<p>Output in SVG format. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aa3cbced9f1d4ae661f13018f4c980aa1ab9c7fdc67b488efaf1b27b02985a40fb"></a>deal_II_intermediate&#160;</td><td class="fielddoc">
<p>Output in deal.II intermediate format. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aa3cbced9f1d4ae661f13018f4c980aa1af7b5982bac28c91f885940695ca47542"></a>hdf5&#160;</td><td class="fielddoc">
<p>Output in HDF5 format. </p>
</td></tr>
</table>

<p>Definition at line <a class="el" href="data__out__base_8h_source.html#l01385">1385</a> of file <a class="el" href="data__out__base_8h_source.html">data_out_base.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a473ac0a368162c07135934c7d0c1d2cb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void DataOutBase::write_dx </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>patches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std_cxx1x::tuple&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>, std::string &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_data_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDataOutBase_1_1DXFlags.html">DXFlags</a> &amp;&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write the given list of patches to the output stream in OpenDX format.</p>
<p>Since OpenDX uses some kind of visual data flow oriented programming language, some of these programs are provided in <code>contrib/dx</code>. </p>

</div>
</div>
<a class="anchor" id="a75dd1bbf8e69bfa61048f4faad37aae2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void DataOutBase::write_eps </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>patches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std_cxx1x::tuple&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>, std::string &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_data_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDataOutBase_1_1EpsFlags.html">EpsFlags</a> &amp;&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write the given list of patches to the output stream in eps format.</p>
<p>Output in this format circumvents the use of auxiliary graphic programs converting some output format into a graphics format. This has the advantage that output is easy and fast, and the disadvantage that you have to give a whole bunch of parameters which determine the direction of sight, the mode of colorization, the scaling of the height axis, etc. (Of course, all these parameters have reasonable default values, which you may want to change from time to time.) At present, this format only supports output for two-dimensional data, with values in the third direction taken from a data vector.</p>
<p>Basically, output consists of the mesh and the cells in between them. You can draw either of these, or both, or none if you are really interested in an empty picture. If written, the mesh uses black lines. The cells in between the mesh are either not printed (this will result in a loss of hidden line removal, i.e. you can "see through" the cells to lines behind), printed in white (which does nothing apart from the hidden line removal), or colorized using one of the data vectors (which need not be the same as the one used for computing the height information) and a customizable color function. The default color functions chooses the color between black, blue, green, red and white, with growing values of the data field chosen for colorization. At present, cells are displayed with one color per cell only, which is taken from the value of the data field at the center of the cell; bilinear interpolation of the color on a cell is not used.</p>
<p>By default, the viewpoint is chosen like the default viewpoint in GNUPLOT, i.e. with an angle of 60 degrees with respect to the positive z-axis and rotated 30 degrees in positive sense (as seen from above) away from the negative y-axis. Of course you can change these settings.</p>
<p>EPS output is written without a border around the picture, i.e. the bounding box is close to the output on all four sides. Coordinates are written using at most five digits, to keep picture size at a reasonable size.</p>
<p>All parameters along with their default values are listed in the documentation of the <code><a class="el" href="structDataOutBase_1_1EpsFlags.html">EpsFlags</a></code> member class of this class. See there for more and detailed information. </p>

</div>
</div>
<a class="anchor" id="af7ea4056dc818119998197b57ab29ee0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void DataOutBase::write_gmv </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>patches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std_cxx1x::tuple&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>, std::string &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_data_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDataOutBase_1_1GmvFlags.html">GmvFlags</a> &amp;&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write the given list of patches to the output stream in GMV format.</p>
<p>Data is written in the following format: nodes are considered the points of the patches. In spatial dimensions less than three, zeroes are inserted for the missing coordinates. The data vectors are written as node or cell data, where for the first the data space is interpolated to (bi-,tri-)linear elements. </p>

</div>
</div>
<a class="anchor" id="a4e5435b971e7a342ef0040df0992d5cd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void DataOutBase::write_gnuplot </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>patches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std_cxx1x::tuple&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>, std::string &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_data_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDataOutBase_1_1GnuplotFlags.html">GnuplotFlags</a> &amp;&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write the given list of patches to the output stream in gnuplot format. Visualization of two-dimensional data can then be achieved by starting <code>gnuplot</code> and endtering the commands</p>
<pre class="fragment">* set data style lines
* splot "filename" using 1:2:n
* </pre><p> This example assumes that the number of the data vector displayed is <b>n-2</b>.</p>
<p>The GNUPLOT format is not able to handle data on unstructured grids directly. Directly would mean that you only give the vertices and the solution values thereon and the program constructs its own grid to represent the data. This is only possible for a structured tensor product grid in two dimensions. However, it is possible to give several such patches within one file, which is exactly what the respective function of this class does: writing each cell's data as a patch of data, at least if the patches as passed from derived classes represent cells. Note that the functions on patches need not be continuous at interfaces between patches, so this method also works for discontinuous elements. Note also, that GNUPLOT can do hidden line removal for patched data.</p>
<p>While this discussion applies to two spatial dimensions, it is more complicated in 3d. The reason is that we could still use patches, but it is difficult when trying to visualize them, since if we use a cut through the data (by, for example, using x- and z-coordinates, a fixed y-value and plot function values in z-direction, then the patched data is not a patch in the sense GNUPLOT wants it any more. Therefore, we use another approach, namely writing the data on the 3d grid as a sequence of lines, i.e. two points each associated with one or more data sets. There are therefore 12 lines for each subcells of a patch.</p>
<p>Given the lines as described above, a cut through this data in Gnuplot can then be achieved like this (&amp; stands for the dollar sign in the following): </p>
<pre class="fragment">*   set data style lines
*   splot [:][:][0:] "T" using 1:2:(&amp;3==.5 ? &amp;4 : -1)
* </pre><p>This command plots data in x- and y-direction unbounded, but in z-direction only those data points which are above the x-y-plane (we assume here a positive solution, if it has negative values, you might want to decrease the lower bound). Furthermore, it only takes the data points with z-values (<code>&amp;3</code>) equal to 0.5, i.e. a cut through the domain at <code>z=0.5</code>. For the data points on this plane, the data values of the first data set (<code>&amp;4</code>) are raised in z-direction above the x-y-plane; all other points are denoted the value <code>-1</code> instead of the value of the data vector and are not plotted due to the lower bound in z plotting direction, given in the third pair of brackets.</p>
<p>More complex cuts are possible, including nonlinear ones. Note however, that only those points which are actually on the cut-surface are plotted. </p>

</div>
</div>
<a class="anchor" id="aff66fc3b49a9130d45808721f16eac98"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void DataOutBase::write_povray </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>patches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std_cxx1x::tuple&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>, std::string &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_data_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDataOutBase_1_1PovrayFlags.html">PovrayFlags</a> &amp;&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write the given list of patches to the output stream for the Povray raytracer.</p>
<p>Output in this format creates a povray source file, include standard camera and light source definition for rendering with povray 3.1 At present, this format only supports output for two-dimensional data, with values in the third direction taken from a data vector.</p>
<p>The output uses two different povray-objects:</p>
<ul>
<li>
<p class="startli"><code>BICUBIC_PATCH</code> A <code>bicubic_patch</code> is a 3-dimensional Bezier patch. It consists of 16 Points describing the surface. The 4 corner points are touched by the object, while the other 12 points pull and stretch the patch into shape. One <code>bicubic_patch</code> is generated on each patch. Therefor the number of subdivisions has to be 3 to provide the patch with 16 points. A bicubic patch is not exact but generates very smooth images.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><code>MESH</code> The mesh object is used to store large number of triangles. Every square of the patch data is split into one upper-left and one lower-right triangle. If the number of subdivisions is three, 32 triangle are generated for every patch.</p>
<p class="endli">Using the smooth flag povray interpolates the normals on the triangles, imitating a curved surface </p>
</li>
</ul>
<p>All objects get one texture definition called Tex. This texture has to be declared somewhere before the object data. This may be in an external data file or at the beginning of the output file. Setting the <code>external_data</code> flag to false, an standard camera, light and texture (scaled to fit the scene) is added to the outputfile. Set to true an include file "data.inc" is included. This file is not generated by deal and has to include camera, light and the texture definition Tex.</p>
<p>You need povray (&gt;=3.0) to render the scene. The minimum options for povray are: </p>
<pre class="fragment">*   povray +I&lt;inputfile&gt; +W&lt;horiz. size&gt; +H&lt;ver. size&gt; +L&lt;include path&gt;
* </pre><p> If the external file "data.inc" is used, the path to this file has to be included in the povray options. </p>

</div>
</div>
<a class="anchor" id="a881b231c2909953ff1882d374e98f66f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void DataOutBase::write_tecplot </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>patches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std_cxx1x::tuple&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>, std::string &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_data_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDataOutBase_1_1TecplotFlags.html">TecplotFlags</a> &amp;&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write the given list of patches to the output stream in Tecplot ASCII format (FEBLOCK).</p>
<p>For more information consult the Tecplot Users and Reference manuals. </p>

</div>
</div>
<a class="anchor" id="a922a99bd5d401fecf6592cf42a3b638e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void DataOutBase::write_tecplot_binary </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>patches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std_cxx1x::tuple&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>, std::string &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_data_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDataOutBase_1_1TecplotFlags.html">TecplotFlags</a> &amp;&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write the given list of patches to the output stream in Tecplot binary format.</p>
<p>For this to work properly <code>./configure</code> checks for the Tecplot API at build time. To write Tecplot binary files directly make sure that the TECHOME environment variable points to the Tecplot installation directory, and that the files $TECHOME/include/TECIO.h and $TECHOME/lib/tecio.a are readable. If these files are not available (or in the case of 1D) this function will simply call <a class="el" href="classDataOutBase.html#a881b231c2909953ff1882d374e98f66f">write_tecplot()</a> and thus larger ASCII data files will be produced rather than more efficient Tecplot binary files.</p>
<dl class="section warning"><dt>Warning</dt><dd><a class="el" href="structDataOutBase_1_1TecplotFlags.html#a125c9de7b09e8fe7606da42e3ac61127">TecplotFlags::tecplot_binary_file_name</a> indicates the name of the file to be written. If the file name is not set ASCII output is produced.</dd></dl>
<p>For more information consult the Tecplot Users and Reference manuals. </p>

</div>
</div>
<a class="anchor" id="a1001da1aae0925adf22db3acab3ae53f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void DataOutBase::write_ucd </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>patches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std_cxx1x::tuple&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>, std::string &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_data_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDataOutBase_1_1UcdFlags.html">UcdFlags</a> &amp;&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write the given list of patches to the output stream in UCD format described in the AVS developer's guide (now AVS). Due to limitations in the present format, only node based data can be output, which in one reason why we invented the patch concept. In order to write higher order elements, you may split them up into several subdivisions of each cell. These subcells will then, however, also appear as different cells by programs which understand the UCD format.</p>
<p>No use is made of the possibility to give model data since these are not supported by all UCD aware programs. You may give cell data in derived classes by setting all values of a given data set on a patch to the same value. </p>

</div>
</div>
<a class="anchor" id="af046f700b34e45c5bee967c1ed4e202b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void DataOutBase::write_vtk </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>patches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std_cxx1x::tuple&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>, std::string &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_data_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDataOutBase_1_1VtkFlags.html">VtkFlags</a> &amp;&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write the given list of patches to the output stream in VTK format. The data is written in the traditional VTK format as opposed to the XML-based format that <a class="el" href="classDataOutBase.html#a6b996bd158c560e1cd02d13e369fb7a1">write_vtu()</a> produces.</p>
<p>The vector_data_ranges argument denotes ranges of components in the output that are considered a vector, rather than simply a collection of scalar fields. The VTK output format has special provisions that allow these components to be output by a single name rather than having to group several scalar fields into a vector later on in the visualization program.</p>
<dl class="section note"><dt>Note</dt><dd>VTK is a legacy format and has largely been supplanted by the VTU format (an XML-structured version of VTK). In particular, VTU allows for the compression of data and consequently leads to much smaller file sizes that equivalent VTK files for large files. Since all visualization programs that support VTK also support VTU, you should consider using the latter file format instead, by using the <a class="el" href="classDataOutBase.html#a6b996bd158c560e1cd02d13e369fb7a1">write_vtu()</a> function. </dd></dl>

</div>
</div>
<a class="anchor" id="a6b996bd158c560e1cd02d13e369fb7a1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void DataOutBase::write_vtu </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>patches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std_cxx1x::tuple&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>, std::string &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_data_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDataOutBase_1_1VtkFlags.html">VtkFlags</a> &amp;&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write the given list of patches to the output stream in VTU format. The data is written in the XML-based VTK format as opposed to the traditional format that <a class="el" href="classDataOutBase.html#af046f700b34e45c5bee967c1ed4e202b">write_vtk()</a> produces.</p>
<p>The vector_data_ranges argument denotes ranges of components in the output that are considered a vector, rather than simply a collection of scalar fields. The VTK output format has special provisions that allow these components to be output by a single name rather than having to group several scalar fields into a vector later on in the visualization program.</p>
<p>Some visualization programs, such as ParaView, can read several separate VTU files to parallelize visualization. In that case, you need a <code>.pvtu</code> file that describes which VTU files form a group. The <a class="el" href="classDataOutInterface.html#a81fbfc0a7a531a2e2f09e23c68ca382a">DataOutInterface::write_pvtu_record()</a> function can generate such a master record. Likewise, <a class="el" href="classDataOutInterface.html#aa8274771a3c242d17b4bca5aaa90898c">DataOutInterface::write_visit_record()</a> does the same for VisIt. Finally, for time dependent problems, you may also want to look at <a class="el" href="classDataOutInterface.html#a0d247c3780325546472c006d8ef3b12d">DataOutInterface::write_pvd_record()</a></p>
<p>The use of this function is explained in <a class="el" href="step_40.html">step-40</a>. </p>

</div>
</div>
<a class="anchor" id="a8f6aea17753b0958caee64834f78999a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void DataOutBase::write_vtu_header </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDataOutBase_1_1VtkFlags.html">VtkFlags</a> &amp;&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This writes the header for the xml based vtu file format. This routine is used internally together with <a class="el" href="classDataOutBase.html#ac6a3748f848775d4742b1f538e055091">DataOutInterface::write_vtu_footer()</a> and <a class="el" href="classDataOutBase.html#a53050da07d33c6d10cb467d61f4946c6">DataOutInterface::write_vtu_main()</a> by <a class="el" href="classDataOutBase.html#a6b996bd158c560e1cd02d13e369fb7a1">DataOutBase::write_vtu()</a>. </p>

</div>
</div>
<a class="anchor" id="ac6a3748f848775d4742b1f538e055091"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void DataOutBase::write_vtu_footer </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This writes the footer for the xml based vtu file format. This routine is used internally together with <a class="el" href="classDataOutBase.html#a8f6aea17753b0958caee64834f78999a">DataOutInterface::write_vtu_header()</a> and <a class="el" href="classDataOutBase.html#a53050da07d33c6d10cb467d61f4946c6">DataOutInterface::write_vtu_main()</a> by <a class="el" href="classDataOutBase.html#a6b996bd158c560e1cd02d13e369fb7a1">DataOutBase::write_vtu()</a>. </p>

</div>
</div>
<a class="anchor" id="a53050da07d33c6d10cb467d61f4946c6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void DataOutBase::write_vtu_main </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>patches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std_cxx1x::tuple&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>, std::string &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_data_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDataOutBase_1_1VtkFlags.html">VtkFlags</a> &amp;&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This writes the main part for the xml based vtu file format. This routine is used internally together with <a class="el" href="classDataOutBase.html#a8f6aea17753b0958caee64834f78999a">DataOutInterface::write_vtu_header()</a> and <a class="el" href="classDataOutBase.html#ac6a3748f848775d4742b1f538e055091">DataOutInterface::write_vtu_footer()</a> by <a class="el" href="classDataOutBase.html#a6b996bd158c560e1cd02d13e369fb7a1">DataOutBase::write_vtu()</a>. </p>

</div>
</div>
<a class="anchor" id="a64581e953d029519c308ff5ea5bd9123"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void DataOutBase::write_svg </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>patches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std_cxx1x::tuple&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>, std::string &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_data_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDataOutBase_1_1SvgFlags.html">SvgFlags</a> &amp;&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write the given list of patches to the output stream in SVG format.</p>
<p>SVG (Scalable <a class="el" href="classVector.html">Vector</a> Graphics) is an XML-based vector image format developed and maintained by the World Wide Web Consortium (W3C). This function conforms to the latest specification SVG 1.1, released on August 16, 2011. Controlling the graphic output is possible by setting or clearing the respective flags (see the <a class="el" href="structDataOutBase_1_1SvgFlags.html">SvgFlags</a> struct). At present, this format only supports output for two-dimensional data, with values in the third direction taken from a data vector.</p>
<p>For the output, each patch is subdivided into four triangles which are then written as polygons and filled with a linear color gradient. The arising coloring of the patches visualizes the data values at the vertices taken from the specified data vector. A colorbar can be drawn to encode the coloring.</p>
<dl class="section note"><dt>Note</dt><dd>Yet only implemented for two dimensions with an additional dimension reserved for data information. </dd></dl>

</div>
</div>
<a class="anchor" id="aac4bd3488253d6a9321aed165ce4e6e8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void DataOutBase::write_deal_II_intermediate </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>patches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std_cxx1x::tuple&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>, std::string &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_data_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDataOutBase_1_1Deal__II__IntermediateFlags.html">Deal_II_IntermediateFlags</a> &amp;&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write the given list of patches to the output stream in deal.II intermediate format. This is not a format understood by any other graphics program, but is rather a direct dump of the intermediate internal format used by deal.II. This internal format is generated by the various classes that can generate output using the <a class="el" href="classDataOutBase.html">DataOutBase</a> class, for example from a finite element solution, and is then converted in the present class to the final graphics format.</p>
<p>Note that the intermediate format is what its name suggests: a direct representation of internal data. It isn't standardized and will change whenever we change our internal representation. You can only expect to process files written in this format using the same version of deal.II that was used for writing.</p>
<p>The reason why we offer to write out this intermediate format is that it can be read back into a deal.II program using the <a class="el" href="classDataOutReader.html">DataOutReader</a> class, which is helpful in at least two contexts: First, this can be used to later generate graphical output in any other graphics format presently understood; this way, it is not necessary to know at run-time which output format is requested, or if multiple output files in different formats are needed. Secondly, in contrast to almost all other graphics formats, it is possible to merge several files that contain intermediate format data, and generate a single output file from it, which may be again in intermediate format or any of the final formats. This latter option is most helpful for parallel programs: as demonstrated in the <a class="el" href="step_17.html">step-17</a> example program, it is possible to let only one processor generate the graphical output for the entire parallel program, but this can become vastly inefficient if many processors are involved, because the load is no longer balanced. The way out is to let each processor generate intermediate graphical output for its chunk of the domain, and the later merge the different files into one, which is an operation that is much cheaper than the generation of the intermediate data.</p>
<p>Intermediate format deal.II data is usually stored in files with the ending <code>.d2</code>. </p>

</div>
</div>
<a class="anchor" id="adf4705279f86cbfff11a523c7e903008"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void DataOutBase::write_hdf5_parallel </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>patches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDataOutBase_1_1DataOutFilter.html">DataOutFilter</a> &amp;&#160;</td>
          <td class="paramname"><em>data_filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write the data in data_filter to a single HDF5 file containing both the mesh and solution values. </p>

</div>
</div>
<a class="anchor" id="a5e24d8498a8542e3b1be3d24f1a75ae4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void DataOutBase::write_hdf5_parallel </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>patches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDataOutBase_1_1DataOutFilter.html">DataOutFilter</a> &amp;&#160;</td>
          <td class="paramname"><em>data_filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>write_mesh_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>mesh_filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>solution_filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write the data in data_filter to HDF5 file(s). If write_mesh_file is false, the mesh data will not be written and the solution file will contain only the solution values. If write_mesh_file is true and the filenames are the same, the resulting file will contain both mesh data and solution values. </p>

</div>
</div>
<a class="anchor" id="a46148b2ffd978c31d960961004778200"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void DataOutBase::write_filtered_data </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>patches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std_cxx1x::tuple&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>, std::string &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_data_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDataOutBase_1_1DataOutFilter.html">DataOutFilter</a> &amp;&#160;</td>
          <td class="paramname"><em>filtered_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classDataOutBase_1_1DataOutFilter.html">DataOutFilter</a> is an intermediate data format that reduces the amount of data that will be written to files. The object filled by this function can then later be used again to write data in a concrete file format; see, for example, <a class="el" href="classDataOutBase.html#adf4705279f86cbfff11a523c7e903008">DataOutBase::write_hdf5_parallel()</a>. </p>

</div>
</div>
<a class="anchor" id="a19cc8f9c1709149a34dd350290513592"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::pair&lt;unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>&gt; DataOutBase::determine_intermediate_format_dimensions </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given an input stream that contains data written by <a class="el" href="classDataOutBase.html#aac4bd3488253d6a9321aed165ce4e6e8">write_deal_II_intermediate()</a>, determine the <code>dim</code> and <code>spacedim</code> template parameters with which that function was called, and return them as a pair of values.</p>
<p>Note that this function eats a number of elements at the present position of the stream, and therefore alters it. In order to read from it using, for example, the <a class="el" href="classDataOutReader.html">DataOutReader</a> class, you may wish to either reset the stream to its previous position, or close and reopen it. </p>

</div>
</div>
<a class="anchor" id="a7c3ba5b0ee6f2aa1d99235d3ecee12dc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1">OutputFormat</a> DataOutBase::parse_output_format </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>format_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the OutputFormat value corresponding to the given string. If the string does not match any known format, an exception is thrown.</p>
<p>Since this function does not need data from this object, it is static and can thus be called without creating an object of this class. Its main purpose is to allow a program to use any implemented output format without the need to extend the program's parser each time a new format is implemented.</p>
<p>To get a list of presently available format names, e.g. to give it to the <a class="el" href="classParameterHandler.html">ParameterHandler</a> class, use the function <a class="el" href="classDataOutBase.html#a25ef0b2156ecc21a658b1153530ea8b2">get_output_format_names()</a>. </p>

</div>
</div>
<a class="anchor" id="a25ef0b2156ecc21a658b1153530ea8b2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string DataOutBase::get_output_format_names </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a list of implemented output formats. The different names are separated by vertical bar signs (<code>`|'</code>) as used by the <a class="el" href="classParameterHandler.html">ParameterHandler</a> classes. </p>

</div>
</div>
<a class="anchor" id="a8326a026d08fcef45d76c14f0c54396b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string DataOutBase::default_suffix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1">OutputFormat</a>&#160;</td>
          <td class="paramname"><em>output_format</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Provide a function which tells us which suffix a file with a given output format usually has. At present the following formats are defined: </p>
<ul>
<li>
<code>dx</code>: <code>.dx</code> </li>
<li>
<code>ucd</code>: <code>.inp</code> </li>
<li>
<code>gnuplot</code>: <code>.gnuplot</code> </li>
<li>
<code>povray</code>: <code>.pov</code> </li>
<li>
<code>eps</code>: <code>.eps</code> </li>
<li>
<code>gmv</code>: <code>.gmv</code> </li>
<li>
<code>tecplot</code>: <code>.dat</code> </li>
<li>
<code>tecplot_binary</code>: <code>.plt</code> </li>
<li>
<code>vtk</code>: <code>.vtk</code> </li>
<li>
<code>vtu</code>: <code>.vtu</code> </li>
<li>
<code>svg</code>: <code>.svg</code> </li>
<li>
<code>deal_II_intermediate</code>: <code>.d2</code>. </li>
</ul>

</div>
</div>
<a class="anchor" id="abb4a968caedd8f0caa89925a165e0cdf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::size_t DataOutBase::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determine an estimate for the memory consumption (in bytes) of this object. Since sometimes the size of objects can not be determined exactly (for example: what is the memory consumption of an STL <code>std::map</code> type with a certain number of elements?), this is only an estimate. however often quite close to the true value. </p>

</div>
</div>
<a class="anchor" id="acd44f1120ddff471fcce767a255dd9e5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename STREAM &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void DataOutBase::write_nodes </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>patches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">STREAM &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write the coordinates of nodes in the desired format. </p>

</div>
</div>
<a class="anchor" id="a4618130ae0a33acd3274800c3ce5d946"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename STREAM &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void DataOutBase::write_cells </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>patches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">STREAM &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write the node numbers of a cell in the desired format. </p>

</div>
</div>
<a class="anchor" id="af41edc2aabf16c0723892e9f48bef281"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, class STREAM &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void DataOutBase::write_data </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>patches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_data_sets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>double_precision</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">STREAM &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write data in the desired format. </p>

</div>
</div>
<a class="anchor" id="a630429272938e9c1f79d609b6f9fc431"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classPoint.html">Point</a>&lt;2&gt; DataOutBase::svg_project_point </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPoint.html">Point</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPoint.html">Point</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>camera_position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPoint.html">Point</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>camera_direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPoint.html">Point</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>camera_horizontal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>camera_focus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function projects a three-dimensional point (<a class="el" href="classPoint.html">Point&lt;3&gt;</a> point) onto a two-dimensional image plane, specified by the position of the camera viewing system (<a class="el" href="classPoint.html">Point&lt;3&gt;</a> camera_position), camera direction (<a class="el" href="classPoint.html">Point&lt;3&gt;</a> camera_position), camera horizontal (<a class="el" href="classPoint.html">Point&lt;3&gt;</a> camera_horizontal, necessary for the correct alignment of the later images), and the focus of the camera (float camera_focus).</p>
<p>For SVG output. </p>

</div>
</div>
<a class="anchor" id="ad08657a80ea6f827777c69b0f90c129c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classPoint.html">Point</a>&lt;6&gt; DataOutBase::svg_get_gradient_parameters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPoint.html">Point</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>points</em>[]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classFunction.html">Function</a> to compute the gradient parameters for a triangle with given values for the vertices.</p>
<p>Used for svg output. </p>

</div>
</div>
<a class="anchor" id="a08c97ec37b1acefbe0693fc034c5758e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void DataOutBase::write_gmv_reorder_data_vectors </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>patches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_vectors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is a helper function for the <a class="el" href="classDataOutBase.html#af7ea4056dc818119998197b57ab29ee0">write_gmv()</a> function. There, the data in the patches needs to be copied around as output is one variable globally at a time, rather than all data on each vertex at a time. This copying around can be done detached from the main thread, and is thus moved into this separate function.</p>
<p>Note that because of the similarity of the formats, this function is also used by the Vtk and Tecplot output functions. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/deal.II/base/<a class="el" href="data__out__base_8h_source.html">data_out_base.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jan 27 2014 15:27:17 for The deal.II Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
