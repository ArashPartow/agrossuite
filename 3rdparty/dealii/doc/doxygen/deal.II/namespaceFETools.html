<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>The deal.II Library: FETools Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="http://www.dealii.org/deal.ico"></link>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2014 by the deal.II authors"></meta>
<meta name="deal.II-version" content="8.1.0"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 8.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">FETools Namespace Reference<div class="ingroups"><a class="el" href="group__feall.html">Finite elements</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFETools_1_1FEFactoryBase.html">FEFactoryBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFETools_1_1FEFactory.html">FEFactory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a4945a239d321d126dfccce60a73a4e67"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a4945a239d321d126dfccce60a73a4e67"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#a4945a239d321d126dfccce60a73a4e67">compute_component_wise</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe, std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;renumbering, std::vector&lt; std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &gt; &amp;start_indices)</td></tr>
<tr class="separator:a4945a239d321d126dfccce60a73a4e67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7f8f27696c0adadc316996b7281f096"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ad7f8f27696c0adadc316996b7281f096"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#ad7f8f27696c0adadc316996b7281f096">compute_block_renumbering</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe, std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;renumbering, std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;block_data, <a class="el" href="classbool.html">bool</a> return_start_indices=true)</td></tr>
<tr class="separator:ad7f8f27696c0adadc316996b7281f096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a188d7528e6dbfa5fd5f567670b3b5fe9"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a188d7528e6dbfa5fd5f567670b3b5fe9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#a188d7528e6dbfa5fd5f567670b3b5fe9">hierarchic_to_lexicographic_numbering</a> (const <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt; &amp;fe_data, std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;h2l)</td></tr>
<tr class="separator:a188d7528e6dbfa5fd5f567670b3b5fe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aba07d10b2579f7259d37adb84f8808"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a4aba07d10b2579f7259d37adb84f8808"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#a4aba07d10b2579f7259d37adb84f8808">hierarchic_to_lexicographic_numbering</a> (const <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt; &amp;fe_data)</td></tr>
<tr class="separator:a4aba07d10b2579f7259d37adb84f8808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1db6ab2ac1c2318f07fc020756cf76b9"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a1db6ab2ac1c2318f07fc020756cf76b9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#a1db6ab2ac1c2318f07fc020756cf76b9">lexicographic_to_hierarchic_numbering</a> (const <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt; &amp;fe_data, std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;l2h)</td></tr>
<tr class="separator:a1db6ab2ac1c2318f07fc020756cf76b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41a15f1b5d3806344f355ef07960e9ce"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a41a15f1b5d3806344f355ef07960e9ce"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#a41a15f1b5d3806344f355ef07960e9ce">lexicographic_to_hierarchic_numbering</a> (const <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt; &amp;fe_data)</td></tr>
<tr class="separator:a41a15f1b5d3806344f355ef07960e9ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b33ff9d615cd6dacdd585dcadb10dd8"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a5b33ff9d615cd6dacdd585dcadb10dd8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, dim &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#a5b33ff9d615cd6dacdd585dcadb10dd8">get_fe_from_name</a> (const std::string &amp;name)</td></tr>
<tr class="separator:a5b33ff9d615cd6dacdd585dcadb10dd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a006641198ca5641c5c8ae20b741b4b"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a5a006641198ca5641c5c8ae20b741b4b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#a5a006641198ca5641c5c8ae20b741b4b">add_fe_name</a> (const std::string &amp;name, const <a class="el" href="classFETools_1_1FEFactoryBase.html">FEFactoryBase</a>&lt; dim, spacedim &gt; *factory)</td></tr>
<tr class="separator:a5a006641198ca5641c5c8ae20b741b4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a7c886f1760c13445c576d442e82656"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga7a7c886f1760c13445c576d442e82656">DeclException1</a> (ExcInvalidFEName, std::string,&lt;&lt; &quot;Can't re-generate a finite element from the string '&quot;&lt;&lt; arg1&lt;&lt; &quot;'.&quot;)</td></tr>
<tr class="separator:ga7a7c886f1760c13445c576d442e82656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa495d33626165d02e2bac6c66b7aecfa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaa495d33626165d02e2bac6c66b7aecfa">DeclException2</a> (ExcInvalidFEDimension, char, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;The dimension &quot;&lt;&lt; arg1&lt;&lt; &quot; in the finite element string must match &quot;&lt;&lt; &quot;the space dimension &quot;&lt;&lt; arg2&lt;&lt; &quot;.&quot;)</td></tr>
<tr class="separator:gaa495d33626165d02e2bac6c66b7aecfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48230ff349d3d9df373d7cc4366ec62f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga48230ff349d3d9df373d7cc4366ec62f">DeclException0</a> (ExcInvalidFE)</td></tr>
<tr class="separator:ga48230ff349d3d9df373d7cc4366ec62f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25f9f7b18f75644cafa9126c29999c70"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga25f9f7b18f75644cafa9126c29999c70">DeclException0</a> (ExcFENotPrimitive)</td></tr>
<tr class="separator:ga25f9f7b18f75644cafa9126c29999c70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d6bdd9293a64902fb95d7a9f28cf7f6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga0d6bdd9293a64902fb95d7a9f28cf7f6">DeclException0</a> (ExcTriangulationMismatch)</td></tr>
<tr class="separator:ga0d6bdd9293a64902fb95d7a9f28cf7f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad88779c8e5f1d8d9a56dd28c5a97a792"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gad88779c8e5f1d8d9a56dd28c5a97a792">DeclException1</a> (ExcHangingNodesNotAllowed, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;You are using continuous elements on a grid with &quot;&lt;&lt; &quot;hanging nodes but without providing hanging node &quot;&lt;&lt; &quot;constraints. Use the respective function with &quot;&lt;&lt; &quot;additional <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> argument(s), instead.&quot;&lt;&lt; (arg1?&quot;&quot;:&quot;&quot;))</td></tr>
<tr class="separator:gad88779c8e5f1d8d9a56dd28c5a97a792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaaa41a1d8fbdb49d6b91e6d49c5d3b2e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaaaa41a1d8fbdb49d6b91e6d49c5d3b2e">DeclException0</a> (ExcGridNotRefinedAtLeastOnce)</td></tr>
<tr class="separator:gaaaa41a1d8fbdb49d6b91e6d49c5d3b2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7212ae8c27a23737206debe97f31387a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga7212ae8c27a23737206debe97f31387a">DeclException4</a> (ExcMatrixDimensionMismatch, <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;This is a &quot;&lt;&lt; arg1&lt;&lt; &quot;x&quot;&lt;&lt; arg2&lt;&lt; &quot; matrix, &quot;&lt;&lt; &quot;but should be a &quot;&lt;&lt; arg3&lt;&lt; &quot;x&quot;&lt;&lt; arg4&lt;&lt; &quot; matrix.&quot;)</td></tr>
<tr class="separator:ga7212ae8c27a23737206debe97f31387a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3477f9cc7014a27d957882c129bdfbab"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga3477f9cc7014a27d957882c129bdfbab">DeclException1</a> (ExcLeastSquaresError, <a class="el" href="classdouble.html">double</a>,&lt;&lt; &quot;Least squares fit leaves a gap of &quot;&lt;&lt; arg1)</td></tr>
<tr class="separator:ga3477f9cc7014a27d957882c129bdfbab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga528bcabaac09e43acd643fe8e9535233"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga528bcabaac09e43acd643fe8e9535233">DeclException2</a> (ExcNotGreaterThan, <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>,&lt;&lt; arg1&lt;&lt; &quot; must be greater than &quot;&lt;&lt; arg2)</td></tr>
<tr class="separator:ga528bcabaac09e43acd643fe8e9535233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Generation of local matrices</div></td></tr>
<tr class="memitem:ab1e885987df913c64885ece9034b5c44"><td class="memTemplParams" colspan="2">template&lt;int dim, typename number , int spacedim&gt; </td></tr>
<tr class="memitem:ab1e885987df913c64885ece9034b5c44"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#ab1e885987df913c64885ece9034b5c44">get_interpolation_matrix</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe1, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe2, <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;interpolation_matrix)</td></tr>
<tr class="separator:ab1e885987df913c64885ece9034b5c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a6ade80f618ca06382d4cdc04cc0940"><td class="memTemplParams" colspan="2">template&lt;int dim, typename number , int spacedim&gt; </td></tr>
<tr class="memitem:a3a6ade80f618ca06382d4cdc04cc0940"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#a3a6ade80f618ca06382d4cdc04cc0940">get_back_interpolation_matrix</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe1, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe2, <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;interpolation_matrix)</td></tr>
<tr class="separator:a3a6ade80f618ca06382d4cdc04cc0940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeebb94b65dba9e3790ea358afbc0d274"><td class="memTemplParams" colspan="2">template&lt;int dim, typename number , int spacedim&gt; </td></tr>
<tr class="memitem:aeebb94b65dba9e3790ea358afbc0d274"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#aeebb94b65dba9e3790ea358afbc0d274">get_interpolation_difference_matrix</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe1, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe2, <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;difference_matrix)</td></tr>
<tr class="separator:aeebb94b65dba9e3790ea358afbc0d274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a415b74d2b5da88cfc78d8ef00f0bbfab"><td class="memTemplParams" colspan="2">template&lt;int dim, typename number , int spacedim&gt; </td></tr>
<tr class="memitem:a415b74d2b5da88cfc78d8ef00f0bbfab"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#a415b74d2b5da88cfc78d8ef00f0bbfab">get_projection_matrix</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe1, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe2, <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;matrix)</td></tr>
<tr class="separator:a415b74d2b5da88cfc78d8ef00f0bbfab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0b7f5e7d5fd89b6cef5141dfbeac3e9"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ab0b7f5e7d5fd89b6cef5141dfbeac3e9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#ab0b7f5e7d5fd89b6cef5141dfbeac3e9">compute_node_matrix</a> (<a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;M, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe)</td></tr>
<tr class="separator:ab0b7f5e7d5fd89b6cef5141dfbeac3e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62bdda6b45855efb3480abd6d586f8b6"><td class="memTemplParams" colspan="2">template&lt;int dim, typename number , int spacedim&gt; </td></tr>
<tr class="memitem:a62bdda6b45855efb3480abd6d586f8b6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#a62bdda6b45855efb3480abd6d586f8b6">compute_embedding_matrices</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe, std::vector&lt; std::vector&lt; <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &gt; &gt; &amp;matrices, const <a class="el" href="classbool.html">bool</a> isotropic_only=false)</td></tr>
<tr class="separator:a62bdda6b45855efb3480abd6d586f8b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4ab9ff4946df4bb6a456659dfc281f3"><td class="memTemplParams" colspan="2">template&lt;int dim, typename number , int spacedim&gt; </td></tr>
<tr class="memitem:ae4ab9ff4946df4bb6a456659dfc281f3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#ae4ab9ff4946df4bb6a456659dfc281f3">compute_face_embedding_matrices</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe, <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;(&amp;matrices)[<a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::max_children_per_face], const unsigned <a class="el" href="classint.html">int</a> face_coarse, const unsigned <a class="el" href="classint.html">int</a> face_fine)</td></tr>
<tr class="separator:ae4ab9ff4946df4bb6a456659dfc281f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2d4cc00c2a413d837e33d65d4becc4a"><td class="memTemplParams" colspan="2">template&lt;int dim, typename number , int spacedim&gt; </td></tr>
<tr class="memitem:af2d4cc00c2a413d837e33d65d4becc4a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#af2d4cc00c2a413d837e33d65d4becc4a">compute_projection_matrices</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe, std::vector&lt; std::vector&lt; <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &gt; &gt; &amp;matrices, const <a class="el" href="classbool.html">bool</a> isotropic_only=false)</td></tr>
<tr class="separator:af2d4cc00c2a413d837e33d65d4becc4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1a0545c897ee022029f8c5f2c252735"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ab1a0545c897ee022029f8c5f2c252735"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#ab1a0545c897ee022029f8c5f2c252735">compute_projection_from_quadrature_points_matrix</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;lhs_quadrature, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;rhs_quadrature, <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;X)</td></tr>
<tr class="separator:ab1a0545c897ee022029f8c5f2c252735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a860d229b5510b389a562ed701ad83811"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a860d229b5510b389a562ed701ad83811"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#a860d229b5510b389a562ed701ad83811">compute_interpolation_to_quadrature_points_matrix</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;quadrature, <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;I_q)</td></tr>
<tr class="separator:a860d229b5510b389a562ed701ad83811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27c2ca67f06c280e784936238d60439b"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a27c2ca67f06c280e784936238d60439b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#a27c2ca67f06c280e784936238d60439b">compute_projection_from_quadrature_points</a> (const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;projection_matrix, const std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt; &gt; &amp;vector_of_tensors_at_qp, std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt; &gt; &amp;vector_of_tensors_at_nodes)</td></tr>
<tr class="separator:a27c2ca67f06c280e784936238d60439b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a193da89bd69465aec120b2a2f159533d"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a193da89bd69465aec120b2a2f159533d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#a193da89bd69465aec120b2a2f159533d">compute_projection_from_quadrature_points</a> (const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;projection_matrix, const std::vector&lt; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim &gt; &gt; &amp;vector_of_tensors_at_qp, std::vector&lt; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim &gt; &gt; &amp;vector_of_tensors_at_nodes)</td></tr>
<tr class="separator:a193da89bd69465aec120b2a2f159533d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bf0993a1b0c400670b079a8186b2360"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a8bf0993a1b0c400670b079a8186b2360"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#a8bf0993a1b0c400670b079a8186b2360">compute_projection_from_face_quadrature_points_matrix</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt; &amp;lhs_quadrature, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt; &amp;rhs_quadrature, const typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;::active_cell_iterator &amp;cell, const unsigned <a class="el" href="classint.html">int</a> face, <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;X)</td></tr>
<tr class="separator:a8bf0993a1b0c400670b079a8186b2360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Functions which should be in DoFTools</div></td></tr>
<tr class="memitem:a1743132fd4fdbf9113e95c5a30da7ebc"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, template&lt; int, int &gt; class DH1, template&lt; int, int &gt; class DH2, class InVector , class OutVector &gt; </td></tr>
<tr class="memitem:a1743132fd4fdbf9113e95c5a30da7ebc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#a1743132fd4fdbf9113e95c5a30da7ebc">interpolate</a> (const DH1&lt; dim, spacedim &gt; &amp;dof1, const InVector &amp;u1, const DH2&lt; dim, spacedim &gt; &amp;dof2, OutVector &amp;u2)</td></tr>
<tr class="separator:a1743132fd4fdbf9113e95c5a30da7ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c7e30b8e08fa84c0450a60c04c52464"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, template&lt; int, int &gt; class DH1, template&lt; int, int &gt; class DH2, class InVector , class OutVector &gt; </td></tr>
<tr class="memitem:a1c7e30b8e08fa84c0450a60c04c52464"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#a1c7e30b8e08fa84c0450a60c04c52464">interpolate</a> (const DH1&lt; dim, spacedim &gt; &amp;dof1, const InVector &amp;u1, const DH2&lt; dim, spacedim &gt; &amp;dof2, const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints, OutVector &amp;u2)</td></tr>
<tr class="separator:a1c7e30b8e08fa84c0450a60c04c52464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0a0a52af833b660bc126260df08d3df"><td class="memTemplParams" colspan="2">template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </td></tr>
<tr class="memitem:af0a0a52af833b660bc126260df08d3df"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#af0a0a52af833b660bc126260df08d3df">back_interpolate</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof1, const InVector &amp;u1, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe2, OutVector &amp;u1_interpolated)</td></tr>
<tr class="separator:af0a0a52af833b660bc126260df08d3df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7f4de621c3e8e6d540e1e1c46a855d0"><td class="memTemplParams" colspan="2">template&lt;int dim, template&lt; int &gt; class DH, class InVector , class OutVector , int spacedim&gt; </td></tr>
<tr class="memitem:af7f4de621c3e8e6d540e1e1c46a855d0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#af7f4de621c3e8e6d540e1e1c46a855d0">back_interpolate</a> (const DH&lt; dim &gt; &amp;dof1, const InVector &amp;u1, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe2, OutVector &amp;u1_interpolated)</td></tr>
<tr class="separator:af7f4de621c3e8e6d540e1e1c46a855d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab27f4acb5bb40f3486af5341ee3f98b"><td class="memTemplParams" colspan="2">template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </td></tr>
<tr class="memitem:aab27f4acb5bb40f3486af5341ee3f98b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#aab27f4acb5bb40f3486af5341ee3f98b">back_interpolate</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof1, const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints1, const InVector &amp;u1, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof2, const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints2, OutVector &amp;u1_interpolated)</td></tr>
<tr class="separator:aab27f4acb5bb40f3486af5341ee3f98b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f2e45e9f0117e1ae3ca704885c96ebc"><td class="memTemplParams" colspan="2">template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </td></tr>
<tr class="memitem:a0f2e45e9f0117e1ae3ca704885c96ebc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#a0f2e45e9f0117e1ae3ca704885c96ebc">interpolation_difference</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof1, const InVector &amp;z1, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe2, OutVector &amp;z1_difference)</td></tr>
<tr class="separator:a0f2e45e9f0117e1ae3ca704885c96ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eca657cb613f5ae67bb94be051b58d4"><td class="memTemplParams" colspan="2">template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </td></tr>
<tr class="memitem:a4eca657cb613f5ae67bb94be051b58d4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#a4eca657cb613f5ae67bb94be051b58d4">interpolation_difference</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof1, const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints1, const InVector &amp;z1, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof2, const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints2, OutVector &amp;z1_difference)</td></tr>
<tr class="separator:a4eca657cb613f5ae67bb94be051b58d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a3ad6cbc7cef0f14e60f3ae5a3a5115"><td class="memTemplParams" colspan="2">template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </td></tr>
<tr class="memitem:a2a3ad6cbc7cef0f14e60f3ae5a3a5115"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#a2a3ad6cbc7cef0f14e60f3ae5a3a5115">project_dg</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof1, const InVector &amp;u1, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof2, OutVector &amp;u2)</td></tr>
<tr class="separator:a2a3ad6cbc7cef0f14e60f3ae5a3a5115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2c5f72f3b99909fdf7d7bb215792400"><td class="memTemplParams" colspan="2">template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </td></tr>
<tr class="memitem:ab2c5f72f3b99909fdf7d7bb215792400"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#ab2c5f72f3b99909fdf7d7bb215792400">extrapolate</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof1, const InVector &amp;z1, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof2, OutVector &amp;z2)</td></tr>
<tr class="separator:ab2c5f72f3b99909fdf7d7bb215792400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eb266657f56c7504ab3e23e87188a2f"><td class="memTemplParams" colspan="2">template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </td></tr>
<tr class="memitem:a5eb266657f56c7504ab3e23e87188a2f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#a5eb266657f56c7504ab3e23e87188a2f">extrapolate</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof1, const InVector &amp;z1, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof2, const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints, OutVector &amp;z2)</td></tr>
<tr class="separator:a5eb266657f56c7504ab3e23e87188a2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This namespace offers interpolations and extrapolations of discrete functions of one <code><a class="el" href="classFiniteElement.html">FiniteElement</a></code> <code>fe1</code> to another <code><a class="el" href="classFiniteElement.html">FiniteElement</a></code> <code>fe2</code>.</p>
<p>It also provides the local interpolation matrices that interpolate on each cell. Furthermore it provides the difference matrix <img class="formulaInl" alt="$id-I_h$" src="form_214.png"/> that is needed for evaluating <img class="formulaInl" alt="$(id-I_h)z$" src="form_215.png"/> for e.g. the dual solution <img class="formulaInl" alt="$z$" src="form_11.png"/>.</p>
<p>For more information about the <code>spacedim</code> template parameter check the documentation of <a class="el" href="classFiniteElement.html">FiniteElement</a> or the one of <a class="el" href="classTriangulation.html">Triangulation</a>.</p>
<dl class="section author"><dt>Author</dt><dd>Wolfgang Bangerth, Ralf Hartmann, Guido Kanschat; 2000, 2003, 2004, 2005, 2006 </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a4945a239d321d126dfccce60a73a4e67"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::compute_component_wise </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>renumbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>start_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd>In most cases, you will probably want to use compute_base_renumbering().</dd></dl>
<p>Compute the vector required to renumber the dofs of a cell by component. Furthermore, compute the vector storing the start indices of each component in the local block vector.</p>
<p>The second vector is organized such that there is a vector for each base element containing the start index for each component served by this base element.</p>
<p>While the first vector is checked to have the correct size, the second one is reinitialized for convenience. </p>

</div>
</div>
<a class="anchor" id="ad7f8f27696c0adadc316996b7281f096"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::compute_block_renumbering </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>renumbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>block_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>return_start_indices</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the vector required to renumber the dofs of a cell by block. Furthermore, compute the vector storing either the start indices or the size of each local block vector.</p>
<p>If the <code>bool</code> parameter is true, <code>block_data</code> is filled with the start indices of each local block. If it is false, then the block sizes are returned.</p>
<p>The vector <code>renumbering</code> will be indexed by the standard numbering of local degrees of freedom, namely first first vertex, then second vertex, after vertices lines, quads, and hexes. For each index, the entry indicates the index which this degree of freedom receives in a numbering scheme, where the first block is numbered completely before the second. </p>

</div>
</div>
<a class="anchor" id="ab1e885987df913c64885ece9034b5c44"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename number , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::get_interpolation_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>interpolation_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gives the interpolation matrix that interpolates a <code>fe1-</code> function to a <code>fe2-function</code> on each cell. The interpolation_matrix needs to be of size <code>(fe2.dofs_per_cell, fe1.dofs_per_cell)</code>.</p>
<p>Note, that if the finite element space <code>fe1</code> is a subset of the finite element space <code>fe2</code> then the <code>interpolation_matrix</code> is an embedding matrix. </p>

</div>
</div>
<a class="anchor" id="a3a6ade80f618ca06382d4cdc04cc0940"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename number , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::get_back_interpolation_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>interpolation_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gives the interpolation matrix that interpolates a <code>fe1-</code> function to a <code>fe2-function</code>, and interpolates this to a second <code>fe1-function</code> on each cell. The interpolation_matrix needs to be of size <code>(fe1.dofs_per_cell, fe1.dofs_per_cell)</code>.</p>
<p>Note, that this function only makes sense if the finite element space due to <code>fe1</code> is not a subset of the finite element space due to <code>fe2</code>, as if it were a subset then the <code>interpolation_matrix</code> would be only the unit matrix. </p>

</div>
</div>
<a class="anchor" id="aeebb94b65dba9e3790ea358afbc0d274"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename number , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::get_interpolation_difference_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>difference_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gives the unit matrix minus the back interpolation matrix. The <code>difference_matrix</code> needs to be of size <code>(fe1.dofs_per_cell, fe1.dofs_per_cell)</code>.</p>
<p>This function gives the matrix that transforms a <code>fe1</code> function <img class="formulaInl" alt="$z$" src="form_11.png"/> to <img class="formulaInl" alt="$z-I_hz$" src="form_216.png"/> where <img class="formulaInl" alt="$I_h$" src="form_217.png"/> denotes the interpolation operator from the <code>fe1</code> space to the <code>fe2</code> space. This matrix hence is useful to evaluate error-representations where <img class="formulaInl" alt="$z$" src="form_11.png"/> denotes the dual solution. </p>

</div>
</div>
<a class="anchor" id="a415b74d2b5da88cfc78d8ef00f0bbfab"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename number , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::get_projection_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the local <img class="formulaInl" alt="$L^2$" src="form_218.png"/>-projection matrix from fe1 to fe2. </p>

</div>
</div>
<a class="anchor" id="ab0b7f5e7d5fd89b6cef5141dfbeac3e9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::compute_node_matrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the matrix of nodal values of a finite element applied to all its shape functions.</p>
<p>This function is supposed to help building finite elements from polynomial spaces and should be called inside the constructor of an element. Applied to a completely initialized finite element, the result should be the unit matrix by definition of the node values.</p>
<p>Using this matrix allows the construction of the basis of shape functions in two steps.</p>
<ol>
<li>
<p class="startli">Define the space of shape functions using an arbitrary basis <em>w<sub>j</sub></em> and compute the matrix <em>M</em> of node functionals <em>N<sub>i</sub></em> applied to these basis functions.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Compute the basis <em>v<sub>j</sub></em> of the finite element shape function space by applying <em>M<sup>-1</sup></em> to the basis <em>w<sub>j</sub></em>.</p>
<p class="endli"></p>
</li>
</ol>
<dl class="section note"><dt>Note</dt><dd>The <a class="el" href="classFiniteElement.html">FiniteElement</a> must provide generalized support points and and interpolation functions. </dd></dl>

</div>
</div>
<a class="anchor" id="a62bdda6b45855efb3480abd6d586f8b6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename number , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::compute_embedding_matrices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>isotropic_only</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For all possible (isotropic and anisotropic) refinement cases compute the embedding matrices from a coarse cell to the child cells. Each column of the resulting matrices contains the representation of a coarse grid basis function by the fine grid basis; the matrices are split such that there is one matrix for every child.</p>
<p>This function computes the coarse grid function in a sufficiently large number of quadrature points and fits the fine grid functions using least squares approximation. Therefore, the use of this function is restricted to the case that the finite element spaces are actually nested.</p>
<p>Note, that <code>matrices[refinement_case-1][child]</code> includes the embedding (or prolongation) matrix of child <code>child</code> for the <a class="el" href="classRefinementCase.html">RefinementCase</a> <code>refinement_case</code>. Here, we use <code>refinement_case-1</code> instead of <code>refinement_case</code> as for RefinementCase::no_refinement(=0) there are no prolongation matrices available.</p>
<p>Typically this function is called by the various implementations of <a class="el" href="classFiniteElement.html">FiniteElement</a> classes in order to fill the respective <a class="el" href="classFiniteElement.html#afbc42f850096c429fd39cfcbde1b6b56">FiniteElement::prolongation</a> matrices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fe</td><td>The finite element class for which we compute the embedding matrices.</td></tr>
    <tr><td class="paramname">matrices</td><td>A reference to RefinementCase&lt;dim&gt;::isotropic_refinement vectors of <a class="el" href="classFullMatrix.html">FullMatrix</a> objects. Each vector corresponds to one <a class="el" href="classRefinementCase.html">RefinementCase</a> <code>refinement_case</code> and is of the vector size GeometryInfo&lt;dim&gt;::n_children(refinement_case). This is the format used in <a class="el" href="classFiniteElement.html">FiniteElement</a>, where we want to use this function mostly.</td></tr>
    <tr><td class="paramname">isotropic_only</td><td>Set to <code>true</code> if you only want to compute matrices for isotropic refinement. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae4ab9ff4946df4bb6a456659dfc281f3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename number , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::compute_face_embedding_matrices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;(&amp;)&#160;</td>
          <td class="paramname"><em>matrices</em>[GeometryInfo&lt; dim &gt;::max_children_per_face], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_coarse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_fine</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the embedding matrices on faces needed for constraint matrices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fe</td><td>The finite element for which to compute these matrices. </td></tr>
    <tr><td class="paramname">matrices</td><td>An array of <em>GeometryInfo&lt;dim&gt;::subfaces_per_face = 2<sup>dim-1</sup></em> <a class="el" href="classFullMatrix.html">FullMatrix</a> objects,holding the embedding matrix for each subface. </td></tr>
    <tr><td class="paramname">face_coarse</td><td>The number of the face on the coarse side of the face for which this is computed. </td></tr>
    <tr><td class="paramname">face_fine</td><td>The number of the face on the refined side of the face for which this is computed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This function will be used in computing constraint matrices. It is not sufficiently tested yet. </dd></dl>

</div>
</div>
<a class="anchor" id="af2d4cc00c2a413d837e33d65d4becc4a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename number , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::compute_projection_matrices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>isotropic_only</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For all possible (isotropic and anisotropic) refinement cases compute the <em>L<sup>2</sup></em>-projection matrices from the children to a coarse cell.</p>
<p>Note, that <code>matrices[refinement_case-1][child]</code> includes the projection (or restriction) matrix of child <code>child</code> for the <a class="el" href="classRefinementCase.html">RefinementCase</a> <code>refinement_case</code>. Here, we use <code>refinement_case-1</code> instead of <code>refinement_case</code> as for RefinementCase::no_refinement(=0) there are no projection matrices available.</p>
<p>Typically this function is called by the various implementations of <a class="el" href="classFiniteElement.html">FiniteElement</a> classes in order to fill the respective <a class="el" href="classFiniteElement.html#a4993707a4ec342560ff74e5d22401794">FiniteElement::restriction</a> matrices.</p>
<ul>
<li>fe The finite element class for which we compute the projection matrices. </li>
<li>matrices A reference to <code>RefinementCase&lt;dim&gt;::isotropic_refinement</code> vectors of <a class="el" href="classFullMatrix.html">FullMatrix</a> objects. Each vector corresponds to one <a class="el" href="classRefinementCase.html">RefinementCase</a> <code>refinement_case</code> and is of the vector size <code>GeometryInfo&lt;dim&gt;::n_children(refinement_case)</code>. This is the format used in <a class="el" href="classFiniteElement.html">FiniteElement</a>, where we want to use this function mostly.</li>
</ul>
<ul>
<li>isotropic_only Set to <code>true</code> if you only want to compute matrices for isotropic refinement. </li>
</ul>

</div>
</div>
<a class="anchor" id="ab1a0545c897ee022029f8c5f2c252735"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::compute_projection_from_quadrature_points_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs_quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs_quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Projects scalar data defined in quadrature points to a finite element space on a single cell.</p>
<p>What this function does is the following: assume that there is scalar data <code>u<sub>q</sub>, 0 &lt;= q &lt; Q:=quadrature.size()</code> defined at the quadrature points of a cell, with the points defined by the given <code>rhs_quadrature</code> object. We may then want to ask for that finite element function (on a single cell) <code>v<sub>h</sub></code> in the finite-dimensional space defined by the given FE object that is the projection of <code>u</code> in the following sense:</p>
<p>Usually, the projection <code>v<sub>h</sub></code> is that function that satisfies <code>(v<sub>h</sub>,w)=(u,w)</code> for all discrete test functions <code>w</code>. In the present case, we can't evaluate the right hand side, since <code>u</code> is only defined in the quadrature points given by <code>rhs_quadrature</code>, so we replace it by a quadrature approximation. Likewise, the left hand side is approximated using the <code>lhs_quadrature</code> object; if this quadrature object is chosen appropriately, then the integration of the left hand side can be done exactly, without any approximation. The use of different quadrature objects is necessary if the quadrature object for the right hand side has too few quadrature points &ndash; for example, if data <code>q</code> is only defined at the cell center, then the corresponding one-point quadrature formula is obviously insufficient to approximate the scalar product on the left hand side by a definite form.</p>
<p>After these quadrature approximations, we end up with a nodal representation <code>V<sub>h</sub></code> of <code>v<sub>h</sub></code> that satisfies the following system of linear equations: <code>M V<sub>h</sub> = Q U</code>, where <code>M<sub>ij</sub>=(phi_i,phi_j)</code> is the mass matrix approximated by <code>lhs_quadrature</code>, and <code>Q</code> is the matrix <code>Q<sub>iq</sub>=phi<sub>i</sub>(x<sub>q</sub>) w<sub>q</sub></code> where <code>w<sub>q</sub></code> are quadrature weights; <code>U</code> is the vector of quadrature point data <code>u<sub>q</sub></code>.</p>
<p>In order to then get the nodal representation <code>V<sub>h</sub></code> of the projection of <code>U</code>, one computes <code>V<sub>h</sub> = X U, X=M<sup>-1</sup> Q</code>. The purpose of this function is to compute the matrix <code>X</code> and return it through the last argument of this function.</p>
<p>Note that this function presently only supports scalar data. An extension of the mass matrix is of course trivial, but one has to define the order of data in the vector <code>U</code> if it contains vector valued data in all quadrature points.</p>
<p>A use for this function is described in the introduction to the <a class="el" href="step_18.html">step-18</a> example program.</p>
<p>The opposite of this function, interpolation of a finite element function onto quadrature points is essentially what the <code><a class="el" href="classFEValuesBase.html#a884144525a19d80f4e20b4e509c9132b">FEValues::get_function_values</a></code> functions do; to make things a little simpler, the <code><a class="el" href="namespaceFETools.html#a860d229b5510b389a562ed701ad83811">FETools::compute_interpolation_to_quadrature_points_matrix</a></code> provides the matrix form of this.</p>
<p>Note that this function works on a single cell, rather than an entire triangulation. In effect, it therefore doesn't matter if you use a continuous or discontinuous version of the finite element.</p>
<p>It is worth noting that there are a few confusing cases of this function. The first one is that it really only makes sense to project onto a finite element that has at most as many degrees of freedom per cell as there are quadrature points; the projection of N quadrature point data into a space with M&gt;N unknowns is well-defined, but often yields funny and non-intuitive results. Secondly, one would think that if the quadrature point data is defined in the support points of the finite element, i.e. the quadrature points of <code>ths_quadrature</code> equal <code>fe.get_unit_support_points()</code>, then the projection should be the identity, i.e. each degree of freedom of the finite element equals the value of the given data in the support point of the corresponding shape function. However, this is not generally the case: while the matrix <code>Q</code> in that case is the identity matrix, the mass matrix <code>M</code> is not equal to the identity matrix, except for the special case that the quadrature formula <code>lhs_quadrature</code> also has its quadrature points in the support points of the finite element.</p>
<p>Finally, this function only defines a cell wise projection, while one frequently wants to apply it to all cells in a triangulation. However, if it is applied to one cell after the other, the results from later cells may overwrite nodal values computed already from previous cells if degrees of freedom live on the interfaces between cells. The function is therefore most useful for discontinuous elements. </p>

</div>
</div>
<a class="anchor" id="a860d229b5510b389a562ed701ad83811"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::compute_interpolation_to_quadrature_points_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>I_q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a (scalar) local finite element function, compute the matrix that maps the vector of nodal values onto the vector of values of this function at quadrature points as given by the second argument. In a sense, this function does the opposite of the <a class="el" href="namespaceFETools.html#ab1a0545c897ee022029f8c5f2c252735">FETools::compute_projection_from_quadrature_points_matrix</a> function. </p>

</div>
</div>
<a class="anchor" id="a27c2ca67f06c280e784936238d60439b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::compute_projection_from_quadrature_points </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>projection_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_of_tensors_at_qp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_of_tensors_at_nodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the projection of tensorial (first-order tensor) data stored at the quadrature points <code>vector_of_tensors_at_qp</code> to data <code>vector_of_tensors_at_nodes</code> at the support points of the cell. The data in <code>vector_of_tensors_at_qp</code> is ordered sequentially following the quadrature point numbering. The size of <code>vector_of_tensors_at_qp</code> must correspond to the number of columns of <code>projection_matrix</code>. The size of <code>vector_of_tensors_at_nodes</code> must correspond to the number of rows of <code>vector_of_tensors_at_nodes</code> . The projection matrix <code>projection_matrix</code> desribes the projection of scalar data from the quadrature points and can be obtained from the <a class="el" href="namespaceFETools.html#ab1a0545c897ee022029f8c5f2c252735">FETools::compute_projection_from_quadrature_points_matrix</a> function. </p>

</div>
</div>
<a class="anchor" id="a193da89bd69465aec120b2a2f159533d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::compute_projection_from_quadrature_points </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>projection_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_of_tensors_at_qp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_of_tensors_at_nodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>same as last function but for a <code><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a></code> . </p>

</div>
</div>
<a class="anchor" id="a8bf0993a1b0c400670b079a8186b2360"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::compute_projection_from_face_quadrature_points_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs_quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs_quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;::active_cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method implements the <a class="el" href="namespaceFETools.html#ab1a0545c897ee022029f8c5f2c252735">FETools::compute_projection_from_quadrature_points_matrix</a> method for faces of a mesh. The matrix that it returns, X, is face specific and its size is fe.dofs_per_cell by rhs_quadrature.size(). The dimension, dim must be larger than 1 for this class, since <a class="el" href="classQuadrature.html">Quadrature</a>&lt;dim-1&gt; objects are required. See the documentation on the <a class="el" href="classQuadrature.html">Quadrature</a> class for more information. </p>

</div>
</div>
<a class="anchor" id="a1743132fd4fdbf9113e95c5a30da7ebc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, template&lt; int, int &gt; class DH1, template&lt; int, int &gt; class DH2, class InVector , class OutVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::interpolate </td>
          <td>(</td>
          <td class="paramtype">const DH1&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>u1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DH2&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>u2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gives the interpolation of a the <code>dof1-function</code> <code>u1</code> to a <code>dof2-function</code> <code>u2</code>. <code>dof1</code> and <code>dof2</code> need to be DoFHandlers based on the same triangulation.</p>
<p>If the elements <code>fe1</code> and <code>fe2</code> are either both continuous or both discontinuous then this interpolation is the usual point interpolation. The same is true if <code>fe1</code> is a continuous and <code>fe2</code> is a discontinuous finite element. For the case that <code>fe1</code> is a discontinuous and <code>fe2</code> is a continuous finite element there is no point interpolation defined at the discontinuities. Therefore the meanvalue is taken at the DoF values on the discontinuities.</p>
<p>Note that for continuous elements on grids with hanging nodes (i.e. locally refined grids) this function does not give the expected output. Indeed, the resulting output vector does not necessarily respect continuity requirements at hanging nodes: if, for example, you are interpolating a Q2 field to a Q1 field, then at hanging nodes the output field will have the function value of the input field, which however is not usually the mean value of the two adjacent nodes. It is thus not part of the Q1 function space on the whole triangulation, although it is of course Q1 on each cell.</p>
<p>For this case (continuous elements on grids with hanging nodes), please use the <code><a class="el" href="namespaceFETools.html#a1743132fd4fdbf9113e95c5a30da7ebc">interpolate()</a></code> function with an additional <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> argument, see below, or make the field conforming yourself by calling the <code>distribute</code> function of your hanging node constraints object. </p>

</div>
</div>
<a class="anchor" id="a1c7e30b8e08fa84c0450a60c04c52464"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, template&lt; int, int &gt; class DH1, template&lt; int, int &gt; class DH2, class InVector , class OutVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::interpolate </td>
          <td>(</td>
          <td class="paramtype">const DH1&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>u1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DH2&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>u2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gives the interpolation of a the <code>dof1-function</code> <code>u1</code> to a <code>dof2-function</code> <code>u2</code>. <code>dof1</code> and <code>dof2</code> need to be DoFHandlers (or hp::DoFHandlers) based on the same triangulation. <code>constraints</code> is a hanging node constraints object corresponding to <code>dof2</code>. This object is particular important when interpolating onto continuous elements on grids with hanging nodes (locally refined grids).</p>
<p>If the elements <code>fe1</code> and <code>fe2</code> are either both continuous or both discontinuous then this interpolation is the usual point interpolation. The same is true if <code>fe1</code> is a continuous and <code>fe2</code> is a discontinuous finite element. For the case that <code>fe1</code> is a discontinuous and <code>fe2</code> is a continuous finite element there is no point interpolation defined at the discontinuities. Therefore the mean value is taken at the DoF values at the discontinuities. </p>

</div>
</div>
<a class="anchor" id="af0a0a52af833b660bc126260df08d3df"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::back_interpolate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>u1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>u1_interpolated</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gives the interpolation of the <code>fe1-function</code> <code>u1</code> to a <code>fe2-function</code>, and interpolates this to a second <code>fe1-function</code> named <code>u1_interpolated</code>.</p>
<p>Note, that this function does not work on continuous elements at hanging nodes. For that case use the <code>back_interpolate</code> function, below, that takes an additional <code><a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a></code> object.</p>
<p>Furthermore note, that for the specific case when the finite element space corresponding to <code>fe1</code> is a subset of the finite element space corresponding to <code>fe2</code>, this function is simply an identity mapping. </p>

</div>
</div>
<a class="anchor" id="af7f4de621c3e8e6d540e1e1c46a855d0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, template&lt; int &gt; class DH, class InVector , class OutVector , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::back_interpolate </td>
          <td>(</td>
          <td class="paramtype">const DH&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>u1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>u1_interpolated</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as last function, except that the dof handler objects might be of type <code><a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a></code>. </p>

</div>
</div>
<a class="anchor" id="aab27f4acb5bb40f3486af5341ee3f98b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::back_interpolate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>u1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>u1_interpolated</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gives the interpolation of the <code>dof1-function</code> <code>u1</code> to a <code>dof2-function</code>, and interpolates this to a second <code>dof1-function</code> named <code>u1_interpolated</code>. <code>constraints1</code> and <code>constraints2</code> are the hanging node constraints corresponding to <code>dof1</code> and <code>dof2</code>, respectively. These objects are particular important when continuous elements on grids with hanging nodes (locally refined grids) are involved.</p>
<p>Furthermore note, that for the specific case when the finite element space corresponding to <code>dof1</code> is a subset of the finite element space corresponding to <code>dof2</code>, this function is simply an identity mapping. </p>

</div>
</div>
<a class="anchor" id="a0f2e45e9f0117e1ae3ca704885c96ebc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::interpolation_difference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>z1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>z1_difference</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gives <img class="formulaInl" alt="$(Id-I_h)z_1$" src="form_219.png"/> for a given <code>dof1-function</code> <img class="formulaInl" alt="$z_1$" src="form_220.png"/>, where <img class="formulaInl" alt="$I_h$" src="form_217.png"/> is the interpolation from <code>fe1</code> to <code>fe2</code>. The result <img class="formulaInl" alt="$(Id-I_h)z_1$" src="form_219.png"/> is written into <code>z1_difference</code>.</p>
<p>Note, that this function does not work for continuous elements at hanging nodes. For that case use the <code>interpolation_difference</code> function, below, that takes an additional <code><a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a></code> object. </p>

</div>
</div>
<a class="anchor" id="a4eca657cb613f5ae67bb94be051b58d4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::interpolation_difference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>z1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>z1_difference</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gives <img class="formulaInl" alt="$(Id-I_h)z_1$" src="form_219.png"/> for a given <code>dof1-function</code> <img class="formulaInl" alt="$z_1$" src="form_220.png"/>, where <img class="formulaInl" alt="$I_h$" src="form_217.png"/> is the interpolation from <code>fe1</code> to <code>fe2</code>. The result <img class="formulaInl" alt="$(Id-I_h)z_1$" src="form_219.png"/> is written into <code>z1_difference</code>. <code>constraints1</code> and <code>constraints2</code> are the hanging node constraints corresponding to <code>dof1</code> and <code>dof2</code>, respectively. These objects are particular important when continuous elements on grids with hanging nodes (locally refined grids) are involved.</p>
<p>For parallel computations with PETSc, supply <code>z1</code> with ghost elements and <code>z1_difference</code> without ghost elements. </p>

</div>
</div>
<a class="anchor" id="a2a3ad6cbc7cef0f14e60f3ae5a3a5115"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::project_dg </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>u1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>u2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><img class="formulaInl" alt="$L^2$" src="form_218.png"/> projection for discontinuous elements. Operates the same direction as interpolate.</p>
<p>The global projection can be computed by local matrices if the finite element spaces are discontinuous. With continuous elements, this is impossible, since a global mass matrix must be inverted. </p>

</div>
</div>
<a class="anchor" id="ab2c5f72f3b99909fdf7d7bb215792400"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::extrapolate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>z1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>z2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gives the patchwise extrapolation of a <code>dof1</code> function <code>z1</code> to a <code>dof2</code> function <code>z2</code>. <code>dof1</code> and <code>dof2</code> need to be <a class="el" href="classDoFHandler.html">DoFHandler</a> based on the same triangulation.</p>
<p>This function is interesting for e.g. extrapolating patchwise a piecewise linear solution to a piecewise quadratic solution.</p>
<p>Note that the resulting field does not satisfy continuity requirements of the given finite elements.</p>
<p>When you use continuous elements on grids with hanging nodes, please use the <code>extrapolate</code> function with an additional <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> argument, see below.</p>
<p>Since this function operates on patches of cells, it is required that the underlying grid is refined at least once for every coarse grid cell. If this is not the case, an exception will be raised. </p>

</div>
</div>
<a class="anchor" id="a5eb266657f56c7504ab3e23e87188a2f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::extrapolate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>z1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>z2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gives the patchwise extrapolation of a <code>dof1</code> function <code>z1</code> to a <code>dof2</code> function <code>z2</code>. <code>dof1</code> and <code>dof2</code> need to be <a class="el" href="classDoFHandler.html">DoFHandler</a> based on the same triangulation. <code>constraints</code> is a hanging node constraints object corresponding to <code>dof2</code>. This object is particular important when interpolating onto continuous elements on grids with hanging nodes (locally refined grids).</p>
<p>Otherwise, the same holds as for the other <code>extrapolate</code> function. </p>

</div>
</div>
<a class="anchor" id="a188d7528e6dbfa5fd5f567670b3b5fe9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::hierarchic_to_lexicographic_numbering </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>h2l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The numbering of the degrees of freedom in continuous finite elements is hierarchic, i.e. in such a way that we first number the vertex dofs, in the order of the vertices as defined by the triangulation, then the line dofs in the order and respecting the direction of the lines, then the dofs on quads, etc. However, we could have, as well, numbered them in a lexicographic way, i.e. with indices first running in x-direction, then in y-direction and finally in z-direction. Discontinuous elements of class <a class="el" href="classFE__DGQ.html">FE_DGQ()</a> are numbered in this way, for example.</p>
<p>This function constructs a table which lexicographic index each degree of freedom in the hierarchic numbering would have. It operates on the continuous finite element given as first argument, and outputs the lexicographic indices in the second.</p>
<p>Note that since this function uses specifics of the continuous finite elements, it can only operate on FiniteElementData&lt;dim&gt; objects inherent in <a class="el" href="classFE__Q.html">FE_Q()</a>. However, this function does not take a <a class="el" href="classFE__Q.html">FE_Q</a> object as it is also invoked by the <a class="el" href="classFE__Q.html">FE_Q()</a> constructor.</p>
<p>It is assumed that the size of the output argument already matches the correct size, which is equal to the number of degrees of freedom in the finite element. </p>

</div>
</div>
<a class="anchor" id="a4aba07d10b2579f7259d37adb84f8808"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;unsigned <a class="el" href="classint.html">int</a>&gt; FETools::hierarchic_to_lexicographic_numbering </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like the previous function but instead of returning its result through the last argument return it as a value. </p>

</div>
</div>
<a class="anchor" id="a1db6ab2ac1c2318f07fc020756cf76b9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::lexicographic_to_hierarchic_numbering </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>l2h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is the reverse function to the above one, generating the map from the lexicographic to the hierarchical numbering. All the remarks made about the above function are also valid here. </p>

</div>
</div>
<a class="anchor" id="a41a15f1b5d3806344f355ef07960e9ce"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;unsigned <a class="el" href="classint.html">int</a>&gt; FETools::lexicographic_to_hierarchic_numbering </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like the previous function but instead of returning its result through the last argument return it as a value. </p>

</div>
</div>
<a class="anchor" id="a5b33ff9d615cd6dacdd585dcadb10dd8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFiniteElement.html">FiniteElement</a>&lt;dim, dim&gt;* FETools::get_fe_from_name </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parse the name of a finite element and generate a finite element object accordingly.</p>
<p>The name must be in the form which is returned by the <a class="el" href="classFiniteElement.html#a09655d1d2555af8dcd48caebd4039d29">FiniteElement::get_name</a> function, where a few modifications are allowed:</p>
<ul>
<li>
<p class="startli">Dimension template parameters &lt;2&gt; etc. can be omitted. Alternatively, the explicit number can be replaced by <code>dim</code> or <code>d</code>. If a number is given, it <b>must</b> match the template parameter of this function.</p>
<p class="endli"></p>
</li>
<li>
The powers used for <a class="el" href="classFESystem.html">FESystem</a> may either be numbers or can be replaced by <code>dim</code> or <code>d</code>. </li>
</ul>
<p>If no finite element can be reconstructed from this string, an exception of type <code>FETools::ExcInvalidFEName</code> is thrown.</p>
<p>The function returns a pointer to a newly create finite element. It is in the caller's responsibility to destroy the object pointed to at an appropriate later time.</p>
<p>Since the value of the template argument can't be deduced from the (string) argument given to this function, you have to explicitly specify it when you call this function.</p>
<p>This function knows about all the standard elements defined in the library. However, it doesn't by default know about elements that you may have defined in your program. To make your own elements known to this function, use the <a class="el" href="namespaceFETools.html#a5a006641198ca5641c5c8ae20b741b4b">add_fe_name()</a> function. This function does not work if one wants to get a codimension 1 finite element. </p>

</div>
</div>
<a class="anchor" id="a5a006641198ca5641c5c8ae20b741b4b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::add_fe_name </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FEFactoryBase&lt; dim, spacedim &gt; *&#160;</td>
          <td class="paramname"><em>factory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extend the list of finite elements that can be generated by <a class="el" href="namespaceFETools.html#a5b33ff9d615cd6dacdd585dcadb10dd8">get_fe_from_name()</a> by the one given as <code>name</code>. If <a class="el" href="namespaceFETools.html#a5b33ff9d615cd6dacdd585dcadb10dd8">get_fe_from_name()</a> is later called with this name, it will use the object given as second argument to create a finite element object.</p>
<p>The format of the <code>name</code> parameter should include the name of a finite element. However, it is safe to use either the class name alone or to use the result of <a class="el" href="classFiniteElement.html#a09655d1d2555af8dcd48caebd4039d29">FiniteElement::get_name</a> (which includes the space dimension as well as the polynomial degree), since everything after the first non-name character will be ignored.</p>
<p>The <a class="el" href="classFETools_1_1FEFactory.html">FEFactory</a> object should be an object newly created with <code>new</code>. <a class="el" href="namespaceFETools.html">FETools</a> will take ownership of this object and delete it once it is not used anymore.</p>
<p>In most cases, if you want objects of type <code>MyFE</code> be created whenever the name <code>my_fe</code> is given to get_fe_from_name, you will want the second argument to this function be of type <a class="el" href="classFETools_1_1FEFactory.html">FEFactory</a>&lt;MyFE&gt;, but you can of course create your custom finite element factory class.</p>
<p>This function takes over ownership of the object given as second argument, i.e. you should never attempt to destroy it later on. The object will be deleted at the end of the program's lifetime.</p>
<p>If the name of the element is already in use, an exception is thrown. Thus, functionality of <a class="el" href="namespaceFETools.html#a5b33ff9d615cd6dacdd585dcadb10dd8">get_fe_from_name()</a> can only be added, not changed.</p>
<dl class="section note"><dt>Note</dt><dd>This function manipulates a global table (one table for each space dimension). It is thread safe in the sense that every access to this table is secured by a lock. Nevertheless, since each name can be added only once, user code has to make sure that only one thread adds a new element.</dd></dl>
<p>Note also that this table exists once for each space dimension. If you have a program that works with finite elements in different space dimensions (for example, <a class="el" href="step_4.html">step-4</a> does something like this), then you should call this function for each space dimension for which you want your finite element added to the map. </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jan 27 2014 15:27:23 for The deal.II Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
