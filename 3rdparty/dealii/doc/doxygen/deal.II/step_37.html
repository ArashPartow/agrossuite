<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>The deal.II Library: The step-37 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="http://www.dealii.org/deal.ico"></link>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2014 by the deal.II authors"></meta>
<meta name="deal.II-version" content="8.1.0"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 8.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The step-37 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Thetestcase">The test case</a>
        <li><a href="#Matrixvectorproductimplementation">Matrix-vector product implementation</a>
        <li><a href="#Combinationwithmultigrid">Combination with multigrid</a>
        <li><a href="#UsingCPUdependentinstructionsvectorization">Using CPU-dependent instructions (vectorization)</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Equationdata">Equation data</a>
        <li><a href="#Matrixfreeimplementation">Matrix-free implementation</a>
      <ul>
        <li><a href="#Initialization">Initialization</a>
        <li><a href="#LocalevaluationofLaplaceoperator">Local evaluation of Laplace operator</a>
        <li><a href="#vmultfunctions">vmult functions</a>
      </ul>
        <li><a href="#LaplaceProblemclass">LaplaceProblem class</a>
      <ul>
        <li><a href="#LaplaceProblemsetup_system">LaplaceProblem::setup_system</a>
        <li><a href="#LaplaceProblemassemble_system">LaplaceProblem::assemble_system</a>
        <li><a href="#LaplaceProblemassemble_multigrid">LaplaceProblem::assemble_multigrid</a>
        <li><a href="#LaplaceProblemsolve">LaplaceProblem::solve</a>
        <li><a href="#LaplaceProblemoutput_results">LaplaceProblem::output_results</a>
        <li><a href="#LaplaceProblemrun">LaplaceProblem::run</a>
      </ul>
        <li><a href="#Thecodemaincodefunction">The <code>main</code> function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Programoutput">Program output</a>
        <li><a href="#Comparisonwithasparsematrix">Comparison with a sparse matrix</a>
        <li><a href="#Possibilitiesforextensions">Possibilities for extensions</a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <br/>
</p>
<p><em> This program was contributed by Katharina Kormann and Martin Kronbichler.</em></p>
<p><em>The algorithm for the matrix-vector product is based on the article <a href="http://dx.doi.org/10.1016/j.compfluid.2012.04.012">A generic interface for parallel cell-based finite element operator application</a> by Martin Kronbichler and Katharina Kormann, Computers and Fluids 63:135&ndash;147, 2012, and the paper "Parallel finite element operator application: Graph partitioning and coloring" by Katharina Kormann and Martin Kronbichler in: Proceedings of the 7th IEEE International Conference on e-Science, 2011. </em></p>
<p><a class="anchor" id="Intro"></a> <a class="anchor" id="Introduction"></a></p>
<h1>Introduction</h1>
<p>This example shows how to implement a matrix-free method, that is, a method that does not explicitly store the matrix elements, for a second-order Poisson equation with variable coefficients on a hypercube. The elliptic equation will be solved with a multigrid method.</p>
<p>The major motivation for matrix-free methods is the fact that today access to main memory (i.e., for objects that don't fit in the cache) has become the bottleneck in scientific computing: To perform a matrix-vector product, modern CPUs spend far more time waiting for data to arrive from memory than on actually doing the floating point multiplications and additions. Thus, if we could substitute looking up matrix elements in memory by re-computing them &mdash; or rather, the operator represented by these entries &mdash;, we may win in terms of overall run-time (even if this requires a significant number of additional floating point operations). That said, to realize this with a trivial implementation is not enough and one needs to really look at what it takes to make this happen. This tutorial program (and the papers referenced above) show how one can implement such a scheme and demonstrates the speedup that can be obtained.</p>
<p><a class="anchor" id="Thetestcase"></a></p>
<h3>The test case</h3>
<p>In this example, we consider the Poisson problem </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} - \nabla \cdot a(\mathbf x) \nabla u &amp;=&amp; 1, \\ u &amp;=&amp; 0 \quad \text{on}\ \partial \Omega \end{eqnarray*}" src="form_3051.png"/>
</p>
<p> where <img class="formulaInl" alt="$a(\mathbf x)$" src="form_1781.png"/> is a variable coefficient. Below, we explain how to implement a matrix-vector product for this problem without explicitly forming the matrix. The construction can, of course, be done in a similar way for other equations as well.</p>
<p>We choose as domain <img class="formulaInl" alt="$\Omega=[0,1]^3$" src="form_3052.png"/> and <img class="formulaInl" alt="$a(\mathbf x)=\frac{1}{0.05 + 2\|\mathbf x\|^2}$" src="form_3053.png"/>. Since the coefficient is symmetric around the origin but the domain is not, we will end up with a non-symmetric solution.</p>
<p><a class="anchor" id="Matrixvectorproductimplementation"></a></p>
<h3>Matrix-vector product implementation</h3>
<p>In order to find out how we can write a code that performs a matrix-vector product, but does not need to store the matrix elements, let us start at looking how a finite element matrix <em>A</em> is assembled: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} A = \sum_{\mathrm{cell}=1}^{\mathrm{n\_cells}} P_{\mathrm{cell,{loc-glob}}}^T A_{\mathrm{cell}} P_{\mathrm{cell,{loc-glob}}}. \end{eqnarray*}" src="form_3054.png"/>
</p>
<p> In this formula, the matrix <em>P</em><sub>cell,loc-glob</sub> is a rectangular matrix that defines the index mapping from local degrees of freedom in the current cell to the global degrees of freedom. The information from which this operator can be built is usually encoded in the <code>local_dof_indices</code> variable we have always used in the assembly of matrices. Moreover, <em>A</em><sub>cell</sub> denotes the cell-operation associated with <em>A</em>.</p>
<p>If we are to perform a matrix-vector product, we can hence use that </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} y &amp;=&amp; A\cdot u = \left(\sum_{\text{cell}=1}^{\mathrm{n\_cells}} P_\mathrm{cell,{loc-glob}}^T A_\mathrm{cell} P_\mathrm{cell,{loc-glob}}\right) \cdot u \\ &amp;=&amp; \sum_{\mathrm{cell}=1}^{\mathrm{n\_cells}} P_\mathrm{cell,{loc-glob}}^T A_\mathrm{cell} u_\mathrm{cell} \\ &amp;=&amp; \sum_{\mathrm{cell}=1}^{\mathrm{n\_cells}} P_\mathrm{cell,{loc-glob}}^T v_\mathrm{cell}, \end{eqnarray*}" src="form_3055.png"/>
</p>
<p> where <em>u</em><sub>cell</sub> are the values of <em>u</em> at the degrees of freedom of the respective cell, and <em>v</em><sub>cell</sub>=<em>A</em><sub>cell</sub><em>u</em><sub>cell</sub> correspondingly for the result. A naive attempt to implement the local action of the Laplacian would hence be to use the following code: </p>
<div class="fragment"><div class="line"><a class="code" href="classMatrixFree.html">MatrixFree&lt;dim&gt;::vmult</a> (<a class="code" href="classVector.html">Vector&lt;double&gt;</a>       &amp;dst,</div>
<div class="line">                        <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;src)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  dst = 0;</div>
<div class="line"></div>
<div class="line">  <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>  quadrature_formula(fe.degree+1);</div>
<div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values (fe, quadrature_formula,</div>
<div class="line">                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>|</div>
<div class="line">                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div>
<div class="line"></div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   dofs_per_cell = fe.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>;</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#a4d64837b1d374e9c46f07af8f094b29b">size</a>();</div>
<div class="line"></div>
<div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>   cell_matrix (dofs_per_cell, dofs_per_cell);</div>
<div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       cell_src (dofs_per_cell),</div>
<div class="line">                       cell_dst (dofs_per_cell);</div>
<div class="line">  <span class="keyword">const</span> Coefficient&lt;dim&gt; coefficient;</div>
<div class="line">  std::vector&lt;double&gt; coefficient_values(n_q_points);</div>
<div class="line"></div>
<div class="line">  std::vector&lt;unsigned int&gt; local_dof_indices (dofs_per_cell);</div>
<div class="line"></div>
<div class="line">  <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div>
<div class="line">    cell = dof_handler.<a class="code" href="classDoFHandler.html#a6f2aa9c61385cbb749ed3d2e7bfe3de1">begin_active</a>(),</div>
<div class="line">    endc = dof_handler.<a class="code" href="classDoFHandler.html#abf64c3734383b6fb1bed4888935f2edf">end</a>();</div>
<div class="line">  <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div>
<div class="line">    {</div>
<div class="line">      cell_matrix = 0;</div>
<div class="line">      fe_values.<a class="code" href="classFEValues.html#afde502903642c57ade24dfcebf5c1650">reinit</a> (cell);</div>
<div class="line">      coefficient.value_list(fe_values.<a class="code" href="classFEValuesBase.html#a5f8732ebe2d3c6746f6de26a79cb1e45">get_quadrature_points</a>(),</div>
<div class="line">                             coefficient_values);</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_q_points; ++q)</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div>
<div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div>
<div class="line">            cell_matrix(i,j) += (fe_values.<a class="code" href="classFEValuesBase.html#ac4cee7628c2903a89c5c399fddeb00a5">shape_grad</a>(i,q) *</div>
<div class="line">                                 fe_values.<a class="code" href="classFEValuesBase.html#ac4cee7628c2903a89c5c399fddeb00a5">shape_grad</a>(j,q) *</div>
<div class="line">                                 fe_values.<a class="code" href="classFEValuesBase.html#ad097580a2f71878695096cc73b271b9d">JxW</a>(q)*</div>
<div class="line">                                 coefficient_values[q]);</div>
<div class="line"></div>
<div class="line">      cell-&gt;get_dof_indices (local_dof_indices);</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div>
<div class="line">        cell_src(i) = src(local_dof_indices(i));</div>
<div class="line"></div>
<div class="line">      cell_matrix.<a class="code" href="classFullMatrix.html#a4aa3d40db354f5ebc1b045b7062fc0fe">vmult</a> (cell_dst, cell_src);</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div>
<div class="line">        dst(local_dof_indices(i)) += cell_dst;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Here we neglected boundary conditions as well as any hanging nodes we may have, though neither would be very difficult to include using the <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> class. Note how we first generate the local matrix in the usual way as a sum over all quadrature points for each local matrix entry. To form the actual product as expressed in the above formula, we extract the values of <code>src</code> of the cell-related degrees of freedom (the action of <em>P</em><sub>cell,loc-glob</sub>), multiply by the local matrix (the action of <em>A</em><sub>cell</sub>), and finally add the result to the destination vector <code>dst</code> (the action of <em>P</em><sub>cell,loc-glob</sub><sup>T</sup>, added over all the elements). It is not more difficult than that, in principle.</p>
<p>While this code is completely correct, it is very slow. For every cell, we generate a local matrix, which takes three nested loops with loop length equal to the number of local degrees of freedom to compute. The multiplication itself is then done by two nested loops, which means that it is much cheaper.</p>
<p>One way to improve this is to realize that conceptually the local matrix can be thought of as the product of three matrices, </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} A_\mathrm{cell} = B_\mathrm{cell}^T D_\mathrm{cell} B_\mathrm{cell}, \end{eqnarray*}" src="form_3056.png"/>
</p>
<p> where for the example of the Laplace operator the (<em>q</em>*dim+<em>d,i</em>)-th element of <em>B</em><sub>cell</sub> is given by <code>fe_values.shape_grad(i,q)[d]</code>. The matrix consists of <code>dim*n_q_points</code> rows and <code>dofs_per_cell</code> columns). The matrix <em>D</em><sub>cell</sub> is diagonal and contains the values <code>fe_values.JxW(q) * coefficient_values[q]</code> (or, rather, <code>dim</code> copies of each of these values). This kind of representation of finite element matrices can often be found in the engineering literature.</p>
<p>When the cell-based matrix is applied to a vector </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} A_\mathrm{cell}\cdot u_\mathrm{cell} = B_\mathrm{cell}^T D_\mathrm{cell} B_\mathrm{cell} \cdot u_\mathrm{cell}, \end{eqnarray*}" src="form_3057.png"/>
</p>
<p> one would then never form the matrix-matrix products, but rather multiply with the vector from right to left so that only three successive matrix-vector products are formed. This removed the three nested loops in the calculation of the local matrix. What happens is as follows: We first transform the vector of values on the local dofs to a vector of gradients on the quadrature points. In the second loop, we multiply these gradients by the integration weight. The third loop applies the second gradient (in transposed form), so that we get back to a vector of (Laplacian) values on the cell dofs. This reduces the complexity of the work on one cell from something like <img class="formulaInl" alt="$\mathcal {O}(\mathrm{dofs\_per\_cell}^3)$" src="form_3058.png"/> to <img class="formulaInl" alt="$\mathcal {O}(\mathrm{dofs\_per\_cell}^2)$" src="form_3059.png"/>.</p>
<p>The bottleneck in the above code is the operations done by the call to <a class="el" href="classFEValues.html#afde502903642c57ade24dfcebf5c1650">FEValues::reinit</a> for every <code>cell</code>, which take about as much time as the other steps together (at least if the mesh is unstructured; deal.II can recognize that the gradients are often unchanged on structured meshes). That is certainly not ideal and we would like to do better than this. What the reinit function does is to calculate the gradient in real space by transforming the gradient on the reference cell using the Jacobian of the transformation from real to reference cell. This is done for each basis function on the cell, for each quadrature point. The Jacobian does not depend on the basis function, but it is different on different quadrature points in general. If you only build the matrix once as we've done in all previous tutorial programs, there is nothing one can do about the need to call <a class="el" href="classFEValues.html#afde502903642c57ade24dfcebf5c1650">FEValues::reinit</a> on every cell since this transformation has to be done when we want to compute the local matrix elements.</p>
<p>However, in a matrix-free implementation, we are not interested in applying the matrix only once. Rather, in iterative solvers, we need to expect that we have to apply the matrix many times, and so we can think about whether we may be able to cache something between different applications. On the other hand, we realize that we must not cache too much data since otherwise we get back to the situation where memory access becomes the dominating factor.</p>
<p>The trick is now to factor out the Jacobian transformation and first apply the gradient on the reference cell only. That transforms the vector of values on the local dofs to a vector of gradients on the quadrature points. There, we first apply the Jacobian that we factored out from the gradient, then we apply the weights of the quadrature, and we apply the transposed Jacobian for preparing the third loop which again uses the gradients on the unit cell.</p>
<p>Let us again write this in terms of matrices. Let the matrix <em>B</em><sub>cell</sub> denote the cell-related gradient matrix, with each row containing the values on the quadrature points. It is constructed by a matrix-matrix product as </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} B_\mathrm{cell} = J_\mathrm{cell} B_\mathrm{ref\_cell}, \end{eqnarray*}" src="form_3060.png"/>
</p>
<p> where <em>B</em><sub>ref_cell</sub> denotes the gradient on the reference cell and <em>J</em><sub>cell</sub> denotes the Jacobian transformation from unit to real cell (in the language of transformations, the operation represented by <em>J</em><sub>cell</sub> represents a covariant transformation). <em>J</em><sub>cell</sub> is block-diagonal, and the blocks size is equal to the dimension of the problem. Each diagonal block is the Jacobian transformation that goes from the reference cell to the real cell.</p>
<p>Putting things together, we find that </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} A_\mathrm{cell} = B_\mathrm{cell}^T D B_\mathrm{cell} = B_\mathrm{ref\_cell}^T J_\mathrm{cell}^T D_\mathrm{cell} J_\mathrm{cell} B_\mathrm{ref\_cell}, \end{eqnarray*}" src="form_3061.png"/>
</p>
<p> so we calculate the product (starting the local product from the right) </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} v_\mathrm{cell} = B_\mathrm{ref\_cell}^T J_\mathrm{cell}^T D J_\mathrm{cell} B_\mathrm{ref\_cell} u_\mathrm{cell}, \quad v = \sum_{\mathrm{cell}=1}^{\mathrm{n\_cells}} P_\mathrm{cell,{loc-glob}}^T v_\mathrm{cell}. \end{eqnarray*}" src="form_3062.png"/>
</p>
 <div class="fragment"><div class="line">...</div>
<div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values_reference (fe, quadrature_formula,</div>
<div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>);</div>
<div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> reference_cell;</div>
<div class="line">  <a class="code" href="namespaceGridGenerator.html#a7149c59cefa805a132177cfa6cb953bd">GridGenerator::hyper_cube</a>(reference_cell, 0., 1.);</div>
<div class="line">  fe_values_reference.reinit (reference_cell.<a class="code" href="classTriangulation.html#a7b87a97ff0d6ffe416aa37fda33c46c7">begin</a>());</div>
<div class="line"></div>
<div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values (fe, quadrature_formula,</div>
<div class="line">                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fac654119724aff0c394743170ae949d18">update_inverse_jacobians</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> |</div>
<div class="line">                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div>
<div class="line">    {</div>
<div class="line">      fe_values.<a class="code" href="classFEValues.html#afde502903642c57ade24dfcebf5c1650">reinit</a> (cell);</div>
<div class="line">      coefficient.value_list(fe_values.<a class="code" href="classFEValuesBase.html#a5f8732ebe2d3c6746f6de26a79cb1e45">get_quadrature_points</a>(),</div>
<div class="line">                             coefficient_values);</div>
<div class="line"></div>
<div class="line">      cell-&gt;get_dof_indices (local_dof_indices);</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div>
<div class="line">        cell_src(i) = src(local_dof_indices(i));</div>
<div class="line"></div>
<div class="line">      temp_vector = 0;</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_q_points; ++q)</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; d&lt;dim; ++d)</div>
<div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div>
<div class="line">            temp_vector(q*dim+d) +=</div>
<div class="line">              fe_values_reference.shape_grad(i,q)[d] * cell_src(i);</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_q_points; ++q)</div>
<div class="line">        {</div>
<div class="line">          <span class="comment">// apply the transposed inverse Jacobian of the mapping</span></div>
<div class="line">          <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> temp;</div>
<div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; d&lt;dim; ++d)</div>
<div class="line">            temp[d] = temp_vector(q*dim+d);</div>
<div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; d&lt;dim; ++d)</div>
<div class="line">            {</div>
<div class="line">              <span class="keywordtype">double</span> sum = 0;</div>
<div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> e=0; e&lt;dim; ++e)</div>
<div class="line">                sum += fe_values.<a class="code" href="classFEValuesBase.html#a665ab681011424cb1b0ba11c4155a121">inverse_jacobian</a>(q)[e][d] *</div>
<div class="line">                       temp[e];</div>
<div class="line">              temp_vector(q*dim+d) = sum;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">          <span class="comment">// multiply by coefficient and integration weight</span></div>
<div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; d&lt;dim; ++d)</div>
<div class="line">            temp_vector(q*dim+d) *= fe_values.<a class="code" href="classFEValuesBase.html#ad097580a2f71878695096cc73b271b9d">JxW</a>(q) * coefficient_values[q];</div>
<div class="line"></div>
<div class="line">          <span class="comment">// apply the inverse Jacobian of the mapping</span></div>
<div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; d&lt;dim; ++d)</div>
<div class="line">            temp[d] = temp_vector(q*dim+d);</div>
<div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; d&lt;dim; ++d)</div>
<div class="line">            {</div>
<div class="line">              <span class="keywordtype">double</span> sum = 0;</div>
<div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> e=0; e&lt;dim; ++e)</div>
<div class="line">                sum += fe_values.<a class="code" href="classFEValuesBase.html#a665ab681011424cb1b0ba11c4155a121">inverse_jacobian</a>(q)[d][e] *</div>
<div class="line">                       temp[e];</div>
<div class="line">              temp_vector(q*dim+d) = sum;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">      cell_dst = 0;</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_q_points; ++q)</div>
<div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; d&lt;dim; ++d)</div>
<div class="line">            cell_dst(i) += fe_values_reference.shape_grad(i,q)[d] *</div>
<div class="line">                           temp_vector(q*dim+d);</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div>
<div class="line">        dst(local_dof_indices(i)) += cell_dst(i);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Note how we create an additional <a class="el" href="classFEValues.html">FEValues</a> object for the reference cell gradients and how we initialize it to the reference cell. The actual derivative data is then applied by the inverse, transposed Jacobians (deal.II calls the Jacobian matrix from unit to real cell inverse_jacobian, because the transformation direction in deal.II is from real to unit cell).</p>
<p>Finally, we are using tensor product basis functions and now that we have separated out the gradient on the reference cell <em>B</em><sub>ref_cell</sub>, we can exploit the tensor-product structure to further reduce the complexity. We illustrate this in two space dimensions, but the same technique can be used in higher dimensions. On the reference cell, the basis functions are of the tensor product form <img class="formulaInl" alt="$\phi(x,y,z) = \varphi_i(x) \varphi_j(y)$" src="form_3063.png"/>. The part of the matrix <em>B</em><sub>ref_cell</sub> that computes the first component has the form <img class="formulaInl" alt="$B_\mathrm{sub\_cell}^x = B_\mathrm{grad,x} \otimes B_\mathrm{val,y}$" src="form_3064.png"/>, where <em>B</em><sub>grad,x</sub> and <em>B</em><sub>val,y</sub> contain the evaluation of all the 1D basis functions on all the 1D quadrature points. Forming a matrix <em>U</em> with <em>U(j,i)</em> containing the coefficient belonging to basis function <img class="formulaInl" alt="$\varphi_i(x) \varphi_j(y)$" src="form_3065.png"/>, we get <img class="formulaInl" alt="$(B_\mathrm{grad,x} \otimes B_\mathrm{val,y})u_\mathrm{cell} = B_\mathrm{val,y} U B_\mathrm{grad,x}$" src="form_3066.png"/>. This reduces the complexity for computing this product from <img class="formulaInl" alt="$p^4$" src="form_3067.png"/> to <img class="formulaInl" alt="$2 p^3$" src="form_3068.png"/>, where <em>p</em>-1 is the degree of the finite element (i.e., equivalently, <em>p</em> is the number of shape functions in each coordinate direction), or <img class="formulaInl" alt="$p^{2d}$" src="form_3069.png"/> to <img class="formulaInl" alt="$d p^{d+1}$" src="form_3070.png"/> in general.</p>
<p>Implementing a matrix-free and cell-based finite element operator requires a somewhat different design compared to the usual matrix assembly codes shown in previous tutorial programs. The data structures for doing this are the <a class="el" href="classMatrixFree.html">MatrixFree</a> class that collects all data and issues a (parallel) loop over all cells and the <a class="el" href="classFEEvaluation.html">FEEvaluation</a> class that evaluates finite element basis functions by making use of the tensor product structure.</p>
<p>The implementation of the matrix-free matrix-vector product shown in this tutorial is slower than a matrix-vector product using a sparse matrix for linear elements, but faster for all higher order elements thanks to the reduced complexity due to the tensor product structure and due to less memory transfer during computations. The impact of reduced memory transfer is particularly beneficial when working on a multicore processor where several processing units share access to memory. In that case, an algorithm which is computation bound will show almost perfect parallel speedup, whereas an algorithm that is bound by memory transfer might not achieve similar speedup (even when the work is perfectly parallel and one could expect perfect scaling like in sparse matrix-vector products). An additional gain with this implementation is that we do not have to build the sparse matrix itself, which can also be quite expensive depending on the underlying differential equation. Moreover, the above framework is simple to generalize to nonlinear operations, as we demonstrate in <a class="el" href="step_48.html">step-48</a>.</p>
<p><a class="anchor" id="Combinationwithmultigrid"></a></p>
<h3>Combination with multigrid</h3>
<p>Above, we have gone to significant lengths to implement a matrix-vector product that does not actually store the matrix elements. In many user codes, however, one wants more than just performing some number of matrix-vector products &mdash; one wants to do as little of these operations as possible when solving linear equation systems. In theory, we could use the CG method without preconditioning; however, that would not be very efficient. Rather, one uses preconditioners for improving speed. On the other hand, most of the more frequently used preconditioners such as SSOR, ILU or algebraic multigrid (AMG) cannot be used here because their implementation requires knowledge of the elements of the system matrix.</p>
<p>One solution is to use multigrid methods as shown in <a class="el" href="step_16.html">step-16</a>. They are known to be very fast, and they are suitable for our purpose since they can be designed based purely on matrix-vector products. All one needs to do is to find a smoother that works with matrix-vector products only (our choice requires knowledge of the diagonal entries of the matrix, though). One such candidate would be a damped Jacobi iteration, but that is often not sufficiently good in damping high-frequency errors. A Chebyshev preconditioner, eventually, is what we use here. It can be seen as an extension of the Jacobi method by using Chebyshev polynomials. With degree zero, the Jacobi method with optimal damping parameter is retrieved, whereas higher order corrections improve the smoothing properties if some parameters are suitably chosen. The effectiveness of Chebyshev smoothing in multigrid has been demonstrated, e.g., in the article <a href="http://www.sciencedirect.com/science/article/pii/S0021999103001943"><em>M. Adams, M. Brezina, J. Hu, R. Tuminaro. Parallel multigrid smoothers: polynomial versus Gauss&ndash;Seidel, J. Comput. Phys. 188:593&ndash;610, 2003</em> </a>. This publication also identifies one more advantage of Chebyshev smoothers that we exploit here, namely that they are easy to parallelize, whereas SOR/Gauss&ndash;Seidel smoothing relies on substitutions, for which a naive parallelization works on diagonal sub-blocks of the matrix, thereby decreases efficiency (for more detail see e.g. Y. Saad, Iterative Methods for Sparse Linear Systems, SIAM, 2nd edition, 2003, chapters 11 &amp; 12).</p>
<p>The implementation into the multigrid framework is then straightforward. The multigrid implementation in this program is based on a simplified version of <a class="el" href="step_16.html">step-16</a> that disregards adaptivity.</p>
<p><a class="anchor" id="UsingCPUdependentinstructionsvectorization"></a></p>
<h3>Using CPU-dependent instructions (vectorization)</h3>
<p>The computational kernels for evaluation in <a class="el" href="classFEEvaluation.html">FEEvaluation</a> are written in a way to optimally use computational resources. Indeed, they operate not on double data types, but something we call <a class="el" href="classVectorizedArray.html">VectorizedArray</a> (check e.g. the return type of <a class="el" href="classFEEvaluationBase.html#afce22e496c9f641f58949edcbf56375d">FEEvaluationBase::get_value</a>, which is <a class="el" href="classVectorizedArray.html">VectorizedArray</a> for a scalar element and a <a class="el" href="classTensor.html">Tensor</a> of <a class="el" href="classVectorizedArray.html">VectorizedArray</a> for a vector finite element). <a class="el" href="classVectorizedArray.html">VectorizedArray</a> is a short array of doubles or float whose length depends on the particular computer system in use. For example, systems based on x86-64 support the streaming SIMD extensions (SSE), where the processor's vector units can process two doubles (or four single-precision floats) by one CPU instruction. Newer processors with support for the so-called advanced vector extensions (AVX) with 256 bit operands can use four doubles and eight floats, respectively. Vectorization is a single-instruction/multiple-data (SIMD) concept, that is, one CPU instruction is used to process multiple data values at once. Often, finite element programs do not use vectorization explicitly as the benefits of this concept are only in arithmetic intensive operations. The bulk of typical finite element workloads are memory bandwidth limited (operations on sparse matrices and vectors) where the additional computational power is useless.</p>
<p>Behind the scenes, optimized BLAS packages might heavily rely on vectorization, though. Also, optimizing compilers might automatically transform loops involving standard code into more efficient vectorized form. However, the data flow must be very regular in order for compilers to produce efficient code. For example, already the automatic vectorization of the prototype operation that benefits from vectorization, matrix-matrix products, fails on most compilers (as of writing this tutorial in early 2012, neither gcc-4.6 nor the Intel compiler v. 12 manage to produce useful vectorized code for the <a class="el" href="classFullMatrix.html#a841d80d9df94300b5856cbeb173d572c">FullMatrix::mmult</a> function, and not even on the simpler case where the matrix bounds are compile-time constants instead of run-time constants as in <a class="el" href="classFullMatrix.html#a841d80d9df94300b5856cbeb173d572c">FullMatrix::mmult</a>). The main reason for this is that the information to be processed at the innermost loop (that is where vectorization is applied) is not necessarily a multiple of the vector length, leaving parts of the resources unused. Moreover, the data that can potentially be processed together might not be laid out in a contiguous way in memory or not with the necessary alignment to address boundaries that are needed by the processor. Or the compiler might not be able to prove that data arrays do not overlap when loading several elements at once.</p>
<p>In the matrix-free implementation in deal.II, we have therefore chosen to apply vectorization at the level which is most appropriate for finite element computations: The cell-wise computations are typically exactly the same for all cells (except for reading from and writing to vectors), and hence SIMD can be used to process several cells at once. In all what follows, you can think of a <a class="el" href="classVectorizedArray.html">VectorizedArray</a> to hold data from several cells. Remember that it is not related to the spatial dimension and the number of elements e.g. in a <a class="el" href="classTensor.html">Tensor</a> or <a class="el" href="classPoint.html">Point</a>.</p>
<p>Note that vectorization depends on the CPU that is used for deal.II. In order to generate the fastest kernels of <a class="el" href="classFEEvaluation.html">FEEvaluation</a> for your computer, you should compile deal.II with the so-called <em>native</em> processor variant. When using the gcc compiler, it can be enabled by setting the variable <code>CMAKE_CXX_FLAGS</code> to <code>"-march=native"</code> in the cmake build settings (on the command line, specify <code>-DCMAKE_CXX_FLAGS="-march=native"</code>, see the deal.II README for more information). Similar options exist for other compilers.</p>
<p><a class="anchor" id="CommProg"></a> </p>
<h1>The commented program</h1>
<p>First include the necessary files from the deal.II library.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/base/quadrature_lib.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/base/function.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/base/logstream.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/base/timer.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/lac/vector.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/lac/full_matrix.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/lac/solver_cg.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/lac/precondition.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_q.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_values.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_accessor.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_iterator.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_boundary_lib.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_generator.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/multigrid/multigrid.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/multigrid/mg_transfer.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/multigrid/mg_tools.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/multigrid/mg_coarse.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/multigrid/mg_smoother.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/multigrid/mg_matrix.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/data_out.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/vector_tools.h&gt;</span></div>
</div><!-- fragment --><p>This includes the data structures for the efficient implementation of matrix-free methods or more generic finite element operators with the class <a class="el" href="classMatrixFree.html">MatrixFree</a>.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/matrix_free/matrix_free.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/matrix_free/fe_evaluation.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span>Step37</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">using namespace </span>dealii;</div>
</div><!-- fragment --><p>To be efficient, the operations performed in the matrix-free implementation require knowledge of loop lengths at compile time, which are given by the degree of the finite element. Hence, we collect the values of the two template parameters that can be changed at one place in the code. Of course, one could make the degree of the finite element a run-time parameter by compiling the computational kernels for all degrees that are likely (say, between 1 and 6) and selecting the appropriate kernel at run time. Here, we simply choose second order <img class="formulaInl" alt="$Q_2$" src="form_622.png"/> elements and choose dimension 3 as standard.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree_finite_element = 2;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dimension = 3;</div>
</div><!-- fragment --><p><a class="anchor" id="Equationdata"></a> </p>
<h3>Equation data</h3>
<p>We define a variable coefficient function for the Poisson problem. It is similar to the function in <a class="el" href="step_5.html">step-5</a> but we use the form <img class="formulaInl" alt="$a(\mathbf x)=\frac{1}{0.05 + 2\|\bf x\|^2}$" src="form_3071.png"/> instead of a discontinuous one. It is merely to demonstrate the possibilities of this implementation, rather than making much sense physically. We define the coefficient in the same way as functions in earlier tutorial programs. There is one new function, namely a <code>value</code> method with template argument <code>number</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keyword">class </span>Coefficient : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  Coefficient ()  : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;() {}</div>
<div class="line"></div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#a9783cc12b6b205d4019379b0cc6f3956">value</a> (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>   &amp;p,</div>
<div class="line">                        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  component = 0) <span class="keyword">const</span>;</div>
<div class="line"></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> number&gt;</div>
<div class="line">  number <a class="code" href="classFunction.html#a9783cc12b6b205d4019379b0cc6f3956">value</a> (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim,number&gt;</a> &amp;p,</div>
<div class="line">                <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const</span>;</div>
<div class="line"></div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classFunction.html#af6f1aceeeb499ff07d828df250f4f3b2">value_list</a> (<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &gt; &amp;points,</div>
<div class="line">                           std::vector&lt;double&gt;            &amp;values,</div>
<div class="line">                           <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>              component = 0) <span class="keyword">const</span>;</div>
<div class="line">};</div>
</div><!-- fragment --><p>This is the new function mentioned above: Evaluate the coefficient for abstract type <code>number</code>. It might be just a usual double, but it can also be a somewhat more complicated type that we call <a class="el" href="classVectorizedArray.html">VectorizedArray</a>. This data type is essentially a short array of doubles as discussed in the introduction that holds data from several cells. For example, we evaluate the coefficient shown here not on a simple point as usually done, but we hand it a <a class="el" href="classPoint.html">Point</a>&lt;dim,VectorizedArray&lt;double&gt; &gt; point, which is actually a collection of two points in the case of SSE2. Do not confuse the entries in VectorizedArray&lt;double&gt; with the different coordinates of the point. Indeed, the data is laid out such that <code>p[0]</code> returns a VectorizedArray&lt;double&gt;, which in turn contains the x-coordinate for the first point and the second point. You may access the coordinates individually using e.g. <code>p[0][j]</code>, j=0,1, but it is recommended to define operations on a <a class="el" href="classVectorizedArray.html">VectorizedArray</a> as much as possible in order to make use of vectorized operations.</p>
<p>In the function implementation, we assume that the number type overloads basic arithmetic operations, so we just write the code as usual. The standard functions <code>value</code> and value_list that are virtual functions contained in the base class are then computed from the templated function with double type, in order to avoid duplicating code.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> number&gt;</div>
<div class="line">number Coefficient&lt;dim&gt;::value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim,number&gt;</a> &amp;p,</div>
<div class="line">                                <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> / *component* /)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  <span class="keywordflow">return</span> 1. / (0.05 + 2.*p.<a class="code" href="classPoint.html#ad46f55479010282e242b1d8e427285e8">square</a>());</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">double</span> Coefficient&lt;dim&gt;::value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>  &amp;p,</div>
<div class="line">                                <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  <span class="keywordflow">return</span> value&lt;double&gt;(p,component);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> Coefficient&lt;dim&gt;::value_list (<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &gt; &amp;points,</div>
<div class="line">                                   std::vector&lt;double&gt;            &amp;values,</div>
<div class="line">                                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>              component)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (values.size() == points.size(),</div>
<div class="line">          <a class="code" href="group__Exceptions.html#ga325fd73751a9373f1b901962daeb2ea7">ExcDimensionMismatch</a> (values.size(), points.size()));</div>
<div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (component == 0,</div>
<div class="line">          <a class="code" href="group__Exceptions.html#ga3f3f87a5613ac8b4e64ecd458dea8e9b">ExcIndexRange</a> (component, 0, 1));</div>
<div class="line"></div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_points = points.size();</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;n_points; ++i)</div>
<div class="line">    values[i] = value&lt;double&gt;(points[i],component);</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="Matrixfreeimplementation"></a> </p>
<h3>Matrix-free implementation</h3>
<p>The following class, called <code>LaplaceOperator</code>, implements the differential operator. For all practical purposes, it is a matrix, i.e., you can ask it for its size (member functions <code>m(), n()</code>) and you can apply it to a vector (the various variants of the <code>vmult()</code> function). The difference to a real matrix of course lies in the fact that this class doesn't actually store the <em>elements</em> of the matrix, but only knows how to compute the action of the operator when applied to a vector.</p>
<p>In this program, we want to make use of the data cache for finite element operator application that is integrated in deal.II. The main class that collects all data is called <a class="el" href="classMatrixFree.html">MatrixFree</a>. It contains mapping information (Jacobians) and index relations between local and global degrees of freedom. It also contains constraints like the ones from Dirichlet boundary conditions (or hanging nodes, if we had any). Moreover, it can issue a loop over all cells in parallel, where it makes sure that only cells are worked on that do not share any degree of freedom (this makes the loop thread-safe when writing into destination vectors). This is a more advanced strategy compared to the <a class="el" href="namespaceWorkStream.html">WorkStream</a> class described in the <a class="el" href="group__threads.html">Parallel computing with multiple processors accessing shared memory</a> module that serializes operations that might not be thread-safe. Of course, to not destroy thread-safety, we have to be careful when writing into class-global structures.</p>
<p>First comes the implementation of the matrix-free class. It provides some standard information we expect for matrices (like returning the dimensions of the matrix), it implements matrix-vector multiplications in several forms (transposed and untransposed), and it provides functions for initializing the structure with data. The class has three template arguments, one for the dimension (as many deal.II classes carry), one for the degree of the finite element (which we need to enable efficient computations through the <a class="el" href="classFEEvaluation.html">FEEvaluation</a> class), and one for the underlying scalar type. We want to use <code>double</code> numbers (i.e., double precision, 64-bit floating point) for the final matrix, but floats (single precision, 32-bit floating point numbers) for the multigrid level matrices (as that is only a preconditioner, and floats can be worked with twice as fast).</p>
<p>In this class, we store the actual <a class="el" href="classMatrixFree.html">MatrixFree</a> object, the variable coefficient that is evaluated at all quadrature points (so that we don't have to recompute it during matrix-vector products), and a vector that contains the diagonal of the matrix that we need for the multigrid smoother. We choose to let the user provide the diagonal in this program, but we could also integrate a function in this class to evaluate the diagonal. Unfortunately, this forces us to define matrix entries at two places, once when we evaluate the product and once for the diagonal, but the work is still much less than when we compute sparse matrices.</p>
<p>As a sidenote, if we implemented several different operations on the same grid and degrees of freedom (like a mass matrix and a Laplace matrix), we would have to have two classes like the current one for each of the operators (maybe with a common base class). However, in that case, we would not store a <a class="el" href="classMatrixFree.html">MatrixFree</a> object in this class to avoid doing the expensive work of precomputing everything <a class="el" href="classMatrixFree.html">MatrixFree</a> stores twice. Rather, we would keep this object in the main class and simply store a reference.</p>
<dl class="section note"><dt>Note</dt><dd>Observe how we store the values for the coefficient: We use a vector type <code><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt;VectorizedArray&lt;number&gt; &gt;</code> structure. One would think that one can use <code>std::vector&lt;VectorizedArray&lt;number&gt; &gt;</code> as well, but there are some technicalities with vectorization: A certain alignment of the data with the memory address boundaries is required (essentially, a <a class="el" href="classVectorizedArray.html">VectorizedArray</a> of 16 bytes length as in SSE needs to start at a memory address that is divisible by 16). The chosen class makes sure that this alignment is respected, whereas std::vector can in general not, which may lead to segmentation faults at strange places for some systems or suboptimal performance for other systems.</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div>
<div class="line"><span class="keyword">class </span>LaplaceOperator : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  LaplaceOperator ();</div>
<div class="line"></div>
<div class="line">  <span class="keywordtype">void</span> clear();</div>
<div class="line"></div>
<div class="line">  <span class="keywordtype">void</span> reinit (<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>  &amp;dof_handler,</div>
<div class="line">               <span class="keyword">const</span> <a class="code" href="classConstraintMatrix.html">ConstraintMatrix</a>  &amp;constraints,</div>
<div class="line">               <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>      level = <a class="code" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>);</div>
<div class="line"></div>
<div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> m () <span class="keyword">const</span>;</div>
<div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n () <span class="keyword">const</span>;</div>
<div class="line"></div>
<div class="line">  <span class="keywordtype">void</span> vmult (<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;dst,</div>
<div class="line">              <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;src) <span class="keyword">const</span>;</div>
<div class="line">  <span class="keywordtype">void</span> Tvmult (<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;dst,</div>
<div class="line">               <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;src) <span class="keyword">const</span>;</div>
<div class="line">  <span class="keywordtype">void</span> vmult_add (<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;dst,</div>
<div class="line">                  <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;src) <span class="keyword">const</span>;</div>
<div class="line">  <span class="keywordtype">void</span> Tvmult_add (<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;dst,</div>
<div class="line">                   <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;src) <span class="keyword">const</span>;</div>
<div class="line"></div>
<div class="line">  number el (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> row,</div>
<div class="line">             <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> col) <span class="keyword">const</span>;</div>
<div class="line">  <span class="keywordtype">void</span> set_diagonal (<span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;number&gt;</a> &amp;diagonal);</div>
<div class="line"></div>
<div class="line">  std::size_t <a class="code" href="namespaceMemoryConsumption.html#ac131e0968c353873300f677282378600">memory_consumption</a> () <span class="keyword">const</span>;</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keywordtype">void</span> local_apply (<span class="keyword">const</span> <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim,number&gt;</a>    &amp;data,</div>
<div class="line">                    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>                      &amp;dst,</div>
<div class="line">                    <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a>                &amp;src,</div>
<div class="line">                    <span class="keyword">const</span> std::pair&lt;unsigned int,unsigned int&gt; &amp;cell_range) <span class="keyword">const</span>;</div>
<div class="line"></div>
<div class="line">  <span class="keywordtype">void</span> evaluate_coefficient(<span class="keyword">const</span> Coefficient&lt;dim&gt; &amp;<span class="keyword">function</span>);</div>
<div class="line"></div>
<div class="line">  <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim,number&gt;</a>      data;</div>
<div class="line">  <a class="code" href="classAlignedVector.html">AlignedVector&lt;VectorizedArray&lt;number&gt;</a> &gt; coefficient;</div>
<div class="line"></div>
<div class="line">  <a class="code" href="classVector.html">Vector&lt;number&gt;</a>  diagonal_values;</div>
<div class="line">  <span class="keywordtype">bool</span>            diagonal_is_available;</div>
<div class="line">};</div>
</div><!-- fragment --><p>This is the constructor of the <code>LaplaceOperator</code> class. All it does is to subscribe to the general deal.II <code><a class="el" href="classSubscriptor.html">Subscriptor</a></code> scheme that makes sure that we do not delete an object of this class as long as it used somewhere else, e.g. in a preconditioner.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div>
<div class="line">LaplaceOperator&lt;dim,fe_degree,number&gt;::LaplaceOperator ()</div>
<div class="line">  :</div>
<div class="line">  <a class="code" href="classSubscriptor.html">Subscriptor</a>()</div>
<div class="line">{}</div>
</div><!-- fragment --><p>The next functions return the number of rows and columns of the global matrix (i.e. the dimensions of the operator this class represents, the point of this tutorial program was, after all, that we don't actually store the elements of the rows and columns of this operator). Since the matrix is square, the returned numbers are the same. We get the number from the vector partitioner stored in the data field (a partitioner distributes elements of a vector onto a number of different machines if programs are run in parallel; since this program is written to run on only a single machine, the partitioner will simply say that all elements of the vector &ndash; or, in the current case, all rows and columns of a matrix &ndash; are stored on the current machine).</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span></div>
<div class="line">LaplaceOperator&lt;dim,fe_degree,number&gt;::m ()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  <span class="keywordflow">return</span> data.get_vector_partitioner()-&gt;<a class="code" href="classNamedData.html#ad244309f259068fa0b24e9e03724f240">size</a>();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span></div>
<div class="line">LaplaceOperator&lt;dim,fe_degree,number&gt;::n ()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  <span class="keywordflow">return</span> data.get_vector_partitioner()-&gt;<a class="code" href="classNamedData.html#ad244309f259068fa0b24e9e03724f240">size</a>();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line">LaplaceOperator&lt;dim,fe_degree,number&gt;::clear ()</div>
<div class="line">{</div>
<div class="line">  data.clear();</div>
<div class="line">  diagonal_is_available = <span class="keyword">false</span>;</div>
<div class="line">  diagonal_values.reinit(0);</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="Initialization"></a> </p>
<h4>Initialization</h4>
<p>Once we have created the multigrid dof_handler and the constraints, we can call the reinit function for each level of the multigrid routine (and the active cells). The main purpose of the reinit function is to setup the <code> <a class="el" href="classMatrixFree.html">MatrixFree</a> </code> instance for the problem. Also, the coefficient is evaluated. For this, we need to activate the update flag in the AdditionalData field of <a class="el" href="classMatrixFree.html">MatrixFree</a> that enables the storage of quadrature point coordinates in real space (by default, it only caches data for gradients (inverse transposed Jacobians) and JxW values). Note that if we call the reinit function without specifying the level (i.e., giving <code>level = <a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a></code>), we have told the class to loop over the active cells.</p>
<p>We also set one option regarding task parallelism. We choose to use the <code>partition_color</code> strategy, which is based on subdivision of cells into partitions where cells in partition <img class="formulaInl" alt="$k$" src="form_188.png"/> (or, more precisely, the degrees of freedom on these cells) only interact with cells in partitions <img class="formulaInl" alt="$k-1$" src="form_3072.png"/>, <img class="formulaInl" alt="$k$" src="form_188.png"/>, and <img class="formulaInl" alt="$k+1$" src="form_3073.png"/>. Within each partition, cells are colored in such a way that cells with the same color do not share degrees of freedom and can, therefore, be worked on at the same time without interference. This determines a task dependency graph that is scheduled by the Intel Threading Building Blocks library. Another option would be the strategy <code>partition_partition</code>, which performs better when the grid is more unstructured. We could also manually set the size of chunks that form one task in the scheduling process by setting <code>tasks_block_size</code>, but the default strategy to let the function decide works well already.</p>
<p>To initialize the coefficient, we directly give it the Coefficient class defined above and then select the method <code>coefficient_function.value</code> with vectorized number (which the compiler can deduce from the point data type). The use of the <a class="el" href="classFEEvaluation.html">FEEvaluation</a> class (and its template arguments) will be explained below.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line">LaplaceOperator&lt;dim,fe_degree,number&gt;::reinit (<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>  &amp;dof_handler,</div>
<div class="line">                                               <span class="keyword">const</span> <a class="code" href="classConstraintMatrix.html">ConstraintMatrix</a>  &amp;constraints,</div>
<div class="line">                                               <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>      level)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">typename</span> <a class="code" href="structMatrixFree_1_1AdditionalData.html">MatrixFree&lt;dim,number&gt;::AdditionalData</a> additional_data;</div>
<div class="line">  additional_data.<a class="code" href="structMatrixFree_1_1AdditionalData.html#a2c5d05b92a9c51568b7fd6c70938007a">tasks_parallel_scheme</a> =</div>
<div class="line">    <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim,number&gt;::AdditionalData::partition_color</a>;</div>
<div class="line">  additional_data.<a class="code" href="structMatrixFree_1_1AdditionalData.html#a4393524200af9a9f7351f5166af9c41d">level_mg_handler</a> = level;</div>
<div class="line">  additional_data.<a class="code" href="structMatrixFree_1_1AdditionalData.html#a1ffc56a213bd3eb3c2654de6ee2c889a">mapping_update_flags</a> = (<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> |</div>
<div class="line">                                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div>
<div class="line">  data.reinit (dof_handler, constraints, <a class="code" href="classQGauss.html">QGauss&lt;1&gt;</a>(fe_degree+1),</div>
<div class="line">               additional_data);</div>
<div class="line">  evaluate_coefficient(Coefficient&lt;dim&gt;());</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line">LaplaceOperator&lt;dim,fe_degree,number&gt;::</div>
<div class="line">evaluate_coefficient (<span class="keyword">const</span> Coefficient&lt;dim&gt; &amp;coefficient_function)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_cells = data.n_macro_cells();</div>
<div class="line">  <a class="code" href="classFEEvaluation.html">FEEvaluation&lt;dim,fe_degree,fe_degree+1,1,number&gt;</a> phi (data);</div>
<div class="line">  coefficient.resize (n_cells * phi.n_q_points);</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell=0; cell&lt;n_cells; ++cell)</div>
<div class="line">    {</div>
<div class="line">      phi.reinit (cell);</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;phi.n_q_points; ++q)</div>
<div class="line">        coefficient[cell*phi.n_q_points+q] =</div>
<div class="line">          coefficient_function.value(phi.quadrature_point(q));</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="LocalevaluationofLaplaceoperator"></a> </p>
<h4>Local evaluation of Laplace operator</h4>
<p>Here comes the main function of this class, the evaluation of the matrix-vector product (or, in general, a finite element operator evaluation). This is done in a function that takes exactly four arguments, the <a class="el" href="classMatrixFree.html">MatrixFree</a> object, the destination and source vectors, and a range of cells that are to be worked on. The method <code>cell_loop</code> in the <a class="el" href="classMatrixFree.html">MatrixFree</a> class will internally call this function with some range of cells that is obtained by checking which cells are possible to work on simultaneously so that write operations do not cause any race condition. Note that the total range of cells as visible in this class is usually not equal to the number of (active) cells in the triangulation. In fact, "cell" may be the wrong term to begin with, since it is rather a collection of quadrature points from several cells, and the <a class="el" href="classMatrixFree.html">MatrixFree</a> class groups the quadrature points of several cells into one block to enable a higher degree of vectorization. The number of such "cells" is stored in <a class="el" href="classMatrixFree.html">MatrixFree</a> and can be queried through <a class="el" href="classMatrixFree.html#afcababa3f89a9e27b85341074fcee075">MatrixFree::n_macro_cells()</a>. Compared to the deal.II cell iterators, in this class all cells are laid out in a plain array with no direct knowledge of level or neighborship relations, which makes it possible to index the cells by unsigned integers.</p>
<p>The implementation of the Laplace operator is quite simple: First, we need to create an object <a class="el" href="classFEEvaluation.html">FEEvaluation</a> that contains the computational kernels and has data fields to store temporary results (e.g. gradients evaluated on all quadrature points on a collection of a few cells). Note that temporary results do not use a lot of memory, and since we specify template arguments with the element order, the data is stored on the stack (without expensive memory allocation). Usually, one only needs to set two template arguments, the dimension as first argument and the degree of the finite element as the second argument (this is equal to the number of degrees of freedom per dimension minus one for <a class="el" href="classFE__Q.html">FE_Q</a> elements). However, here we also want to be able to use float numbers for the multigrid preconditioner, which is the last (fifth) template argument. Therefore, we cannot rely on the default template arguments and must also fill the third and fourth field, consequently. The third argument specifies the number of quadrature points per direction and has a default value equal to the degree of the element plus one. The fourth argument sets the number of components (one can also evaluate vector-valued functions in systems of PDEs, but the default is a scalar element), and finally the last argument sets the number type.</p>
<p>Next, we loop over the given cell range and then we continue with the actual implementation: </p>
<ol>
<li>
Tell the <a class="el" href="classFEEvaluation.html">FEEvaluation</a> object the (macro) cell we want to work on. </li>
<li>
Read in the values of the source vectors (<code>read_dof_values</code>), including the resolution of constraints. This stores <img class="formulaInl" alt="$u_\mathrm{cell}$" src="form_3074.png"/> as described in the introduction. </li>
<li>
Compute the unit-cell gradient (the evaluation of finite element functions). Since <a class="el" href="classFEEvaluation.html">FEEvaluation</a> can combine value computations with gradient computations, it uses a unified interface to all kinds of derivatives of order between zero and two. We only want gradients, no values and no second derivatives, so we set the function arguments to true in the gradient slot (second slot), and to false in the values slot (first slot) and Hessian slot (third slot). Note that the <a class="el" href="classFEEvaluation.html">FEEvaluation</a> class internally evaluates shape functions in an efficient way where one dimension is worked on at a time (using the tensor product form of shape functions and quadrature points as mentioned in the introduction). This gives complexity equal to <img class="formulaInl" alt="$\mathcal O(d^2 (p+1)^{d+1})$" src="form_3075.png"/> for polynomial degree <img class="formulaInl" alt="$p$" src="form_65.png"/> in <img class="formulaInl" alt="$d$" src="form_172.png"/> dimensions, compared to the naive approach with loops over all local degrees of freedom and quadrature points that is used in <a class="el" href="classFEValues.html">FEValues</a> and costs <img class="formulaInl" alt="$\mathcal O(d (p+1)^{2d})$" src="form_3076.png"/>. </li>
<li>
Next comes the application of the Jacobian transformation, the multiplication by the variable coefficient and the quadrature weight. <a class="el" href="classFEEvaluation.html">FEEvaluation</a> has an access function <code>get_gradient</code> that applies the Jacobian and returns the gradient in real space. Then, we just need to multiply by the (scalar) coefficient, and let the function <code>submit_gradient</code> apply the second Jacobian (for the test function) and the quadrature weight and Jacobian determinant (JxW). Note that the submitted gradient is stored in the same data field as where it is read from in <code>get_gradient</code>. Therefore, you need to make sure to not read from the same quadrature point again after having called <code>submit_gradient</code> on that particular quadrature point. In general, it is a good idea to copy the result of <code>get_gradient</code> when it is used more often than once. </li>
<li>
Next follows the summation over quadrature points for all test functions that corresponds to the actual integration step. For the Laplace operator, we just multiply by the gradient, so we call the integrate function with the respective argument set. If you have an equation where you test by both the values of the test functions and the gradients, both template arguments need to be set to true. Calling first the integrate function for values and then gradients in a separate call leads to wrong results, since the second call will internally overwrite the results from the first call. Note that there is no function argument for the second derivative for integrate step. </li>
<li>
Eventually, the local contributions in the vector <img class="formulaInl" alt="$v_\mathrm{cell}$" src="form_3077.png"/> as mentioned in the introduction need to be added into the result vector (and constraints are applied). This is done with a call to <code>distribute_local_to_global</code>, the same name as the corresponding function in the <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> (only that we now store the local vector in the <a class="el" href="classFEEvaluation.html">FEEvaluation</a> object, as are the indices between local and global degrees of freedom). </li>
</ol>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line">LaplaceOperator&lt;dim,fe_degree,number&gt;::</div>
<div class="line">local_apply (<span class="keyword">const</span> <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim,number&gt;</a>         &amp;data,</div>
<div class="line">             <a class="code" href="classVector.html">Vector&lt;double&gt;</a>                       &amp;dst,</div>
<div class="line">             <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a>                 &amp;src,</div>
<div class="line">             <span class="keyword">const</span> std::pair&lt;unsigned int,unsigned int&gt; &amp;cell_range)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  <a class="code" href="classFEEvaluation.html">FEEvaluation&lt;dim,fe_degree,fe_degree+1,1,number&gt;</a> phi (data);</div>
<div class="line">  <a class="code" href="group__Exceptions.html#ga9442b63275c9ef3fab29bc222831c49c">AssertDimension</a> (coefficient.size(), data.<a class="code" href="classMatrixFree.html#afcababa3f89a9e27b85341074fcee075">n_macro_cells</a>() * phi.n_q_points);</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell=cell_range.first; cell&lt;cell_range.second; ++cell)</div>
<div class="line">    {</div>
<div class="line">      phi.reinit (cell);</div>
<div class="line">      phi.read_dof_values(src);</div>
<div class="line">      phi.evaluate (<span class="keyword">false</span>,<span class="keyword">true</span>,<span class="keyword">false</span>);</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;phi.n_q_points; ++q)</div>
<div class="line">        phi.submit_gradient (coefficient[cell*phi.n_q_points+q] *</div>
<div class="line">                             phi.get_gradient(q), q);</div>
<div class="line">      phi.integrate (<span class="keyword">false</span>,<span class="keyword">true</span>);</div>
<div class="line">      phi.distribute_local_to_global (dst);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="vmultfunctions"></a> </p>
<h4>vmult functions</h4>
<p>Now to the <code>vmult</code> function that is called externally: In addition to what we do in a <code>vmult_add</code> function further down, we set the destination to zero first. The transposed matrix-vector is needed for well-defined multigrid preconditioner operations. Since we solve a Laplace problem, this is the same operation, and we just refer to the vmult operation.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line">LaplaceOperator&lt;dim,fe_degree,number&gt;::vmult (<a class="code" href="classVector.html">Vector&lt;double&gt;</a>       &amp;dst,</div>
<div class="line">                                              <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;src)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  dst = 0;</div>
<div class="line">  vmult_add (dst, src);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line">LaplaceOperator&lt;dim,fe_degree,number&gt;::Tvmult (<a class="code" href="classVector.html">Vector&lt;double&gt;</a>       &amp;dst,</div>
<div class="line">                                               <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;src)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  dst = 0;</div>
<div class="line">  vmult_add (dst,src);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line">LaplaceOperator&lt;dim,fe_degree,number&gt;::Tvmult_add (<a class="code" href="classVector.html">Vector&lt;double&gt;</a>       &amp;dst,</div>
<div class="line">                                                   <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;src)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  vmult_add (dst,src);</div>
<div class="line">}</div>
</div><!-- fragment --><p>This function implements the loop over all cells. This is done with the <code>cell_loop</code> of the <a class="el" href="classMatrixFree.html">MatrixFree</a> class, which takes the operator() of this class with arguments <a class="el" href="classMatrixFree.html">MatrixFree</a>, OutVector, InVector, cell_range. Note that we could also use a simple function as local operation in case we had constant coefficients (all we need then is the <a class="el" href="classMatrixFree.html">MatrixFree</a>, the vectors and the cell range), but since the coefficient is stored in a variable of this class, we cannot use that variant here. The cell loop is automatically performed on several threads if multithreading is enabled (this class uses a quite elaborate algorithm to work on cells that do not share any degrees of freedom that could possibly give rise to race conditions, using the dynamic task scheduler of the Intel Threading Building Blocks).</p>
<p>After the cell loop, we need to touch the constrained degrees of freedom: Since the assembly loop automatically resolves constraints (just as the <a class="el" href="classConstraintMatrix.html#aa9f3612a8fc51eafa34252bb436e8ae4">ConstraintMatrix::distribute_local_to_global</a> call does), it does not compute any contribution for constrained degrees of freedom. In other words, the entries for constrained DoFs remain zero after the first part of this function, as if the matrix had empty rows and columns for constrained degrees of freedom. On the other hand, iterative solvers like CG only work for non-singular matrices, so we have to modify the operation on constrained DoFs. The easiest way to do that is to pretend that the sub-block of the matrix that corresponds to constrained DoFs is the identity matrix, in which case application of the matrix would simply copy the elements of the right hand side vector into the left hand side. In general, however, one needs to make sure that the diagonal entries of this sub-block are of the same order of magnitude as the diagonal elements of the rest of the matrix. Here, the domain extent is of unit size, so we can simply choose unit size. If we had domains that are far away from unit size, we would need to choose a number that is close to the size of other diagonal matrix entries, so that these artificial eigenvalues do not change the eigenvalue spectrum (and make convergence with CG more difficult).</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line">LaplaceOperator&lt;dim,fe_degree,number&gt;::vmult_add (<a class="code" href="classVector.html">Vector&lt;double&gt;</a>       &amp;dst,</div>
<div class="line">                                                  <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;src)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  data.<a class="code" href="classMatrixFree.html#afcc5d69d8b3ac27ec73cb22e1d4b8614">cell_loop</a> (&amp;LaplaceOperator::local_apply, <span class="keyword">this</span>, dst, src);</div>
<div class="line"></div>
<div class="line">  <span class="keyword">const</span> std::vector&lt;unsigned int&gt; &amp;</div>
<div class="line">  constrained_dofs = data.<a class="code" href="classMatrixFree.html#ac87bf2eb35ff9c5b6a5a6e977a15016f">get_constrained_dofs</a>();</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;constrained_dofs.size(); ++i)</div>
<div class="line">    dst(constrained_dofs[i]) += src(constrained_dofs[i]);</div>
<div class="line">}</div>
</div><!-- fragment --><p>The next function is used to return entries of the matrix. Since this class is intended not to store the matrix entries, it would make no sense to provide access to all those elements. However, diagonal entries are explicitly needed for the implementation of the Chebyshev smoother that we intend to use in the multigrid preconditioner. This matrix is equipped with a vector that stores the diagonal.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div>
<div class="line">number</div>
<div class="line">LaplaceOperator&lt;dim,fe_degree,number&gt;::el (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> row,</div>
<div class="line">                                           <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> col)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (row == col, <a class="code" href="group__Exceptions.html#gac43116aa5c4896cb376bf817ee854e70">ExcNotImplemented</a>());</div>
<div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (diagonal_is_available == <span class="keyword">true</span>, <a class="code" href="group__Exceptions.html#ga6828fc99b1b7b1028785afba072c20c9">ExcNotInitialized</a>());</div>
<div class="line">  <span class="keywordflow">return</span> diagonal_values(row);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Regarding the calculation of the diagonal, we expect the user to provide a vector with the diagonal entries (and we will compute them in the code below). We only need it for the level matrices of multigrid, not the system matrix (since we only need these diagonals for the multigrid smoother). Since we fill only elements into unconstrained entries, we have to set constrained entries to one in order to avoid the same problems as discussed above.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line">LaplaceOperator&lt;dim,fe_degree,number&gt;::set_diagonal(<span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;number&gt;</a> &amp;diagonal)</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="group__Exceptions.html#ga9442b63275c9ef3fab29bc222831c49c">AssertDimension</a> (m(), diagonal.<a class="code" href="classVector.html#ad900ae86530d76f5fbff32c21c582b71">size</a>());</div>
<div class="line"></div>
<div class="line">  diagonal_values = diagonal;</div>
<div class="line"></div>
<div class="line">  <span class="keyword">const</span> std::vector&lt;unsigned int&gt; &amp;</div>
<div class="line">  constrained_dofs = data.<a class="code" href="classMatrixFree.html#ac87bf2eb35ff9c5b6a5a6e977a15016f">get_constrained_dofs</a>();</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;constrained_dofs.size(); ++i)</div>
<div class="line">    diagonal_values(constrained_dofs[i]) = 1.0;</div>
<div class="line"></div>
<div class="line">  diagonal_is_available = <span class="keyword">true</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Eventually, we provide a function that calculates how much memory this class uses. We just need to sum up the memory consumption in the <a class="el" href="classMatrixFree.html">MatrixFree</a> object and the memory for storing the other member variables. As a remark: In 3D and for Cartesian meshes, most memory is consumed for storing the vector indices on the local cells (corresponding to local_dof_indices). For general (non-Cartesian) meshes, the cached Jacobian transformation consumes most memory.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div>
<div class="line">std::size_t</div>
<div class="line">LaplaceOperator&lt;dim,fe_degree,number&gt;::memory_consumption ()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  <span class="keywordflow">return</span> (data.<a class="code" href="classMatrixFree.html#acccb7e2db859dede4c09279e7d418784">memory_consumption</a> () +</div>
<div class="line">          coefficient.memory_consumption() +</div>
<div class="line">          diagonal_values.memory_consumption() +</div>
<div class="line">          <a class="code" href="namespaceMemoryConsumption.html#ac131e0968c353873300f677282378600">MemoryConsumption::memory_consumption</a>(diagonal_is_available));</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="LaplaceProblemclass"></a> </p>
<h3>LaplaceProblem class</h3>
<p>This class is based on the one in <a class="el" href="step_16.html">step-16</a>. However, we replaced the SparseMatrix&lt;double&gt; class by our matrix-free implementation, which means that we can also skip the sparsity patterns. Notice that we define the LaplaceOperator class with the degree of finite element as template argument (the value is defined at the top of the file), and that we use float numbers for the multigrid level matrices.</p>
<p>The class also has a member variable to keep track of all the time we spend on setting up the entire chain of data before we actually go about solving the problem. In addition, there is an output stream (that is disabled by default) that can be used to output details for the individual setup operations instead of the summary only that is printed out by default.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keyword">class </span>LaplaceProblem</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  LaplaceProblem ();</div>
<div class="line">  <span class="keywordtype">void</span> run ();</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keywordtype">void</span> setup_system ();</div>
<div class="line">  <span class="keywordtype">void</span> assemble_system ();</div>
<div class="line">  <span class="keywordtype">void</span> assemble_multigrid ();</div>
<div class="line">  <span class="keywordtype">void</span> solve ();</div>
<div class="line">  <span class="keywordtype">void</span> output_results (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle) <span class="keyword">const</span>;</div>
<div class="line"></div>
<div class="line">  <span class="keyword">typedef</span> LaplaceOperator&lt;dim,degree_finite_element,double&gt; SystemMatrixType;</div>
<div class="line">  <span class="keyword">typedef</span> LaplaceOperator&lt;dim,degree_finite_element,float&gt;  LevelMatrixType;</div>
<div class="line"></div>
<div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a>               triangulation;</div>
<div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>                        fe;</div>
<div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>                  dof_handler;</div>
<div class="line">  <a class="code" href="classConstraintMatrix.html">ConstraintMatrix</a>                 constraints;</div>
<div class="line"></div>
<div class="line">  SystemMatrixType                 system_matrix;</div>
<div class="line">  <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;LevelMatrixType&gt;</a>   mg_matrices;</div>
<div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;float&gt;</a>                coarse_matrix;</div>
<div class="line">  <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;ConstraintMatrix&gt;</a>  mg_constraints;</div>
<div class="line"></div>
<div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>                   solution;</div>
<div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>                   system_rhs;</div>
<div class="line"></div>
<div class="line">  <span class="keywordtype">double</span>                           setup_time;</div>
<div class="line">  <a class="code" href="classConditionalOStream.html">ConditionalOStream</a>               time_details;</div>
<div class="line">};</div>
</div><!-- fragment --><p>When we initialize the finite element, we of course have to use the degree specified at the top of the file as well (otherwise, an exception will be thrown at some point, since the computational kernel defined in the templated LaplaceOperator class and the information from the finite element read out by <a class="el" href="classMatrixFree.html">MatrixFree</a> will not match).</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">LaplaceProblem&lt;dim&gt;::LaplaceProblem ()</div>
<div class="line">  :</div>
<div class="line">  fe (degree_finite_element),</div>
<div class="line">  dof_handler (triangulation),</div>
<div class="line">  time_details (std::cout, false)</div>
<div class="line">{}</div>
</div><!-- fragment --><p><a class="anchor" id="LaplaceProblemsetup_system"></a> </p>
<h4>LaplaceProblem::setup_system</h4>
<p>This is the function of <a class="el" href="step_16.html">step-16</a> with relevant changes due to the LaplaceOperator class. We do not use adaptive grids, so we do not have to compute edge matrices. Thus, all we do is to implement Dirichlet boundary conditions through the <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a>, set up the (one-dimensional) quadrature that should be used by the matrix-free class, and call the initialization functions.</p>
<p>In the process, we output data on both the run time of the program as well as on memory consumption, where we output memory data in megabytes (1 million bytes).</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::setup_system ()</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classTimer.html">Timer</a> time;</div>
<div class="line">  time.<a class="code" href="classTimer.html#a3a8b5272198d029779dc9302a54305a8">start</a> ();</div>
<div class="line">  setup_time = 0;</div>
<div class="line"></div>
<div class="line">  system_matrix.clear();</div>
<div class="line">  mg_matrices.clear();</div>
<div class="line">  mg_constraints.clear();</div>
<div class="line"></div>
<div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#afcfcc3b473f444f50d206ae62dfe3694">distribute_dofs</a> (fe);</div>
<div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a3e864b78dbc0a07e771768e5ae209cff">distribute_mg_dofs</a> (fe);</div>
<div class="line"></div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Number of degrees of freedom: &quot;</span></div>
<div class="line">            &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#a54e7270f2ba6206604f794114b39a2aa">n_dofs</a>()</div>
<div class="line">            &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line">  constraints.<a class="code" href="classConstraintMatrix.html#a24120d0331183f9a63cbe41493a19f6b">clear</a>();</div>
<div class="line">  <a class="code" href="namespaceVectorTools.html#a199f38e07822b47e5b5957c21ce35d1b">VectorTools::interpolate_boundary_values</a> (dof_handler,</div>
<div class="line">                                            0,</div>
<div class="line">                                            <a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a>(),</div>
<div class="line">                                            constraints);</div>
<div class="line">  constraints.<a class="code" href="classConstraintMatrix.html#a8056d07faa2a7ed3f158c1b42d56abc8">close</a>();</div>
<div class="line">  setup_time += time.<a class="code" href="classTimer.html#ac4e81ca4d1e1274363ce4e6d70a8aba5">wall_time</a>();</div>
<div class="line">  time_details &lt;&lt; <span class="stringliteral">&quot;Distribute DoFs &amp; B.C.     (CPU/wall) &quot;</span></div>
<div class="line">               &lt;&lt; time() &lt;&lt; <span class="stringliteral">&quot;s/&quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#ac4e81ca4d1e1274363ce4e6d70a8aba5">wall_time</a>() &lt;&lt; <span class="stringliteral">&quot;s&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  time.<a class="code" href="classTimer.html#aa3f7871196bb56202af2bc982bfbfff6">restart</a>();</div>
<div class="line"></div>
<div class="line">  system_matrix.reinit (dof_handler, constraints);</div>
<div class="line">  std::cout.precision(4);</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;System matrix memory consumption:     &quot;</span></div>
<div class="line">            &lt;&lt; system_matrix.memory_consumption()*1e-6</div>
<div class="line">            &lt;&lt; <span class="stringliteral">&quot; MB.&quot;</span></div>
<div class="line">            &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line">  solution.<a class="code" href="classVector.html#ac3adfcf8cf35943558fc27ef989b7263">reinit</a> (dof_handler.<a class="code" href="classDoFHandler.html#a54e7270f2ba6206604f794114b39a2aa">n_dofs</a>());</div>
<div class="line">  system_rhs.<a class="code" href="classBlockVector.html#a4caa9be7a7053fd6ae9fac1da74e564b">reinit</a> (dof_handler.<a class="code" href="classDoFHandler.html#a54e7270f2ba6206604f794114b39a2aa">n_dofs</a>());</div>
<div class="line"></div>
<div class="line">  setup_time += time.<a class="code" href="classTimer.html#ac4e81ca4d1e1274363ce4e6d70a8aba5">wall_time</a>();</div>
<div class="line">  time_details &lt;&lt; <span class="stringliteral">&quot;Setup matrix-free system   (CPU/wall) &quot;</span></div>
<div class="line">               &lt;&lt; time() &lt;&lt; <span class="stringliteral">&quot;s/&quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#ac4e81ca4d1e1274363ce4e6d70a8aba5">wall_time</a>() &lt;&lt; <span class="stringliteral">&quot;s&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  time.<a class="code" href="classTimer.html#aa3f7871196bb56202af2bc982bfbfff6">restart</a>();</div>
</div><!-- fragment --><p>Next, initialize the matrices for the multigrid method on all the levels. The function <a class="el" href="namespaceMGTools.html#ac2b927637a50289ecf80aea74c75f850">MGTools::make_boundary_list</a> returns for each multigrid level which degrees of freedom are located on a Dirichlet boundary; we force these DoFs to have value zero by adding to the <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> object a zero condition by using the command <a class="el" href="classConstraintMatrix.html#a24eb022f65797389badbb6d21da5b708">ConstraintMatrix::add_line</a>. Once this is done, we close the <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> on each level so it can be used to read out indices internally in the <a class="el" href="classMatrixFree.html">MatrixFree</a>.</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nlevels = triangulation.<a class="code" href="classTriangulation.html#ad966e087386ee0330371ebd73f2cfe99">n_levels</a>();</div>
<div class="line">  mg_matrices.resize(0, nlevels-1);</div>
<div class="line">  mg_constraints.resize (0, nlevels-1);</div>
<div class="line"></div>
<div class="line">  <span class="keyword">typename</span> <a class="code" href="structFunctionMap.html#aa286a6c5e13045f84faabfd7170b1c48">FunctionMap&lt;dim&gt;::type</a> dirichlet_boundary;</div>
<div class="line">  <a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a>               homogeneous_dirichlet_bc (1);</div>
<div class="line">  dirichlet_boundary[0] = &amp;homogeneous_dirichlet_bc;</div>
<div class="line">  std::vector&lt;std::set&lt;types::global_dof_index&gt; &gt; boundary_indices(triangulation.<a class="code" href="classTriangulation.html#ad966e087386ee0330371ebd73f2cfe99">n_levels</a>());</div>
<div class="line">  <a class="code" href="namespaceMGTools.html#ac2b927637a50289ecf80aea74c75f850">MGTools::make_boundary_list</a> (dof_handler,</div>
<div class="line">                               dirichlet_boundary,</div>
<div class="line">                               boundary_indices);</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level=0; level&lt;nlevels; ++level)</div>
<div class="line">    {</div>
<div class="line">      std::set&lt;types::global_dof_index&gt;::iterator bc_it = boundary_indices[level].begin();</div>
<div class="line">      <span class="keywordflow">for</span> ( ; bc_it != boundary_indices[level].end(); ++bc_it)</div>
<div class="line">        mg_constraints[level].add_line(*bc_it);</div>
<div class="line"></div>
<div class="line">      mg_constraints[level].close();</div>
<div class="line">      mg_matrices[level].reinit(dof_handler,</div>
<div class="line">                                mg_constraints[level],</div>
<div class="line">                                level);</div>
<div class="line">    }</div>
<div class="line">  coarse_matrix.<a class="code" href="classTableBase.html#aa1057871726271c6c04b7ae0738e0cfa">reinit</a> (dof_handler.<a class="code" href="classDoFHandler.html#a54e7270f2ba6206604f794114b39a2aa">n_dofs</a>(0),</div>
<div class="line">                        dof_handler.<a class="code" href="classDoFHandler.html#a54e7270f2ba6206604f794114b39a2aa">n_dofs</a>(0));</div>
<div class="line">  setup_time += time.<a class="code" href="classTimer.html#ac4e81ca4d1e1274363ce4e6d70a8aba5">wall_time</a>();</div>
<div class="line">  time_details &lt;&lt; <span class="stringliteral">&quot;Setup matrix-free levels   (CPU/wall) &quot;</span></div>
<div class="line">               &lt;&lt; time() &lt;&lt; <span class="stringliteral">&quot;s/&quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#ac4e81ca4d1e1274363ce4e6d70a8aba5">wall_time</a>() &lt;&lt; <span class="stringliteral">&quot;s&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="LaplaceProblemassemble_system"></a> </p>
<h4>LaplaceProblem::assemble_system</h4>
<p>The assemble function is significantly reduced compared to <a class="el" href="step_16.html">step-16</a>. All we need to do is to assemble the right hand side. That is the same as in many other tutorial programs. In the end, we condense the constraints from Dirichlet boundary conditions away from the right hand side.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::assemble_system ()</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classTimer.html">Timer</a> time;</div>
<div class="line">  <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>  quadrature_formula(fe.degree+1);</div>
<div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values (fe, quadrature_formula,</div>
<div class="line">                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>   | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div>
<div class="line"></div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   dofs_per_cell = fe.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>;</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#a4d64837b1d374e9c46f07af8f094b29b">size</a>();</div>
<div class="line"></div>
<div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices (dofs_per_cell);</div>
<div class="line"></div>
<div class="line">  <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> cell = dof_handler.<a class="code" href="classDoFHandler.html#a6f2aa9c61385cbb749ed3d2e7bfe3de1">begin_active</a>(),</div>
<div class="line">                                                 endc = dof_handler.<a class="code" href="classDoFHandler.html#abf64c3734383b6fb1bed4888935f2edf">end</a>();</div>
<div class="line">  <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div>
<div class="line">    {</div>
<div class="line">      cell-&gt;get_dof_indices (local_dof_indices);</div>
<div class="line">      fe_values.<a class="code" href="classFEValues.html#afde502903642c57ade24dfcebf5c1650">reinit</a> (cell);</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div>
<div class="line">        {</div>
<div class="line">          <span class="keywordtype">double</span> rhs_val = 0;</div>
<div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_q_points; ++q)</div>
<div class="line">            rhs_val += (fe_values.<a class="code" href="classFEValuesBase.html#abe4de48ff59778bb82a0ec13037804aa">shape_value</a>(i,q) * 1.0 *</div>
<div class="line">                        fe_values.<a class="code" href="classFEValuesBase.html#ad097580a2f71878695096cc73b271b9d">JxW</a>(q));</div>
<div class="line">          system_rhs(local_dof_indices[i]) += rhs_val;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">  constraints.<a class="code" href="classConstraintMatrix.html#a66337316e8fbbc786c9f0383d085ab01">condense</a>(system_rhs);</div>
<div class="line">  setup_time += time.<a class="code" href="classTimer.html#ac4e81ca4d1e1274363ce4e6d70a8aba5">wall_time</a>();</div>
<div class="line">  time_details &lt;&lt; <span class="stringliteral">&quot;Assemble right hand side   (CPU/wall) &quot;</span></div>
<div class="line">               &lt;&lt; time() &lt;&lt; <span class="stringliteral">&quot;s/&quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#ac4e81ca4d1e1274363ce4e6d70a8aba5">wall_time</a>() &lt;&lt; <span class="stringliteral">&quot;s&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="LaplaceProblemassemble_multigrid"></a> </p>
<h4>LaplaceProblem::assemble_multigrid</h4>
<p>Here is another assemble function. Again, it is simpler than assembling matrices. We need to compute the diagonal of the Laplace matrices on the individual levels, send the final matrices to the LaplaceOperator class, and we need to compute the full matrix on the coarsest level (since that is inverted exactly in the deal.II multigrid implementation).</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::assemble_multigrid ()</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classTimer.html">Timer</a> time;</div>
<div class="line">  coarse_matrix = 0;</div>
<div class="line">  <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>  quadrature_formula(fe.degree+1);</div>
<div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values (fe, quadrature_formula,</div>
<div class="line">                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>  | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fac654119724aff0c394743170ae949d18">update_inverse_jacobians</a> |</div>
<div class="line">                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div>
<div class="line"></div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   dofs_per_cell = fe.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>;</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#a4d64837b1d374e9c46f07af8f094b29b">size</a>();</div>
<div class="line"></div>
<div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices (dofs_per_cell);</div>
<div class="line">  <span class="keyword">const</span> Coefficient&lt;dim&gt;    coefficient;</div>
<div class="line">  std::vector&lt;double&gt;       coefficient_values (n_q_points);</div>
<div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>        local_matrix (dofs_per_cell, dofs_per_cell);</div>
<div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>            local_diagonal (dofs_per_cell);</div>
<div class="line"></div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_levels = triangulation.<a class="code" href="classTriangulation.html#ad966e087386ee0330371ebd73f2cfe99">n_levels</a>();</div>
<div class="line">  std::vector&lt;Vector&lt;float&gt; &gt; diagonals (n_levels);</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level=0; level&lt;n_levels; ++level)</div>
<div class="line">    diagonals[level].reinit (dof_handler.<a class="code" href="classDoFHandler.html#a54e7270f2ba6206604f794114b39a2aa">n_dofs</a>(level));</div>
<div class="line"></div>
<div class="line">  std::vector&lt;unsigned int&gt; cell_no(triangulation.<a class="code" href="classTriangulation.html#ad966e087386ee0330371ebd73f2cfe99">n_levels</a>());</div>
<div class="line">  <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::cell_iterator</a> cell = dof_handler.<a class="code" href="classDoFHandler.html#a0f72091ff71f88c939915dd0d76df4a1">begin</a>(),</div>
<div class="line">                                          endc = dof_handler.<a class="code" href="classDoFHandler.html#abf64c3734383b6fb1bed4888935f2edf">end</a>();</div>
<div class="line">  <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div>
<div class="line">    {</div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = cell-&gt;level();</div>
<div class="line">      cell-&gt;get_mg_dof_indices (local_dof_indices);</div>
<div class="line">      fe_values.<a class="code" href="classFEValues.html#afde502903642c57ade24dfcebf5c1650">reinit</a> (cell);</div>
<div class="line">      coefficient.value_list (fe_values.<a class="code" href="classFEValuesBase.html#a5f8732ebe2d3c6746f6de26a79cb1e45">get_quadrature_points</a>(),</div>
<div class="line">                              coefficient_values);</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div>
<div class="line">        {</div>
<div class="line">          <span class="keywordtype">double</span> local_diag = 0;</div>
<div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_q_points; ++q)</div>
<div class="line">            local_diag += ((fe_values.<a class="code" href="classFEValuesBase.html#ac4cee7628c2903a89c5c399fddeb00a5">shape_grad</a>(i,q) *</div>
<div class="line">                            fe_values.<a class="code" href="classFEValuesBase.html#ac4cee7628c2903a89c5c399fddeb00a5">shape_grad</a>(i,q)) *</div>
<div class="line">                           coefficient_values[q] * fe_values.<a class="code" href="classFEValuesBase.html#ad097580a2f71878695096cc73b271b9d">JxW</a>(q));</div>
<div class="line">          local_diagonal(i) = local_diag;</div>
<div class="line">        }</div>
<div class="line">      mg_constraints[level].distribute_local_to_global(local_diagonal,</div>
<div class="line">                                                       local_dof_indices,</div>
<div class="line">                                                       diagonals[level]);</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (level == 0)</div>
<div class="line">        {</div>
<div class="line">          local_matrix = 0;</div>
<div class="line"></div>
<div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div>
<div class="line">              {</div>
<div class="line">                <span class="keywordtype">double</span> add_value = 0;</div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_q_points; ++q)</div>
<div class="line">                  add_value += (fe_values.<a class="code" href="classFEValuesBase.html#ac4cee7628c2903a89c5c399fddeb00a5">shape_grad</a>(i,q) *</div>
<div class="line">                                fe_values.<a class="code" href="classFEValuesBase.html#ac4cee7628c2903a89c5c399fddeb00a5">shape_grad</a>(j,q) *</div>
<div class="line">                                coefficient_values[q] *</div>
<div class="line">                                fe_values.<a class="code" href="classFEValuesBase.html#ad097580a2f71878695096cc73b271b9d">JxW</a>(q));</div>
<div class="line">                local_matrix(i,j) = add_value;</div>
<div class="line">              }</div>
<div class="line">          mg_constraints[0].distribute_local_to_global (local_matrix,</div>
<div class="line">                                                        local_dof_indices,</div>
<div class="line">                                                        coarse_matrix);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level=0; level&lt;n_levels; ++level)</div>
<div class="line">    mg_matrices[level].set_diagonal (diagonals[level]);</div>
<div class="line"></div>
<div class="line">  setup_time += time.<a class="code" href="classTimer.html#ac4e81ca4d1e1274363ce4e6d70a8aba5">wall_time</a>();</div>
<div class="line">  time_details &lt;&lt; <span class="stringliteral">&quot;Assemble MG diagonal       (CPU/wall) &quot;</span></div>
<div class="line">               &lt;&lt; time() &lt;&lt; <span class="stringliteral">&quot;s/&quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#ac4e81ca4d1e1274363ce4e6d70a8aba5">wall_time</a>() &lt;&lt; <span class="stringliteral">&quot;s&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="LaplaceProblemsolve"></a> </p>
<h4>LaplaceProblem::solve</h4>
<p>The solution process again looks like <a class="el" href="step_16.html">step-16</a>. We now use a Chebyshev smoother instead of SOR (SOR would be very difficult to implement because we do not have the matrix elements available explicitly, and it is difficult to make it work efficiently in parallel). The multigrid classes provide a simple interface for using the Chebyshev smoother which is defined in a preconditioner class: <a class="el" href="classMGSmootherPrecondition.html">MGSmootherPrecondition</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::solve ()</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classTimer.html">Timer</a> time;</div>
<div class="line">  <a class="code" href="classMGTransferPrebuilt.html">MGTransferPrebuilt&lt;Vector&lt;double&gt;</a> &gt; mg_transfer;</div>
<div class="line">  mg_transfer.<a class="code" href="classMGTransferPrebuilt.html#a58e346481bd8a8a9994bb8b5d5d9772a">build_matrices</a>(dof_handler);</div>
<div class="line">  setup_time += time.<a class="code" href="classTimer.html#ac4e81ca4d1e1274363ce4e6d70a8aba5">wall_time</a>();</div>
<div class="line">  time_details &lt;&lt; <span class="stringliteral">&quot;MG build transfer time     (CPU/wall) &quot;</span> &lt;&lt; time()</div>
<div class="line">               &lt;&lt; <span class="stringliteral">&quot;s/&quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#ac4e81ca4d1e1274363ce4e6d70a8aba5">wall_time</a>() &lt;&lt; <span class="stringliteral">&quot;s\n&quot;</span>;</div>
<div class="line">  time.<a class="code" href="classTimer.html#aa3f7871196bb56202af2bc982bfbfff6">restart</a>();</div>
<div class="line"></div>
<div class="line">  <a class="code" href="classMGCoarseGridHouseholder.html">MGCoarseGridHouseholder&lt;float, Vector&lt;double&gt;</a> &gt; mg_coarse;</div>
<div class="line">  mg_coarse.<a class="code" href="classMGCoarseGridHouseholder.html#a2790d07d059be92b2a7b608d1917e78e">initialize</a>(coarse_matrix);</div>
<div class="line">  setup_time += time.<a class="code" href="classTimer.html#ac4e81ca4d1e1274363ce4e6d70a8aba5">wall_time</a>();</div>
<div class="line">  time_details &lt;&lt; <span class="stringliteral">&quot;MG coarse time             (CPU/wall) &quot;</span> &lt;&lt; time()</div>
<div class="line">               &lt;&lt; <span class="stringliteral">&quot;s/&quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#ac4e81ca4d1e1274363ce4e6d70a8aba5">wall_time</a>() &lt;&lt; <span class="stringliteral">&quot;s\n&quot;</span>;</div>
<div class="line">  time.<a class="code" href="classTimer.html#aa3f7871196bb56202af2bc982bfbfff6">restart</a>();</div>
<div class="line"></div>
<div class="line">  <span class="keyword">typedef</span> <a class="code" href="classPreconditionChebyshev.html">PreconditionChebyshev&lt;LevelMatrixType,Vector&lt;double&gt;</a> &gt; SMOOTHER;</div>
<div class="line">  <a class="code" href="classMGSmootherPrecondition.html">MGSmootherPrecondition&lt;LevelMatrixType, SMOOTHER, Vector&lt;double&gt;</a> &gt;</div>
<div class="line">  mg_smoother;</div>
</div><!-- fragment --><p>Then, we initialize the smoother with our level matrices and the mandatory additional data for the Chebyshev smoother. We use quite a high degree here (6), since matrix-vector products are comparably cheap and more parallel than the level-transfer operations. We choose to smooth out a range of <img class="formulaInl" alt="$[1.2 \hat{\lambda}_{\max}/10,1.2 \hat{\lambda}_{\max}]$" src="form_3078.png"/> in the smoother where <img class="formulaInl" alt="$\hat{\lambda}_{\max}$" src="form_3079.png"/> is an estimate of the largest eigenvalue. In order to compute that eigenvalue, the Chebyshev initializations performs a few steps of a CG algorithm without preconditioner. Since the highest eigenvalue is usually the easiest one to find and a rough estimate is enough, we choose 10 iterations.</p>
<div class="fragment"><div class="line"><span class="keyword">typename</span> SMOOTHER::AdditionalData smoother_data;</div>
<div class="line">smoother_data.smoothing_range = 10.;</div>
<div class="line">smoother_data.degree = 6;</div>
<div class="line">smoother_data.eig_cg_n_iterations = 10;</div>
<div class="line">mg_smoother.<a class="code" href="classMGSmootherPrecondition.html#ad615e8f1c011441b2a6f9d5d1a6f952f">initialize</a>(mg_matrices, smoother_data);</div>
<div class="line"></div>
<div class="line"><a class="code" href="classMGMatrix.html">MGMatrix&lt;LevelMatrixType, Vector&lt;double&gt;</a> &gt;</div>
<div class="line">mg_matrix(&amp;mg_matrices);</div>
<div class="line"></div>
<div class="line"><a class="code" href="classMultigrid.html">Multigrid&lt;Vector&lt;double&gt;</a> &gt; mg(dof_handler,</div>
<div class="line">                              mg_matrix,</div>
<div class="line">                              mg_coarse,</div>
<div class="line">                              mg_transfer,</div>
<div class="line">                              mg_smoother,</div>
<div class="line">                              mg_smoother);</div>
<div class="line"><a class="code" href="classPreconditionMG.html">PreconditionMG&lt;dim, Vector&lt;double&gt;</a>,</div>
<div class="line">               <a class="code" href="classMGTransferPrebuilt.html">MGTransferPrebuilt&lt;Vector&lt;double&gt;</a> &gt; &gt;</div>
<div class="line">               preconditioner(dof_handler, mg, mg_transfer);</div>
</div><!-- fragment --><p>Finally, write out the memory consumption of the <a class="el" href="classMultigrid.html">Multigrid</a> object (or rather, of its most significant components, since there is no built-in function for the total multigrid object), then create the solver object and solve the system. This is very easy, and we didn't even see any difference in the solve process compared to <a class="el" href="step_16.html">step-16</a>. The magic is all hidden behind the implementation of the LaplaceOperator::vmult operation. Note that we print out the solve time and the accumulated setup time through standard out, i.e., in any case, whereas detailed times for the setup operations are only printed in case the flag for detail_times in the constructor is changed.</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> std::size_t multigrid_memory</div>
<div class="line">    = (mg_matrices.memory_consumption() +</div>
<div class="line">       mg_transfer.<a class="code" href="classMGTransferPrebuilt.html#a99163d6072d3bbd7f81522a4ffcd9308">memory_consumption</a>() +</div>
<div class="line">       coarse_matrix.<a class="code" href="classFullMatrix.html#a175b03e4ae3fdfb6469e50d913b1042d">memory_consumption</a>());</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Multigrid objects memory consumption: &quot;</span></div>
<div class="line">            &lt;&lt; multigrid_memory * 1e-6</div>
<div class="line">            &lt;&lt; <span class="stringliteral">&quot; MB.&quot;</span></div>
<div class="line">            &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a>           solver_control (1000, 1e-12*system_rhs.<a class="code" href="classBlockVectorBase.html#a39191b8a99e917a95c8523f94c807a95">l2_norm</a>());</div>
<div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;&gt;</a>              cg (solver_control);</div>
<div class="line">  setup_time += time.<a class="code" href="classTimer.html#ac4e81ca4d1e1274363ce4e6d70a8aba5">wall_time</a>();</div>
<div class="line">  time_details &lt;&lt; <span class="stringliteral">&quot;MG build smoother time     (CPU/wall) &quot;</span> &lt;&lt; time()</div>
<div class="line">               &lt;&lt; <span class="stringliteral">&quot;s/&quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#ac4e81ca4d1e1274363ce4e6d70a8aba5">wall_time</a>() &lt;&lt; <span class="stringliteral">&quot;s\n&quot;</span>;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Total setup time               (wall) &quot;</span> &lt;&lt; setup_time</div>
<div class="line">            &lt;&lt; <span class="stringliteral">&quot;s\n&quot;</span>;</div>
<div class="line"></div>
<div class="line">  time.<a class="code" href="classTimer.html#a9020542d73357a4eef512eefaf57524b">reset</a>();</div>
<div class="line">  time.<a class="code" href="classTimer.html#a3a8b5272198d029779dc9302a54305a8">start</a>();</div>
<div class="line">  cg.solve (system_matrix, solution, system_rhs,</div>
<div class="line">            preconditioner);</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Time solve (&quot;</span></div>
<div class="line">            &lt;&lt; solver_control.last_step()</div>
<div class="line">            &lt;&lt; <span class="stringliteral">&quot; iterations)  (CPU/wall) &quot;</span> &lt;&lt; time() &lt;&lt; <span class="stringliteral">&quot;s/&quot;</span></div>
<div class="line">            &lt;&lt; time.<a class="code" href="classTimer.html#ac4e81ca4d1e1274363ce4e6d70a8aba5">wall_time</a>() &lt;&lt; <span class="stringliteral">&quot;s\n&quot;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="LaplaceProblemoutput_results"></a> </p>
<h4>LaplaceProblem::output_results</h4>
<p>Here is the data output, which is a simplified version of <a class="el" href="step_5.html">step-5</a>. We use the standard VTU (= compressed VTK) output for each grid produced in the refinement process.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::output_results (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div>
<div class="line"></div>
<div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a5e63bad650805ce93cd74c6dc3b29b11">attach_dof_handler</a> (dof_handler);</div>
<div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a59a6b70a4b909e0229a20487dd68cc43">add_data_vector</a> (solution, <span class="stringliteral">&quot;solution&quot;</span>);</div>
<div class="line">  data_out.<a class="code" href="classDataOut.html#ab3d44201acb97fba286a897452236b51">build_patches</a> ();</div>
<div class="line"></div>
<div class="line">  std::ostringstream filename;</div>
<div class="line">  filename &lt;&lt; <span class="stringliteral">&quot;solution-&quot;</span></div>
<div class="line">           &lt;&lt; cycle</div>
<div class="line">           &lt;&lt; <span class="stringliteral">&quot;.vtu&quot;</span>;</div>
<div class="line"></div>
<div class="line">  std::ofstream output (filename.str().c_str());</div>
<div class="line">  data_out.<a class="code" href="classDataOutInterface.html#a91f8a3e092130d7f44838729dca458ea">write_vtu</a> (output);</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="LaplaceProblemrun"></a> </p>
<h4>LaplaceProblem::run</h4>
<p>The function that runs the program is very similar to the one in <a class="el" href="step_16.html">step-16</a>. We make less refinement steps in 3D compared to 2D, but that's it.</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::run ()</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle=0; cycle&lt;9-dim; ++cycle)</div>
<div class="line">      {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (cycle == 0)</div>
<div class="line">          {</div>
<div class="line">            <a class="code" href="namespaceGridGenerator.html#a7149c59cefa805a132177cfa6cb953bd">GridGenerator::hyper_cube</a> (triangulation, 0., 1.);</div>
<div class="line">            triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a> (3-dim);</div>
<div class="line">          }</div>
<div class="line">        triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a> (1);</div>
<div class="line">        setup_system ();</div>
<div class="line">        assemble_system ();</div>
<div class="line">        assemble_multigrid ();</div>
<div class="line">        solve ();</div>
<div class="line">        output_results (cycle);</div>
<div class="line">        std::cout &lt;&lt; std::endl;</div>
<div class="line">      };</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="Thecodemaincodefunction"></a> </p>
<h3>The <code>main</code> function</h3>
<p>This is as in most other programs.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code" href="group__ParameterGui.html#ga0ddf1224851353fc92bfbff6f499fa97">main</a> ()</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">try</span></div>
<div class="line">    {</div>
<div class="line">      <span class="keyword">using namespace </span>Step37;</div>
<div class="line"></div>
<div class="line">      deallog.<a class="code" href="classLogStream.html#a8028e970ad8388596d625ed463894e98">depth_console</a>(0);</div>
<div class="line">      LaplaceProblem&lt;dimension&gt; laplace_problem;</div>
<div class="line">      laplace_problem.run ();</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div>
<div class="line">    {</div>
<div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">catch</span> (...)</div>
<div class="line">    {</div>
<div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p> <a class="anchor" id="Results"></a></p>
<h1>Results</h1>
<p><a class="anchor" id="Programoutput"></a></p>
<h3>Program output</h3>
<p>Since this example solves the same problem as <a class="el" href="step_5.html">step-5</a> (except for a different coefficient), there is little to say about the solution. We show a picture anyway, illustrating the size of the solution through both isocontours and volume rendering:</p>
<div class="image">
<img src="images/step-37.solution.png" />
</div>
<p>Of more interest is to evaluate some aspects of the multigrid solver. When we run this program in 2D for quadratic ( <img class="formulaInl" alt="$Q_2$" src="form_622.png"/>) elements, we get the following output: </p>
<div class="fragment"><div class="line">Cycle 0</div>
<div class="line">Number of degrees of freedom: 81</div>
<div class="line">System matrix memory consumption:     0.008982 MB.</div>
<div class="line">Multigrid objects memory consumption: 0.02617 MB.</div>
<div class="line">Total setup time               (wall) 0.001811s</div>
<div class="line">Time solve (5 iterations)  (CPU/wall) 0s/0.0002651s</div>
<div class="line"></div>
<div class="line">Cycle 1</div>
<div class="line">Number of degrees of freedom: 289</div>
<div class="line">System matrix memory consumption:     0.01817 MB.</div>
<div class="line">Multigrid objects memory consumption: 0.05779 MB.</div>
<div class="line">Total setup time               (wall) 0.001223s</div>
<div class="line">Time solve (5 iterations)  (CPU/wall) 0s/0.000926s</div>
<div class="line"></div>
<div class="line">Cycle 2</div>
<div class="line">Number of degrees of freedom: 1089</div>
<div class="line">System matrix memory consumption:     0.05286 MB.</div>
<div class="line">Multigrid objects memory consumption: 0.1581 MB.</div>
<div class="line">Total setup time               (wall) 0.003045s</div>
<div class="line">Time solve (6 iterations)  (CPU/wall) 0.012s/0.003393s</div>
<div class="line"></div>
<div class="line">Cycle 3</div>
<div class="line">Number of degrees of freedom: 4225</div>
<div class="line">System matrix memory consumption:     0.1957 MB.</div>
<div class="line">Multigrid objects memory consumption: 0.5228 MB.</div>
<div class="line">Total setup time               (wall) 0.008561s</div>
<div class="line">Time solve (6 iterations)  (CPU/wall) 0.02s/0.01133s</div>
<div class="line"></div>
<div class="line">Cycle 4</div>
<div class="line">Number of degrees of freedom: 16641</div>
<div class="line">System matrix memory consumption:     0.7343 MB.</div>
<div class="line">Multigrid objects memory consumption: 1.925 MB.</div>
<div class="line">Total setup time               (wall) 0.02938s</div>
<div class="line">Time solve (6 iterations)  (CPU/wall) 0.068s/0.03312s</div>
<div class="line"></div>
<div class="line">Cycle 5</div>
<div class="line">Number of degrees of freedom: 66049</div>
<div class="line">System matrix memory consumption:     2.856 MB.</div>
<div class="line">Multigrid objects memory consumption: 7.435 MB.</div>
<div class="line">Total setup time               (wall) 0.1128s</div>
<div class="line">Time solve (6 iterations)  (CPU/wall) 0.228s/0.09577s</div>
<div class="line"></div>
<div class="line">Cycle 6</div>
<div class="line">Number of degrees of freedom: 263169</div>
<div class="line">System matrix memory consumption:     11.28 MB.</div>
<div class="line">Multigrid objects memory consumption: 29.3 MB.</div>
<div class="line">Total setup time               (wall) 0.4553s</div>
<div class="line">Time solve (6 iterations)  (CPU/wall) 1.272s/0.3955s</div>
</div><!-- fragment --><p>As in <a class="el" href="step_16.html">step-16</a>, we see that the number of CG iterations remains constant with increasing number of degrees of freedom. We can also see that the various objects we have to store for the multigrid method on the individual levels of our mesh together make up more than twice as much as the matrix on the finest level. For the present example, about half the memory consumption of the multigrid objects are the level transfer matrices, and the other half is consumed by the matrix-free objects (and there, mainly the indices and the variable coefficient).</p>
<p>Not much changes if we run the program in three spatial dimensions, with the exception that the multilevel objects now take up some more memory (because the level transfer matrices are denser) and the computing times are somewhat larger:</p>
<div class="fragment"><div class="line">Cycle 0</div>
<div class="line">Number of degrees of freedom: 125</div>
<div class="line">System matrix memory consumption:     0.01093 MB.</div>
<div class="line">Multigrid objects memory consumption: 0.03094 MB.</div>
<div class="line">Total setup time               (wall) 0.002481s</div>
<div class="line">Time solve (5 iterations)  (CPU/wall) 0s/0.000334s</div>
<div class="line"></div>
<div class="line">Cycle 1</div>
<div class="line">Number of degrees of freedom: 729</div>
<div class="line">System matrix memory consumption:     0.04105 MB.</div>
<div class="line">Multigrid objects memory consumption: 0.1274 MB.</div>
<div class="line">Total setup time               (wall) 0.004471s</div>
<div class="line">Time solve (5 iterations)  (CPU/wall) 0.004s/0.001979s</div>
<div class="line"></div>
<div class="line">Cycle 2</div>
<div class="line">Number of degrees of freedom: 4913</div>
<div class="line">System matrix memory consumption:     0.2821 MB.</div>
<div class="line">Multigrid objects memory consumption: 0.8048 MB.</div>
<div class="line">Total setup time               (wall) 0.01651s</div>
<div class="line">Time solve (4 iterations)  (CPU/wall) 0.036s/0.01295s</div>
<div class="line"></div>
<div class="line">Cycle 3</div>
<div class="line">Number of degrees of freedom: 35937</div>
<div class="line">System matrix memory consumption:     1.948 MB.</div>
<div class="line">Multigrid objects memory consumption: 5.734 MB.</div>
<div class="line">Total setup time               (wall) 0.1072s</div>
<div class="line">Time solve (5 iterations)  (CPU/wall) 0.16s/0.0709s</div>
<div class="line"></div>
<div class="line">Cycle 4</div>
<div class="line">Number of degrees of freedom: 274625</div>
<div class="line">System matrix memory consumption:     14.49 MB.</div>
<div class="line">Multigrid objects memory consumption: 44.41 MB.</div>
<div class="line">Total setup time               (wall) 0.8173s</div>
<div class="line">Time solve (5 iterations)  (CPU/wall) 1.52s/0.5093s</div>
<div class="line"></div>
<div class="line">Cycle 5</div>
<div class="line">Number of degrees of freedom: 2146689</div>
<div class="line">System matrix memory consumption:     115.9 MB.</div>
<div class="line">Multigrid objects memory consumption: 342.6 MB.</div>
<div class="line">Total setup time               (wall) 6.387s</div>
<div class="line">Time solve (5 iterations)  (CPU/wall) 12.45s/3.767s</div>
</div><!-- fragment --><p><a class="anchor" id="Comparisonwithasparsematrix"></a></p>
<h3>Comparison with a sparse matrix</h3>
<p>In order to understand the capabilities of the matrix-free implementation, we compare the performance on the 3d example above with a <a class="el" href="classSparseMatrix.html">SparseMatrix</a> implementation and we measure the computation times for both initialization of the problem (distribute DoFs, setup and assemble matrices, setup multigrid structures) and the actual solution for the matrix-free variant and the variant based on sparse matrices. We base the preconditioner on float numbers and the actual matrix and vectors on double numbers, as shown above. Tests are run on an Intel Core i7-2620M notebook processor (two cores and <a href="http://en.wikipedia.org/wiki/Advanced_Vector_Extensions">AVX</a> support, i.e., four operations on doubles can be done with one CPU instruction, which is heavily used in <a class="el" href="classFEEvaluation.html">FEEvaluation</a>) and optimized mode. The example makes use of multithreading, so both cores are actually used.</p>
<table  align="center" border="1">
<tr>
<th>&#160; </th><th colspan="2">Sparse matrix </th><th colspan="2">Matrix-free implementation  </th></tr>
<tr>
<th>n_dofs </th><th>Setup + assemble </th><th>&#160;Solve&#160; </th><th>Setup + assemble </th><th>&#160;Solve&#160;  </th></tr>
<tr>
<td align="right">125 </td><td align="center">0.0048s </td><td align="center">0.00075s </td><td align="center">0.0025s </td><td align="center">0.00033s  </td></tr>
<tr>
<td align="right">729 </td><td align="center">0.014s </td><td align="center">0.0022s </td><td align="center">0.0026s </td><td align="center">0.0018s  </td></tr>
<tr>
<td align="right">4,913 </td><td align="center">0.10s </td><td align="center">0.012s </td><td align="center">0.017s </td><td align="center">0.013s  </td></tr>
<tr>
<td align="right">35,937 </td><td align="center">0.80s </td><td align="center">0.14s </td><td align="center">0.11s </td><td align="center">0.071s  </td></tr>
<tr>
<td align="right">274,625 </td><td align="center">5.93s </td><td align="center">1.05s </td><td align="center">0.82s </td><td align="center">0.51s  </td></tr>
<tr>
<td align="right">2,146,689 </td><td align="center">46.7s </td><td align="center">8.44s </td><td align="center">6.39s </td><td align="center">3.77s  </td></tr>
</table>
<p>The table clearly shows that the matrix-free implementation is twice as fast for the solver, and more than six times as fast when it comes to initialization costs. As the problem size is made a factor 8 larger, we note that the times usually go up by a factor eight, too (as the solver iterations are constant at 5). There are two deviations. The first is in the sparse matrix between 5k and 36k degrees of freedom, where the time increases by a factor 12. This is the threshold when the cache in the processor can no longer hold all data necessary for the matrix-vector products and all matrix elements must be fetched from main memory. The second deviation is the times for the matrix-free solve which increase by less than a factor 8. This is because of more parallelism from more cells, exploited by the (involved) dynamic task scheduling approach taken in the cell loop of the <a class="el" href="classMatrixFree.html">MatrixFree</a> class. Note that about 30% of the time in the matrix-free solver is spent on restriction and prolongation, which use sparse matrices. So the speedup could be even better if all parts were done efficiently.</p>
<p>Of course, this picture does not necessarily translate to all cases, as there are problems where knowledge of matrix entries enables much better solvers (as happens when the coefficient is varying more strongly than in the above example). Moreover, it also depends on the computer system. The present system has good memory performance, so sparse matrices perform comparably well. Nonetheless, the matrix-free implementation gives a nice speedup already for the <em>Q</em><sub>2</sub> elements used in this example. This becomes particularly apparent for time-dependent or nonlinear problems where sparse matrices would need to be reassembled over and over again, which becomes much easier with this class. And of course, thanks to the better complexity of the products, the method gains increasingly larger advantages when the order of the elements increases (the matrix-free implementation has costs 4<em>d</em><sup>2</sup><em>p</em> per degree of freedom, compared to 2<em>p<sup>d</sup></em> for the sparse matrix, so it will win anyway for order 4 and higher in 3d).</p>
<p><a class="anchor" id="Possibilitiesforextensions"></a></p>
<h3>Possibilities for extensions</h3>
<p>Above, we have shown figures for second-order finite elements. Our implementation gains more compared to sparse matrices if higher order elements are used. However, <a class="el" href="classFE__Q.html">FE_Q</a> elements with equidistant nodes are badly conditioned if the order increases. In this case, the smoother and the multigrid solver break down. Node clustering close to the element boundaries resolves this problem (and the multigrid solver converges in 5 or 6 iterations also for very high order). Elements with this properties are the Gauss-Lobatto <a class="el" href="classFE__Q.html">FE_Q</a> elements, which are presented in <a class="el" href="step_48.html">step-48</a>. <a class="anchor" id="PlainProg"></a> </p>
<h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div>
<div class="line"><span class="comment"> * @f$Id: @ref step_37 &quot;step-37&quot;.cc 31478 2013-10-29 10:09:48Z kronbichler @f$</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * Copyright (C) 2009 - 2013 by the deal.II authors</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div>
<div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div>
<div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div>
<div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div>
<div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE at</span></div>
<div class="line"><span class="comment"> * the top level of the deal.II distribution.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * Authors: Katharina Kormann, Martin Kronbichler, Uppsala University, 2009-2012</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/base/quadrature_lib.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/base/function.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/base/logstream.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/base/timer.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/lac/vector.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/lac/full_matrix.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/lac/solver_cg.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/lac/precondition.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_q.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_values.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_accessor.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_iterator.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_boundary_lib.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_generator.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/multigrid/multigrid.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/multigrid/mg_transfer.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/multigrid/mg_tools.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/multigrid/mg_coarse.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/multigrid/mg_smoother.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/multigrid/mg_matrix.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/data_out.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/vector_tools.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/matrix_free/matrix_free.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/matrix_free/fe_evaluation.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span>Step37</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">using namespace </span>dealii;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree_finite_element = 2;</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dimension = 3;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keyword">class </span>Coefficient : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div>
<div class="line">  {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    Coefficient ()  : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;() {}</div>
<div class="line"></div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>   &amp;p,</div>
<div class="line">                          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  component = 0) <span class="keyword">const</span>;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> number&gt;</div>
<div class="line">    number value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim,number&gt;</a> &amp;p,</div>
<div class="line">                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const</span>;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> value_list (<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &gt; &amp;points,</div>
<div class="line">                             std::vector&lt;double&gt;            &amp;values,</div>
<div class="line">                             <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>              component = 0) <span class="keyword">const</span>;</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> number&gt;</div>
<div class="line">  number Coefficient&lt;dim&gt;::value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim,number&gt;</a> &amp;p,</div>
<div class="line">                                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <span class="keywordflow">return</span> 1. / (0.05 + 2.*p.<a class="code" href="classPoint.html#ad46f55479010282e242b1d8e427285e8">square</a>());</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">double</span> Coefficient&lt;dim&gt;::value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>  &amp;p,</div>
<div class="line">                                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <span class="keywordflow">return</span> value&lt;double&gt;(p,component);</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> Coefficient&lt;dim&gt;::value_list (<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &gt; &amp;points,</div>
<div class="line">                                     std::vector&lt;double&gt;            &amp;values,</div>
<div class="line">                                     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>              component)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (values.size() == points.size(),</div>
<div class="line">            <a class="code" href="group__Exceptions.html#ga325fd73751a9373f1b901962daeb2ea7">ExcDimensionMismatch</a> (values.size(), points.size()));</div>
<div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (component == 0,</div>
<div class="line">            <a class="code" href="group__Exceptions.html#ga3f3f87a5613ac8b4e64ecd458dea8e9b">ExcIndexRange</a> (component, 0, 1));</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_points = points.size();</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;n_points; ++i)</div>
<div class="line">      values[i] = value&lt;double&gt;(points[i],component);</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div>
<div class="line">  <span class="keyword">class </span>LaplaceOperator : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div>
<div class="line">  {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    LaplaceOperator ();</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> clear();</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> reinit (<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>  &amp;dof_handler,</div>
<div class="line">                 <span class="keyword">const</span> <a class="code" href="classConstraintMatrix.html">ConstraintMatrix</a>  &amp;constraints,</div>
<div class="line">                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>      level = <a class="code" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>);</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> m () <span class="keyword">const</span>;</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n () <span class="keyword">const</span>;</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> vmult (<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;dst,</div>
<div class="line">                <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;src) <span class="keyword">const</span>;</div>
<div class="line">    <span class="keywordtype">void</span> Tvmult (<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;dst,</div>
<div class="line">                 <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;src) <span class="keyword">const</span>;</div>
<div class="line">    <span class="keywordtype">void</span> vmult_add (<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;dst,</div>
<div class="line">                    <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;src) <span class="keyword">const</span>;</div>
<div class="line">    <span class="keywordtype">void</span> Tvmult_add (<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;dst,</div>
<div class="line">                     <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;src) <span class="keyword">const</span>;</div>
<div class="line"></div>
<div class="line">    number el (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> row,</div>
<div class="line">               <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> col) <span class="keyword">const</span>;</div>
<div class="line">    <span class="keywordtype">void</span> set_diagonal (<span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;number&gt;</a> &amp;diagonal);</div>
<div class="line"></div>
<div class="line">    std::size_t <a class="code" href="namespaceMemoryConsumption.html#ac131e0968c353873300f677282378600">memory_consumption</a> () <span class="keyword">const</span>;</div>
<div class="line"></div>
<div class="line">  <span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">void</span> local_apply (<span class="keyword">const</span> <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim,number&gt;</a>    &amp;data,</div>
<div class="line">                      <a class="code" href="classVector.html">Vector&lt;double&gt;</a>                      &amp;dst,</div>
<div class="line">                      <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a>                &amp;src,</div>
<div class="line">                      <span class="keyword">const</span> std::pair&lt;unsigned int,unsigned int&gt; &amp;cell_range) <span class="keyword">const</span>;</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> evaluate_coefficient(<span class="keyword">const</span> Coefficient&lt;dim&gt; &amp;<span class="keyword">function</span>);</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim,number&gt;</a>      data;</div>
<div class="line">    <a class="code" href="classAlignedVector.html">AlignedVector&lt;VectorizedArray&lt;number&gt;</a> &gt; coefficient;</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classVector.html">Vector&lt;number&gt;</a>  diagonal_values;</div>
<div class="line">    <span class="keywordtype">bool</span>            diagonal_is_available;</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div>
<div class="line">  LaplaceOperator&lt;dim,fe_degree,number&gt;::LaplaceOperator ()</div>
<div class="line">    :</div>
<div class="line">    <a class="code" href="classSubscriptor.html">Subscriptor</a>()</div>
<div class="line">  {}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div>
<div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span></div>
<div class="line">  LaplaceOperator&lt;dim,fe_degree,number&gt;::m ()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <span class="keywordflow">return</span> data.<a class="code" href="classMatrixFree.html#a70b8d93c1f10d3d930cc82e0eb5ee025">get_vector_partitioner</a>()-&gt;size();</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div>
<div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span></div>
<div class="line">  LaplaceOperator&lt;dim,fe_degree,number&gt;::n ()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <span class="keywordflow">return</span> data.<a class="code" href="classMatrixFree.html#a70b8d93c1f10d3d930cc82e0eb5ee025">get_vector_partitioner</a>()-&gt;size();</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div>
<div class="line">  <span class="keywordtype">void</span></div>
<div class="line">  LaplaceOperator&lt;dim,fe_degree,number&gt;::clear ()</div>
<div class="line">  {</div>
<div class="line">    data.<a class="code" href="classMatrixFree.html#ada65411919b8f5cac76c36f7f510ccc9">clear</a>();</div>
<div class="line">    diagonal_is_available = <span class="keyword">false</span>;</div>
<div class="line">    diagonal_values.reinit(0);</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div>
<div class="line">  <span class="keywordtype">void</span></div>
<div class="line">  LaplaceOperator&lt;dim,fe_degree,number&gt;::reinit (<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>  &amp;dof_handler,</div>
<div class="line">                                                 <span class="keyword">const</span> <a class="code" href="classConstraintMatrix.html">ConstraintMatrix</a>  &amp;constraints,</div>
<div class="line">                                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>      level)</div>
<div class="line">  {</div>
<div class="line">    <span class="keyword">typename</span> <a class="code" href="structMatrixFree_1_1AdditionalData.html">MatrixFree&lt;dim,number&gt;::AdditionalData</a> additional_data;</div>
<div class="line">    additional_data.<a class="code" href="structMatrixFree_1_1AdditionalData.html#a2c5d05b92a9c51568b7fd6c70938007a">tasks_parallel_scheme</a> =</div>
<div class="line">      <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim,number&gt;::AdditionalData::partition_color</a>;</div>
<div class="line">    additional_data.<a class="code" href="structMatrixFree_1_1AdditionalData.html#a4393524200af9a9f7351f5166af9c41d">level_mg_handler</a> = level;</div>
<div class="line">    additional_data.<a class="code" href="structMatrixFree_1_1AdditionalData.html#a1ffc56a213bd3eb3c2654de6ee2c889a">mapping_update_flags</a> = (<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> |</div>
<div class="line">                                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div>
<div class="line">    data.<a class="code" href="classMatrixFree.html#a4b2b86483ad9ee30c1185310fce4aeec">reinit</a> (dof_handler, constraints, <a class="code" href="classQGauss.html">QGauss&lt;1&gt;</a>(fe_degree+1),</div>
<div class="line">                 additional_data);</div>
<div class="line">    evaluate_coefficient(Coefficient&lt;dim&gt;());</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div>
<div class="line">  <span class="keywordtype">void</span></div>
<div class="line">  LaplaceOperator&lt;dim,fe_degree,number&gt;::</div>
<div class="line">  evaluate_coefficient (<span class="keyword">const</span> Coefficient&lt;dim&gt; &amp;coefficient_function)</div>
<div class="line">  {</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_cells = data.<a class="code" href="classMatrixFree.html#afcababa3f89a9e27b85341074fcee075">n_macro_cells</a>();</div>
<div class="line">    <a class="code" href="classFEEvaluation.html">FEEvaluation&lt;dim,fe_degree,fe_degree+1,1,number&gt;</a> phi (data);</div>
<div class="line">    coefficient.resize (n_cells * phi.n_q_points);</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell=0; cell&lt;n_cells; ++cell)</div>
<div class="line">      {</div>
<div class="line">        phi.reinit (cell);</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;phi.n_q_points; ++q)</div>
<div class="line">          coefficient[cell*phi.n_q_points+q] =</div>
<div class="line">            coefficient_function.value(phi.quadrature_point(q));</div>
<div class="line">      }</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div>
<div class="line">  <span class="keywordtype">void</span></div>
<div class="line">  LaplaceOperator&lt;dim,fe_degree,number&gt;::</div>
<div class="line">  local_apply (<span class="keyword">const</span> <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim,number&gt;</a>         &amp;data,</div>
<div class="line">               <a class="code" href="classVector.html">Vector&lt;double&gt;</a>                       &amp;dst,</div>
<div class="line">               <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a>                 &amp;src,</div>
<div class="line">               <span class="keyword">const</span> std::pair&lt;unsigned int,unsigned int&gt; &amp;cell_range)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <a class="code" href="classFEEvaluation.html">FEEvaluation&lt;dim,fe_degree,fe_degree+1,1,number&gt;</a> phi (data);</div>
<div class="line">    <a class="code" href="group__Exceptions.html#ga9442b63275c9ef3fab29bc222831c49c">AssertDimension</a> (coefficient.size(), data.<a class="code" href="classMatrixFree.html#afcababa3f89a9e27b85341074fcee075">n_macro_cells</a>() * phi.n_q_points);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell=cell_range.first; cell&lt;cell_range.second; ++cell)</div>
<div class="line">      {</div>
<div class="line">        phi.reinit (cell);</div>
<div class="line">        phi.read_dof_values(src);</div>
<div class="line">        phi.evaluate (<span class="keyword">false</span>,<span class="keyword">true</span>,<span class="keyword">false</span>);</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;phi.n_q_points; ++q)</div>
<div class="line">          phi.submit_gradient (coefficient[cell*phi.n_q_points+q] *</div>
<div class="line">                               phi.get_gradient(q), q);</div>
<div class="line">        phi.integrate (<span class="keyword">false</span>,<span class="keyword">true</span>);</div>
<div class="line">        phi.distribute_local_to_global (dst);</div>
<div class="line">      }</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div>
<div class="line">  <span class="keywordtype">void</span></div>
<div class="line">  LaplaceOperator&lt;dim,fe_degree,number&gt;::vmult (<a class="code" href="classVector.html">Vector&lt;double&gt;</a>       &amp;dst,</div>
<div class="line">                                                <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;src)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    dst = 0;</div>
<div class="line">    vmult_add (dst, src);</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div>
<div class="line">  <span class="keywordtype">void</span></div>
<div class="line">  LaplaceOperator&lt;dim,fe_degree,number&gt;::Tvmult (<a class="code" href="classVector.html">Vector&lt;double&gt;</a>       &amp;dst,</div>
<div class="line">                                                 <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;src)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    dst = 0;</div>
<div class="line">    vmult_add (dst,src);</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div>
<div class="line">  <span class="keywordtype">void</span></div>
<div class="line">  LaplaceOperator&lt;dim,fe_degree,number&gt;::Tvmult_add (<a class="code" href="classVector.html">Vector&lt;double&gt;</a>       &amp;dst,</div>
<div class="line">                                                     <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;src)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    vmult_add (dst,src);</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div>
<div class="line">  <span class="keywordtype">void</span></div>
<div class="line">  LaplaceOperator&lt;dim,fe_degree,number&gt;::vmult_add (<a class="code" href="classVector.html">Vector&lt;double&gt;</a>       &amp;dst,</div>
<div class="line">                                                    <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;src)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    data.<a class="code" href="classMatrixFree.html#afcc5d69d8b3ac27ec73cb22e1d4b8614">cell_loop</a> (&amp;LaplaceOperator::local_apply, <span class="keyword">this</span>, dst, src);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> std::vector&lt;unsigned int&gt; &amp;</div>
<div class="line">    constrained_dofs = data.<a class="code" href="classMatrixFree.html#ac87bf2eb35ff9c5b6a5a6e977a15016f">get_constrained_dofs</a>();</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;constrained_dofs.size(); ++i)</div>
<div class="line">      dst(constrained_dofs[i]) += src(constrained_dofs[i]);</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div>
<div class="line">  number</div>
<div class="line">  LaplaceOperator&lt;dim,fe_degree,number&gt;::el (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> row,</div>
<div class="line">                                             <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> col)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (row == col, <a class="code" href="group__Exceptions.html#gac43116aa5c4896cb376bf817ee854e70">ExcNotImplemented</a>());</div>
<div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (diagonal_is_available == <span class="keyword">true</span>, <a class="code" href="group__Exceptions.html#ga6828fc99b1b7b1028785afba072c20c9">ExcNotInitialized</a>());</div>
<div class="line">    <span class="keywordflow">return</span> diagonal_values(row);</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div>
<div class="line">  <span class="keywordtype">void</span></div>
<div class="line">  LaplaceOperator&lt;dim,fe_degree,number&gt;::set_diagonal(<span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;number&gt;</a> &amp;diagonal)</div>
<div class="line">  {</div>
<div class="line">    <a class="code" href="group__Exceptions.html#ga9442b63275c9ef3fab29bc222831c49c">AssertDimension</a> (m(), diagonal.<a class="code" href="classVector.html#ad900ae86530d76f5fbff32c21c582b71">size</a>());</div>
<div class="line"></div>
<div class="line">    diagonal_values = diagonal;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> std::vector&lt;unsigned int&gt; &amp;</div>
<div class="line">    constrained_dofs = data.<a class="code" href="classMatrixFree.html#ac87bf2eb35ff9c5b6a5a6e977a15016f">get_constrained_dofs</a>();</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;constrained_dofs.size(); ++i)</div>
<div class="line">      diagonal_values(constrained_dofs[i]) = 1.0;</div>
<div class="line"></div>
<div class="line">    diagonal_is_available = <span class="keyword">true</span>;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div>
<div class="line">  std::size_t</div>
<div class="line">  LaplaceOperator&lt;dim,fe_degree,number&gt;::memory_consumption ()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <span class="keywordflow">return</span> (data.<a class="code" href="classMatrixFree.html#acccb7e2db859dede4c09279e7d418784">memory_consumption</a> () +</div>
<div class="line">            coefficient.memory_consumption() +</div>
<div class="line">            diagonal_values.memory_consumption() +</div>
<div class="line">            <a class="code" href="namespaceMemoryConsumption.html#ac131e0968c353873300f677282378600">MemoryConsumption::memory_consumption</a>(diagonal_is_available));</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keyword">class </span>LaplaceProblem</div>
<div class="line">  {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    LaplaceProblem ();</div>
<div class="line">    <span class="keywordtype">void</span> run ();</div>
<div class="line"></div>
<div class="line">  <span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">void</span> setup_system ();</div>
<div class="line">    <span class="keywordtype">void</span> assemble_system ();</div>
<div class="line">    <span class="keywordtype">void</span> assemble_multigrid ();</div>
<div class="line">    <span class="keywordtype">void</span> solve ();</div>
<div class="line">    <span class="keywordtype">void</span> output_results (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle) <span class="keyword">const</span>;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">typedef</span> LaplaceOperator&lt;dim,degree_finite_element,double&gt; SystemMatrixType;</div>
<div class="line">    <span class="keyword">typedef</span> LaplaceOperator&lt;dim,degree_finite_element,float&gt;  LevelMatrixType;</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a>               triangulation;</div>
<div class="line">    <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>                        fe;</div>
<div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>                  dof_handler;</div>
<div class="line">    <a class="code" href="classConstraintMatrix.html">ConstraintMatrix</a>                 constraints;</div>
<div class="line"></div>
<div class="line">    SystemMatrixType                 system_matrix;</div>
<div class="line">    <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;LevelMatrixType&gt;</a>   mg_matrices;</div>
<div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;float&gt;</a>                coarse_matrix;</div>
<div class="line">    <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;ConstraintMatrix&gt;</a>  mg_constraints;</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>                   solution;</div>
<div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>                   system_rhs;</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">double</span>                           setup_time;</div>
<div class="line">    <a class="code" href="classConditionalOStream.html">ConditionalOStream</a>               time_details;</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  LaplaceProblem&lt;dim&gt;::LaplaceProblem ()</div>
<div class="line">    :</div>
<div class="line">    fe (degree_finite_element),</div>
<div class="line">    dof_handler (triangulation),</div>
<div class="line">    time_details (std::cout, false)</div>
<div class="line">  {}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::setup_system ()</div>
<div class="line">  {</div>
<div class="line">    <a class="code" href="classTimer.html">Timer</a> time;</div>
<div class="line">    time.<a class="code" href="classTimer.html#a3a8b5272198d029779dc9302a54305a8">start</a> ();</div>
<div class="line">    setup_time = 0;</div>
<div class="line"></div>
<div class="line">    system_matrix.clear();</div>
<div class="line">    mg_matrices.clear();</div>
<div class="line">    mg_constraints.clear();</div>
<div class="line"></div>
<div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#afcfcc3b473f444f50d206ae62dfe3694">distribute_dofs</a> (fe);</div>
<div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a3e864b78dbc0a07e771768e5ae209cff">distribute_mg_dofs</a> (fe);</div>
<div class="line"></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Number of degrees of freedom: &quot;</span></div>
<div class="line">              &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#a54e7270f2ba6206604f794114b39a2aa">n_dofs</a>()</div>
<div class="line">              &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line">    constraints.<a class="code" href="classConstraintMatrix.html#a24120d0331183f9a63cbe41493a19f6b">clear</a>();</div>
<div class="line">    <a class="code" href="namespaceVectorTools.html#a199f38e07822b47e5b5957c21ce35d1b">VectorTools::interpolate_boundary_values</a> (dof_handler,</div>
<div class="line">                                              0,</div>
<div class="line">                                              <a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a>(),</div>
<div class="line">                                              constraints);</div>
<div class="line">    constraints.<a class="code" href="classConstraintMatrix.html#a8056d07faa2a7ed3f158c1b42d56abc8">close</a>();</div>
<div class="line">    setup_time += time.<a class="code" href="classTimer.html#ac4e81ca4d1e1274363ce4e6d70a8aba5">wall_time</a>();</div>
<div class="line">    time_details &lt;&lt; <span class="stringliteral">&quot;Distribute DoFs &amp; B.C.     (CPU/wall) &quot;</span></div>
<div class="line">                 &lt;&lt; time() &lt;&lt; <span class="stringliteral">&quot;s/&quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#ac4e81ca4d1e1274363ce4e6d70a8aba5">wall_time</a>() &lt;&lt; <span class="stringliteral">&quot;s&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    time.<a class="code" href="classTimer.html#aa3f7871196bb56202af2bc982bfbfff6">restart</a>();</div>
<div class="line"></div>
<div class="line">    system_matrix.reinit (dof_handler, constraints);</div>
<div class="line">    std::cout.precision(4);</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;System matrix memory consumption:     &quot;</span></div>
<div class="line">              &lt;&lt; system_matrix.memory_consumption()*1e-6</div>
<div class="line">              &lt;&lt; <span class="stringliteral">&quot; MB.&quot;</span></div>
<div class="line">              &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line">    solution.<a class="code" href="classVector.html#ac3adfcf8cf35943558fc27ef989b7263">reinit</a> (dof_handler.<a class="code" href="classDoFHandler.html#a54e7270f2ba6206604f794114b39a2aa">n_dofs</a>());</div>
<div class="line">    system_rhs.<a class="code" href="classBlockVector.html#a4caa9be7a7053fd6ae9fac1da74e564b">reinit</a> (dof_handler.<a class="code" href="classDoFHandler.html#a54e7270f2ba6206604f794114b39a2aa">n_dofs</a>());</div>
<div class="line"></div>
<div class="line">    setup_time += time.<a class="code" href="classTimer.html#ac4e81ca4d1e1274363ce4e6d70a8aba5">wall_time</a>();</div>
<div class="line">    time_details &lt;&lt; <span class="stringliteral">&quot;Setup matrix-free system   (CPU/wall) &quot;</span></div>
<div class="line">                 &lt;&lt; time() &lt;&lt; <span class="stringliteral">&quot;s/&quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#ac4e81ca4d1e1274363ce4e6d70a8aba5">wall_time</a>() &lt;&lt; <span class="stringliteral">&quot;s&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    time.<a class="code" href="classTimer.html#aa3f7871196bb56202af2bc982bfbfff6">restart</a>();</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nlevels = triangulation.<a class="code" href="classTriangulation.html#ad966e087386ee0330371ebd73f2cfe99">n_levels</a>();</div>
<div class="line">    mg_matrices.resize(0, nlevels-1);</div>
<div class="line">    mg_constraints.resize (0, nlevels-1);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">typename</span> <a class="code" href="structFunctionMap.html#aa286a6c5e13045f84faabfd7170b1c48">FunctionMap&lt;dim&gt;::type</a> dirichlet_boundary;</div>
<div class="line">    <a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a>               homogeneous_dirichlet_bc (1);</div>
<div class="line">    dirichlet_boundary[0] = &amp;homogeneous_dirichlet_bc;</div>
<div class="line">    std::vector&lt;std::set&lt;types::global_dof_index&gt; &gt; boundary_indices(triangulation.<a class="code" href="classTriangulation.html#ad966e087386ee0330371ebd73f2cfe99">n_levels</a>());</div>
<div class="line">    <a class="code" href="namespaceMGTools.html#ac2b927637a50289ecf80aea74c75f850">MGTools::make_boundary_list</a> (dof_handler,</div>
<div class="line">                                 dirichlet_boundary,</div>
<div class="line">                                 boundary_indices);</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level=0; level&lt;nlevels; ++level)</div>
<div class="line">      {</div>
<div class="line">        std::set&lt;types::global_dof_index&gt;::iterator bc_it = boundary_indices[level].begin();</div>
<div class="line">        <span class="keywordflow">for</span> ( ; bc_it != boundary_indices[level].end(); ++bc_it)</div>
<div class="line">          mg_constraints[level].add_line(*bc_it);</div>
<div class="line"></div>
<div class="line">        mg_constraints[level].close();</div>
<div class="line">        mg_matrices[level].reinit(dof_handler,</div>
<div class="line">                                  mg_constraints[level],</div>
<div class="line">                                  level);</div>
<div class="line">      }</div>
<div class="line">    coarse_matrix.<a class="code" href="classTableBase.html#aa1057871726271c6c04b7ae0738e0cfa">reinit</a> (dof_handler.<a class="code" href="classDoFHandler.html#a54e7270f2ba6206604f794114b39a2aa">n_dofs</a>(0),</div>
<div class="line">                          dof_handler.<a class="code" href="classDoFHandler.html#a54e7270f2ba6206604f794114b39a2aa">n_dofs</a>(0));</div>
<div class="line">    setup_time += time.<a class="code" href="classTimer.html#ac4e81ca4d1e1274363ce4e6d70a8aba5">wall_time</a>();</div>
<div class="line">    time_details &lt;&lt; <span class="stringliteral">&quot;Setup matrix-free levels   (CPU/wall) &quot;</span></div>
<div class="line">                 &lt;&lt; time() &lt;&lt; <span class="stringliteral">&quot;s/&quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#ac4e81ca4d1e1274363ce4e6d70a8aba5">wall_time</a>() &lt;&lt; <span class="stringliteral">&quot;s&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::assemble_system ()</div>
<div class="line">  {</div>
<div class="line">    <a class="code" href="classTimer.html">Timer</a> time;</div>
<div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>  quadrature_formula(fe.degree+1);</div>
<div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values (fe, quadrature_formula,</div>
<div class="line">                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>   | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   dofs_per_cell = fe.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#a4d64837b1d374e9c46f07af8f094b29b">size</a>();</div>
<div class="line"></div>
<div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices (dofs_per_cell);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> cell = dof_handler.<a class="code" href="classDoFHandler.html#a6f2aa9c61385cbb749ed3d2e7bfe3de1">begin_active</a>(),</div>
<div class="line">                                                   endc = dof_handler.<a class="code" href="classDoFHandler.html#abf64c3734383b6fb1bed4888935f2edf">end</a>();</div>
<div class="line">    <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div>
<div class="line">      {</div>
<div class="line">        cell-&gt;get_dof_indices (local_dof_indices);</div>
<div class="line">        fe_values.<a class="code" href="classFEValues.html#afde502903642c57ade24dfcebf5c1650">reinit</a> (cell);</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div>
<div class="line">          {</div>
<div class="line">            <span class="keywordtype">double</span> rhs_val = 0;</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_q_points; ++q)</div>
<div class="line">              rhs_val += (fe_values.<a class="code" href="classFEValuesBase.html#abe4de48ff59778bb82a0ec13037804aa">shape_value</a>(i,q) * 1.0 *</div>
<div class="line">                          fe_values.<a class="code" href="classFEValuesBase.html#ad097580a2f71878695096cc73b271b9d">JxW</a>(q));</div>
<div class="line">            system_rhs(local_dof_indices[i]) += rhs_val;</div>
<div class="line">          }</div>
<div class="line">      }</div>
<div class="line">    constraints.<a class="code" href="classConstraintMatrix.html#a66337316e8fbbc786c9f0383d085ab01">condense</a>(system_rhs);</div>
<div class="line">    setup_time += time.<a class="code" href="classTimer.html#ac4e81ca4d1e1274363ce4e6d70a8aba5">wall_time</a>();</div>
<div class="line">    time_details &lt;&lt; <span class="stringliteral">&quot;Assemble right hand side   (CPU/wall) &quot;</span></div>
<div class="line">                 &lt;&lt; time() &lt;&lt; <span class="stringliteral">&quot;s/&quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#ac4e81ca4d1e1274363ce4e6d70a8aba5">wall_time</a>() &lt;&lt; <span class="stringliteral">&quot;s&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::assemble_multigrid ()</div>
<div class="line">  {</div>
<div class="line">    <a class="code" href="classTimer.html">Timer</a> time;</div>
<div class="line">    coarse_matrix = 0;</div>
<div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>  quadrature_formula(fe.degree+1);</div>
<div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values (fe, quadrature_formula,</div>
<div class="line">                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>  | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fac654119724aff0c394743170ae949d18">update_inverse_jacobians</a> |</div>
<div class="line">                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   dofs_per_cell = fe.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#a4d64837b1d374e9c46f07af8f094b29b">size</a>();</div>
<div class="line"></div>
<div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices (dofs_per_cell);</div>
<div class="line">    <span class="keyword">const</span> Coefficient&lt;dim&gt;    coefficient;</div>
<div class="line">    std::vector&lt;double&gt;       coefficient_values (n_q_points);</div>
<div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>        local_matrix (dofs_per_cell, dofs_per_cell);</div>
<div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>            local_diagonal (dofs_per_cell);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_levels = triangulation.<a class="code" href="classTriangulation.html#ad966e087386ee0330371ebd73f2cfe99">n_levels</a>();</div>
<div class="line">    std::vector&lt;Vector&lt;float&gt; &gt; diagonals (n_levels);</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level=0; level&lt;n_levels; ++level)</div>
<div class="line">      diagonals[level].reinit (dof_handler.<a class="code" href="classDoFHandler.html#a54e7270f2ba6206604f794114b39a2aa">n_dofs</a>(level));</div>
<div class="line"></div>
<div class="line">    std::vector&lt;unsigned int&gt; cell_no(triangulation.<a class="code" href="classTriangulation.html#ad966e087386ee0330371ebd73f2cfe99">n_levels</a>());</div>
<div class="line">    <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::cell_iterator</a> cell = dof_handler.<a class="code" href="classDoFHandler.html#a0f72091ff71f88c939915dd0d76df4a1">begin</a>(),</div>
<div class="line">                                            endc = dof_handler.<a class="code" href="classDoFHandler.html#abf64c3734383b6fb1bed4888935f2edf">end</a>();</div>
<div class="line">    <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div>
<div class="line">      {</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = cell-&gt;level();</div>
<div class="line">        cell-&gt;get_mg_dof_indices (local_dof_indices);</div>
<div class="line">        fe_values.<a class="code" href="classFEValues.html#afde502903642c57ade24dfcebf5c1650">reinit</a> (cell);</div>
<div class="line">        coefficient.value_list (fe_values.<a class="code" href="classFEValuesBase.html#a5f8732ebe2d3c6746f6de26a79cb1e45">get_quadrature_points</a>(),</div>
<div class="line">                                coefficient_values);</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div>
<div class="line">          {</div>
<div class="line">            <span class="keywordtype">double</span> local_diag = 0;</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_q_points; ++q)</div>
<div class="line">              local_diag += ((fe_values.<a class="code" href="classFEValuesBase.html#ac4cee7628c2903a89c5c399fddeb00a5">shape_grad</a>(i,q) *</div>
<div class="line">                              fe_values.<a class="code" href="classFEValuesBase.html#ac4cee7628c2903a89c5c399fddeb00a5">shape_grad</a>(i,q)) *</div>
<div class="line">                             coefficient_values[q] * fe_values.<a class="code" href="classFEValuesBase.html#ad097580a2f71878695096cc73b271b9d">JxW</a>(q));</div>
<div class="line">            local_diagonal(i) = local_diag;</div>
<div class="line">          }</div>
<div class="line">        mg_constraints[level].distribute_local_to_global(local_diagonal,</div>
<div class="line">                                                         local_dof_indices,</div>
<div class="line">                                                         diagonals[level]);</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (level == 0)</div>
<div class="line">          {</div>
<div class="line">            local_matrix = 0;</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div>
<div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div>
<div class="line">                {</div>
<div class="line">                  <span class="keywordtype">double</span> add_value = 0;</div>
<div class="line">                  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_q_points; ++q)</div>
<div class="line">                    add_value += (fe_values.<a class="code" href="classFEValuesBase.html#ac4cee7628c2903a89c5c399fddeb00a5">shape_grad</a>(i,q) *</div>
<div class="line">                                  fe_values.<a class="code" href="classFEValuesBase.html#ac4cee7628c2903a89c5c399fddeb00a5">shape_grad</a>(j,q) *</div>
<div class="line">                                  coefficient_values[q] *</div>
<div class="line">                                  fe_values.<a class="code" href="classFEValuesBase.html#ad097580a2f71878695096cc73b271b9d">JxW</a>(q));</div>
<div class="line">                  local_matrix(i,j) = add_value;</div>
<div class="line">                }</div>
<div class="line">            mg_constraints[0].distribute_local_to_global (local_matrix,</div>
<div class="line">                                                          local_dof_indices,</div>
<div class="line">                                                          coarse_matrix);</div>
<div class="line">          }</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level=0; level&lt;n_levels; ++level)</div>
<div class="line">      mg_matrices[level].set_diagonal (diagonals[level]);</div>
<div class="line"></div>
<div class="line">    setup_time += time.<a class="code" href="classTimer.html#ac4e81ca4d1e1274363ce4e6d70a8aba5">wall_time</a>();</div>
<div class="line">    time_details &lt;&lt; <span class="stringliteral">&quot;Assemble MG diagonal       (CPU/wall) &quot;</span></div>
<div class="line">                 &lt;&lt; time() &lt;&lt; <span class="stringliteral">&quot;s/&quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#ac4e81ca4d1e1274363ce4e6d70a8aba5">wall_time</a>() &lt;&lt; <span class="stringliteral">&quot;s&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::solve ()</div>
<div class="line">  {</div>
<div class="line">    <a class="code" href="classTimer.html">Timer</a> time;</div>
<div class="line">    <a class="code" href="classMGTransferPrebuilt.html">MGTransferPrebuilt&lt;Vector&lt;double&gt;</a> &gt; mg_transfer;</div>
<div class="line">    mg_transfer.<a class="code" href="classMGTransferPrebuilt.html#a58e346481bd8a8a9994bb8b5d5d9772a">build_matrices</a>(dof_handler);</div>
<div class="line">    setup_time += time.<a class="code" href="classTimer.html#ac4e81ca4d1e1274363ce4e6d70a8aba5">wall_time</a>();</div>
<div class="line">    time_details &lt;&lt; <span class="stringliteral">&quot;MG build transfer time     (CPU/wall) &quot;</span> &lt;&lt; time()</div>
<div class="line">                 &lt;&lt; <span class="stringliteral">&quot;s/&quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#ac4e81ca4d1e1274363ce4e6d70a8aba5">wall_time</a>() &lt;&lt; <span class="stringliteral">&quot;s\n&quot;</span>;</div>
<div class="line">    time.<a class="code" href="classTimer.html#aa3f7871196bb56202af2bc982bfbfff6">restart</a>();</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classMGCoarseGridHouseholder.html">MGCoarseGridHouseholder&lt;float, Vector&lt;double&gt;</a> &gt; mg_coarse;</div>
<div class="line">    mg_coarse.<a class="code" href="classMGCoarseGridHouseholder.html#a2790d07d059be92b2a7b608d1917e78e">initialize</a>(coarse_matrix);</div>
<div class="line">    setup_time += time.<a class="code" href="classTimer.html#ac4e81ca4d1e1274363ce4e6d70a8aba5">wall_time</a>();</div>
<div class="line">    time_details &lt;&lt; <span class="stringliteral">&quot;MG coarse time             (CPU/wall) &quot;</span> &lt;&lt; time()</div>
<div class="line">                 &lt;&lt; <span class="stringliteral">&quot;s/&quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#ac4e81ca4d1e1274363ce4e6d70a8aba5">wall_time</a>() &lt;&lt; <span class="stringliteral">&quot;s\n&quot;</span>;</div>
<div class="line">    time.<a class="code" href="classTimer.html#aa3f7871196bb56202af2bc982bfbfff6">restart</a>();</div>
<div class="line"></div>
<div class="line">    <span class="keyword">typedef</span> <a class="code" href="classPreconditionChebyshev.html">PreconditionChebyshev&lt;LevelMatrixType,Vector&lt;double&gt;</a> &gt; SMOOTHER;</div>
<div class="line">    <a class="code" href="classMGSmootherPrecondition.html">MGSmootherPrecondition&lt;LevelMatrixType, SMOOTHER, Vector&lt;double&gt;</a> &gt;</div>
<div class="line">    mg_smoother;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">typename</span> SMOOTHER::AdditionalData smoother_data;</div>
<div class="line">    smoother_data.smoothing_range = 10.;</div>
<div class="line">    smoother_data.degree = 6;</div>
<div class="line">    smoother_data.eig_cg_n_iterations = 10;</div>
<div class="line">    mg_smoother.<a class="code" href="classMGSmootherPrecondition.html#ad615e8f1c011441b2a6f9d5d1a6f952f">initialize</a>(mg_matrices, smoother_data);</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classMGMatrix.html">MGMatrix&lt;LevelMatrixType, Vector&lt;double&gt;</a> &gt;</div>
<div class="line">    mg_matrix(&amp;mg_matrices);</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classMultigrid.html">Multigrid&lt;Vector&lt;double&gt;</a> &gt; mg(dof_handler,</div>
<div class="line">                                  mg_matrix,</div>
<div class="line">                                  mg_coarse,</div>
<div class="line">                                  mg_transfer,</div>
<div class="line">                                  mg_smoother,</div>
<div class="line">                                  mg_smoother);</div>
<div class="line">    <a class="code" href="classPreconditionMG.html">PreconditionMG&lt;dim, Vector&lt;double&gt;</a>,</div>
<div class="line">                   <a class="code" href="classMGTransferPrebuilt.html">MGTransferPrebuilt&lt;Vector&lt;double&gt;</a> &gt; &gt;</div>
<div class="line">                   preconditioner(dof_handler, mg, mg_transfer);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> std::size_t multigrid_memory</div>
<div class="line">      = (mg_matrices.memory_consumption() +</div>
<div class="line">         mg_transfer.<a class="code" href="classMGTransferPrebuilt.html#a99163d6072d3bbd7f81522a4ffcd9308">memory_consumption</a>() +</div>
<div class="line">         coarse_matrix.<a class="code" href="classFullMatrix.html#a175b03e4ae3fdfb6469e50d913b1042d">memory_consumption</a>());</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Multigrid objects memory consumption: &quot;</span></div>
<div class="line">              &lt;&lt; multigrid_memory * 1e-6</div>
<div class="line">              &lt;&lt; <span class="stringliteral">&quot; MB.&quot;</span></div>
<div class="line">              &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a>           solver_control (1000, 1e-12*system_rhs.<a class="code" href="classBlockVectorBase.html#a39191b8a99e917a95c8523f94c807a95">l2_norm</a>());</div>
<div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;&gt;</a>              cg (solver_control);</div>
<div class="line">    setup_time += time.<a class="code" href="classTimer.html#ac4e81ca4d1e1274363ce4e6d70a8aba5">wall_time</a>();</div>
<div class="line">    time_details &lt;&lt; <span class="stringliteral">&quot;MG build smoother time     (CPU/wall) &quot;</span> &lt;&lt; time()</div>
<div class="line">                 &lt;&lt; <span class="stringliteral">&quot;s/&quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#ac4e81ca4d1e1274363ce4e6d70a8aba5">wall_time</a>() &lt;&lt; <span class="stringliteral">&quot;s\n&quot;</span>;</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Total setup time               (wall) &quot;</span> &lt;&lt; setup_time</div>
<div class="line">              &lt;&lt; <span class="stringliteral">&quot;s\n&quot;</span>;</div>
<div class="line"></div>
<div class="line">    time.<a class="code" href="classTimer.html#a9020542d73357a4eef512eefaf57524b">reset</a>();</div>
<div class="line">    time.<a class="code" href="classTimer.html#a3a8b5272198d029779dc9302a54305a8">start</a>();</div>
<div class="line">    cg.solve (system_matrix, solution, system_rhs,</div>
<div class="line">              preconditioner);</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Time solve (&quot;</span></div>
<div class="line">              &lt;&lt; solver_control.last_step()</div>
<div class="line">              &lt;&lt; <span class="stringliteral">&quot; iterations)  (CPU/wall) &quot;</span> &lt;&lt; time() &lt;&lt; <span class="stringliteral">&quot;s/&quot;</span></div>
<div class="line">              &lt;&lt; time.<a class="code" href="classTimer.html#ac4e81ca4d1e1274363ce4e6d70a8aba5">wall_time</a>() &lt;&lt; <span class="stringliteral">&quot;s\n&quot;</span>;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::output_results (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div>
<div class="line"></div>
<div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a5e63bad650805ce93cd74c6dc3b29b11">attach_dof_handler</a> (dof_handler);</div>
<div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a59a6b70a4b909e0229a20487dd68cc43">add_data_vector</a> (solution, <span class="stringliteral">&quot;solution&quot;</span>);</div>
<div class="line">    data_out.<a class="code" href="classDataOut.html#ab3d44201acb97fba286a897452236b51">build_patches</a> ();</div>
<div class="line"></div>
<div class="line">    std::ostringstream filename;</div>
<div class="line">    filename &lt;&lt; <span class="stringliteral">&quot;solution-&quot;</span></div>
<div class="line">             &lt;&lt; cycle</div>
<div class="line">             &lt;&lt; <span class="stringliteral">&quot;.vtu&quot;</span>;</div>
<div class="line"></div>
<div class="line">    std::ofstream output (filename.str().c_str());</div>
<div class="line">    data_out.<a class="code" href="classDataOutInterface.html#a91f8a3e092130d7f44838729dca458ea">write_vtu</a> (output);</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::run ()</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle=0; cycle&lt;9-dim; ++cycle)</div>
<div class="line">      {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (cycle == 0)</div>
<div class="line">          {</div>
<div class="line">            <a class="code" href="namespaceGridGenerator.html#a7149c59cefa805a132177cfa6cb953bd">GridGenerator::hyper_cube</a> (triangulation, 0., 1.);</div>
<div class="line">            triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a> (3-dim);</div>
<div class="line">          }</div>
<div class="line">        triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a> (1);</div>
<div class="line">        setup_system ();</div>
<div class="line">        assemble_system ();</div>
<div class="line">        assemble_multigrid ();</div>
<div class="line">        solve ();</div>
<div class="line">        output_results (cycle);</div>
<div class="line">        std::cout &lt;&lt; std::endl;</div>
<div class="line">      };</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> <a class="code" href="group__ParameterGui.html#ga0ddf1224851353fc92bfbff6f499fa97">main</a> ()</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">try</span></div>
<div class="line">    {</div>
<div class="line">      <span class="keyword">using namespace </span>Step37;</div>
<div class="line"></div>
<div class="line">      deallog.<a class="code" href="classLogStream.html#a8028e970ad8388596d625ed463894e98">depth_console</a>(0);</div>
<div class="line">      LaplaceProblem&lt;dimension&gt; laplace_problem;</div>
<div class="line">      laplace_problem.run ();</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div>
<div class="line">    {</div>
<div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">catch</span> (...)</div>
<div class="line">    {</div>
<div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jan 27 2014 15:27:01 for The deal.II Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
