<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>The deal.II Library: Triangulation&lt; dim, spacedim &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="http://www.dealii.org/deal.ico"></link>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2014 by the deal.II authors"></meta>
<meta name="deal.II-version" content="8.1.0"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 8.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classTriangulation-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Triangulation&lt; dim, spacedim &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__grid.html">Grid classes</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="grid_2tria_8h_source.html">tria.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Triangulation&lt; dim, spacedim &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classTriangulation__inherit__graph.svg" width="907" height="355"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTriangulation_1_1DistortedCellList.html">DistortedCellList</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation_1_1RefinementListener.html">RefinementListener</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTriangulation_1_1Signals.html">Signals</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a0633dd17e535a59162b79f338c6ff5ae"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">MeshSmoothing</a> { <br/>
&#160;&#160;<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea9828da1d84133b33b112afd4a0ac15ec">none</a> = 0x0, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeaa2ab57e4f7b1633f26092ae861ea3bfc">limit_level_difference_at_vertices</a> = 0x1, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeaf065376600b9b08c1c65d00505225e2f">eliminate_unrefined_islands</a> = 0x2, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea37c283b96070dc09dde81f51d3ce1812">patch_level_1</a> = 0x4, 
<br/>
&#160;&#160;<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeae94a75f4383724ef8f58639aef2eb6c0">coarsest_level_1</a> = 0x8, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeaa44d17458e16327fb4b674745b883910">allow_anisotropic_smoothing</a> = 0x10, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeaf3f26812258d56f4306f9b4a4858ee1e">eliminate_refined_inner_islands</a> = 0x100, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea5eaba327f7131b70f58aa6d0837dfa58">eliminate_refined_boundary_islands</a> = 0x200, 
<br/>
&#160;&#160;<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea75171630dec90d241c811d2732410303">do_not_produce_unrefined_islands</a> = 0x400, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea3fb6b9153821aefc45661f67f22e232a">smoothing_on_refinement</a>, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea8d8dbaaa62136a7e51c7bf5c02d6e1e7">smoothing_on_coarsening</a>, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeaf64b535fd0fad99b6032412d2cccac36">maximum_smoothing</a> = 0xffff ^ allow_anisotropic_smoothing
<br/>
 }</td></tr>
<tr class="separator:a0633dd17e535a59162b79f338c6ff5ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a850b56c93cbebd27eb066edbd84aa711"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a850b56c93cbebd27eb066edbd84aa711"></a>
typedef <a class="el" href="classTriaIterator.html">TriaIterator</a><br class="typebreak"/>
&lt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>cell_iterator</b></td></tr>
<tr class="separator:a850b56c93cbebd27eb066edbd84aa711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f54e1f60de3cc5adb6ad00d23ee150b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7f54e1f60de3cc5adb6ad00d23ee150b"></a>
typedef <a class="el" href="classTriaActiveIterator.html">TriaActiveIterator</a><br class="typebreak"/>
&lt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>active_cell_iterator</b></td></tr>
<tr class="separator:a7f54e1f60de3cc5adb6ad00d23ee150b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af68ea64660d05c8f91eb75012f898372"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af68ea64660d05c8f91eb75012f898372"></a>
typedef <a class="el" href="classTriaIterator.html">TriaIterator</a><br class="typebreak"/>
&lt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; dim-1, dim, <br class="typebreak"/>
spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>face_iterator</b></td></tr>
<tr class="separator:af68ea64660d05c8f91eb75012f898372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abab170f8787b0c8af9d306b26608b58a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abab170f8787b0c8af9d306b26608b58a"></a>
typedef <a class="el" href="classTriaActiveIterator.html">TriaActiveIterator</a><br class="typebreak"/>
&lt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; dim-1, dim, <br class="typebreak"/>
spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>active_face_iterator</b></td></tr>
<tr class="separator:abab170f8787b0c8af9d306b26608b58a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab55a6afcfd5873ade44604050e0c77c2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab55a6afcfd5873ade44604050e0c77c2"></a>
typedef <br class="typebreak"/>
IteratorSelector::line_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>line_iterator</b></td></tr>
<tr class="separator:ab55a6afcfd5873ade44604050e0c77c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fa940d9c1af25341d346897619d52a9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4fa940d9c1af25341d346897619d52a9"></a>
typedef <br class="typebreak"/>
IteratorSelector::active_line_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>active_line_iterator</b></td></tr>
<tr class="separator:a4fa940d9c1af25341d346897619d52a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab669f6ed477c1e86436f0756ed459519"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab669f6ed477c1e86436f0756ed459519"></a>
typedef <br class="typebreak"/>
IteratorSelector::quad_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>quad_iterator</b></td></tr>
<tr class="separator:ab669f6ed477c1e86436f0756ed459519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a385007039aa93e1b343c21da3f3bda57"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a385007039aa93e1b343c21da3f3bda57"></a>
typedef <br class="typebreak"/>
IteratorSelector::active_quad_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>active_quad_iterator</b></td></tr>
<tr class="separator:a385007039aa93e1b343c21da3f3bda57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e125105f164e7174fb31f4225d6314e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1e125105f164e7174fb31f4225d6314e"></a>
typedef <br class="typebreak"/>
IteratorSelector::hex_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>hex_iterator</b></td></tr>
<tr class="separator:a1e125105f164e7174fb31f4225d6314e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa24f9f22d85dd210d649037db754479"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa24f9f22d85dd210d649037db754479"></a>
typedef <br class="typebreak"/>
IteratorSelector::active_hex_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>active_hex_iterator</b></td></tr>
<tr class="separator:afa24f9f22d85dd210d649037db754479"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a67f431ce66c6df985caf5587bf329ebc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a67f431ce66c6df985caf5587bf329ebc">Triangulation</a> (const <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">MeshSmoothing</a> <a class="el" href="classTriangulation.html#ac9474a14d0e8429412c82450013bde67">smooth_grid</a>=<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea9828da1d84133b33b112afd4a0ac15ec">none</a>, const <a class="el" href="classbool.html">bool</a> <a class="el" href="classTriangulation.html#a5c55287cc4c709190b521fd98a4f5e02">check_for_distorted_cells</a>=false)</td></tr>
<tr class="separator:a67f431ce66c6df985caf5587bf329ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac915084b738c83c836e2e26d439c4c67"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ac915084b738c83c836e2e26d439c4c67">Triangulation</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;t)</td></tr>
<tr class="separator:ac915084b738c83c836e2e26d439c4c67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5c7d0ad970c39d13625d0409506afad"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aa5c7d0ad970c39d13625d0409506afad">~Triangulation</a> ()</td></tr>
<tr class="separator:aa5c7d0ad970c39d13625d0409506afad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12d54b7dae635d867bf8d2c4b3605817"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a12d54b7dae635d867bf8d2c4b3605817">clear</a> ()</td></tr>
<tr class="separator:a12d54b7dae635d867bf8d2c4b3605817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a302f66ccc9bd281cf850fdc4f76e50"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a4a302f66ccc9bd281cf850fdc4f76e50">set_mesh_smoothing</a> (const <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">MeshSmoothing</a> mesh_smoothing)</td></tr>
<tr class="separator:a4a302f66ccc9bd281cf850fdc4f76e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0509d862f0e07071dcff837bd58fd082"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga0509d862f0e07071dcff837bd58fd082">set_boundary</a> (const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> number, const <a class="el" href="classBoundary.html">Boundary</a>&lt; dim, spacedim &gt; &amp;boundary_object)</td></tr>
<tr class="separator:ga0509d862f0e07071dcff837bd58fd082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad20f248873a8f12785b2043a35633fdc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#gad20f248873a8f12785b2043a35633fdc">set_boundary</a> (const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> number)</td></tr>
<tr class="separator:gad20f248873a8f12785b2043a35633fdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9fc7cf1ddf0db399d6790ba390110eb2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classBoundary.html">Boundary</a>&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga9fc7cf1ddf0db399d6790ba390110eb2">get_boundary</a> (const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> number) const </td></tr>
<tr class="separator:ga9fc7cf1ddf0db399d6790ba390110eb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ca82f769e668f1fa559c9e381c7af2a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga4ca82f769e668f1fa559c9e381c7af2a">get_boundary_indicators</a> () const </td></tr>
<tr class="separator:ga4ca82f769e668f1fa559c9e381c7af2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20dd4d20bf729c20410e47eb9bcd7065"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a20dd4d20bf729c20410e47eb9bcd7065">copy_triangulation</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;old_tria)</td></tr>
<tr class="separator:a20dd4d20bf729c20410e47eb9bcd7065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b6edd805a4d8b91d016080bf43233c1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a5b6edd805a4d8b91d016080bf43233c1">create_triangulation</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &gt; &amp;<a class="el" href="classTriangulation.html#a51469854babb27752dc9f26ed9d5ee30">vertices</a>, const std::vector&lt; <a class="el" href="structCellData.html">CellData</a>&lt; dim &gt; &gt; &amp;cells, const <a class="el" href="structSubCellData.html">SubCellData</a> &amp;subcelldata)</td></tr>
<tr class="separator:a5b6edd805a4d8b91d016080bf43233c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fdc77eaaa3926a066ed48fc47215a39"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a6fdc77eaaa3926a066ed48fc47215a39">create_triangulation_compatibility</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &gt; &amp;<a class="el" href="classTriangulation.html#a51469854babb27752dc9f26ed9d5ee30">vertices</a>, const std::vector&lt; <a class="el" href="structCellData.html">CellData</a>&lt; dim &gt; &gt; &amp;cells, const <a class="el" href="structSubCellData.html">SubCellData</a> &amp;subcelldata)</td></tr>
<tr class="separator:a6fdc77eaaa3926a066ed48fc47215a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdc34248a9ba0c38fd0020256a8def5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#afdc34248a9ba0c38fd0020256a8def5c">flip_all_direction_flags</a> ()</td></tr>
<tr class="separator:afdc34248a9ba0c38fd0020256a8def5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a083e0e57550eddc85f8804f04fc7f3cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a083e0e57550eddc85f8804f04fc7f3cd">distort_random</a> (const <a class="el" href="classdouble.html">double</a> factor, const <a class="el" href="classbool.html">bool</a> keep_boundary=true) <a class="el" href="group__Sparsity.html#ga0849dabf81f46d4d964e251c286784dd">DEAL_II_DEPRECATED</a></td></tr>
<tr class="separator:a083e0e57550eddc85f8804f04fc7f3cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12ababc0092a02034feb15e6281e45c7"><td class="memItemLeft" align="right" valign="top">virtual std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a12ababc0092a02034feb15e6281e45c7">memory_consumption</a> () const </td></tr>
<tr class="separator:a12ababc0092a02034feb15e6281e45c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ae613e76606c08f919aa6e4bdf5f94a"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a5ae613e76606c08f919aa6e4bdf5f94a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a5ae613e76606c08f919aa6e4bdf5f94a">save</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version) const </td></tr>
<tr class="separator:a5ae613e76606c08f919aa6e4bdf5f94a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2f72d5fbb277ec65dbe0382ae72a929"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:ae2f72d5fbb277ec65dbe0382ae72a929"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ae2f72d5fbb277ec65dbe0382ae72a929">load</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:ae2f72d5fbb277ec65dbe0382ae72a929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Mesh refinement</div></td></tr>
<tr class="memitem:aed8e461d4b2b23a0e1730afdef36e694"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aed8e461d4b2b23a0e1730afdef36e694">set_all_refine_flags</a> ()</td></tr>
<tr class="separator:aed8e461d4b2b23a0e1730afdef36e694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ad0b3fb24aae17f4668427a433dea19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a> (const unsigned <a class="el" href="classint.html">int</a> times=1)</td></tr>
<tr class="separator:a6ad0b3fb24aae17f4668427a433dea19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaedd900205c1879d8d9ef6ffe7d1a554"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aaedd900205c1879d8d9ef6ffe7d1a554">execute_coarsening_and_refinement</a> ()</td></tr>
<tr class="separator:aaedd900205c1879d8d9ef6ffe7d1a554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9fa3177e0e43ab0cf243215d284a35a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ab9fa3177e0e43ab0cf243215d284a35a">prepare_coarsening_and_refinement</a> ()</td></tr>
<tr class="separator:ab9fa3177e0e43ab0cf243215d284a35a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">History of a triangulation</div></td></tr>
<tr class="memitem:abf284939143dc421b87dfb40756c1e71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#abf284939143dc421b87dfb40756c1e71">save_refine_flags</a> (std::ostream &amp;out) const </td></tr>
<tr class="separator:abf284939143dc421b87dfb40756c1e71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71862b248b9f25914ae3f306f42dd2d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a71862b248b9f25914ae3f306f42dd2d3">save_refine_flags</a> (std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;v) const </td></tr>
<tr class="separator:a71862b248b9f25914ae3f306f42dd2d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43fc07c3f9e1f02658ca556f41087c85"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a43fc07c3f9e1f02658ca556f41087c85">load_refine_flags</a> (std::istream &amp;in)</td></tr>
<tr class="separator:a43fc07c3f9e1f02658ca556f41087c85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac924a05e66d5e76458ad088a2b7b5583"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ac924a05e66d5e76458ad088a2b7b5583">load_refine_flags</a> (const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;v)</td></tr>
<tr class="separator:ac924a05e66d5e76458ad088a2b7b5583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a023699c907ed013ea8e304b4c4ba1b8d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a023699c907ed013ea8e304b4c4ba1b8d">save_coarsen_flags</a> (std::ostream &amp;out) const </td></tr>
<tr class="separator:a023699c907ed013ea8e304b4c4ba1b8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab433d3029e1e9f15b03aee4d79d082e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ab433d3029e1e9f15b03aee4d79d082e0">save_coarsen_flags</a> (std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;v) const </td></tr>
<tr class="separator:ab433d3029e1e9f15b03aee4d79d082e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4029122ffe741f843f2f3a7deeceea9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aa4029122ffe741f843f2f3a7deeceea9">load_coarsen_flags</a> (std::istream &amp;out)</td></tr>
<tr class="separator:aa4029122ffe741f843f2f3a7deeceea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48a9463dcf9aeb3a69831e5e1a321053"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a48a9463dcf9aeb3a69831e5e1a321053">load_coarsen_flags</a> (const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;v)</td></tr>
<tr class="separator:a48a9463dcf9aeb3a69831e5e1a321053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa47ade3bd9afd94e38a8469762071352"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aa47ade3bd9afd94e38a8469762071352">get_anisotropic_refinement_flag</a> () const </td></tr>
<tr class="separator:aa47ade3bd9afd94e38a8469762071352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">User data</div></td></tr>
<tr class="memitem:aaa726b33b52f694cfca48fae8e761661"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aaa726b33b52f694cfca48fae8e761661">clear_user_flags</a> ()</td></tr>
<tr class="separator:aaa726b33b52f694cfca48fae8e761661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf0b21f16759e23f3d0d731301eec4fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aaf0b21f16759e23f3d0d731301eec4fb">save_user_flags</a> (std::ostream &amp;out) const </td></tr>
<tr class="separator:aaf0b21f16759e23f3d0d731301eec4fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a316d2b612074326bdc73f7f9c9704955"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a316d2b612074326bdc73f7f9c9704955">save_user_flags</a> (std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;v) const </td></tr>
<tr class="separator:a316d2b612074326bdc73f7f9c9704955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3612ed3c7f7f9cccd3003d85b6f7350"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#af3612ed3c7f7f9cccd3003d85b6f7350">load_user_flags</a> (std::istream &amp;in)</td></tr>
<tr class="separator:af3612ed3c7f7f9cccd3003d85b6f7350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac17946286639b12a03804ebc400eab51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ac17946286639b12a03804ebc400eab51">load_user_flags</a> (const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;v)</td></tr>
<tr class="separator:ac17946286639b12a03804ebc400eab51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8896f8e838dd34ed5b7c1aa351f76f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#af8896f8e838dd34ed5b7c1aa351f76f5">clear_user_flags_line</a> ()</td></tr>
<tr class="separator:af8896f8e838dd34ed5b7c1aa351f76f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a998ac27a1c0e2cd403bbeff5f0e55a07"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a998ac27a1c0e2cd403bbeff5f0e55a07">save_user_flags_line</a> (std::ostream &amp;out) const </td></tr>
<tr class="separator:a998ac27a1c0e2cd403bbeff5f0e55a07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69092dd9aea53f9133dd8c39c0684077"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a69092dd9aea53f9133dd8c39c0684077">save_user_flags_line</a> (std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;v) const </td></tr>
<tr class="separator:a69092dd9aea53f9133dd8c39c0684077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25190c31d16cde2a01fa0f2318aa0b74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a25190c31d16cde2a01fa0f2318aa0b74">load_user_flags_line</a> (std::istream &amp;in)</td></tr>
<tr class="separator:a25190c31d16cde2a01fa0f2318aa0b74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87294511c2f203a57531aaaf2bd2ce39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a87294511c2f203a57531aaaf2bd2ce39">load_user_flags_line</a> (const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;v)</td></tr>
<tr class="separator:a87294511c2f203a57531aaaf2bd2ce39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dd263157214206ceb637c402552f0eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a1dd263157214206ceb637c402552f0eb">clear_user_flags_quad</a> ()</td></tr>
<tr class="separator:a1dd263157214206ceb637c402552f0eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad97c6e1e446b4422274960740d69177a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ad97c6e1e446b4422274960740d69177a">save_user_flags_quad</a> (std::ostream &amp;out) const </td></tr>
<tr class="separator:ad97c6e1e446b4422274960740d69177a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41aed06ec1d5f1c77d438cc79c208adf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a41aed06ec1d5f1c77d438cc79c208adf">save_user_flags_quad</a> (std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;v) const </td></tr>
<tr class="separator:a41aed06ec1d5f1c77d438cc79c208adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e868cde85c04bcc8cec82ba09f24e7b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a5e868cde85c04bcc8cec82ba09f24e7b">load_user_flags_quad</a> (std::istream &amp;in)</td></tr>
<tr class="separator:a5e868cde85c04bcc8cec82ba09f24e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8651e0def48d61e3f8f0aa8051ae5985"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a8651e0def48d61e3f8f0aa8051ae5985">load_user_flags_quad</a> (const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;v)</td></tr>
<tr class="separator:a8651e0def48d61e3f8f0aa8051ae5985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cbe198bb49c3135378bb680582afd46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a7cbe198bb49c3135378bb680582afd46">clear_user_flags_hex</a> ()</td></tr>
<tr class="separator:a7cbe198bb49c3135378bb680582afd46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac478792002df16eb6cb3d051d2415c7f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ac478792002df16eb6cb3d051d2415c7f">save_user_flags_hex</a> (std::ostream &amp;out) const </td></tr>
<tr class="separator:ac478792002df16eb6cb3d051d2415c7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0c4c9531ee6b07d4c2f2610c5acedc4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ad0c4c9531ee6b07d4c2f2610c5acedc4">save_user_flags_hex</a> (std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;v) const </td></tr>
<tr class="separator:ad0c4c9531ee6b07d4c2f2610c5acedc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e15f4d848adbe6c8bf1af374e467a31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a6e15f4d848adbe6c8bf1af374e467a31">load_user_flags_hex</a> (std::istream &amp;in)</td></tr>
<tr class="separator:a6e15f4d848adbe6c8bf1af374e467a31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77e827086d26927d08129c8489fdcd45"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a77e827086d26927d08129c8489fdcd45">load_user_flags_hex</a> (const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;v)</td></tr>
<tr class="separator:a77e827086d26927d08129c8489fdcd45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26562806fd764afdffb973dce92554e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a26562806fd764afdffb973dce92554e8">clear_user_data</a> ()</td></tr>
<tr class="separator:a26562806fd764afdffb973dce92554e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f1cddf06093db7bdeaeb9411e5e75a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a5f1cddf06093db7bdeaeb9411e5e75a0">clear_user_pointers</a> () <a class="el" href="group__Sparsity.html#ga0849dabf81f46d4d964e251c286784dd">DEAL_II_DEPRECATED</a></td></tr>
<tr class="separator:a5f1cddf06093db7bdeaeb9411e5e75a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50eeaf89c218d08e31203d0e37f77553"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a50eeaf89c218d08e31203d0e37f77553">save_user_indices</a> (std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;v) const </td></tr>
<tr class="separator:a50eeaf89c218d08e31203d0e37f77553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12a2359968a027a8b14ae381c8886d30"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a12a2359968a027a8b14ae381c8886d30">load_user_indices</a> (const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;v)</td></tr>
<tr class="separator:a12a2359968a027a8b14ae381c8886d30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1908040531ff67ef48f1e8c306fde5dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a1908040531ff67ef48f1e8c306fde5dd">save_user_pointers</a> (std::vector&lt; void * &gt; &amp;v) const </td></tr>
<tr class="separator:a1908040531ff67ef48f1e8c306fde5dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8087e84b3b755bcb31767c574342ac0a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a8087e84b3b755bcb31767c574342ac0a">load_user_pointers</a> (const std::vector&lt; void * &gt; &amp;v)</td></tr>
<tr class="separator:a8087e84b3b755bcb31767c574342ac0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b9bed5e7c567fdc0f3219b6adf21530"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a6b9bed5e7c567fdc0f3219b6adf21530">save_user_indices_line</a> (std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;v) const </td></tr>
<tr class="separator:a6b9bed5e7c567fdc0f3219b6adf21530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b2160dd04545294d138ca00deb4af42"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a7b2160dd04545294d138ca00deb4af42">load_user_indices_line</a> (const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;v)</td></tr>
<tr class="separator:a7b2160dd04545294d138ca00deb4af42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a891905d9655d39e2deee193794837ea0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a891905d9655d39e2deee193794837ea0">save_user_indices_quad</a> (std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;v) const </td></tr>
<tr class="separator:a891905d9655d39e2deee193794837ea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1020c09b32fbb78156b00b833271e21d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a1020c09b32fbb78156b00b833271e21d">load_user_indices_quad</a> (const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;v)</td></tr>
<tr class="separator:a1020c09b32fbb78156b00b833271e21d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae97338e9965e6d8a40345afb8bf7041a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ae97338e9965e6d8a40345afb8bf7041a">save_user_indices_hex</a> (std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;v) const </td></tr>
<tr class="separator:ae97338e9965e6d8a40345afb8bf7041a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abad8869b9c8234d6c81c24c69dd97d39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#abad8869b9c8234d6c81c24c69dd97d39">load_user_indices_hex</a> (const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;v)</td></tr>
<tr class="separator:abad8869b9c8234d6c81c24c69dd97d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55979902666e00468f6e2d07a28bab3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a55979902666e00468f6e2d07a28bab3f">save_user_pointers_line</a> (std::vector&lt; void * &gt; &amp;v) const </td></tr>
<tr class="separator:a55979902666e00468f6e2d07a28bab3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab55095dab9f1be46f088d6d29d016ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aab55095dab9f1be46f088d6d29d016ba">load_user_pointers_line</a> (const std::vector&lt; void * &gt; &amp;v)</td></tr>
<tr class="separator:aab55095dab9f1be46f088d6d29d016ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbd5c7e00637bd88f3e50316f6d846fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#afbd5c7e00637bd88f3e50316f6d846fc">save_user_pointers_quad</a> (std::vector&lt; void * &gt; &amp;v) const </td></tr>
<tr class="separator:afbd5c7e00637bd88f3e50316f6d846fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fadda245a0bef85ae6b957d6154a884"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a6fadda245a0bef85ae6b957d6154a884">load_user_pointers_quad</a> (const std::vector&lt; void * &gt; &amp;v)</td></tr>
<tr class="separator:a6fadda245a0bef85ae6b957d6154a884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88c180e97d314b70539bfed90065585b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a88c180e97d314b70539bfed90065585b">save_user_pointers_hex</a> (std::vector&lt; void * &gt; &amp;v) const </td></tr>
<tr class="separator:a88c180e97d314b70539bfed90065585b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e9198f6d3a8dedb19db011e99903863"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a8e9198f6d3a8dedb19db011e99903863">load_user_pointers_hex</a> (const std::vector&lt; void * &gt; &amp;v)</td></tr>
<tr class="separator:a8e9198f6d3a8dedb19db011e99903863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Cell iterator functions</div></td></tr>
<tr class="memitem:a7b87a97ff0d6ffe416aa37fda33c46c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriaIterator.html">cell_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a7b87a97ff0d6ffe416aa37fda33c46c7">begin</a> (const unsigned <a class="el" href="classint.html">int</a> level=0) const </td></tr>
<tr class="separator:a7b87a97ff0d6ffe416aa37fda33c46c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af99e25cc64755f18659c0fbc46c3d87d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriaActiveIterator.html">active_cell_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#af99e25cc64755f18659c0fbc46c3d87d">begin_active</a> (const unsigned <a class="el" href="classint.html">int</a> level=0) const </td></tr>
<tr class="separator:af99e25cc64755f18659c0fbc46c3d87d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa234819cf914abe2b700535c682688a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriaIterator.html">cell_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aa234819cf914abe2b700535c682688a7">end</a> () const </td></tr>
<tr class="separator:aa234819cf914abe2b700535c682688a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf9fa59d3fcecea4e90745e4181d1ed3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriaIterator.html">cell_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#adf9fa59d3fcecea4e90745e4181d1ed3">end</a> (const unsigned <a class="el" href="classint.html">int</a> level) const </td></tr>
<tr class="separator:adf9fa59d3fcecea4e90745e4181d1ed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01fbdd9c7d9c15e771c1bd07bc197dd8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriaActiveIterator.html">active_cell_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a01fbdd9c7d9c15e771c1bd07bc197dd8">end_active</a> (const unsigned <a class="el" href="classint.html">int</a> level) const </td></tr>
<tr class="separator:a01fbdd9c7d9c15e771c1bd07bc197dd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17622fd924c1a5812af2edda8fe6a3c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriaIterator.html">cell_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a17622fd924c1a5812af2edda8fe6a3c9">last</a> () const </td></tr>
<tr class="separator:a17622fd924c1a5812af2edda8fe6a3c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8e680fd57aaac70a8b7c9e86b32e4cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriaActiveIterator.html">active_cell_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#af8e680fd57aaac70a8b7c9e86b32e4cd">last_active</a> () const </td></tr>
<tr class="separator:af8e680fd57aaac70a8b7c9e86b32e4cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Face iterator functions</div></td></tr>
<tr class="memitem:ada7832002fa74f10c7eedf86c2a62578"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriaIterator.html">face_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ada7832002fa74f10c7eedf86c2a62578">begin_face</a> () const </td></tr>
<tr class="separator:ada7832002fa74f10c7eedf86c2a62578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a418e5a43b438de9d30ee00ac35403d8a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriaActiveIterator.html">active_face_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a418e5a43b438de9d30ee00ac35403d8a">begin_active_face</a> () const </td></tr>
<tr class="separator:a418e5a43b438de9d30ee00ac35403d8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0288a5ee4dadc95617dc2f7d9406909f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriaIterator.html">face_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a0288a5ee4dadc95617dc2f7d9406909f">end_face</a> () const </td></tr>
<tr class="separator:a0288a5ee4dadc95617dc2f7d9406909f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Information about the triangulation</div></td></tr>
<tr class="memitem:af4f3b8a6a82b2f198df99c99aa695557"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#af4f3b8a6a82b2f198df99c99aa695557">n_lines</a> () const </td></tr>
<tr class="separator:af4f3b8a6a82b2f198df99c99aa695557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a843d74b989a033cb3dc5d2ef78a83e57"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a843d74b989a033cb3dc5d2ef78a83e57">n_lines</a> (const unsigned <a class="el" href="classint.html">int</a> level) const </td></tr>
<tr class="separator:a843d74b989a033cb3dc5d2ef78a83e57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a697a4109298cc3a572f89d84b4e37d91"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a697a4109298cc3a572f89d84b4e37d91">n_active_lines</a> () const </td></tr>
<tr class="separator:a697a4109298cc3a572f89d84b4e37d91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8db1be8df4f945c3029a17032e5d847d"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a8db1be8df4f945c3029a17032e5d847d">n_active_lines</a> (const unsigned <a class="el" href="classint.html">int</a> level) const </td></tr>
<tr class="separator:a8db1be8df4f945c3029a17032e5d847d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa96bd1cc871af381a87b6c267e011e1"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aaa96bd1cc871af381a87b6c267e011e1">n_quads</a> () const </td></tr>
<tr class="separator:aaa96bd1cc871af381a87b6c267e011e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f07241c9c910d106490479dd688836c"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a1f07241c9c910d106490479dd688836c">n_quads</a> (const unsigned <a class="el" href="classint.html">int</a> level) const </td></tr>
<tr class="separator:a1f07241c9c910d106490479dd688836c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a226ef774feb8e9cfd6c80117bb63fe77"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a226ef774feb8e9cfd6c80117bb63fe77">n_active_quads</a> () const </td></tr>
<tr class="separator:a226ef774feb8e9cfd6c80117bb63fe77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5044a9fc8ca76a99817e57ce80baf866"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a5044a9fc8ca76a99817e57ce80baf866">n_active_quads</a> (const unsigned <a class="el" href="classint.html">int</a> level) const </td></tr>
<tr class="separator:a5044a9fc8ca76a99817e57ce80baf866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab9ee1975a0516c11f63f2906b893dad"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aab9ee1975a0516c11f63f2906b893dad">n_hexs</a> () const </td></tr>
<tr class="separator:aab9ee1975a0516c11f63f2906b893dad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc0531954b814e7d974c7cabb7dba2d4"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#afc0531954b814e7d974c7cabb7dba2d4">n_hexs</a> (const unsigned <a class="el" href="classint.html">int</a> level) const </td></tr>
<tr class="separator:afc0531954b814e7d974c7cabb7dba2d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef9946784a199fa6f39b5b5fa66abe7a"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aef9946784a199fa6f39b5b5fa66abe7a">n_active_hexs</a> () const </td></tr>
<tr class="separator:aef9946784a199fa6f39b5b5fa66abe7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87baa4a14d49a05aa00eb94d5954b0bc"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a87baa4a14d49a05aa00eb94d5954b0bc">n_active_hexs</a> (const unsigned <a class="el" href="classint.html">int</a> level) const </td></tr>
<tr class="separator:a87baa4a14d49a05aa00eb94d5954b0bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07ed51250524b5b9599671be911c89c4"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a07ed51250524b5b9599671be911c89c4">n_cells</a> () const </td></tr>
<tr class="separator:a07ed51250524b5b9599671be911c89c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a068b191bfec8efc720be890551953cd7"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a068b191bfec8efc720be890551953cd7">n_cells</a> (const unsigned <a class="el" href="classint.html">int</a> level) const </td></tr>
<tr class="separator:a068b191bfec8efc720be890551953cd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa21f25016ce1b9d70d2003a128985870"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aa21f25016ce1b9d70d2003a128985870">n_active_cells</a> () const </td></tr>
<tr class="separator:aa21f25016ce1b9d70d2003a128985870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d3f0a84249aacde06a34c56e0f7337b"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a0d3f0a84249aacde06a34c56e0f7337b">n_active_cells</a> (const unsigned <a class="el" href="classint.html">int</a> level) const </td></tr>
<tr class="separator:a0d3f0a84249aacde06a34c56e0f7337b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2860a815a9914acc8c12de32b71fc424"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a2860a815a9914acc8c12de32b71fc424">n_faces</a> () const </td></tr>
<tr class="separator:a2860a815a9914acc8c12de32b71fc424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10e55064151a14d73442af70fc607d64"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a10e55064151a14d73442af70fc607d64">n_active_faces</a> () const </td></tr>
<tr class="separator:a10e55064151a14d73442af70fc607d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad966e087386ee0330371ebd73f2cfe99"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ad966e087386ee0330371ebd73f2cfe99">n_levels</a> () const </td></tr>
<tr class="separator:ad966e087386ee0330371ebd73f2cfe99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a303fbfcda0fb05e63151771658253785"><td class="memItemLeft" align="right" valign="top">virtual unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a303fbfcda0fb05e63151771658253785">n_global_levels</a> () const </td></tr>
<tr class="separator:a303fbfcda0fb05e63151771658253785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad49cc6eadbda275e0c2ef0155469d656"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ad49cc6eadbda275e0c2ef0155469d656">n_vertices</a> () const </td></tr>
<tr class="separator:ad49cc6eadbda275e0c2ef0155469d656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fcee3caf27bb54c53ddb279cf6b8f5a"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classPoint.html">Point</a><br class="typebreak"/>
&lt; spacedim &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a6fcee3caf27bb54c53ddb279cf6b8f5a">get_vertices</a> () const </td></tr>
<tr class="separator:a6fcee3caf27bb54c53ddb279cf6b8f5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef1492349593137ebabb8b37b9ad9e14"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aef1492349593137ebabb8b37b9ad9e14">n_used_vertices</a> () const </td></tr>
<tr class="separator:aef1492349593137ebabb8b37b9ad9e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7770373aa26c78042c8e751a22e2415e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a7770373aa26c78042c8e751a22e2415e">vertex_used</a> (const unsigned <a class="el" href="classint.html">int</a> index) const </td></tr>
<tr class="separator:a7770373aa26c78042c8e751a22e2415e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a427f9be6dd029861354009ae6afc8b63"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a427f9be6dd029861354009ae6afc8b63">get_used_vertices</a> () const </td></tr>
<tr class="separator:a427f9be6dd029861354009ae6afc8b63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c2b4e1c451f1b5f57fe43c4563e6f4d"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a9c2b4e1c451f1b5f57fe43c4563e6f4d">max_adjacent_cells</a> () const </td></tr>
<tr class="separator:a9c2b4e1c451f1b5f57fe43c4563e6f4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa556f79e81b7d257030791772bfd3321"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aa556f79e81b7d257030791772bfd3321">locally_owned_subdomain</a> () const </td></tr>
<tr class="separator:aa556f79e81b7d257030791772bfd3321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Internal information about the number of objects</div></td></tr>
<tr class="memitem:aebeddf6ba0ac7f8b93c0fe0b253fe2f0"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aebeddf6ba0ac7f8b93c0fe0b253fe2f0">n_raw_lines</a> () const </td></tr>
<tr class="separator:aebeddf6ba0ac7f8b93c0fe0b253fe2f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2ae32286d0d39dbb9ae9e1f77abedd7"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#af2ae32286d0d39dbb9ae9e1f77abedd7">n_raw_lines</a> (const unsigned <a class="el" href="classint.html">int</a> level) const </td></tr>
<tr class="separator:af2ae32286d0d39dbb9ae9e1f77abedd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acff58f8bcaec384491c431e3c8b1750b"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#acff58f8bcaec384491c431e3c8b1750b">n_raw_quads</a> () const </td></tr>
<tr class="separator:acff58f8bcaec384491c431e3c8b1750b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a894995d0112d1b64c179e5542bccf929"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a894995d0112d1b64c179e5542bccf929">n_raw_quads</a> (const unsigned <a class="el" href="classint.html">int</a> level) const </td></tr>
<tr class="separator:a894995d0112d1b64c179e5542bccf929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c43630dd0391a6f74e1fde3c03f460b"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a7c43630dd0391a6f74e1fde3c03f460b">n_raw_hexs</a> () const </td></tr>
<tr class="separator:a7c43630dd0391a6f74e1fde3c03f460b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98dc15415c9e084516e67cca005190d9"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a98dc15415c9e084516e67cca005190d9">n_raw_hexs</a> (const unsigned <a class="el" href="classint.html">int</a> level) const </td></tr>
<tr class="separator:a98dc15415c9e084516e67cca005190d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b97a0de5539b6c80d910452926ddfc6"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a8b97a0de5539b6c80d910452926ddfc6">n_raw_cells</a> (const unsigned <a class="el" href="classint.html">int</a> level) const </td></tr>
<tr class="separator:a8b97a0de5539b6c80d910452926ddfc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e8dd46f42dfc70f368d9d423e5018b1"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a5e8dd46f42dfc70f368d9d423e5018b1">n_raw_faces</a> () const </td></tr>
<tr class="separator:a5e8dd46f42dfc70f368d9d423e5018b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Exceptions</div></td></tr>
<tr class="memitem:gafabd02cda5d7aebc9c5d14e67850dcc1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gafabd02cda5d7aebc9c5d14e67850dcc1">DeclException1</a> (ExcInvalidLevel, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;The given level &quot;&lt;&lt; arg1&lt;&lt; &quot; is not in the valid range!&quot;)</td></tr>
<tr class="separator:gafabd02cda5d7aebc9c5d14e67850dcc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b833230e0de45218a98451d8d24fb5f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga5b833230e0de45218a98451d8d24fb5f">DeclException0</a> (ExcTriangulationNotEmpty)</td></tr>
<tr class="separator:ga5b833230e0de45218a98451d8d24fb5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga966384346b2c7308b814ab09065d0470"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga966384346b2c7308b814ab09065d0470">DeclException0</a> (ExcGridReadError)</td></tr>
<tr class="separator:ga966384346b2c7308b814ab09065d0470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafa031bdac9392e3cdaa7ecf87171335"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaafa031bdac9392e3cdaa7ecf87171335">DeclException0</a> (ExcFacesHaveNoLevel)</td></tr>
<tr class="separator:gaafa031bdac9392e3cdaa7ecf87171335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga391a9a406c14d6830d2ccbf0c59b429b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga391a9a406c14d6830d2ccbf0c59b429b">DeclException1</a> (ExcEmptyLevel, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;You tried to do something on level &quot;&lt;&lt; arg1&lt;&lt; &quot;, but this level is empty.&quot;)</td></tr>
<tr class="separator:ga391a9a406c14d6830d2ccbf0c59b429b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cec3f85f90fe0e3d9e9ec626a0dbfc3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga7cec3f85f90fe0e3d9e9ec626a0dbfc3">DeclException0</a> (ExcNonOrientableTriangulation)</td></tr>
<tr class="separator:ga7cec3f85f90fe0e3d9e9ec626a0dbfc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSubscriptor"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSubscriptor')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSubscriptor.html">Subscriptor</a></td></tr>
<tr class="memitem:ae5541017c0966b0af345db75895106f2 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#ae5541017c0966b0af345db75895106f2">Subscriptor</a> ()</td></tr>
<tr class="separator:ae5541017c0966b0af345db75895106f2 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367fce3122075f05f168d14f114b4c65 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a367fce3122075f05f168d14f114b4c65">Subscriptor</a> (const <a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;)</td></tr>
<tr class="separator:a367fce3122075f05f168d14f114b4c65 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c6c557e06110d2127fa6459119e94af inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a6c6c557e06110d2127fa6459119e94af">~Subscriptor</a> ()</td></tr>
<tr class="separator:a6c6c557e06110d2127fa6459119e94af inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24ee69d4b3cf9690d1208b2443cbbb80 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a24ee69d4b3cf9690d1208b2443cbbb80">operator=</a> (const <a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;)</td></tr>
<tr class="separator:a24ee69d4b3cf9690d1208b2443cbbb80 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3422499827ecd52f1d12d65eb6cc3125 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a3422499827ecd52f1d12d65eb6cc3125">subscribe</a> (const char *identifier=0) const </td></tr>
<tr class="separator:a3422499827ecd52f1d12d65eb6cc3125 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b4839b1cffc18781144ede1744b35ea inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a2b4839b1cffc18781144ede1744b35ea">unsubscribe</a> (const char *identifier=0) const </td></tr>
<tr class="separator:a2b4839b1cffc18781144ede1744b35ea inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b45274c8e1936bff024df01d618e86f inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a7b45274c8e1936bff024df01d618e86f">n_subscriptions</a> () const </td></tr>
<tr class="separator:a7b45274c8e1936bff024df01d618e86f inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbbc5f845063b1f23223b7ac96e89e13 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#adbbc5f845063b1f23223b7ac96e89e13">list_subscribers</a> () const </td></tr>
<tr class="separator:adbbc5f845063b1f23223b7ac96e89e13 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2f0251d20c6a5295024de3b2e9b4359 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac2f0251d20c6a5295024de3b2e9b4359">DeclException3</a> (ExcInUse, <a class="el" href="classint.html">int</a>, char *, std::string &amp;,&lt;&lt; &quot;Object of class &quot;&lt;&lt; arg2&lt;&lt; &quot; is still used by &quot;&lt;&lt; arg1&lt;&lt; &quot; other objects.\n&quot;&lt;&lt; &quot;(Additional information: &quot;&lt;&lt; arg3&lt;&lt; &quot;)\n&quot;&lt;&lt; &quot;Note the entry in the Frequently Asked Questions of &quot;&lt;&lt; &quot;deal.II (linked to from http://www.dealii.org/) for &quot;&lt;&lt; &quot;more information on what this error means.&quot;)</td></tr>
<tr class="separator:gac2f0251d20c6a5295024de3b2e9b4359 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e000d9ce953da6afe4bbbaca4397344 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga9e000d9ce953da6afe4bbbaca4397344">DeclException2</a> (ExcNoSubscriber, char *, char *,&lt;&lt; &quot;No subscriber with identifier \&quot;&quot;&lt;&lt; arg2&lt;&lt; &quot;\&quot; did <a class="el" href="classSubscriptor.html#a3422499827ecd52f1d12d65eb6cc3125">subscribe</a> to this object of class &quot;&lt;&lt; arg1)</td></tr>
<tr class="separator:ga9e000d9ce953da6afe4bbbaca4397344 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38 inherit pub_methods_classSubscriptor"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38 inherit pub_methods_classSubscriptor"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:a68efd17a8330ab676d9cd711029b0f38 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a9560225362e43bc6201424bdfca5dcb2"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classStraightBoundary.html">StraightBoundary</a><br class="typebreak"/>
&lt; dim, spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a9560225362e43bc6201424bdfca5dcb2">straight_boundary</a></td></tr>
<tr class="separator:a9560225362e43bc6201424bdfca5dcb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefd8ddbf96799abebb6c05dced569329"><td class="memItemLeft" align="right" valign="top">static const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aefd8ddbf96799abebb6c05dced569329">dimension</a> = dim</td></tr>
<tr class="separator:aefd8ddbf96799abebb6c05dced569329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3414a986e63a95d54e961b9b35d756fb"><td class="memItemLeft" align="right" valign="top">static const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a3414a986e63a95d54e961b9b35d756fb">space_dimension</a> = spacedim</td></tr>
<tr class="separator:a3414a986e63a95d54e961b9b35d756fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:af9e3e5c077024f40355432c771ccf541"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#af9e3e5c077024f40355432c771ccf541">write_bool_vector</a> (const unsigned <a class="el" href="classint.html">int</a> magic_number1, const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;v, const unsigned <a class="el" href="classint.html">int</a> magic_number2, std::ostream &amp;out)</td></tr>
<tr class="separator:af9e3e5c077024f40355432c771ccf541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20c92032e652bdafdfd7624a55aa2866"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a20c92032e652bdafdfd7624a55aa2866">read_bool_vector</a> (const unsigned <a class="el" href="classint.html">int</a> magic_number1, std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;v, const unsigned <a class="el" href="classint.html">int</a> magic_number2, std::istream &amp;in)</td></tr>
<tr class="separator:a20c92032e652bdafdfd7624a55aa2866"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ac9474a14d0e8429412c82450013bde67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">MeshSmoothing</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ac9474a14d0e8429412c82450013bde67">smooth_grid</a></td></tr>
<tr class="separator:ac9474a14d0e8429412c82450013bde67"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:a4433a58d98b319f9b4ee8dce40acbf29"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
::<a class="el" href="structinternal_1_1Triangulation_1_1Iterators.html">internal::Triangulation::Iterators</a><br class="typebreak"/>
&lt; dim, spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a4433a58d98b319f9b4ee8dce40acbf29">IteratorSelector</a></td></tr>
<tr class="separator:a4433a58d98b319f9b4ee8dce40acbf29"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a61d0ea3487d046b34de4ee8f60abf1b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a61d0ea3487d046b34de4ee8f60abf1b2">clear_despite_subscriptions</a> ()</td></tr>
<tr class="separator:a61d0ea3487d046b34de4ee8f60abf1b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a73cdc08e502d9a140a625184526b89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTriangulation_1_1DistortedCellList.html">DistortedCellList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a8a73cdc08e502d9a140a625184526b89">execute_refinement</a> ()</td></tr>
<tr class="separator:a8a73cdc08e502d9a140a625184526b89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeebb271c1406d688a1ffb802a7bb509"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#afeebb271c1406d688a1ffb802a7bb509">execute_coarsening</a> ()</td></tr>
<tr class="separator:afeebb271c1406d688a1ffb802a7bb509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37dc87bf8f3793947ba51f2da20b8442"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a37dc87bf8f3793947ba51f2da20b8442">fix_coarsen_flags</a> ()</td></tr>
<tr class="separator:a37dc87bf8f3793947ba51f2da20b8442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Line iterator functions for internal use</div></td></tr>
<tr class="memitem:aa80d23446209a526187d0aaf14cbadd3"><td class="memItemLeft" align="right" valign="top">raw_line_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aa80d23446209a526187d0aaf14cbadd3">begin_raw_line</a> (const unsigned <a class="el" href="classint.html">int</a> level=0) const </td></tr>
<tr class="separator:aa80d23446209a526187d0aaf14cbadd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a398d08de81359d2cd4eb91c5460e5462"><td class="memItemLeft" align="right" valign="top">line_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a398d08de81359d2cd4eb91c5460e5462">begin_line</a> (const unsigned <a class="el" href="classint.html">int</a> level=0) const </td></tr>
<tr class="separator:a398d08de81359d2cd4eb91c5460e5462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addbe4a4dfce72e5225e86f9695648217"><td class="memItemLeft" align="right" valign="top">active_line_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#addbe4a4dfce72e5225e86f9695648217">begin_active_line</a> (const unsigned <a class="el" href="classint.html">int</a> level=0) const </td></tr>
<tr class="separator:addbe4a4dfce72e5225e86f9695648217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb606b6430f3607930ec70c25190ee0c"><td class="memItemLeft" align="right" valign="top">line_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#adb606b6430f3607930ec70c25190ee0c">end_line</a> () const </td></tr>
<tr class="separator:adb606b6430f3607930ec70c25190ee0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Quad iterator functions for internal use</div></td></tr>
<tr class="memitem:a964ed750f98d62df01f204ec8e5d81f2"><td class="memItemLeft" align="right" valign="top">raw_quad_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a964ed750f98d62df01f204ec8e5d81f2">begin_raw_quad</a> (const unsigned <a class="el" href="classint.html">int</a> level=0) const </td></tr>
<tr class="separator:a964ed750f98d62df01f204ec8e5d81f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14f73e2e21f851cad5973d840ab5e09b"><td class="memItemLeft" align="right" valign="top">quad_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a14f73e2e21f851cad5973d840ab5e09b">begin_quad</a> (const unsigned <a class="el" href="classint.html">int</a> level=0) const </td></tr>
<tr class="separator:a14f73e2e21f851cad5973d840ab5e09b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a5634ea026a09209b140edb63557b02"><td class="memItemLeft" align="right" valign="top">active_quad_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a6a5634ea026a09209b140edb63557b02">begin_active_quad</a> (const unsigned <a class="el" href="classint.html">int</a> level=0) const </td></tr>
<tr class="separator:a6a5634ea026a09209b140edb63557b02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada72d919ebc3793bbb4d9f76ea52739d"><td class="memItemLeft" align="right" valign="top">quad_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ada72d919ebc3793bbb4d9f76ea52739d">end_quad</a> () const </td></tr>
<tr class="separator:ada72d919ebc3793bbb4d9f76ea52739d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Hex iterator functions for internal use</div></td></tr>
<tr class="memitem:a7422aa35664a5e00b54e38e954e094d0"><td class="memItemLeft" align="right" valign="top">raw_hex_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a7422aa35664a5e00b54e38e954e094d0">begin_raw_hex</a> (const unsigned <a class="el" href="classint.html">int</a> level=0) const </td></tr>
<tr class="separator:a7422aa35664a5e00b54e38e954e094d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b56d10117ed133dccb98068994297a7"><td class="memItemLeft" align="right" valign="top">hex_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a8b56d10117ed133dccb98068994297a7">begin_hex</a> (const unsigned <a class="el" href="classint.html">int</a> level=0) const </td></tr>
<tr class="separator:a8b56d10117ed133dccb98068994297a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac35f5da52a334721342e130d456e2e64"><td class="memItemLeft" align="right" valign="top">active_hex_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ac35f5da52a334721342e130d456e2e64">begin_active_hex</a> (const unsigned <a class="el" href="classint.html">int</a> level=0) const </td></tr>
<tr class="separator:ac35f5da52a334721342e130d456e2e64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e726f2c9dc5cb8f6986162e8b0461c2"><td class="memItemLeft" align="right" valign="top">hex_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a3e726f2c9dc5cb8f6986162e8b0461c2">end_hex</a> () const </td></tr>
<tr class="separator:a3e726f2c9dc5cb8f6986162e8b0461c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:adde1a4821058619ac4328ddad4c77ef4"><td class="memItemLeft" align="right" valign="top">std::vector<br class="typebreak"/>
&lt;::<a class="el" href="classinternal_1_1Triangulation_1_1TriaLevel.html">internal::Triangulation::TriaLevel</a><br class="typebreak"/>
&lt; dim &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#adde1a4821058619ac4328ddad4c77ef4">levels</a></td></tr>
<tr class="separator:adde1a4821058619ac4328ddad4c77ef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6922da19b39c86383eabd4e60b04135"><td class="memItemLeft" align="right" valign="top">::<a class="el" href="classinternal_1_1Triangulation_1_1TriaFaces.html">internal::Triangulation::TriaFaces</a><br class="typebreak"/>
&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ac6922da19b39c86383eabd4e60b04135">faces</a></td></tr>
<tr class="separator:ac6922da19b39c86383eabd4e60b04135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51469854babb27752dc9f26ed9d5ee30"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a51469854babb27752dc9f26ed9d5ee30">vertices</a></td></tr>
<tr class="separator:a51469854babb27752dc9f26ed9d5ee30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12d0610e5c578ced9903db01a70f466f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a12d0610e5c578ced9903db01a70f466f">vertices_used</a></td></tr>
<tr class="separator:a12d0610e5c578ced9903db01a70f466f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d03fe8e53609ec5da4a1cae0ce3a7a4"><td class="memItemLeft" align="right" valign="top">std::map&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>, <br class="typebreak"/>
<a class="el" href="classSmartPointer.html">SmartPointer</a>&lt; const <a class="el" href="classBoundary.html">Boundary</a><br class="typebreak"/>
&lt; dim, spacedim &gt;<br class="typebreak"/>
, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a1d03fe8e53609ec5da4a1cae0ce3a7a4">boundary</a></td></tr>
<tr class="separator:a1d03fe8e53609ec5da4a1cae0ce3a7a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12dc6feb50966969856aa359f6fa316a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a12dc6feb50966969856aa359f6fa316a">anisotropic_refinement</a></td></tr>
<tr class="separator:a12dc6feb50966969856aa359f6fa316a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c55287cc4c709190b521fd98a4f5e02"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a5c55287cc4c709190b521fd98a4f5e02">check_for_distorted_cells</a></td></tr>
<tr class="separator:a5c55287cc4c709190b521fd98a4f5e02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a889fab464a381e942a091bcb76be9931"><td class="memItemLeft" align="right" valign="top">::<a class="el" href="structinternal_1_1Triangulation_1_1NumberCache.html">internal::Triangulation::NumberCache</a><br class="typebreak"/>
&lt; dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a889fab464a381e942a091bcb76be9931">number_cache</a></td></tr>
<tr class="separator:a889fab464a381e942a091bcb76be9931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31fd498d2f522ab65d8bc15f58c6a9ce"><td class="memItemLeft" align="right" valign="top">std::map&lt; unsigned <a class="el" href="classint.html">int</a>, <br class="typebreak"/>
<a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a31fd498d2f522ab65d8bc15f58c6a9ce">vertex_to_boundary_id_map_1d</a></td></tr>
<tr class="separator:a31fd498d2f522ab65d8bc15f58c6a9ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7226748b3e95ebf102e3a35d188aabd3"><td class="memItemLeft" align="right" valign="top">std::multimap&lt; const <br class="typebreak"/>
<a class="el" href="classTriangulation_1_1RefinementListener.html">RefinementListener</a> <br class="typebreak"/>
*, std::vector<br class="typebreak"/>
&lt; boost::signals2::connection &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a7226748b3e95ebf102e3a35d188aabd3">refinement_listener_map</a></td></tr>
<tr class="separator:a7226748b3e95ebf102e3a35d188aabd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a78484ccbc5d665a7ffc679fe62cecd7d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a78484ccbc5d665a7ffc679fe62cecd7d"></a>
template&lt;int , int , int &gt; </td></tr>
<tr class="memitem:a78484ccbc5d665a7ffc679fe62cecd7d"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>TriaAccessorBase</b></td></tr>
<tr class="separator:a78484ccbc5d665a7ffc679fe62cecd7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43c0730c894c987ae4e06de5f80bae12"><td class="memTemplParams" colspan="2"><a class="anchor" id="a43c0730c894c987ae4e06de5f80bae12"></a>
template&lt;int , int , int &gt; </td></tr>
<tr class="memitem:a43c0730c894c987ae4e06de5f80bae12"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>TriaAccessor</b></td></tr>
<tr class="separator:a43c0730c894c987ae4e06de5f80bae12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97f9b1157ed4068cc2ff016ceb0050fb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a97f9b1157ed4068cc2ff016ceb0050fb"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>TriaAccessor&lt; 0, 1, spacedim &gt;</b></td></tr>
<tr class="separator:a97f9b1157ed4068cc2ff016ceb0050fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16c6f26ee460554f57d2bbd3c5433c57"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a16c6f26ee460554f57d2bbd3c5433c57"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>CellAccessor&lt; dim, spacedim &gt;</b></td></tr>
<tr class="separator:a16c6f26ee460554f57d2bbd3c5433c57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5c9dbc906874eb72a28a620771a85ba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af5c9dbc906874eb72a28a620771a85ba"></a>
struct&#160;</td><td class="memItemRight" valign="bottom"><b>::internal::TriaAccessor::Implementation</b></td></tr>
<tr class="separator:af5c9dbc906874eb72a28a620771a85ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65e5f35a0d84abb5beafea34de7d8e82"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a65e5f35a0d84abb5beafea34de7d8e82"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>hp::DoFHandler&lt; dim, spacedim &gt;</b></td></tr>
<tr class="separator:a65e5f35a0d84abb5beafea34de7d8e82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cba6935d1886a01bc644a2301bc8321"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4cba6935d1886a01bc644a2301bc8321"></a>
struct&#160;</td><td class="memItemRight" valign="bottom"><b>::internal::Triangulation::Implementation</b></td></tr>
<tr class="separator:a4cba6935d1886a01bc644a2301bc8321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46a19fc147f11f0537a5e00c066e7e00"><td class="memTemplParams" colspan="2"><a class="anchor" id="a46a19fc147f11f0537a5e00c066e7e00"></a>
template&lt;typename &gt; </td></tr>
<tr class="memitem:a46a19fc147f11f0537a5e00c066e7e00"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>::internal::Triangulation::TriaObjects</b></td></tr>
<tr class="separator:a46a19fc147f11f0537a5e00c066e7e00"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Keeping up with what happens to a triangulation</h2></td></tr>
<tr class="memitem:ad136f601f63a6d1bd8e205edd93cbae3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTriangulation_1_1Signals.html">Signals</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ad136f601f63a6d1bd8e205edd93cbae3">signals</a></td></tr>
<tr class="separator:ad136f601f63a6d1bd8e205edd93cbae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae526b3400d10580ea1492ff3fd3c407a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ae526b3400d10580ea1492ff3fd3c407a">add_refinement_listener</a> (<a class="el" href="classTriangulation_1_1RefinementListener.html">RefinementListener</a> &amp;listener) const <a class="el" href="group__Sparsity.html#ga0849dabf81f46d4d964e251c286784dd">DEAL_II_DEPRECATED</a></td></tr>
<tr class="separator:ae526b3400d10580ea1492ff3fd3c407a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6f8addcc7b73f5a245c094cd949368b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aa6f8addcc7b73f5a245c094cd949368b">remove_refinement_listener</a> (<a class="el" href="classTriangulation_1_1RefinementListener.html">RefinementListener</a> &amp;listener) const <a class="el" href="group__Sparsity.html#ga0849dabf81f46d4d964e251c286784dd">DEAL_II_DEPRECATED</a></td></tr>
<tr class="separator:aa6f8addcc7b73f5a245c094cd949368b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Cell iterator functions for internal use</h2></td></tr>
<tr class="memitem:a4e117ddf1b985983751fd3b7d305a31a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classTriaRawIterator.html">TriaRawIterator</a><br class="typebreak"/>
&lt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a4e117ddf1b985983751fd3b7d305a31a">raw_cell_iterator</a></td></tr>
<tr class="separator:a4e117ddf1b985983751fd3b7d305a31a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7da84e8cf19f2013800be6e083188a59"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7da84e8cf19f2013800be6e083188a59"></a>
typedef <a class="el" href="classTriaRawIterator.html">TriaRawIterator</a><br class="typebreak"/>
&lt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; dim-1, dim, <br class="typebreak"/>
spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>raw_face_iterator</b></td></tr>
<tr class="separator:a7da84e8cf19f2013800be6e083188a59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09cd5eb1b279e0d0eae42f854cada430"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a09cd5eb1b279e0d0eae42f854cada430"></a>
typedef <br class="typebreak"/>
IteratorSelector::raw_line_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>raw_line_iterator</b></td></tr>
<tr class="separator:a09cd5eb1b279e0d0eae42f854cada430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adea27a57672c573db332e1fe31a5d4ff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adea27a57672c573db332e1fe31a5d4ff"></a>
typedef <br class="typebreak"/>
IteratorSelector::raw_quad_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>raw_quad_iterator</b></td></tr>
<tr class="separator:adea27a57672c573db332e1fe31a5d4ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaff61a76dd024751ab03a4bbe27774a6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaff61a76dd024751ab03a4bbe27774a6"></a>
typedef <br class="typebreak"/>
IteratorSelector::raw_hex_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>raw_hex_iterator</b></td></tr>
<tr class="separator:aaff61a76dd024751ab03a4bbe27774a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17040641b1946d912e687500d6fe1121"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriangulation.html#a4e117ddf1b985983751fd3b7d305a31a">raw_cell_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a17040641b1946d912e687500d6fe1121">begin_raw</a> (const unsigned <a class="el" href="classint.html">int</a> level=0) const </td></tr>
<tr class="separator:a17040641b1946d912e687500d6fe1121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fb03f729b362c559dfd941c8ed2e917"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriangulation.html#a4e117ddf1b985983751fd3b7d305a31a">raw_cell_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a9fb03f729b362c559dfd941c8ed2e917">end_raw</a> (const unsigned <a class="el" href="classint.html">int</a> level) const </td></tr>
<tr class="separator:a9fb03f729b362c559dfd941c8ed2e917"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int dim, int spacedim&gt;<br/>
class Triangulation&lt; dim, spacedim &gt;</h3>

<p>Triangulations denote a hierarchy of levels of elements which together form a <code>dim</code> -dimensional manifold in <code>spacedim</code> spatial dimensions (if spacedim is not specified it takes the default value <code>spacedim=dim</code>).</p>
<p>Thus, for example, an object of type <code>Triangulation&lt;1,1&gt;</code> (or simply <code>Triangulation&lt;1&gt;</code> since <code>spacedim==dim</code> by default) is used to represent and handle the usual one-dimensional triangulation used in the finite element method (so, segments on a straight line). On the other hand, objects such as <code>Triangulation&lt;1,2&gt;</code> or <code>Triangulation&lt;2,3&gt;</code> (that are associated with curves in 2D or surfaces in 3D) are the ones one wants to use in the boundary element method.</p>
<p>This class is written to be as independent of the dimension as possible (thus the complex construction of the <a class="el" href="classinternal_1_1Triangulation_1_1TriaLevel.html">internal::Triangulation::TriaLevel</a> classes) to allow code-sharing, to allow reducing the need to mirror changes in the code for one dimension to the code for other dimensions. Nonetheless, some of the functions are dependent of the dimension and there only exist specialized versions for distinct dimensions.</p>
<h3>Structure and iterators</h3>
<p>The actual data structure of a <a class="el" href="classTriangulation.html">Triangulation</a> object is rather complex and quite inconvenient if one attempted to operate on it directly, since data is spread over quite a lot of arrays and other places. However, there are ways powerful enough to work on these data structures without knowing their exact relations. This is done through the concept of iterators (see the STL documentation and <a class="el" href="classTriaIterator.html">TriaIterator</a>). In order to make things as easy and dimension independent as possible, use of class local typedefs is made, see below.</p>
<p>The <a class="el" href="classTriangulation.html">Triangulation</a> class provides iterator which enable looping over all cells without knowing the exact representation used to describe them. Their names are typedefs imported from the Iterators class (thus making them local types to this class) and are as follows:</p>
<ul>
<li>
<code>cell_iterator</code>: loop over all cells used in the <a class="el" href="classTriangulation.html">Triangulation</a> </li>
<li>
<code>active_cell_iterator</code>: loop over all active cells </li>
</ul>
<p>For <code>dim==1</code>, these iterators are mapped as follows: </p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> line_iterator        cell_iterator;</div>
<div class="line"><span class="keyword">typedef</span> active_line_iterator active_cell_iterator;</div>
</div><!-- fragment --><p> while for <code>dim==2</code> we have the additional face iterator: </p>
<div class="fragment"><div class="line"> <span class="keyword">typedef</span> quad_iterator        cell_iterator;</div>
<div class="line"> <span class="keyword">typedef</span> active_quad_iterator active_cell_iterator;</div>
<div class="line"></div>
<div class="line"><span class="keyword">typedef</span> line_iterator        face_iterator;</div>
<div class="line"> <span class="keyword">typedef</span> active_line_iterator active_face_iterator;</div>
</div><!-- fragment --><p>By using the cell iterators, you can write code independent of the spatial dimension. The same applies for substructure iterators, where a substructure is defined as a face of a cell. The face of a cell is a vertex in 1D and a line in 2D; however, vertices are handled in a different way and therefore lines have no faces.</p>
<p>The <a class="el" href="classTriangulation.html">Triangulation</a> class offers functions like <a class="el" href="classTriangulation.html#af99e25cc64755f18659c0fbc46c3d87d">begin_active()</a> which gives you an iterator to the first active cell. There are quite a lot of functions returning iterators. Take a look at the class doc to get an overview.</p>
<p>Usage of these iterators works mostly like with the STL iterators. Some examples taken from the <a class="el" href="classTriangulation.html">Triangulation</a> source code follow (notice that in the last two examples the template parameter <code>spacedim</code> has been omitted, so it takes the default value <code>dim</code>). </p>
<ul>
<li>
<p class="startli"><em>Counting the number of cells on a specific level</em> </p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div>
<div class="line"><span class="keywordtype">int</span> <a class="code" href="classTriangulation.html#a07ed51250524b5b9599671be911c89c4">Triangulation&lt;dim, spacedim&gt;::n_cells</a> (<span class="keyword">const</span> <span class="keywordtype">int</span> level)<span class="keyword"> const </span>{</div>
<div class="line">   cell_iterator cell = <a class="code" href="classTriangulation.html#a7b87a97ff0d6ffe416aa37fda33c46c7">begin</a> (level),</div>
<div class="line">                 endc = <a class="code" href="classTriangulation.html#aa234819cf914abe2b700535c682688a7">end</a>(level);</div>
<div class="line">   <span class="keywordtype">int</span> n=0;</div>
<div class="line">   <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div>
<div class="line">     ++n;</div>
<div class="line">   <span class="keywordflow">return</span> n;</div>
<div class="line"> };</div>
</div><!-- fragment --><p> Another way which uses the STL <code>distance</code> function would be to write </p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">int</span> <a class="code" href="classTriangulation.html#a07ed51250524b5b9599671be911c89c4">Triangulation&lt;dim&gt;::n_cells</a> (<span class="keyword">const</span> <span class="keywordtype">int</span> level)<span class="keyword"> const </span>{</div>
<div class="line">  <span class="keywordtype">int</span> n=0;</div>
<div class="line">  distance (<a class="code" href="classTriangulation.html#a7b87a97ff0d6ffe416aa37fda33c46c7">begin</a>(level),</div>
<div class="line">            (level == <a class="code" href="classTriangulation.html#adde1a4821058619ac4328ddad4c77ef4">levels</a>.size()-1 ?</div>
<div class="line">             cell_iterator(<a class="code" href="classTriangulation.html#aa234819cf914abe2b700535c682688a7">end</a>()) :</div>
<div class="line">             <a class="code" href="classTriangulation.html#a7b87a97ff0d6ffe416aa37fda33c46c7">begin</a> (level+1)),</div>
<div class="line">            n);</div>
<div class="line">  <span class="keywordflow">return</span> n;</div>
<div class="line">};</div>
</div><!-- fragment --><p class="endli"></p>
</li>
<li>
<em>Refining all cells of a triangulation</em> <div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">Triangulation&lt;dim&gt;::refine_global</a> () {</div>
<div class="line">  active_cell_iterator cell = <a class="code" href="classTriangulation.html#af99e25cc64755f18659c0fbc46c3d87d">begin_active</a>(),</div>
<div class="line">                       endc = <a class="code" href="classTriangulation.html#aa234819cf914abe2b700535c682688a7">end</a>();</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">for</span> (; cell != endc; ++cell)</div>
<div class="line">    cell-&gt;set_refine_flag ();</div>
<div class="line">  <a class="code" href="classTriangulation.html#aaedd900205c1879d8d9ef6ffe7d1a554">execute_coarsening_and_refinement</a> ();</div>
<div class="line">};</div>
</div><!-- fragment --> </li>
</ul>
<h3>Usage</h3>
<p>Usage of a <a class="el" href="classTriangulation.html">Triangulation</a> is mainly done through the use of iterators. An example probably shows best how to use it: </p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="group__ParameterGui.html#ga0ddf1224851353fc92bfbff6f499fa97">main</a> () {</div>
<div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> tria;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// read in a coarse grid file</span></div>
<div class="line"></div>
<div class="line">                                   <span class="comment">// we want to log the</span></div>
<div class="line">                                   <span class="comment">// refinement history</span></div>
<div class="line">  ofstream history (<span class="stringliteral">&quot;mesh.history&quot;</span>);</div>
<div class="line"></div>
<div class="line">                                   <span class="comment">// refine first cell</span></div>
<div class="line">  tria.<a class="code" href="classTriangulation.html#af99e25cc64755f18659c0fbc46c3d87d">begin_active</a>()-&gt;set_refine_flag();</div>
<div class="line">  tria.<a class="code" href="classTriangulation.html#abf284939143dc421b87dfb40756c1e71">save_refine_flags</a> (history);</div>
<div class="line">  tria.<a class="code" href="classTriangulation.html#aaedd900205c1879d8d9ef6ffe7d1a554">execute_coarsening_and_refinement</a> ();</div>
<div class="line"></div>
<div class="line">                                   <span class="comment">// refine first active cell</span></div>
<div class="line">                                   <span class="comment">// on coarsest level</span></div>
<div class="line">  tria.<a class="code" href="classTriangulation.html#af99e25cc64755f18659c0fbc46c3d87d">begin_active</a>()-&gt;set_refine_flag ();</div>
<div class="line">  tria.<a class="code" href="classTriangulation.html#abf284939143dc421b87dfb40756c1e71">save_refine_flags</a> (history);</div>
<div class="line">  tria.<a class="code" href="classTriangulation.html#aaedd900205c1879d8d9ef6ffe7d1a554">execute_coarsening_and_refinement</a> ();</div>
<div class="line"></div>
<div class="line">  <a class="code" href="classTriaActiveIterator.html">Triangulation&lt;2&gt;::active_cell_iterator</a> cell;</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;17; ++i)</div>
<div class="line">    {</div>
<div class="line">                                       <span class="comment">// refine the presently</span></div>
<div class="line">                                       <span class="comment">// second last cell 17</span></div>
<div class="line">                                       <span class="comment">// times</span></div>
<div class="line">      cell = tria.<a class="code" href="classTriangulation.html#af8e680fd57aaac70a8b7c9e86b32e4cd">last_active</a>(tria.<a class="code" href="classTriangulation.html#ad966e087386ee0330371ebd73f2cfe99">n_levels</a>()-1);</div>
<div class="line">      --cell;</div>
<div class="line">      cell-&gt;set_refine_flag ();</div>
<div class="line">      tria.<a class="code" href="classTriangulation.html#abf284939143dc421b87dfb40756c1e71">save_refine_flags</a> (history);</div>
<div class="line">      tria.<a class="code" href="classTriangulation.html#aaedd900205c1879d8d9ef6ffe7d1a554">execute_coarsening_and_refinement</a> ();</div>
<div class="line">    };</div>
<div class="line">                                     <span class="comment">// output the grid</span></div>
<div class="line">  ofstream out(<span class="stringliteral">&quot;grid.1&quot;</span>);</div>
<div class="line">  <a class="code" href="classGridOut.html#ae7866155a23f1ad2ee7ab85883075976">GridOut::write_gnuplot</a> (tria, out);</div>
<div class="line">};</div>
</div><!-- fragment --><h3>Creating a triangulation</h3>
<p>There are several possibilities to create a triangulation: </p>
<ul>
<li>
<p class="startli">The most common domains, such as hypercubes (i.e. lines, squares, cubes, etc), hyper-balls (circles, balls, ...) and some other, more weird domains such as the L-shape region and higher dimensional generalizations and others, are provided by the <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> class which takes a triangulation and fills it by a division of the required domain.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Reading in a triangulation: By using an object of the <a class="el" href="classGridIn.html">GridIn</a> class, you can read in fairly general triangulations. See there for more information. The mentioned class uses the interface described directly below to transfer the data into the triangulation.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Explicitly creating a triangulation: you can create a triangulation by providing a list of vertices and a list of cells. Each such cell consists of a vector storing the indices of the vertices of this cell in the vertex list. To see how this works, you can take a look at the GridIn&lt;dim&gt;::read_* functions. The appropriate function to be called is <a class="el" href="classTriangulation.html#a5b6edd805a4d8b91d016080bf43233c1">create_triangulation()</a>.</p>
<p>Creating the hierarchical information needed for this library from cells storing only vertex information can be quite a complex task. For example in 2D, we have to create lines between vertices (but only once, though there are two cells which link these two vertices) and we have to create neighborhood information. Grids being read in should therefore not be too large, reading refined grids would be inefficient (although there is technically no problem in reading grids with several 10.000 or 100.000 cells; the library can handle this without much problems). Apart from the performance aspect, refined grids do not lend too well to multigrid algorithms, since solving on the coarsest level is expensive. It is wiser in any case to read in a grid as coarse as possible and then do the needed refinement steps.</p>
<p>It is your duty to guarantee that cells have the correct orientation. To guarantee this, in the input vector keeping the cell list, the vertex indices for each cell have to be in a defined order, see the documentation of GeometryInfo&lt;dim&gt;. In one dimension, the first vertex index must refer to that vertex with the lower coordinate value. In 2D and 3D, the corresponding conditions are not easy to verify and no full attempt to do so is made. If you violate this condition, you may end up with matrix entries having the wrong sign (clockwise vertex numbering, which results in a negative area element) of with wrong matrix elements (twisted quadrilaterals, i.e. two vertices interchanged; this results in a wrong area element).</p>
<p>There are more subtle conditions which must be imposed upon the vertex numbering within cells. They do not only hold for the data read from an UCD or any other input file, but also for the data passed to <a class="el" href="classTriangulation.html#a5b6edd805a4d8b91d016080bf43233c1">create_triangulation()</a>. See the documentation for the <a class="el" href="classGridIn.html">GridIn</a> class for more details on this, and above all to the <a class="el" href="classGridReordering.html">GridReordering</a> class that explains many of the problems and an algorithm to reorder cells such that they satisfy the conditions outlined above.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Copying a triangulation: when computing on time dependent meshes or when using adaptive refinement, you will often want to create a new triangulation to be the same as another one. This is facilitated by the <code>copy_triangulation</code> function.</p>
<p class="endli">It is guaranteed that vertex, line or cell numbers in the two triangulations are the same and that two iterators walking on the two triangulations visit matching cells if they are incremented in parallel. It may be conceivable to implement a clean-up in the copy operation, which eliminates holes of unused memory, re-joins scattered data and so on. In principle this would be a useful operation but guaranteeing some parallelism in the two triangulations seems more important since usually data will have to be transferred between the grids. </p>
</li>
</ul>
<p>Finally, there is a special function for folks who like bad grids: <a class="el" href="classTriangulation.html#a083e0e57550eddc85f8804f04fc7f3cd">distort_random()</a>. It moves all the vertices in the grid a bit around by a random value, leaving behind a distorted mesh. Note that you should apply this function to the final mesh, since refinement smoothes the mesh a bit.</p>
<p>The function will make sure that vertices on restricted faces (hanging nodes) will end up in the correct place, i.e. in the middle of the two other vertices of the mother line, and the analogue in higher space dimensions (vertices on the boundary are not corrected, so don't distort boundary vertices in more than two space dimension, i.e. in dimensions where boundary vertices can be hanging nodes). Applying the algorithm has another drawback related to the placement of cells, however: the children of a cell will not occupy the same region of the domain as the mother cell does. While this is the usual behavior with cells at the boundary, here you may get into trouble when using multigrid algorithms or when transferring solutions from coarse to fine grids and back. In general, the use of this function is only safe if you only use the most refined level of the triangulation for computations.</p>
<h3>Refinement and coarsening of a triangulation</h3>
<p>Refinement of a triangulation may be done through several ways. The most low-level way is directly through iterators: let <code>i</code> be an iterator to an active cell (i.e. the cell pointed to has no children), then the function call <code>i-&gt;set_refine_flag()</code> marks the respective cell for refinement. Marking non-active cells results in an error.</p>
<p>After all the cells you wanted to mark for refinement, call <a class="el" href="classTriangulation.html#aaedd900205c1879d8d9ef6ffe7d1a554">execute_coarsening_and_refinement()</a> to actually perform the refinement. This function itself first calls the <code>prepare_coarsening_and_refinement</code> function to regularize the resulting triangulation: since a face between two adjacent cells may only be subdivided once (i.e. the levels of two adjacent cells may differ by one at most; it is not possible to have a cell refined twice while the neighboring one is not refined), some additional cells are flagged for refinement to smooth the grid. This enlarges the number of resulting cells but makes the grid more regular, thus leading to better approximation properties and, above all, making the handling of data structures and algorithms much much easier. To be honest, this is mostly an algorithmic step than one needed by the finite element method.</p>
<p>To coarsen a grid, the same way as above is possible by using <code>i-&gt;set_coarsen_flag</code> and calling <a class="el" href="classTriangulation.html#aaedd900205c1879d8d9ef6ffe7d1a554">execute_coarsening_and_refinement()</a>.</p>
<p>The reason for first coarsening, then refining is that the refinement usually adds some additional cells to keep the triangulation regular and thus satisfies all refinement requests, while the coarsening does not delete cells not requested for; therefore the refinement will often revert some effects of coarsening while the opposite is not true. The stated order of coarsening before refinement will thus normally lead to a result closer to the intended one.</p>
<p>Marking cells for refinement 'by hand' through iterators is one way to produce a new grid, especially if you know what kind of grid you are looking for, e.g. if you want to have a grid successively refined towards the boundary or always at the center (see the example programs, they do exactly these things). There are more advanced functions, however, which are more suitable for automatic generation of hierarchical grids in the context of a posteriori error estimation and adaptive finite elements. These functions can be found in the <a class="el" href="namespaceGridRefinement.html">GridRefinement</a> class.</p>
<h3>Smoothing of a triangulation</h3>
<p>Some degradation of approximation properties has been observed for grids which are too unstructured. Therefore, <a class="el" href="classTriangulation.html#ab9fa3177e0e43ab0cf243215d284a35a">prepare_coarsening_and_refinement()</a> which is automatically called by <a class="el" href="classTriangulation.html#aaedd900205c1879d8d9ef6ffe7d1a554">execute_coarsening_and_refinement()</a> can do some smoothing of the triangulation. Note that mesh smoothing is only done for two or more space dimensions, no smoothing is available at present for one spatial dimension. In the following, let <code>execute_*</code> stand for <a class="el" href="classTriangulation.html#aaedd900205c1879d8d9ef6ffe7d1a554">execute_coarsening_and_refinement()</a>.</p>
<p>For the purpose of smoothing, the <a class="el" href="classTriangulation.html">Triangulation</a> constructor takes an argument specifying whether a smoothing step shall be performed on the grid each time <code>execute_*</code> is called. The default is that such a step not be done, since this results in additional cells being produced, which may not be necessary in all cases. If switched on, calling <code>execute_*</code> results in flagging additional cells for refinement to avoid vertices as the ones mentioned. The algorithms for both regularization and smoothing of triangulations are described below in the section on technical issues. The reason why this parameter must be given to the constructor rather than to <code>execute_*</code> is that it would result in algorithmic problems if you called <code>execute_*</code> once without and once with smoothing, since then in some refinement steps would need to be refined twice.</p>
<p>The parameter taken by the constructor is an integer which may be composed bitwise by the constants defined in the enum <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">MeshSmoothing</a> (see there for the possibilities).</p>
<dl class="section note"><dt>Note</dt><dd>While it is possible to pass all of the flags in <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">MeshSmoothing</a> to objects of type <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>, it is not always possible to honor all of these smoothing options if they would require knowledge of refinement/coarsening flags on cells not locally owned by this processor. As a consequence, for some of these flags, the ultimate number of cells of the parallel triangulation may depend on the number of processors into which it is partitioned.</dd></dl>
<h3>Material and boundary information</h3>
<p>Each cell, face or edge stores information denoting the material or the part of the boundary that an object belongs to. The material of a cell may be used during matrix generation in order to implement different coefficients in different parts of the domain. It is not used by functions of the grid and dof handling libraries.</p>
<p>This material_id may be set upon construction of a triangulation (through the <a class="el" href="structCellData.html">CellData</a> data structure), or later through use of cell iterators. For a typical use of this functionality, see the <a class="el" href="step_28.html">step-28</a> tutorial program. The functions of the <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> namespace typically set the material ID of all cells to zero. When reading a triangulation, the material id must be specified in the input file (UCD format) or is otherwise set to zero. Material IDs are inherited by child cells from their parent upon mesh refinement.</p>
<p><a class="el" href="classBoundary.html">Boundary</a> indicators on lower dimensional objects (these have no material id) indicate the number of a boundary component. These are used for two purposes: First, they specify a boundary curve. When a cell is refined, a function can be used to place new vertices on this curve. See the section on boundary approximation below. Furthermore, the weak formulation of the partial differential equation may have different boundary conditions on different parts of the boundary. The boundary indicator can be used in creating the matrix or the right hand side vector to indicate these different parts of the model (this use is like the material id of cells).</p>
<p><a class="el" href="classBoundary.html">Boundary</a> indicators may be in the range from zero to <a class="el" href="namespacenumbers.html#a4e5d3fa25689151c833ba46dcc96fa5b">numbers::internal_face_boundary_id</a>-1. The value <a class="el" href="namespacenumbers.html#a4e5d3fa25689151c833ba46dcc96fa5b">numbers::internal_face_boundary_id</a> is reserved to denote interior lines (in 2D) and interior lines and quads (in 3D), which do not have a boundary indicator. This way, a program can easily determine, whether such an object is at the boundary or not. Material indicators may be in the range from zero to <a class="el" href="namespacenumbers.html#a0057e26e840aa2b146bf44499754774d">numbers::invalid_material_id</a>-1.</p>
<p>Lines in two dimensions and quads in three dimensions inherit their boundary indicator to their children upon refinement. You should therefore make sure that if you have different boundary parts, the different parts are separated by a vertex (in 2D) or a line (in 3D) such that each boundary line or quad has a unique boundary indicator.</p>
<p>By default (unless otherwise specified during creation of a triangulation), all parts of the boundary have boundary indicator zero. As a historical wart, this isn't true for 1d meshes, however: For these, leftmost vertices have boundary indicator zero while rightmost vertices have boundary indicator one. In either case, the boundary indicator of a face can be changed using a call of the kind <code>cell-&gt;face(1)-&gt;set_boundary_indicator(42);</code>.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a></dd></dl>
<h3>History of a triangulation</h3>
<p>It is possible to reconstruct a grid from its refinement history, which can be stored and loaded through the <code>save_refine_flags</code> and <code>load_refine_flags</code> functions. Normally, the code will look like this: </p>
<div class="fragment"><div class="line">                            <span class="comment">// open output file</span></div>
<div class="line">ofstream history(<span class="stringliteral">&quot;mesh.history&quot;</span>);</div>
<div class="line">                            <span class="comment">// do 10 refinement steps</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> step=0; step&lt;10; ++step) {</div>
<div class="line">  ...;</div>
<div class="line">  <span class="comment">// flag cells according to some criterion</span></div>
<div class="line">  ...;</div>
<div class="line">  tria.<a class="code" href="classTriangulation.html#abf284939143dc421b87dfb40756c1e71">save_refine_flags</a> (history);</div>
<div class="line">  tria.<a class="code" href="classTriangulation.html#aaedd900205c1879d8d9ef6ffe7d1a554">execute_coarsening_and_refinement</a> ();</div>
<div class="line">};</div>
</div><!-- fragment --><p>If you want to re-create the grid from the stored information, you write: </p>
<div class="fragment"><div class="line">                            <span class="comment">// open input file</span></div>
<div class="line">ifstream history(<span class="stringliteral">&quot;mesh.history&quot;</span>);</div>
<div class="line">                            <span class="comment">// do 10 refinement steps</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> step=0; step&lt;10; ++step) {</div>
<div class="line">  tria.<a class="code" href="classTriangulation.html#a43fc07c3f9e1f02658ca556f41087c85">load_refine_flags</a> (history);</div>
<div class="line">  tria.<a class="code" href="classTriangulation.html#aaedd900205c1879d8d9ef6ffe7d1a554">execute_coarsening_and_refinement</a> ();</div>
<div class="line">};</div>
</div><!-- fragment --><p>The same scheme is employed for coarsening and the coarsening flags.</p>
<p>You may write other information to the output file between different sets of refinement information, as long as you read it upon re-creation of the grid. You should make sure that the other information in the new triangulation which is to be created from the saved flags, matches that of the old triangulation, for example the smoothing level; if not, the cells actually created from the flags may be other ones, since smoothing adds additional cells, but their number may be depending on the smoothing level.</p>
<p>There actually are two sets of <code>save_*_flags</code> and <code>load_*_flags</code> functions. One takes a stream as argument and reads/writes the information from/to the stream, thus enabling storing flags to files. The other set takes an argument of type <code>vector&lt;bool&gt;</code>. This enables the user to temporarily store some flags, e.g. if another function needs them, and restore them afterwards.</p>
<h3>User flags and data</h3>
<p>A triangulation offers one bit per line, quad, etc for user flags. This field can be accessed as all other data using iterators. Normally, this user flag is used if an algorithm walks over all cells and needs information whether another cell, e.g. a neighbor, has already been processed. See <a class="el" href="DEALGlossary.html#GlossUserFlags">the glossary for more information</a>.</p>
<p>There is another set of user data, which can be either an <code>unsigned int</code> or a <code>void *</code>, for each line, quad, etc. You can access these through the functions listed under <code>User data</code> in the accessor classes. Again, see <a class="el" href="DEALGlossary.html#GlossUserData">the glossary for more information</a>.</p>
<p>The value of these user indices or pointers is <code>NULL</code> by default. Note that the pointers are not inherited to children upon refinement. Still, after a remeshing they are available on all cells, where they were set on the previous mesh.</p>
<p>The usual warning about the missing type safety of <code>void</code> pointers are obviously in place here; responsibility for correctness of types etc lies entirely with the user of the pointer.</p>
<dl class="section note"><dt>Note</dt><dd>User pointers and user indices are stored in the same place. In order to avoid unwanted conversions, <a class="el" href="classTriangulation.html">Triangulation</a> checks which one of them is in use and does not allow access to the other one, until <a class="el" href="classTriangulation.html#a26562806fd764afdffb973dce92554e8">clear_user_data()</a> has been called.</dd></dl>
<h3><a class="el" href="classBoundary.html">Boundary</a> approximation</h3>
<p>You can specify a boundary function for each boundary component. If a new vertex is created on a side or face at the boundary, this function is used to compute where it will be placed. The boundary indicator of the face will be used to determine the proper component. See <a class="el" href="classBoundary.html">Boundary</a> for the details. Usage with the <a class="el" href="classTriangulation.html">Triangulation</a> object is then like this (let <code>Ball</code> be a class derived from <a class="el" href="classBoundary.html">Boundary</a><code>&lt;2&gt;</code>):</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="group__ParameterGui.html#ga0ddf1224851353fc92bfbff6f499fa97">main</a> () {</div>
<div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> tria;</div>
<div class="line">                                   <span class="comment">// set the boundary function</span></div>
<div class="line">                                   <span class="comment">// for all boundaries with</span></div>
<div class="line">                                   <span class="comment">// boundary indicator 0</span></div>
<div class="line">  Ball ball;</div>
<div class="line">  tria.<a class="code" href="group__boundary.html#ga0509d862f0e07071dcff837bd58fd082">set_boundary</a> (0, ball);</div>
<div class="line"></div>
<div class="line">  <span class="comment">// read some coarse grid</span></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <a class="code" href="classTriaActiveIterator.html">Triangulation&lt;2&gt;::active_cell_iterator</a> cell, endc;</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;8; ++i)</div>
<div class="line">    {</div>
<div class="line">      cell = tria.<a class="code" href="classTriangulation.html#af99e25cc64755f18659c0fbc46c3d87d">begin_active</a>();</div>
<div class="line">      endc = tria.<a class="code" href="classTriangulation.html#aa234819cf914abe2b700535c682688a7">end</a>();</div>
<div class="line"></div>
<div class="line">                                       <span class="comment">// refine all</span></div>
<div class="line">                                       <span class="comment">// boundary cells</span></div>
<div class="line">      <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div>
<div class="line">        <span class="keywordflow">if</span> (cell-&gt;at_boundary())</div>
<div class="line">          cell-&gt;set_refine_flag();</div>
<div class="line"></div>
<div class="line">      tria.<a class="code" href="classTriangulation.html#aaedd900205c1879d8d9ef6ffe7d1a554">execute_coarsening_and_refinement</a>();</div>
<div class="line">    };</div>
<div class="line">};</div>
</div><!-- fragment --><p>You should take note of one caveat: if you have concave boundaries, you must make sure that a new boundary vertex does not lie too much inside the cell which is to be refined. The reason is that the center vertex is placed at the point which is the arithmetic mean of the vertices of the original cell. Therefore if your new boundary vertex is too near the center of the old quadrilateral or hexahedron, the distance to the midpoint vertex will become too small, thus generating distorted cells. This issue is discussed extensively in <a class="el" href="DEALGlossary.html#GlossDistorted">distorted cells</a>.</p>
<h3>Getting notice when a triangulation changes</h3>
<p>There are cases where one object would like to know whenever a triangulation is being refined, copied, or modified in a number of other ways. This could of course be achieved if, in your user code, you tell every such object whenever you are about to refine the triangulation, but this will get tedious and is error prone. The <a class="el" href="classTriangulation.html">Triangulation</a> class implements a more elegant way to achieve this: signals.</p>
<p>In essence, a signal is an object (a member of the <a class="el" href="classTriangulation.html">Triangulation</a> class) that another object can connect to. A connection is in essence that the connecting object passes a function object taking a certain number and kind of arguments. Whenever the owner of the signal wants to indicate a certain kind of event, it 'triggers' the signal, which in turn means that all connections of the signal are triggered: in other word, the function objects are executed and can take the action that is necessary.</p>
<p>As a simple example, the following code will print something to the output every time the triangulation has just been refined: </p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> f() {</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Triangulation has been refined.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> f() {</div>
<div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> triangulation;</div>
<div class="line">  <span class="comment">// fill it somehow</span></div>
<div class="line">  triangulation.<a class="code" href="classTriangulation.html#ad136f601f63a6d1bd8e205edd93cbae3">signals</a>.post_refinement.connect (&amp;f);</div>
<div class="line">  triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a> (2);</div>
</div><!-- fragment --><p> This code will produce output twice, once for each refinement cycle.</p>
<p>A more interesting application would be the following, akin to what the <a class="el" href="classFEValues.html">FEValues</a> class does. This class stores a pointer to a triangulation and also an iterator to the cell last handled (so that it can compare the current cell with the previous one and, for example, decide that there is no need to re-compute the Jacobian matrix if the new cell is a simple translation of the previous one). However, whenever the triangulation is modified, the iterator to the previously handled cell needs to be invalidated since it now no longer points to any useful cell (or, at the very least, points to something that may not necessarily resemble the cells previously handled). The code would look something like this (the real code has some more error checking and has to handle the case that subsequent cells might actually belong to different triangulation, but that is of no concern to us here): </p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keyword">class </span><a class="code" href="classFEValues.html">FEValues</a> {</div>
<div class="line">    <a class="code" href="classTriaActiveIterator.html">Triangulation&lt;dim&gt;::active_cell_iterator</a> current_cell, previous_cell;</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> reinit (<a class="code" href="classTriaActiveIterator.html">Triangulation&lt;dim&gt;::active_cell_iterator</a> &amp;cell);</div>
<div class="line">    <span class="keywordtype">void</span> invalidate_previous_cell ();</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line"><a class="code" href="classFEValues.html#afde502903642c57ade24dfcebf5c1650">FEValues&lt;dim&gt;::reinit</a> (<a class="code" href="classTriaActiveIterator.html">Triangulation&lt;dim&gt;::active_cell_iterator</a> &amp;cell) {</div>
<div class="line">  <span class="keywordflow">if</span> (previous_cell.status() != <a class="code" href="namespaceIteratorState.html#a4e92f4a9d339ff987cc3eb5b0a1ac507a457da025bc5a3a2231a667bd5c6f3c92">valid</a>)</div>
<div class="line">    {</div>
<div class="line">      <span class="comment">// previous_cell has not been set. set it now, and register</span></div>
<div class="line">      <span class="comment">// with the triangulation that we want to be informed about</span></div>
<div class="line">      <span class="comment">// mesh refinement</span></div>
<div class="line">      previous_cell = current_cell;</div>
<div class="line">      previous_cell.get_tria().signals.post_refinement</div>
<div class="line">        .connect (std_cxx1x::bind (&amp;<a class="code" href="classFEValues.html">FEValues&lt;dim&gt;::invalidate_previous_cell</a>,</div>
<div class="line">                                   std_cxx1x::ref (*<span class="keyword">this</span>)));</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">    previous_cell = current_cell;</div>
<div class="line"></div>
<div class="line">  current_cell = cell;</div>
<div class="line">  ... <span class="keywordflow">do</span> something with the cell...</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line"><a class="code" href="classFEValues.html">FEValues&lt;dim&gt;::invalidate_previous_cell</a> () {</div>
<div class="line">  previous_cell = <a class="code" href="classTriaActiveIterator.html">Triangulation&lt;dim&gt;::active_cell_iterator</a>();</div>
<div class="line">}</div>
</div><!-- fragment --><p> Here, whenever the triangulation is refined, it triggers the post-refinement signal which calls the function object attached to it. This function object is the member function <code>FEValues&lt;dim&gt;::invalidate_previous_cell</code> where we have bound the single argument (the <code>this</code> pointer of a member function that otherwise takes no arguments) to the <code>this</code> pointer of the <a class="el" href="classFEValues.html">FEValues</a> object. Note how here there is no need for the code that owns the triangulation and the <a class="el" href="classFEValues.html">FEValues</a> object to inform the latter if the former is refined. (In practice, the function would want to connect to some of the other signals that the triangulation offers as well, in particular to creation and deletion signals.)</p>
<p>The <a class="el" href="classTriangulation.html">Triangulation</a> class has a variety of signals that indicate different actions by which the triangulation can modify itself and potentially require follow-up action elsewhere:</p>
<ul>
<li>creation: This signal is triggered whenever the <a class="el" href="classTriangulation.html#a5b6edd805a4d8b91d016080bf43233c1">Triangulation::create_triangulation</a> or <a class="el" href="classTriangulation.html#a20dd4d20bf729c20410e47eb9bcd7065">Triangulation::copy_triangulation</a> is called. This signal is also triggered when loading a triangulation from an archive via <a class="el" href="classTriangulation.html#ae2f72d5fbb277ec65dbe0382ae72a929">Triangulation::load</a>.</li>
<li>pre-refinement: This signal is triggered at the beginning of execution of the <a class="el" href="classTriangulation.html#aaedd900205c1879d8d9ef6ffe7d1a554">Triangulation::execute_coarsening_and_refinement</a> function (which is itself called by other functions such as <a class="el" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">Triangulation::refine_global</a>). At the time this signal is triggered, the triangulation is still unchanged.</li>
<li>post-refinement: This signal is triggered at the end of execution of the <a class="el" href="classTriangulation.html#aaedd900205c1879d8d9ef6ffe7d1a554">Triangulation::execute_coarsening_and_refinement</a> function when the triangulation has reached its final state</li>
<li>copy: This signal is triggered whenever the triangulation owning the signal is copied by another triangulation using <a class="el" href="classTriangulation.html#a20dd4d20bf729c20410e47eb9bcd7065">Triangulation::copy_triangulation</a> (i.e. it is triggered on the <em>old</em> triangulation, but the new one is passed as a argument).</li>
<li>clear: This signal is triggered whenever the <a class="el" href="classTriangulation.html#a12d54b7dae635d867bf8d2c4b3605817">Triangulation::clear</a> function is called. This signal is also triggered when loading a triangulation from an archive via <a class="el" href="classTriangulation.html#ae2f72d5fbb277ec65dbe0382ae72a929">Triangulation::load</a> as the previous content of the triangulation is first destroyed.</li>
<li>any_change: This is a catch-all signal that is triggered whenever the create, post_refinement, or clear signals are triggered. In effect, it can be used to indicate to an object connected to the signal that the triangulation has been changed, whatever the exact cause of the change.</li>
</ul>
<h3>Serializing (loading or storing) triangulations</h3>
<p>Like many other classes in deal.II, the <a class="el" href="classTriangulation.html">Triangulation</a> class can stream its contents to an archive using BOOST's serialization facilities. The data so stored can later be retrieved again from the archive to restore the contents of this object. This facility is frequently used to save the state of a program to disk for possible later resurrection, often in the context of checkpoint/restart strategies for long running computations or on computers that aren't very reliable (e.g. on very large clusters where individual nodes occasionally fail and then bring down an entire MPI job).</p>
<p>For technical reasons, writing and restoring a <a class="el" href="classTriangulation.html">Triangulation</a> object is not-trivial. The primary reason is that unlike many other objects, triangulations rely on many other objects to which they store pointers or with which they interace; for example, triangulations store pointers to objects describing boundaries and manifolds, and they have signals that store pointers to other objects so they can be notified of changes in the triangulation (see the section on signals in this introduction). As objects that are re-loaded at a later time do not usually end up at the same location in memory as they were when they were saved, dealing with pointers to other objects is difficult.</p>
<p>For these reasons, saving a triangulation to an archive does not store all information, but only certain parts. More specifically, the information that is stored is everything that defines the mesh such as vertex locations, vertex indices, how vertices are connected to cells, boundary indicators, subdomain ids, material ids, etc. On the other hand, the following information is not stored:</p>
<ul>
<li>signals</li>
<li>pointers to boundary objects previously set using <a class="el" href="group__boundary.html#ga0509d862f0e07071dcff837bd58fd082">Triangulation::set_boundary</a> On the other hand, since these are objects that are usually set in user code, they can typically easily be set again in that part of your code in which you re-load triangulations.</li>
</ul>
<p>In a sense, this approach to serialization means that re-loading a triangulation is more akin to calling the <a class="el" href="classTriangulation.html#a5b6edd805a4d8b91d016080bf43233c1">Triangulation::create_triangulation</a> function and filling it with some additional content, as that function also does not touch the signals and boundary objects that belong to this triangulation. In keeping with this analogy, the <a class="el" href="classTriangulation.html#ae2f72d5fbb277ec65dbe0382ae72a929">Triangulation::load</a> function also triggers the same kinds of signal as <a class="el" href="classTriangulation.html#a5b6edd805a4d8b91d016080bf43233c1">Triangulation::create_triangulation</a>.</p>
<h3>Technical details</h3>
<h4><a class="el" href="namespaceAlgorithms.html">Algorithms</a> for mesh regularization and smoothing upon refinement</h4>
<p>We chose an inductive point of view: since upon creation of the triangulation all cells are on the same level, all regularity assumptions regarding the maximum difference in level of cells sharing a common face, edge or vertex hold. Since we use the regularization and smoothing in each step of the mesh history, when coming to the point of refining it further the assumptions also hold.</p>
<p>The regularization and smoothing is done in the <code>prepare_coarsening_and_refinement</code> function, which is called by <code>execute_coarsening_and_refinement</code> at the very beginning. It decides which additional cells to flag for refinement by looking at the old grid and the refinement flags for each cell.</p>
<ul>
<li>
<p class="startli"><em>Regularization:</em> The algorithm walks over all cells checking whether the present cell is flagged for refinement and a neighbor of the present cell is refined once less than the present one. If so, flag the neighbor for refinement. Because of the induction above, there may be no neighbor with level two less than the present one.</p>
<p>The neighbor thus flagged for refinement may induce more cells which need to be refined. However, such cells which need additional refinement always are on one level lower than the present one, so we can get away with only one sweep over all cells if we do the loop in the reverse way, starting with those on the highest level. This way, we may flag additional cells on lower levels, but if these induce more refinement needed, this is performed later on when we visit them in out backward running loop.</p>
<p class="endli"></p>
</li>
<li>
<em>Smoothing:</em> <ul>
<li>
<p class="startli"><code>limit_level_difference_at_vertices:</code> First a list is set up which stores for each vertex the highest level one of the adjacent cells belongs to. Now, since we did smoothing in the previous refinement steps also, each cell may only have vertices with levels at most one greater than the level of the present cell.</p>
<p>However, if we store the level plus one for cells marked for refinement, we may end up with cells which have vertices of level two greater than the cells level. We need to refine this cell also, and need thus also update the levels of its vertices. This itself may lead to cells needing refinement, but these are on lower levels, as above, which is why we may do all kinds of additional flagging in one loop only.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><code>eliminate_unrefined_islands:</code> For each cell we count the number of neighbors which are refined or flagged for refinement. If this exceeds the number of neighbors which are not refined and not flagged for refinement, then the current cell is flagged for refinement. Since this may lead to cells on the same level which also will need refinement, we will need additional loops of regularization and smoothing over all cells until nothing changes any more.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><code>eliminate_refined_*_islands</code>: This one does much the same as the above one, but for coarsening. If a cell is flagged for refinement or if all of its children are active and if the number of neighbors which are either active and not flagged for refinement, or not active but all children flagged for coarsening equals the total number of neighbors, then this cell's children are flagged for coarsening or (if this cell was flagged for refinement) the refine flag is cleared.</p>
<p>For a description of the distinction between the two versions of the flag see above in the section about mesh smoothing in the general part of this classes description.</p>
<p class="endli">The same applies as above: several loops may be necessary. </p>
</li>
</ul>
</li>
</ul>
<p>Regularization and smoothing are a bit complementary in that we check whether we need to set additional refinement flags when being on a cell flagged for refinement (regularization) or on a cell not flagged for refinement. This makes readable programming easier.</p>
<p>All the described algorithms apply only for more than one space dimension, since for one dimension no restrictions apply. It may be necessary to apply some smoothing for multigrid algorithms, but this has to be decided upon later.</p>
<h3>Warning</h3>
<p>It seems impossible to preserve <code>constness</code> of a triangulation through iterator usage. Thus, if you declare pointers to a <code>const</code> triangulation object, you should be well aware that you might involuntarily alter the data stored in the triangulation.</p>
<dl class="section author"><dt>Author</dt><dd>Wolfgang Bangerth, 1998; Ralf Hartmann, 2005 </dd></dl>

<p>Definition at line <a class="el" href="dof__iterator__selector_8h_source.html#l00034">34</a> of file <a class="el" href="dof__iterator__selector_8h_source.html">dof_iterator_selector.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a4433a58d98b319f9b4ee8dce40acbf29"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef ::<a class="el" href="structinternal_1_1Triangulation_1_1Iterators.html">internal::Triangulation::Iterators</a>&lt;dim, spacedim&gt; <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classTriangulation.html#a4433a58d98b319f9b4ee8dce40acbf29">IteratorSelector</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>An internal typedef to make the definition of the iterator classes simpler. </p>

<p>Definition at line <a class="el" href="grid_2tria_8h_source.html#l01225">1225</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4e117ddf1b985983751fd3b7d305a31a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classTriaRawIterator.html">TriaRawIterator</a>&lt;<a class="el" href="classCellAccessor.html">CellAccessor</a>&lt;dim,spacedim&gt; &gt; <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classTriangulation.html#a4e117ddf1b985983751fd3b7d305a31a">raw_cell_iterator</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Declare a number of iterator types for raw iterators, i.e., iterators that also iterate over holes in the list of cells left by cells that have been coarsened away in previous mesh refinement cycles.</p>
<p>Since users should never have to access these internal properties of how we store data, these iterator types are made private. </p>

<p>Definition at line <a class="el" href="grid_2tria_8h_source.html#l03304">3304</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="a0633dd17e535a59162b79f338c6ff5ae"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">Triangulation::MeshSmoothing</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare some symbolic names for mesh smoothing algorithms. The meaning of these flags is documented in the <a class="el" href="classTriangulation.html">Triangulation</a> class. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a0633dd17e535a59162b79f338c6ff5aea9828da1d84133b33b112afd4a0ac15ec"></a>none&#160;</td><td class="fielddoc">
<p>No mesh smoothing at all, except that meshes have to remain one-irregular. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a0633dd17e535a59162b79f338c6ff5aeaa2ab57e4f7b1633f26092ae861ea3bfc"></a>limit_level_difference_at_vertices&#160;</td><td class="fielddoc">
<p>It can be shown, that degradation of approximation occurs if the triangulation contains vertices which are member of cells with levels differing by more than one. One such example is the following:</p>
<div class="image">
<img src="limit_level_difference_at_vertices.png" alt="limit_level_difference_at_vertices.png"/>
</div>
<p> It would seem that in two space dimensions, the maximum jump in levels between cells sharing a common vertex is two (as in the example above). However, this is not true if more than four cells meet at a vertex. It is not uncommon that a coarse (initial) mesh contains vertices at which six or even eight cells meet, when small features of the domain have to be resolved even on the coarsest mesh. In that case, the maximum difference in levels is three or four, respectively. The problem gets even worse in three space dimensions.</p>
<p>Looking at an interpolation of the second derivative of the finite element solution (assuming bilinear finite elements), one sees that the numerical solution is almost totally wrong, compared with the true second derivative. Indeed, on regular meshes, there exist sharp estimations that the H<sup>2</sup>-error is only of order one, so we should not be surprised; however, the numerical solution may show a value for the second derivative which may be a factor of ten away from the true value. These problems are located on the small cell adjacent to the center vertex, where cells of non-subsequent levels meet, as well as on the upper and right neighbor of this cell (but with a less degree of deviation from the true value).</p>
<p>If the smoothing indicator given to the constructor contains the bit for <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeaa2ab57e4f7b1633f26092ae861ea3bfc">limit_level_difference_at_vertices</a>, situations as the above one are eliminated by also marking the lower left cell for refinement.</p>
<p>In case of anisotropic refinement, the level of a cell is not linked to the refinement of a cell as directly as in case of isotropic refinement. Furthermore, a cell can be strongly refined in one direction and not or at least much less refined in another. Therefore, it is very difficult to decide, which cases should be excluded from the refinement process. As a consequence, when using anisotropic refinement, the <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeaa2ab57e4f7b1633f26092ae861ea3bfc">limit_level_difference_at_vertices</a> flag must not be set. On the other hand, the implementation of multigrid methods in deal.II requires that this bit be set. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a0633dd17e535a59162b79f338c6ff5aeaf065376600b9b08c1c65d00505225e2f"></a>eliminate_unrefined_islands&#160;</td><td class="fielddoc">
<p>Single cells which are not refined and are surrounded by cells which are refined usually also lead to a sharp decline in approximation properties locally. The reason is that the nodes on the faces between unrefined and refined cells are not real degrees of freedom but carry constraints. The patch without additional degrees of freedom is thus significantly larger then the unrefined cell itself. If in the parameter passed to the constructor the bit for <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeaf065376600b9b08c1c65d00505225e2f">eliminate_unrefined_islands</a> is set, all cells which are not flagged for refinement but which are surrounded by more refined cells than unrefined cells are flagged for refinement. Cells which are not yet refined but flagged for that are accounted for the number of refined neighbors. Cells on the boundary are not accounted for at all. An unrefined island is, by this definition also a cell which (in 2D) is surrounded by three refined cells and one unrefined one, or one surrounded by two refined cells, one unrefined one and is at the boundary on one side. It is thus not a true island, as the name of the flag may indicate. However, no better name came to mind to the author by now. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a0633dd17e535a59162b79f338c6ff5aea37c283b96070dc09dde81f51d3ce1812"></a>patch_level_1&#160;</td><td class="fielddoc">
<p>A triangulation of patch level 1 consists of patches, i.e. of cells that are refined once. This flag ensures that a mesh of patch level 1 is still of patch level 1 after coarsening and refinement. It is, however, the user's responsibility to ensure that the mesh is of patch level 1 before calling <a class="el" href="classTriangulation.html#aaedd900205c1879d8d9ef6ffe7d1a554">Triangulation::execute_coarsening_and_refinement()</a> the first time. The easiest way to achieve this is by calling global_refine(1) straight after creation of the triangulation. It follows that if at least one of the children of a cell is or will be refined than all children need to be refined. If the <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea37c283b96070dc09dde81f51d3ce1812">patch_level_1</a> flag is set, than the flags <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeaf065376600b9b08c1c65d00505225e2f">eliminate_unrefined_islands</a>, <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeaf3f26812258d56f4306f9b4a4858ee1e">eliminate_refined_inner_islands</a> and <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea5eaba327f7131b70f58aa6d0837dfa58">eliminate_refined_boundary_islands</a> will be ignored as they will be fulfilled automatically. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a0633dd17e535a59162b79f338c6ff5aeae94a75f4383724ef8f58639aef2eb6c0"></a>coarsest_level_1&#160;</td><td class="fielddoc">
<p>Each coarse grid cell is refined at least once, i.e. the triangulation might have active cells on level 1 but not on level 0. This flag ensures that a mesh which has coarsest_level_1 has still coarsest_level_1 after coarsening and refinement. It is, however, the user's responsibility to ensure that the mesh has coarsest_level_1 before calling execute_coarsening_and_refinement the first time. The easiest way to achieve this is by calling global_refine(1) straight after creation of the triangulation. It follows that active cells on level 1 may not be coarsenend.</p>
<p>The main use of this flag is to ensure that each cell has at least one neighbor in each coordinate direction (i.e. each cell has at least a left or right, and at least an upper or lower neighbor in 2d). This is a necessary precondition for some algorihms that compute finite differences between cells. The <a class="el" href="classDerivativeApproximation.html">DerivativeApproximation</a> class is one of these algorithms that require that a triangulation is coarsest_level_1 unless all cells already have at least one neighbor in each coordinate direction on the coarsest level. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a0633dd17e535a59162b79f338c6ff5aeaa44d17458e16327fb4b674745b883910"></a>allow_anisotropic_smoothing&#160;</td><td class="fielddoc">
<p>This flag is not included in <code>maximum_smoothing</code>. The flag is concerned with the following case: consider the case that an unrefined and a refined cell share a common face and that one of the children of the refined cell along the common face is flagged for further refinement. In that case, the resulting mesh would have more than one hanging node along one or more of the edges of the triangulation, a situation that is not allowed. Consequently, in order to perform the refinement, the coarser of the two original cells is also going to be refined.</p>
<p>However, in many cases it is sufficient to refine the coarser of the two original cells in an anisotropic way to avoid the case of multiple hanging vertices on a single edge. Doing only the minimal anisotropic refinement can save cells and degrees of freedom. By specifying this flag, the library can produce these anisotropic refinements.</p>
<p>The flag is not included by default since it may lead to anisotropically refined meshes even though no cell has ever been refined anisotropically explicitly by a user command. This surprising fact may lead to programs that do the wrong thing since they are not written for the additional cases that can happen with anisotropic meshes, see the discussion in the introduction to <a class="el" href="step_30.html">step-30</a>. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a0633dd17e535a59162b79f338c6ff5aeaf3f26812258d56f4306f9b4a4858ee1e"></a>eliminate_refined_inner_islands&#160;</td><td class="fielddoc">
<p>This algorithm seeks for isolated cells which are refined or flagged for refinement. This definition is unlike that for <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeaf065376600b9b08c1c65d00505225e2f">eliminate_unrefined_islands</a>, which would mean that an island is defined as a cell which is refined but more of its neighbors are not refined than are refined. For example, in 2D, a cell's refinement would be reverted if at most one of its neighbors is also refined (or refined but flagged for coarsening).</p>
<p>The reason for the change in definition of an island is, that this option would be a bit dangerous, since if you consider a chain of refined cells (e.g. along a kink in the solution), the cells at the two ends would be coarsened, after which the next outermost cells would need to be coarsened. Therefore, only one loop of flagging cells like this could be done to avoid eating up the whole chain of refined cells (`chain reaction'...).</p>
<p>This algorithm also takes into account cells which are not actually refined but are flagged for refinement. If necessary, it takes away the refinement flag.</p>
<p>Actually there are two versions of this flag, <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeaf3f26812258d56f4306f9b4a4858ee1e">eliminate_refined_inner_islands</a> and <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea5eaba327f7131b70f58aa6d0837dfa58">eliminate_refined_boundary_islands</a>. There first eliminates islands defined by the definition above which are in the interior of the domain, while the second eliminates only those islands if the cell is at the boundary. The reason for this split of flags is that one often wants to eliminate such islands in the interior while those at the boundary may well be wanted, for example if one refines the mesh according to a criterion associated with a boundary integral or if one has rough boundary data. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a0633dd17e535a59162b79f338c6ff5aea5eaba327f7131b70f58aa6d0837dfa58"></a>eliminate_refined_boundary_islands&#160;</td><td class="fielddoc">
<p>The result of this flag is very similar to <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeaf3f26812258d56f4306f9b4a4858ee1e">eliminate_refined_inner_islands</a>. See the documentation there. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a0633dd17e535a59162b79f338c6ff5aea75171630dec90d241c811d2732410303"></a>do_not_produce_unrefined_islands&#160;</td><td class="fielddoc">
<p>This flag prevents the occurrence of unrefined islands. In more detail: It prohibits the coarsening of a cell if 'most of the neighbors' will be refined after the step. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a0633dd17e535a59162b79f338c6ff5aea3fb6b9153821aefc45661f67f22e232a"></a>smoothing_on_refinement&#160;</td><td class="fielddoc">
<p>This flag sums up all smoothing algorithms which may be performed upon refinement by flagging some more cells for refinement. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a0633dd17e535a59162b79f338c6ff5aea8d8dbaaa62136a7e51c7bf5c02d6e1e7"></a>smoothing_on_coarsening&#160;</td><td class="fielddoc">
<p>This flag sums up all smoothing algorithms which may be performed upon coarsening by flagging some more cells for coarsening. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a0633dd17e535a59162b79f338c6ff5aeaf64b535fd0fad99b6032412d2cccac36"></a>maximum_smoothing&#160;</td><td class="fielddoc">
<p>This flag includes all the above ones and therefore combines all smoothing algorithms implemented with the exception of anisotropic smoothening. </p>
</td></tr>
</table>

<p>Definition at line <a class="el" href="grid_2tria_8h_source.html#l01243">1243</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a67f431ce66c6df985caf5587bf329ebc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classTriangulation.html">Triangulation</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">MeshSmoothing</a>&#160;</td>
          <td class="paramname"><em>smooth_grid</em> = <code><a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea9828da1d84133b33b112afd4a0ac15ec">none</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>check_for_distorted_cells</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create an empty triangulation. Do not create any cells.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">smooth_grid</td><td>Determines the level of smoothness of the mesh size function that should be enforced upon mesh refinement.</td></tr>
    <tr><td class="paramname">check_for_distorted_cells</td><td>Determines whether the triangulation should check whether any of the cells that are created by <a class="el" href="classTriangulation.html#a5b6edd805a4d8b91d016080bf43233c1">create_triangulation()</a> or <a class="el" href="classTriangulation.html#aaedd900205c1879d8d9ef6ffe7d1a554">execute_coarsening_and_refinement()</a> are distorted (see <a class="el" href="DEALGlossary.html#GlossDistorted">distorted cells</a>). If set, these two functions may throw an exception if they encounter distorted cells. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac915084b738c83c836e2e26d439c4c67"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classTriangulation.html">Triangulation</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy constructor.</p>
<p>You should really use the <code>copy_triangulation</code> function, so we declare this function but let it throw an internal error. The reason for this is that we may want to use triangulation objects in collections. However, C++ containers require that the objects stored in them are copyable, so we need to provide a copy constructor. On the other hand, copying triangulations is so expensive that we do not want such objects copied by accident, for example in compiler-generated temporary objects. By defining a copy constructor but throwing an error, we satisfy the formal requirements of containers, but at the same time disallow actual copies. Finally, through the exception, one easily finds the places where code has to be changed to avoid copies. </p>

</div>
</div>
<a class="anchor" id="aa5c7d0ad970c39d13625d0409506afad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::~<a class="el" href="classTriangulation.html">Triangulation</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Delete the object and all levels of the hierarchy. </p>

<p>Reimplemented in <a class="el" href="classparallel_1_1distributed_1_1Triangulation_3_011_00_01spacedim_01_4.html#ad0d454c1252863c77f2674236a763bef">parallel::distributed::Triangulation&lt; 1, spacedim &gt;</a>, and <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a7c4f65bc1b1bed219dc9761aeff3ffcd">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a12d54b7dae635d867bf8d2c4b3605817"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reset this triangulation into a virgin state by deleting all data.</p>
<p>Note that this operation is only allowed if no subscriptions to this object exist any more, such as <a class="el" href="classDoFHandler.html">DoFHandler</a> objects using it. </p>

<p>Reimplemented in <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a33149c5da6e4af995db056305accf950">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a4a302f66ccc9bd281cf850fdc4f76e50"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::set_mesh_smoothing </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">MeshSmoothing</a>&#160;</td>
          <td class="paramname"><em>mesh_smoothing</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the mesh smoothing to <code>mesh_smoothing</code>. This overrides the MeshSmoothing given to the constructor. It is allowed to call this function only if the triangulation is empty. </p>

</div>
</div>
<a class="anchor" id="a20dd4d20bf729c20410e47eb9bcd7065"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::copy_triangulation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>old_tria</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy a triangulation. This operation is not cheap, so you should be careful with using this. We do not implement this function as a copy constructor, since it makes it easier to maintain collections of triangulations if you can assign them values later on.</p>
<p>Keep in mind that this function also copies the pointer to the boundary descriptor previously set by the <code>set_boundary</code> function. You must therefore also guarantee that the boundary objects has a lifetime at least as long as the copied triangulation.</p>
<p>This triangulation must be empty beforehand.</p>
<p>The function is made <code>virtual</code> since some derived classes might want to disable or extend the functionality of this function.</p>
<dl class="section note"><dt>Note</dt><dd>Calling this function triggers the 'copy' signal on old_tria, i.e. the triangulation being copied <em>from</em>. It also triggers the 'create' signal of the current triangulation. See the section on signals in the general documentation for more information.</dd>
<dd>
The list of connections to signals is not copied from the old to the new triangulation since these connections were established to monitor how the old triangulation changes, not how any triangulation it may be copied to changes. </dd></dl>

<p>Reimplemented in <a class="el" href="classPersistentTriangulation.html#ae377e537ece5c919050a7613aeb18307">PersistentTriangulation&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a5b6edd805a4d8b91d016080bf43233c1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::create_triangulation </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structCellData.html">CellData</a>&lt; dim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structSubCellData.html">SubCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>subcelldata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a triangulation from a list of vertices and a list of cells, each of the latter being a list of <code>1&lt;&lt;dim</code> vertex indices. The triangulation must be empty upon calling this function and the cell list should be useful (connected domain, etc.).</p>
<p>Material data for the cells is given within the <code>cells</code> array, while boundary information is given in the <code>subcelldata</code> field.</p>
<p>The numbering of vertices within the <code>cells</code> array is subject to some constraints; see the general class documentation for this.</p>
<p>For conditions when this function can generate a valid triangulation, see the documentation of this class, and the <a class="el" href="classGridIn.html">GridIn</a> and <a class="el" href="classGridReordering.html">GridReordering</a> class.</p>
<p>If the <code>check_for_distorted_cells</code> flag was specified upon creation of this object, at the very end of its operation, the current function walks over all cells and verifies that none of the cells is deformed (see the entry on <a class="el" href="DEALGlossary.html#GlossDistorted">distorted cells</a> in the glossary), where we call a cell deformed if the determinant of the Jacobian of the mapping from reference cell to real cell is negative at least at one of the vertices (this computation is done using the GeometryInfo::jacobian_determinants_at_vertices function). If there are deformed cells, this function throws an exception of kind <a class="el" href="structTriangulation_1_1DistortedCellList.html">DistortedCellList</a>. Since this happens after all data structures have been set up, you can catch and ignore this exception if you know what you do &ndash; for example, it may be that the determinant is zero (indicating that you have collapsed edges in a cell) but that this is ok because you didn't intend to integrate on this cell anyway. On the other hand, deformed cells are often a sign of a mesh that is too coarse to resolve the geometry of the domain, and in this case ignoring the exception is probably unwise.</p>
<dl class="section note"><dt>Note</dt><dd>This function is used in <a class="el" href="step_14.html">step-14</a> .</dd>
<dd>
This function triggers the create signal after doing its work. See the section on signals in the general documentation of this class.</dd>
<dd>
The check for distorted cells is only done if dim==spacedim, as otherwise cells can legitimately be twisted if the manifold they describe is twisted. </dd></dl>

<p>Reimplemented in <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#af29c9dc23cc9ede2c8143d19331dbaaa">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, and <a class="el" href="classPersistentTriangulation.html#a2112a1e3143f087013be9649b163d235">PersistentTriangulation&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a6fdc77eaaa3926a066ed48fc47215a39"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::create_triangulation_compatibility </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structCellData.html">CellData</a>&lt; dim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structSubCellData.html">SubCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>subcelldata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For backward compatibility, only. This function takes the cell data in the ordering as requested by deal.II versions up to 5.2, converts it to the new (lexicographic) ordering and calls <a class="el" href="classTriangulation.html#a5b6edd805a4d8b91d016080bf43233c1">create_triangulation()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This function internally calls create_triangulation and therefore can throw the same exception as the other function. </dd></dl>

<p>Reimplemented in <a class="el" href="classPersistentTriangulation.html#ac228266d5b75d03738dfd36b4320539f">PersistentTriangulation&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="afdc34248a9ba0c38fd0020256a8def5c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::flip_all_direction_flags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Revert or flip the direction_flags of a dim&lt;spacedim triangulation, see <a class="el" href="DEALGlossary.html#GlossDirectionFlag">GlossDirectionFlag</a> .</p>
<p>This function throws an exception if dim equals spacedim. </p>

</div>
</div>
<a class="anchor" id="a083e0e57550eddc85f8804f04fc7f3cd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::distort_random </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>keep_boundary</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Distort the grid by randomly moving around all the vertices of the grid. The direction of moving is random, while the length of the shift vector has a value of <code>factor</code> times the minimal length of the active lines adjacent to this vertex. Note that <code>factor</code> should obviously be well below <code>0.5</code>.</p>
<p>If <code>keep_boundary</code> is set to <code>true</code> (which is the default), then boundary vertices are not moved.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000181">Deprecated:</a></b></dt><dd>Use <a class="el" href="namespaceGridTools.html#aec039d544c93a6e810427ad45ba0c84f">GridTools::distort_random</a> instead. </dd></dl>

</div>
</div>
<a class="anchor" id="aed8e461d4b2b23a0e1730afdef36e694"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::set_all_refine_flags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flag all active cells for refinement. This will refine all cells of all levels which are not already refined (i.e. only cells are refined which do not yet have children). The cells are only flagged, not refined, thus you have the chance to save the refinement flags. </p>

</div>
</div>
<a class="anchor" id="a6ad0b3fb24aae17f4668427a433dea19"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::refine_global </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>times</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Refine all cells <code>times</code> times, by alternatingly calling set_all_refine_flags and execute_coarsening_and_refinement.</p>
<p>The latter function may throw an exception if it creates cells that are distorted (see its documentation for an explanation). This exception will be propagated through this function if that happens, and you may not get the actual number of refinement steps in that case.</p>
<dl class="section note"><dt>Note</dt><dd>This function triggers the pre- and post-refinement signals before and after doing each individual refinement cycle (i.e. more than once if times &gt; 1) . See the section on signals in the general documentation of this class. </dd></dl>

</div>
</div>
<a class="anchor" id="aaedd900205c1879d8d9ef6ffe7d1a554"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::execute_coarsening_and_refinement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Execute both refinement and coarsening of the triangulation.</p>
<p>The function resets all refinement and coarsening flags to false. It uses the user flags for internal purposes. They will therefore be overwritten by undefined content.</p>
<p>To allow user programs to fix up these cells if that is desired, this function after completing all other work may throw an exception of type <a class="el" href="structTriangulation_1_1DistortedCellList.html">DistortedCellList</a> that contains a list of those cells that have been refined and have at least one child that is distorted. The function does not create such an exception if no cells have created distorted children. Note that for the check for distorted cells to happen, the <code>check_for_distorted_cells</code> flag has to be specified upon creation of a triangulation object.</p>
<p>See the general docs for more information.</p>
<dl class="section note"><dt>Note</dt><dd>This function triggers the pre- and post-refinement signals before and after doing its work. See the section on signals in the general documentation of this class.</dd>
<dd>
If the boundary description is sufficiently irregular, it can happen that some of the children produced by mesh refinement are distorted (see the extensive discussion on <a class="el" href="DEALGlossary.html#GlossDistorted">distorted cells</a>).</dd>
<dd>
This function is <code>virtual</code> to allow derived classes to insert hooks, such as saving refinement flags and the like (see e.g. the <a class="el" href="classPersistentTriangulation.html">PersistentTriangulation</a> class). </dd></dl>

<p>Reimplemented in <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a2e648590aa15f4b591199d981b04fbaa">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, and <a class="el" href="classPersistentTriangulation.html#a73e966a193be270bc4c86d01374d344d">PersistentTriangulation&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ab9fa3177e0e43ab0cf243215d284a35a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::prepare_coarsening_and_refinement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Do both preparation for refinement and coarsening as well as mesh smoothing.</p>
<p>Regarding the refinement process it fixes the closure of the refinement in <code>dim&gt;=2</code> (make sure that no two cells are adjacent with a refinement level differing with more than one), etc. It performs some mesh smoothing if the according flag was given to the constructor of this class. The function returns whether additional cells have been flagged for refinement.</p>
<p>See the general doc of this class for more information on smoothing upon refinement.</p>
<p>Regarding the coarsening part, flagging and deflagging cells in preparation of the actual coarsening step are done. This includes deleting coarsen flags from cells which may not be deleted (e.g. because one neighbor is more refined than the cell), doing some smoothing, etc.</p>
<p>The effect is that only those cells are flagged for coarsening which will actually be coarsened. This includes the fact that all flagged cells belong to parent cells of which all children are flagged.</p>
<p>The function returns whether some cells' flagging has been changed in the process.</p>
<p>This function uses the user flags, so store them if you still need them afterwards. </p>

</div>
</div>
<a class="anchor" id="ae526b3400d10580ea1492ff3fd3c407a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::add_refinement_listener </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation_1_1RefinementListener.html">RefinementListener</a> &amp;&#160;</td>
          <td class="paramname"><em>listener</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a <a class="el" href="classTriangulation_1_1RefinementListener.html">RefinementListener</a>. Adding listeners to the <a class="el" href="classTriangulation.html">Triangulation</a> allows other classes to be informed when the <a class="el" href="classTriangulation.html">Triangulation</a> is refined.</p>
<dl class="section note"><dt>Note</dt><dd>The use of this function has been superseded by the signals mechanism. See the general documentation of the <a class="el" href="classTriangulation.html">Triangulation</a> class for more information.</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000182">Deprecated:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="aa6f8addcc7b73f5a245c094cd949368b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::remove_refinement_listener </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation_1_1RefinementListener.html">RefinementListener</a> &amp;&#160;</td>
          <td class="paramname"><em>listener</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove a <a class="el" href="classTriangulation_1_1RefinementListener.html">RefinementListener</a>. When some class needs no longer to be informed about refinements, the listener should be removed from the <a class="el" href="classTriangulation.html">Triangulation</a>.</p>
<dl class="section note"><dt>Note</dt><dd>The use of this function has been superseded by the signals mechanism. See the general documentation of the <a class="el" href="classTriangulation.html">Triangulation</a> class for more information.</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000183">Deprecated:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="abf284939143dc421b87dfb40756c1e71"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_refine_flags </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Save the addresses of the cells which are flagged for refinement to <code>out</code>. For usage, read the general documentation for this class. </p>

</div>
</div>
<a class="anchor" id="a71862b248b9f25914ae3f306f42dd2d3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_refine_flags </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above, but store the flags to a bitvector rather than to a file. </p>

</div>
</div>
<a class="anchor" id="a43fc07c3f9e1f02658ca556f41087c85"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_refine_flags </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the information stored by <code>save_refine_flags</code>. </p>

</div>
</div>
<a class="anchor" id="ac924a05e66d5e76458ad088a2b7b5583"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_refine_flags </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the information stored by <code>save_refine_flags</code>. </p>

</div>
</div>
<a class="anchor" id="a023699c907ed013ea8e304b4c4ba1b8d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_coarsen_flags </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Analogue to <code>save_refine_flags</code>. </p>

</div>
</div>
<a class="anchor" id="ab433d3029e1e9f15b03aee4d79d082e0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_coarsen_flags </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above, but store the flags to a bitvector rather than to a file. </p>

</div>
</div>
<a class="anchor" id="aa4029122ffe741f843f2f3a7deeceea9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_coarsen_flags </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Analogue to <code>load_refine_flags</code>. </p>

</div>
</div>
<a class="anchor" id="a48a9463dcf9aeb3a69831e5e1a321053"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_coarsen_flags </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Analogue to <code>load_refine_flags</code>. </p>

</div>
</div>
<a class="anchor" id="aa47ade3bd9afd94e38a8469762071352"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::get_anisotropic_refinement_flag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether this triangulation has ever undergone anisotropic (as opposed to only isotropic) refinement. </p>

</div>
</div>
<a class="anchor" id="aaa726b33b52f694cfca48fae8e761661"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::clear_user_flags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear all user flags. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a> . </p>

</div>
</div>
<a class="anchor" id="aaf0b21f16759e23f3d0d731301eec4fb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_flags </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Save all user flags. See the general documentation for this class and the documentation for the <code>save_refine_flags</code> for more details. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a> . </p>

</div>
</div>
<a class="anchor" id="a316d2b612074326bdc73f7f9c9704955"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_flags </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above, but store the flags to a bitvector rather than to a file. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a> . </p>

</div>
</div>
<a class="anchor" id="af3612ed3c7f7f9cccd3003d85b6f7350"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_flags </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the information stored by <code>save_user_flags</code>. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a> . </p>

</div>
</div>
<a class="anchor" id="ac17946286639b12a03804ebc400eab51"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_flags </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the information stored by <code>save_user_flags</code>. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a> . </p>

</div>
</div>
<a class="anchor" id="af8896f8e838dd34ed5b7c1aa351f76f5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::clear_user_flags_line </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear all user flags on lines. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a> . </p>

</div>
</div>
<a class="anchor" id="a998ac27a1c0e2cd403bbeff5f0e55a07"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_flags_line </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Save the user flags on lines. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a> . </p>

</div>
</div>
<a class="anchor" id="a69092dd9aea53f9133dd8c39c0684077"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_flags_line </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above, but store the flags to a bitvector rather than to a file. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a> . </p>

</div>
</div>
<a class="anchor" id="a25190c31d16cde2a01fa0f2318aa0b74"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_flags_line </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load the user flags located on lines. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a> . </p>

</div>
</div>
<a class="anchor" id="a87294511c2f203a57531aaaf2bd2ce39"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_flags_line </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load the user flags located on lines. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a> . </p>

</div>
</div>
<a class="anchor" id="a1dd263157214206ceb637c402552f0eb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::clear_user_flags_quad </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear all user flags on quads. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a> . </p>

</div>
</div>
<a class="anchor" id="ad97c6e1e446b4422274960740d69177a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_flags_quad </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Save the user flags on quads. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a> . </p>

</div>
</div>
<a class="anchor" id="a41aed06ec1d5f1c77d438cc79c208adf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_flags_quad </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above, but store the flags to a bitvector rather than to a file. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a> . </p>

</div>
</div>
<a class="anchor" id="a5e868cde85c04bcc8cec82ba09f24e7b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_flags_quad </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load the user flags located on quads. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a> . </p>

</div>
</div>
<a class="anchor" id="a8651e0def48d61e3f8f0aa8051ae5985"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_flags_quad </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load the user flags located on quads. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a> . </p>

</div>
</div>
<a class="anchor" id="a7cbe198bb49c3135378bb680582afd46"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::clear_user_flags_hex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear all user flags on quads. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a> . </p>

</div>
</div>
<a class="anchor" id="ac478792002df16eb6cb3d051d2415c7f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_flags_hex </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Save the user flags on hexs. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a> . </p>

</div>
</div>
<a class="anchor" id="ad0c4c9531ee6b07d4c2f2610c5acedc4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_flags_hex </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above, but store the flags to a bitvector rather than to a file. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a> . </p>

</div>
</div>
<a class="anchor" id="a6e15f4d848adbe6c8bf1af374e467a31"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_flags_hex </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load the user flags located on hexs. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a> . </p>

</div>
</div>
<a class="anchor" id="a77e827086d26927d08129c8489fdcd45"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_flags_hex </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load the user flags located on hexs. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a> . </p>

</div>
</div>
<a class="anchor" id="a26562806fd764afdffb973dce92554e8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::clear_user_data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear all user pointers and indices and allow the use of both for next access. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a> . </p>

</div>
</div>
<a class="anchor" id="a5f1cddf06093db7bdeaeb9411e5e75a0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::clear_user_pointers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000184">Deprecated:</a></b></dt><dd>User <a class="el" href="classTriangulation.html#a26562806fd764afdffb973dce92554e8">clear_user_data()</a> instead.</dd></dl>
<p>Clear all user pointers. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a> . </p>

</div>
</div>
<a class="anchor" id="a50eeaf89c218d08e31203d0e37f77553"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_indices </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Save all user indices. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a> . </p>

</div>
</div>
<a class="anchor" id="a12a2359968a027a8b14ae381c8886d30"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_indices </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the information stored by <a class="el" href="classTriangulation.html#a50eeaf89c218d08e31203d0e37f77553">save_user_indices()</a>. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a> . </p>

</div>
</div>
<a class="anchor" id="a1908040531ff67ef48f1e8c306fde5dd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_pointers </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; void * &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Save all user pointers. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a> . </p>

</div>
</div>
<a class="anchor" id="a8087e84b3b755bcb31767c574342ac0a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_pointers </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; void * &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the information stored by <a class="el" href="classTriangulation.html#a1908040531ff67ef48f1e8c306fde5dd">save_user_pointers()</a>. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a> . </p>

</div>
</div>
<a class="anchor" id="a6b9bed5e7c567fdc0f3219b6adf21530"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_indices_line </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Save the user indices on lines. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a> . </p>

</div>
</div>
<a class="anchor" id="a7b2160dd04545294d138ca00deb4af42"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_indices_line </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load the user indices located on lines. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a> . </p>

</div>
</div>
<a class="anchor" id="a891905d9655d39e2deee193794837ea0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_indices_quad </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Save the user indices on quads. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a> . </p>

</div>
</div>
<a class="anchor" id="a1020c09b32fbb78156b00b833271e21d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_indices_quad </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load the user indices located on quads. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a> . </p>

</div>
</div>
<a class="anchor" id="ae97338e9965e6d8a40345afb8bf7041a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_indices_hex </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Save the user indices on hexes. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a> . </p>

</div>
</div>
<a class="anchor" id="abad8869b9c8234d6c81c24c69dd97d39"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_indices_hex </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load the user indices located on hexs. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a> . </p>

</div>
</div>
<a class="anchor" id="a55979902666e00468f6e2d07a28bab3f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_pointers_line </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; void * &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Save the user indices on lines. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a> . </p>

</div>
</div>
<a class="anchor" id="aab55095dab9f1be46f088d6d29d016ba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_pointers_line </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; void * &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load the user pointers located on lines. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a> . </p>

</div>
</div>
<a class="anchor" id="afbd5c7e00637bd88f3e50316f6d846fc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_pointers_quad </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; void * &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Save the user pointers on quads. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a> . </p>

</div>
</div>
<a class="anchor" id="a6fadda245a0bef85ae6b957d6154a884"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_pointers_quad </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; void * &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load the user pointers located on quads. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a> . </p>

</div>
</div>
<a class="anchor" id="a88c180e97d314b70539bfed90065585b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_pointers_hex </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; void * &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Save the user pointers on hexes. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a> . </p>

</div>
</div>
<a class="anchor" id="a8e9198f6d3a8dedb19db011e99903863"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_pointers_hex </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; void * &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load the user pointers located on hexs. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a> . </p>

</div>
</div>
<a class="anchor" id="a7b87a97ff0d6ffe416aa37fda33c46c7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaIterator.html">cell_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iterator to the first used cell on level <code>level</code>. </p>

</div>
</div>
<a class="anchor" id="af99e25cc64755f18659c0fbc46c3d87d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaActiveIterator.html">active_cell_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_active </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iterator to the first active cell on level <code>level</code>. If the given level does not contain any active cells (i.e., all cells on this level are further refined, then this function returns <code>end_active(level)</code> so that loops of the kind </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (cell=tria.<a class="code" href="classTriangulation.html#af99e25cc64755f18659c0fbc46c3d87d">begin_active</a>(level); cell!=tria.<a class="code" href="classTriangulation.html#a01fbdd9c7d9c15e771c1bd07bc197dd8">end_active</a>(level); ++cell)</div>
<div class="line">  ...</div>
</div><!-- fragment --><p> have zero iterations, as may be expected if there are no active cells on this level. </p>

</div>
</div>
<a class="anchor" id="aa234819cf914abe2b700535c682688a7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaIterator.html">cell_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iterator past the end; this iterator serves for comparisons of iterators with past-the-end or before-the-beginning states. </p>

</div>
</div>
<a class="anchor" id="adf9fa59d3fcecea4e90745e4181d1ed3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaIterator.html">cell_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::end </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an iterator which is the first iterator not on level. If <code>level</code> is the last level, then this returns <code><a class="el" href="classTriangulation.html#aa234819cf914abe2b700535c682688a7">end()</a></code>. </p>

</div>
</div>
<a class="anchor" id="a01fbdd9c7d9c15e771c1bd07bc197dd8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaActiveIterator.html">active_cell_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::end_active </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an active iterator which is the first active iterator not on the given level. If <code>level</code> is the last level, then this returns <code><a class="el" href="classTriangulation.html#aa234819cf914abe2b700535c682688a7">end()</a></code>. </p>

</div>
</div>
<a class="anchor" id="a17622fd924c1a5812af2edda8fe6a3c9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaIterator.html">cell_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::last </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an iterator pointing to the last used cell. </p>

</div>
</div>
<a class="anchor" id="af8e680fd57aaac70a8b7c9e86b32e4cd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaActiveIterator.html">active_cell_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::last_active </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an iterator pointing to the last active cell. </p>

</div>
</div>
<a class="anchor" id="ada7832002fa74f10c7eedf86c2a62578"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaIterator.html">face_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_face </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iterator to the first used face. </p>

</div>
</div>
<a class="anchor" id="a418e5a43b438de9d30ee00ac35403d8a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaActiveIterator.html">active_face_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_active_face </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iterator to the first active face. </p>

</div>
</div>
<a class="anchor" id="a0288a5ee4dadc95617dc2f7d9406909f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaIterator.html">face_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::end_face </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iterator past the end; this iterator serves for comparisons of iterators with past-the-end or before-the-beginning states. </p>

</div>
</div>
<a class="anchor" id="af4f3b8a6a82b2f198df99c99aa695557"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_lines </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>In the following, most functions are provided in two versions, with and without an argument describing the level. The versions with this argument are only applicable for objects describing the cells of the present triangulation. For example: in 2D <code>n_lines(level)</code> cannot be called, only <code><a class="el" href="classTriangulation.html#af4f3b8a6a82b2f198df99c99aa695557">n_lines()</a></code>, as lines are faces in 2D and therefore have no level. Return total number of used lines, active or not. </p>

</div>
</div>
<a class="anchor" id="a843d74b989a033cb3dc5d2ef78a83e57"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_lines </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return total number of used lines, active or not on level <code>level</code>. </p>

</div>
</div>
<a class="anchor" id="a697a4109298cc3a572f89d84b4e37d91"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_active_lines </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return total number of active lines. </p>

</div>
</div>
<a class="anchor" id="a8db1be8df4f945c3029a17032e5d847d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_active_lines </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return total number of active lines, on level <code>level</code>. </p>

</div>
</div>
<a class="anchor" id="aaa96bd1cc871af381a87b6c267e011e1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_quads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return total number of used quads, active or not. </p>

</div>
</div>
<a class="anchor" id="a1f07241c9c910d106490479dd688836c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_quads </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return total number of used quads, active or not on level <code>level</code>. </p>

</div>
</div>
<a class="anchor" id="a226ef774feb8e9cfd6c80117bb63fe77"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_active_quads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return total number of active quads, active or not. </p>

</div>
</div>
<a class="anchor" id="a5044a9fc8ca76a99817e57ce80baf866"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_active_quads </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return total number of active quads, active or not on level <code>level</code>. </p>

</div>
</div>
<a class="anchor" id="aab9ee1975a0516c11f63f2906b893dad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_hexs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return total number of used hexahedra, active or not. </p>

</div>
</div>
<a class="anchor" id="afc0531954b814e7d974c7cabb7dba2d4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_hexs </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return total number of used hexahedra, active or not on level <code>level</code>. </p>

</div>
</div>
<a class="anchor" id="aef9946784a199fa6f39b5b5fa66abe7a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_active_hexs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return total number of active hexahedra, active or not. </p>

</div>
</div>
<a class="anchor" id="a87baa4a14d49a05aa00eb94d5954b0bc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_active_hexs </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return total number of active hexahedra, active or not on level <code>level</code>. </p>

</div>
</div>
<a class="anchor" id="a07ed51250524b5b9599671be911c89c4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_cells </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return total number of used cells, active or not. Maps to <code><a class="el" href="classTriangulation.html#af4f3b8a6a82b2f198df99c99aa695557">n_lines()</a></code> in one space dimension and so on. </p>

</div>
</div>
<a class="anchor" id="a068b191bfec8efc720be890551953cd7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_cells </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return total number of used cells, active or not, on level <code>level</code>. Maps to <code>n_lines(level)</code> in one space dimension and so on. </p>

</div>
</div>
<a class="anchor" id="aa21f25016ce1b9d70d2003a128985870"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_active_cells </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return total number of active cells. Maps to <code><a class="el" href="classTriangulation.html#a697a4109298cc3a572f89d84b4e37d91">n_active_lines()</a></code> in one space dimension and so on. </p>

</div>
</div>
<a class="anchor" id="a0d3f0a84249aacde06a34c56e0f7337b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_active_cells </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return total number of active cells on level <code>level</code>. Maps to <code>n_active_lines(level)</code> in one space dimension and so on. </p>

</div>
</div>
<a class="anchor" id="a2860a815a9914acc8c12de32b71fc424"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_faces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return total number of used faces, active or not. In 2D, the result equals <a class="el" href="classTriangulation.html#af4f3b8a6a82b2f198df99c99aa695557">n_lines()</a>, while in 3D it equals <a class="el" href="classTriangulation.html#aaa96bd1cc871af381a87b6c267e011e1">n_quads()</a>. Since there are no face objects in 1d, the function returns zero in 1d. </p>

</div>
</div>
<a class="anchor" id="a10e55064151a14d73442af70fc607d64"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_active_faces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return total number of active faces, active or not. In 2D, the result equals <a class="el" href="classTriangulation.html#a697a4109298cc3a572f89d84b4e37d91">n_active_lines()</a>, while in 3D it equals <a class="el" href="classTriangulation.html#a226ef774feb8e9cfd6c80117bb63fe77">n_active_quads()</a>. Since there are no face objects in 1d, the function returns zero in 1d. </p>

</div>
</div>
<a class="anchor" id="ad966e087386ee0330371ebd73f2cfe99"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_levels </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return number of levels in use. This may be less than the number of levels existing in the triangulation if by coarsening the highest level was completely depopulated. That level is not removed, since it will most likely be repopulated soon by the next refinement process. </p>

</div>
</div>
<a class="anchor" id="a303fbfcda0fb05e63151771658253785"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_global_levels </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the number of levels in use. This function is equivalent to <a class="el" href="classTriangulation.html#ad966e087386ee0330371ebd73f2cfe99">n_levels()</a> for a serial <a class="el" href="classTriangulation.html">Triangulation</a>, but gives the maximum of <a class="el" href="classTriangulation.html#ad966e087386ee0330371ebd73f2cfe99">n_levels()</a> over all processors for a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> and therefore can be larger than <a class="el" href="classTriangulation.html#ad966e087386ee0330371ebd73f2cfe99">n_levels()</a>. </p>

<p>Reimplemented in <a class="el" href="classparallel_1_1distributed_1_1Triangulation_3_011_00_01spacedim_01_4.html#a2f1571936baf91cbd443461976c5beea">parallel::distributed::Triangulation&lt; 1, spacedim &gt;</a>, and <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a8c640e3433aabc5e44d95df650f3c1df">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ad49cc6eadbda275e0c2ef0155469d656"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_vertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the total number of vertices. Some of them may not be used, which usually happens upon coarsening of a triangulation when some vertices are discarded, but we do not want to renumber the remaining ones, leading to holes in the numbers of used vertices. You can get the number of used vertices using <code>n_used_vertices</code> function. </p>

</div>
</div>
<a class="anchor" id="a6fcee3caf27bb54c53ddb279cf6b8f5a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt; &gt;&amp; <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::get_vertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a constant reference to all the vertices present in this triangulation. Note that not necessarily all vertices in this array are actually used; for example, if you coarsen a mesh, then some vertices are deleted, but their positions in this array are unchanged as the indices of vertices are only allocated once. You can find out about which vertices are actually used by the function <a class="el" href="classTriangulation.html#a427f9be6dd029861354009ae6afc8b63">get_used_vertices()</a>. </p>

</div>
</div>
<a class="anchor" id="aef1492349593137ebabb8b37b9ad9e14"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_used_vertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of vertices that are presently in use, i.e. belong to at least one used element. </p>

</div>
</div>
<a class="anchor" id="a7770373aa26c78042c8e751a22e2415e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::vertex_used </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return <code>true</code> if the vertex with this <code>index</code> is used. </p>

</div>
</div>
<a class="anchor" id="a427f9be6dd029861354009ae6afc8b63"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classbool.html">bool</a>&gt;&amp; <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::get_used_vertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a constant reference to the array of <code>bools</code> indicating whether an entry in the vertex array is used or not. </p>

</div>
</div>
<a class="anchor" id="a9c2b4e1c451f1b5f57fe43c4563e6f4d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::max_adjacent_cells </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the maximum number of cells meeting at a common vertex. Since this number is an invariant under refinement, only the cells on the coarsest level are considered. The operation is thus reasonably fast. The invariance is only true for sufficiently many cells in the coarsest triangulation (e.g. for a single cell one would be returned), so a minimum of four is returned in two dimensions, 8 in three dimensions, etc, which is how many cells meet if the triangulation is refined.</p>
<p>In one space dimension, two is returned. </p>

</div>
</div>
<a class="anchor" id="aa556f79e81b7d257030791772bfd3321"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::locally_owned_subdomain </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function always returns <code>invalid_subdomain_id</code> but is there for compatibility with the derived <code><a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a></code> class. For distributed parallel triangulations this function returns the subdomain id of those cells that are owned by the current processor. </p>

<p>Reimplemented in <a class="el" href="classparallel_1_1distributed_1_1Triangulation_3_011_00_01spacedim_01_4.html#ad9a0311cbd5e64ca391271d91f4d9201">parallel::distributed::Triangulation&lt; 1, spacedim &gt;</a>, and <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a534826704588b605dd39b20a14e0aef9">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="aebeddf6ba0ac7f8b93c0fe0b253fe2f0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_raw_lines </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Total number of lines, used or unused.</p>
<dl class="section note"><dt>Note</dt><dd>This function really exports internal information about the triangulation. It shouldn't be used in applications. The function is only part of the public interface of this class because it is used in some of the other classes that build very closely on it (in particular, the <a class="el" href="classDoFHandler.html">DoFHandler</a> class). </dd></dl>

</div>
</div>
<a class="anchor" id="af2ae32286d0d39dbb9ae9e1f77abedd7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_raw_lines </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of lines, used or unused, on the given level.</p>
<dl class="section note"><dt>Note</dt><dd>This function really exports internal information about the triangulation. It shouldn't be used in applications. The function is only part of the public interface of this class because it is used in some of the other classes that build very closely on it (in particular, the <a class="el" href="classDoFHandler.html">DoFHandler</a> class). </dd></dl>

</div>
</div>
<a class="anchor" id="acff58f8bcaec384491c431e3c8b1750b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_raw_quads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Total number of quads, used or unused.</p>
<dl class="section note"><dt>Note</dt><dd>This function really exports internal information about the triangulation. It shouldn't be used in applications. The function is only part of the public interface of this class because it is used in some of the other classes that build very closely on it (in particular, the <a class="el" href="classDoFHandler.html">DoFHandler</a> class). </dd></dl>

</div>
</div>
<a class="anchor" id="a894995d0112d1b64c179e5542bccf929"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_raw_quads </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of quads, used or unused, on the given level.</p>
<dl class="section note"><dt>Note</dt><dd>This function really exports internal information about the triangulation. It shouldn't be used in applications. The function is only part of the public interface of this class because it is used in some of the other classes that build very closely on it (in particular, the <a class="el" href="classDoFHandler.html">DoFHandler</a> class). </dd></dl>

</div>
</div>
<a class="anchor" id="a7c43630dd0391a6f74e1fde3c03f460b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_raw_hexs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Total number of hexs, used or unused.</p>
<dl class="section note"><dt>Note</dt><dd>This function really exports internal information about the triangulation. It shouldn't be used in applications. The function is only part of the public interface of this class because it is used in some of the other classes that build very closely on it (in particular, the <a class="el" href="classDoFHandler.html">DoFHandler</a> class). </dd></dl>

</div>
</div>
<a class="anchor" id="a98dc15415c9e084516e67cca005190d9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_raw_hexs </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of hexs, used or unused, on the given level.</p>
<dl class="section note"><dt>Note</dt><dd>This function really exports internal information about the triangulation. It shouldn't be used in applications. The function is only part of the public interface of this class because it is used in some of the other classes that build very closely on it (in particular, the <a class="el" href="classDoFHandler.html">DoFHandler</a> class). </dd></dl>

</div>
</div>
<a class="anchor" id="a8b97a0de5539b6c80d910452926ddfc6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_raw_cells </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of cells, used or unused, on the given level.</p>
<dl class="section note"><dt>Note</dt><dd>This function really exports internal information about the triangulation. It shouldn't be used in applications. The function is only part of the public interface of this class because it is used in some of the other classes that build very closely on it (in particular, the <a class="el" href="classDoFHandler.html">DoFHandler</a> class). </dd></dl>

</div>
</div>
<a class="anchor" id="a5e8dd46f42dfc70f368d9d423e5018b1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_raw_faces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return total number of faces, used or not. In 2d, the result equals <a class="el" href="classTriangulation.html#aebeddf6ba0ac7f8b93c0fe0b253fe2f0">n_raw_lines()</a>, while in 3d it equals <a class="el" href="classTriangulation.html#acff58f8bcaec384491c431e3c8b1750b">n_raw_quads()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This function really exports internal information about the triangulation. It shouldn't be used in applications. The function is only part of the public interface of this class because it is used in some of the other classes that build very closely on it (in particular, the <a class="el" href="classDoFHandler.html">DoFHandler</a> class). </dd></dl>

</div>
</div>
<a class="anchor" id="a12ababc0092a02034feb15e6281e45c7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::size_t <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determine an estimate for the memory consumption (in bytes) of this object.</p>
<p>This function is made virtual, since a triangulation object might be accessed through a pointer to this base class, even if the actual object is a derived class. </p>

<p>Reimplemented in <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#ab9ab727e769019f93afcb5e9e94d6e74">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, and <a class="el" href="classPersistentTriangulation.html#abd7a877e394991fadbf46f0a4eb957c8">PersistentTriangulation&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a5ae613e76606c08f919aa6e4bdf5f94a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class Archive &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write the data of this object to a stream for the purpose of serialization.</p>
<dl class="section note"><dt>Note</dt><dd>This function does not save <em>all</em> member variables of the current triangulation. Rather, only certain kinds of information are stored. For more information see the general documentation of this class. </dd></dl>

</div>
</div>
<a class="anchor" id="ae2f72d5fbb277ec65dbe0382ae72a929"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class Archive &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the data of this object from a stream for the purpose of serialization. Throw away the previous content.</p>
<dl class="section note"><dt>Note</dt><dd>This function does not reset <em>all</em> member variables of the current triangulation to the ones of the triangulation that was previously stored to an archive. Rather, only certain kinds of information are loaded. For more information see the general documentation of this class.</dd>
<dd>
This function calls the <a class="el" href="classTriangulation.html#a12d54b7dae635d867bf8d2c4b3605817">Triangulation::clear()</a> function and consequently triggers the "clear" signal. After loading all data from the archive, it then triggers the "create" signal. For more information on signals, see the general documentation of this class. </dd></dl>

</div>
</div>
<a class="anchor" id="af9e3e5c077024f40355432c771ccf541"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::write_bool_vector </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>magic_number1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>magic_number2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write a bool vector to the given stream, writing a pre- and a postfix magic number. The vector is written in an almost binary format, i.e. the bool flags are packed but the data is written as ASCII text.</p>
<p>The flags are stored in a binary format: for each <code>true</code>, a <code>1</code> bit is stored, a <code>0</code> bit otherwise. The bits are stored as <code>unsigned char</code>, thus avoiding endianess. They are written to <code>out</code> in plain text, thus amounting to 3.6 bits in the output per bits in the input on the average. Other information (magic numbers and number of elements of the input vector) is stored as plain text as well. The format should therefore be interplatform compatible. </p>

</div>
</div>
<a class="anchor" id="a20c92032e652bdafdfd7624a55aa2866"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::read_bool_vector </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>magic_number1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>magic_number2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Re-read a vector of bools previously written by <code>write_bool_vector</code> and compare with the magic numbers. </p>

</div>
</div>
<a class="anchor" id="a17040641b1946d912e687500d6fe1121"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html#a4e117ddf1b985983751fd3b7d305a31a">raw_cell_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_raw </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first cell, used or not, on level <code>level</code>. If a level has no cells, a past-the-end iterator is returned. </p>

</div>
</div>
<a class="anchor" id="a9fb03f729b362c559dfd941c8ed2e917"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html#a4e117ddf1b985983751fd3b7d305a31a">raw_cell_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::end_raw </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a raw iterator which is the first iterator not on level. If <code>level</code> is the last level, then this returns <code><a class="el" href="classTriangulation.html#aa234819cf914abe2b700535c682688a7">end()</a></code>. </p>

</div>
</div>
<a class="anchor" id="aa80d23446209a526187d0aaf14cbadd3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">raw_line_iterator <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_raw_line </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first line, used or not, on level <code>level</code>. If a level has no lines, a past-the-end iterator is returned. If lines are no cells, i.e. for <code>dim&gt;1</code> no <code>level</code> argument must be given. The same applies for all the other functions above, of course. </p>

</div>
</div>
<a class="anchor" id="a398d08de81359d2cd4eb91c5460e5462"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">line_iterator <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_line </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first used line on level <code>level</code>. </p>

</div>
</div>
<a class="anchor" id="addbe4a4dfce72e5225e86f9695648217"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">active_line_iterator <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_active_line </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first active line on level <code>level</code>. </p>

</div>
</div>
<a class="anchor" id="adb606b6430f3607930ec70c25190ee0c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">line_iterator <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::end_line </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator past the end; this iterator serves for comparisons of iterators with past-the-end or before-the-beginning states. </p>

</div>
</div>
<a class="anchor" id="a964ed750f98d62df01f204ec8e5d81f2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">raw_quad_iterator <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_raw_quad </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first quad, used or not, on the given level. If a level has no quads, a past-the-end iterator is returned. If quads are no cells, i.e. for <img class="formulaInl" alt="$dim>2$" src="form_692.png"/> no level argument must be given. </p>

</div>
</div>
<a class="anchor" id="a14f73e2e21f851cad5973d840ab5e09b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">quad_iterator <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_quad </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first used quad on level <code>level</code>. </p>

</div>
</div>
<a class="anchor" id="a6a5634ea026a09209b140edb63557b02"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">active_quad_iterator <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_active_quad </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first active quad on level <code>level</code>. </p>

</div>
</div>
<a class="anchor" id="ada72d919ebc3793bbb4d9f76ea52739d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">quad_iterator <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::end_quad </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator past the end; this iterator serves for comparisons of iterators with past-the-end or before-the-beginning states. </p>

</div>
</div>
<a class="anchor" id="a7422aa35664a5e00b54e38e954e094d0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">raw_hex_iterator <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_raw_hex </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first hex, used or not, on level <code>level</code>. If a level has no hexs, a past-the-end iterator is returned. </p>

</div>
</div>
<a class="anchor" id="a8b56d10117ed133dccb98068994297a7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hex_iterator <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_hex </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first used hex on level <code>level</code>. </p>

</div>
</div>
<a class="anchor" id="ac35f5da52a334721342e130d456e2e64"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">active_hex_iterator <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_active_hex </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first active hex on level <code>level</code>. </p>

</div>
</div>
<a class="anchor" id="a3e726f2c9dc5cb8f6986162e8b0461c2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hex_iterator <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::end_hex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator past the end; this iterator serves for comparisons of iterators with past-the-end or before-the-beginning states. </p>

</div>
</div>
<a class="anchor" id="a61d0ea3487d046b34de4ee8f60abf1b2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::clear_despite_subscriptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The (public) function <a class="el" href="classTriangulation.html#a12d54b7dae635d867bf8d2c4b3605817">clear()</a> will only work when the triangulation is not subscribed to by other users. The <a class="el" href="classTriangulation.html#a61d0ea3487d046b34de4ee8f60abf1b2">clear_despite_subscriptions()</a> function now allows the triangulation being cleared even when there are subscriptions.</p>
<p>Make sure, you know what you do, when calling this function, as its use is reasonable in very rare cases, only. For example, when the subscriptions were for the initially empty <a class="el" href="classTriangulation.html">Triangulation</a> and the <a class="el" href="classTriangulation.html">Triangulation</a> object wants to release its memory before throwing an assertion due to input errors (e.g. in the <a class="el" href="classTriangulation.html#a5b6edd805a4d8b91d016080bf43233c1">create_triangulation()</a> function). </p>

</div>
</div>
<a class="anchor" id="a8a73cdc08e502d9a140a625184526b89"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTriangulation_1_1DistortedCellList.html">DistortedCellList</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::execute_refinement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Refine all cells on all levels which were previously flagged for refinement.</p>
<p>Note, that this function uses the <code>line-&gt;user_flags</code> for <code>dim=2,3</code> and the <code>quad-&gt;user_flags</code> for <code>dim=3</code>.</p>
<p>The function returns a list of cells that have produced children that satisfy the criteria of <a class="el" href="DEALGlossary.html#GlossDistorted">distorted cells</a> if the <code>check_for_distorted_cells</code> flag was specified upon creation of this object, at </p>

</div>
</div>
<a class="anchor" id="afeebb271c1406d688a1ffb802a7bb509"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::execute_coarsening </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Coarsen all cells which were flagged for coarsening, or rather: delete all children of those cells of which all child cells are flagged for coarsening and several other constraints hold (see the general doc of this class). </p>

</div>
</div>
<a class="anchor" id="a37dc87bf8f3793947ba51f2da20b8442"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::fix_coarsen_flags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Make sure that either all or none of the children of a cell are tagged for coarsening. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a9560225362e43bc6201424bdfca5dcb2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classStraightBoundary.html">StraightBoundary</a>&lt;dim,spacedim&gt; <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::straight_boundary</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Default boundary object. This is used for those boundaries for which no boundary object has been explicitly set using <a class="el" href="group__boundary.html#ga0509d862f0e07071dcff837bd58fd082">set_boundary()</a>. </p>

<p>Definition at line <a class="el" href="grid_2tria_8h_source.html#l01234">1234</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a class="anchor" id="aefd8ddbf96799abebb6c05dced569329"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::dimension = dim</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Make the dimension available in function templates. </p>

<p>Definition at line <a class="el" href="grid_2tria_8h_source.html#l01642">1642</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3414a986e63a95d54e961b9b35d756fb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::space_dimension = spacedim</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Make the space-dimension available in function templates. </p>

<p>Definition at line <a class="el" href="grid_2tria_8h_source.html#l01648">1648</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad136f601f63a6d1bd8e205edd93cbae3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTriangulation_1_1Signals.html">Signals</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::signals</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="structTriangulation_1_1Signals.html">Signals</a> for the various actions that a triangulation can do to itself. </p>

<p>Definition at line <a class="el" href="grid_2tria_8h_source.html#l02264">2264</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac9474a14d0e8429412c82450013bde67"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">MeshSmoothing</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::smooth_grid</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Do some smoothing in the process of refining the triangulation. See the general doc of this class for more information about this. </p>

<p>Definition at line <a class="el" href="grid_2tria_8h_source.html#l03243">3243</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a class="anchor" id="adde1a4821058619ac4328ddad4c77ef4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;::<a class="el" href="classinternal_1_1Triangulation_1_1TriaLevel.html">internal::Triangulation::TriaLevel</a>&lt;dim&gt;*&gt; <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::levels</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Array of pointers pointing to the objects storing the cell data on the different levels. </p>

<p>Definition at line <a class="el" href="grid_2tria_8h_source.html#l03523">3523</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac6922da19b39c86383eabd4e60b04135"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">::<a class="el" href="classinternal_1_1Triangulation_1_1TriaFaces.html">internal::Triangulation::TriaFaces</a>&lt;dim&gt;* <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::faces</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pointer to the faces of the triangulation. In 1d this contains nothing, in 2D it contains data concerning lines and in 3D quads and lines. All of these have no level and are therefore treated separately. </p>

<p>Definition at line <a class="el" href="grid_2tria_8h_source.html#l03532">3532</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a class="anchor" id="a51469854babb27752dc9f26ed9d5ee30"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt; &gt; <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::vertices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Array of the vertices of this triangulation. </p>

<p>Definition at line <a class="el" href="grid_2tria_8h_source.html#l03539">3539</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a class="anchor" id="a12d0610e5c578ced9903db01a70f466f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classbool.html">bool</a>&gt; <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::vertices_used</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Array storing a bit-pattern which vertices are used. </p>

<p>Definition at line <a class="el" href="grid_2tria_8h_source.html#l03545">3545</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1d03fe8e53609ec5da4a1cae0ce3a7a4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;<a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>, <a class="el" href="classSmartPointer.html">SmartPointer</a>&lt;const <a class="el" href="classBoundary.html">Boundary</a>&lt;dim, spacedim&gt; , <a class="el" href="classTriangulation.html">Triangulation</a>&lt;dim, spacedim&gt; &gt; &gt; <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::boundary</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Collection of boundary objects. We store only objects, which are not of type <a class="el" href="classStraightBoundary.html">StraightBoundary</a>. </p>

<p>Definition at line <a class="el" href="grid_2tria_8h_source.html#l03553">3553</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a class="anchor" id="a12dc6feb50966969856aa359f6fa316a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::anisotropic_refinement</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Flag indicating whether anisotropic refinement took place. </p>

<p>Definition at line <a class="el" href="grid_2tria_8h_source.html#l03560">3560</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5c55287cc4c709190b521fd98a4f5e02"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classbool.html">bool</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::check_for_distorted_cells</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A flag that determines whether we are to check for distorted cells upon creation and refinement of a mesh. </p>

<p>Definition at line <a class="el" href="grid_2tria_8h_source.html#l03569">3569</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a class="anchor" id="a889fab464a381e942a091bcb76be9931"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">::<a class="el" href="structinternal_1_1Triangulation_1_1NumberCache.html">internal::Triangulation::NumberCache</a>&lt;dim&gt; <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::number_cache</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Cache to hold the numbers of lines, quads, hexes, etc. These numbers are set at the end of the refinement and coarsening functions and enable faster access later on. In the old days, whenever one wanted to access one of these numbers, one had to perform a loop over all lines, e.g., and count the elements until we hit the end iterator. This is time consuming and since access to the number of lines etc is a rather frequent operation, this was not an optimal solution. </p>

<p>Definition at line <a class="el" href="grid_2tria_8h_source.html#l03587">3587</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a class="anchor" id="a31fd498d2f522ab65d8bc15f58c6a9ce"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>&gt;* <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::vertex_to_boundary_id_map_1d</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A map that relates the number of a boundary vertex to the boundary indicator. This field is only used in 1d. We have this field because we store boundary indicator information with faces in 2d and higher where we have space in the structures that store data for faces, but in 1d there is no such space for faces.</p>
<p>The field is declared as a pointer for a rather mundane reason: all other fields of this class that can be modified by the <a class="el" href="classTriaAccessor.html">TriaAccessor</a> hierarchy are pointers, and so these accessor classes store a const pointer to the triangulation. We could no longer do so for <a class="el" href="classTriaAccessor_3_010_00_011_00_01spacedim_01_4.html">TriaAccessor&lt;0,1,spacedim&gt;</a> if this field (that can be modified by <a class="el" href="group__boundary.html#ga0d873908eff8fd51e88be26e51ab5f88">TriaAccessor::set_boundary_indicator</a>) were not a pointer. </p>

<p>Definition at line <a class="el" href="grid_2tria_8h_source.html#l03612">3612</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7226748b3e95ebf102e3a35d188aabd3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::multimap&lt;const <a class="el" href="classTriangulation_1_1RefinementListener.html">RefinementListener</a> *, std::vector&lt;boost::signals2::connection&gt; &gt; <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::refinement_listener_map</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A map that correlates each refinement listener that has been added through the outdated <a class="el" href="classTriangulation_1_1RefinementListener.html">RefinementListener</a> interface via <a class="el" href="classTriangulation.html#ae526b3400d10580ea1492ff3fd3c407a">add_refinement_listener()</a>, with the new-style boost::signal connections for each of the member function. We need to keep this list around so that we can later terminate the connection again when someone calls <a class="el" href="classTriangulation.html#aa6f8addcc7b73f5a245c094cd949368b">remove_refinement_listener()</a>.</p>
<p>The data type is a multimap since, although this would be weird, the same object may add itself multiple times as a listener. </p>

<p>Definition at line <a class="el" href="grid_2tria_8h_source.html#l03627">3627</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/deal.II/dofs/<a class="el" href="dof__iterator__selector_8h_source.html">dof_iterator_selector.h</a></li>
<li>include/deal.II/grid/<a class="el" href="grid_2tria_8h_source.html">tria.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jan 27 2014 15:27:22 for The deal.II Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
