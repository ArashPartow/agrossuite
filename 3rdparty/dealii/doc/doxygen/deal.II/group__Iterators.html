<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>The deal.II Library: Iterators on mesh-like containers</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="http://www.dealii.org/deal.ico"></link>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2014 by the deal.II authors"></meta>
<meta name="deal.II-version" content="8.1.0"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 8.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a>  </div>
  <div class="headertitle">
<div class="title">Iterators on mesh-like containers<div class="ingroups"><a class="el" href="group__grid.html">Grid classes</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Iterators on mesh-like containers:</div>
<div class="dyncontent">
<center><table><tr><td><div class="center"><iframe scrolling="no" frameborder="0" src="group__Iterators.svg" width="451" height="159"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__Accessors"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Accessors.html">Accessor classes of the mesh iterators</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceIteratorState"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIteratorState.html">IteratorState</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceIteratorFilters"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceIteratorFilters.html">IteratorFilters</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIteratorFilters_1_1Active.html">IteratorFilters::Active</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIteratorFilters_1_1UserFlagSet.html">IteratorFilters::UserFlagSet</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIteratorFilters_1_1UserFlagNotSet.html">IteratorFilters::UserFlagNotSet</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIteratorFilters_1_1LevelEqualTo.html">IteratorFilters::LevelEqualTo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIteratorFilters_1_1SubdomainEqualTo.html">IteratorFilters::SubdomainEqualTo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIteratorFilters_1_1LocallyOwnedCell.html">IteratorFilters::LocallyOwnedCell</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIteratorFilters_1_1LocallyOwnedLevelCell.html">IteratorFilters::LocallyOwnedLevelCell</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilteredIterator.html">FilteredIterator&lt; typename &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilteredIterator_1_1PredicateBase.html">FilteredIterator&lt; typename &gt;::PredicateBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilteredIterator_1_1PredicateTemplate.html">FilteredIterator&lt; typename &gt;::PredicateTemplate&lt; Predicate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaRawIterator.html">TriaRawIterator&lt; Accessor &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaIterator.html">TriaIterator&lt; Accessor &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaActiveIterator.html">TriaActiveIterator&lt; typename &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>deal.II has several classes which are understood conceptionally as meshes. Apart from the obvious <a class="el" href="classTriangulation.html">Triangulation</a>, these are, for example, <a class="el" href="classDoFHandler.html">DoFHandler</a>, <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a> and <a class="el" href="classMGDoFHandler.html">MGDoFHandler</a>. All of those define a set of iterators, allowing the user to traverse the whole mesh, i.e. the set of cells, faces, edges, etc that comprise the mesh, or portions of it. These iterators are all in a sense derived from the <a class="el" href="classTriaIterator.html">TriaIterator</a> class.</p>
<p>Basically, the template signature of <a class="el" href="classTriaIterator.html">TriaIterator</a> is </p>
<div class="fragment"><div class="line"><a class="code" href="classTriaIterator.html">TriaIterator&lt;Accessor&gt;</a></div>
</div><!-- fragment --><p>Conceptually, this type represents something like a pointer to an object represented by the <code>Accessor</code> class. Usually, you will not use the actual class names spelled out directly, but employ one of the typedefs provided by the container classes, such as <code>typename Triangulation::cell_iterator</code>. Before going into this, let us first discuss the concept of iterators, before delving into what the accessors do.</p>
<p>As usual in C++, iterators, just as pointers, are incremented to the next element using <code>operator ++</code>, and decremented to the previous element using <code>operator &ndash;</code>. One can also jump <code>n</code> elements ahead using the addition operator, <code>it=it+n</code>, and correspondingly to move a number of elements back. In addition, and keeping with the tradition of the standard template library, containers provide member functions <code>begin()</code> and <code>end()</code> that provide the first element of a collection and a one-past-the-end iterator, respectively. Since there are a number of different iterators available, there is actually a whole family of such functions, such as <code>begin_active()</code>, <code>begin_face()</code>, etc.</p>
<p>In terms of the concepts for iterators defined in the C++ standard, the deal.II mesh iterators are bi-directional iterators: they can be incremented and decremented, but an operation like <code>it=it+n</code> takes a compute time proportional to <code>n</code>, since it is implemented as a sequence of <code>n</code> individual unit increments. Note that this is in contrast to the next more specialized iterator concept, random access iterators, for which access to an arbitrary object requires only constant time, rather than linear.</p>
<h1><a class="anchor" id="IteratorsAndSets"></a>
Iterators as pointers into sets of objects</h1>
<p>As mentioned above, iterators in deal.II can be considered as iterating over all the objects that constitute a mesh. (These objects are lines, quads, and hexes, and are represented by the type of Accessor class given as template argument to the iterator.) This suggests to view a triangulation as a collection of cells and other objects that are held together by a certain data structure that links all these objects, in the same was as a linked list is the data structure that connects objects in a linear fashion.</p>
<p>Triangulations in deal.II can indeed be considered in this way. In particular, they use the computational notion of a forest of regular trees to store their data. This can be understood as follows: Consider the cells of the coarse mesh as roots; then, if one of these coarse mesh cells is refined, it will have 2<sup>dim</sup> children, which in turn can, but do not have to have 2<sup>dim</sup> children of their own, and so on. This means, that each cell of the coarse mesh can be considered the root of a binary tree (in 1d), a quadtree (in 2d), or an octree (in 3d). The collection of these trees emanating from the cells of the coarse mesh then constitutes the forest that completely describes the triangulation, including all of its active and inactive cells. In particular, the active cells are those terminal nodes in the tree that have no decendants, i.e. cells which are not further refined. Correspondingly, inactive cells correspond to nodes in the tree with descendents, i.e. cells that are further refined.</p>
<p>A triangulation contains forests for lines (each of which may have 2 children), quads (each with possibly four children), and hexes (each with no or 8 children). Depending on the dimension, these objects are also termed cells or faces.</p>
<p>Iterators loop over the elements of such forests. While the usual iterators loop over all nodes of a forest, active iterators iterate over the elements in the same order, but skip all non-active entries and therefore only visit terminal nodes (i.e. active cells, faces, etc). There are many ways to traverse the elements of a forest, for example breadth first or depth first. Depending on the type of data structure used to store the forest, some ways are more efficient than others. At present, the way iterators traverse forests in deal.II is breadth first. I.e., iterators first visit all the elements (cells, faces, etc) of the coarse mesh before moving on to all the elements of the immediate level, i.e. the immediate children of the coarse mesh objects; after this come the grandchildren of the coarse mesh, and so on. However, it must be noted that programs should not rely on this particular order of traversing a tree: this is considered an implementation detail that can change between versions, even if we consider this an unlikely option at the present time.</p>
<h1><a class="anchor" id="IteratorsDifferences"></a>
Different kinds of iterators</h1>
<p>Iterators have two properties: what they point to (i.e. the type of the Accessor template argument), and the exact definition of the set they iterate over. In general, iterators are always declared as </p>
<div class="fragment"><div class="line">KindIterator&lt;Accessor&gt;</div>
</div><!-- fragment --><p>Here, <code>Kind</code> determines what property an accessor needs to have to be reached by this iterator (or omitted, for that matter). For example, </p>
<div class="fragment"><div class="line">Iterator&lt;Accessor&gt;</div>
</div><!-- fragment --><p> iterates over all objects of kind Accessor that make up the mesh (for example all cells, whether they are further refined and have children, or not), whereas </p>
<div class="fragment"><div class="line">ActiveIterator&lt;Accessor&gt;</div>
</div><!-- fragment --><p> skips all objects that have children, i.e. objects that are not active. Active iterators therefore operate on a subset of the objects that normal iterators act on, namely those that possess the property that they are active. Note that this is independent of the kind of object we are operating on: all valid accessor classes have to provide the iterator classes a method to find out whether they are active or not.</p>
<p>(For completeness, let us mention that there is a third kind of iterators: "raw
iterators" also traverse objects that are unused in the triangulation, but allocated anyway for efficiency reasons. User code should never use raw iterators, they are only for internal purposes of the library.)</p>
<p>Whether an object is active can be considered a "predicate": a property that is either true or false. Filtered iterators can be used to restrict the scope of existing iterators even more. For instance, you could imagine to iterate over the subset of those <a class="el" href="DEALGlossary.html#GlossActive">active cells</a> having their user flag set or belonging to a certain subdomain (both properties are either true or false for a given object).</p>
<p>This is achieved by using an object of type <a class="el" href="classFilteredIterator.html">FilteredIterator</a> &lt;<a class="el" href="classBaseIterator.html">BaseIterator</a>&gt;, where <a class="el" href="classBaseIterator.html">BaseIterator</a> usually is one of the standard iterators discussed above.</p>
<p>The <a class="el" href="classFilteredIterator.html">FilteredIterator</a> gets an additional Predicate in its constructor and will skip all objects where this Predicate evaluates to <code>false</code>. A collection of predicates already implemented can be found in the namespace <a class="el" href="namespaceIteratorFilters.html">IteratorFilters</a>.</p>
<h2><a class="anchor" id="IteratorsLoops"></a>
Iterating over objects</h2>
<p>All iterators of the same kind and iterating over the same kind of geometrical objects traverse the mesh in the same order. Take this code example: </p>
<div class="fragment"><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> tria;</div>
<div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof1(tria);</div>
<div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof2(tria);</div>
<div class="line">...</div>
<div class="line">typename Trianguation&lt;dim&gt;::cell_iterator ti  = tria.<a class="code" href="classTriangulation.html#a7b87a97ff0d6ffe416aa37fda33c46c7">begin</a>();</div>
<div class="line"><span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::cell_iterator</a>   di1 = dof1.<a class="code" href="classDoFHandler.html#a0f72091ff71f88c939915dd0d76df4a1">begin</a>();</div>
<div class="line"><span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::cell_iterator</a>   di2 = dof2.<a class="code" href="classDoFHandler.html#a0f72091ff71f88c939915dd0d76df4a1">begin</a>();</div>
<div class="line">...</div>
<div class="line">while (ti != tria.<a class="code" href="classTriangulation.html#aa234819cf914abe2b700535c682688a7">end</a>())</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// do something</span></div>
<div class="line">  ++ti;</div>
<div class="line">  ++di1;</div>
<div class="line">  ++di2;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Here, all iterators will always point to the same mesh cell, even though <code><a class="el" href="classDoFHandler.html">DoFHandler</a></code> and <code><a class="el" href="classTriangulation.html">Triangulation</a></code> are very different classes, and even if the DoFHandlers are handling different finite elements: they all access cells in the same order, the difference is only in the Accessor. As mentioned above, the order in which iterators traverse the forest of objects is actually well-defined, but application programs should not assume any such order, but rather consider this an implementation detail of the library.</p>
<p>Corresponding to above example, the order in which iterators traverse active objects is the same for all iterators in the following snippet, the difference to the previous example being that here we only consider active cells: </p>
<div class="fragment"><div class="line"><span class="keyword">typename</span> Trianguation&lt;dim&gt;::active_cell_iterator ti  = tria.<a class="code" href="classTriangulation.html#af99e25cc64755f18659c0fbc46c3d87d">begin_active</a>();</div>
<div class="line"><span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a>   di1 = dof1.<a class="code" href="classDoFHandler.html#a6f2aa9c61385cbb749ed3d2e7bfe3de1">begin_active</a>();</div>
<div class="line"><span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a>   di2 = dof2.<a class="code" href="classDoFHandler.html#a6f2aa9c61385cbb749ed3d2e7bfe3de1">begin_active</a>();</div>
<div class="line">...</div>
<div class="line">while (ti != tria.<a class="code" href="classTriangulation.html#aa234819cf914abe2b700535c682688a7">end</a>())</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// do something</span></div>
<div class="line">  ++ti;</div>
<div class="line">  ++di1;</div>
<div class="line">  ++di2;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="IteratorsAccessors"></a>
Accessors</h1>
<p>Iterators are like pointers: they can be incremented and decremented, but they are really rather dumb. Their magic only lies in the fact that they point to some useful object, in this case the Accessor. For pointers, they point to an actual object that stores some data. On the other hand, the deal.II iterators, when dereferenced, do not return a reference to an actual object, but return an object that knows how to get at the data that represents cells. In general, this object doesn't store itself where the vertices of a cell are or what its neighbors are. However, it knows how to tease this sort of information from out of the arrays and tables and lists that the <a class="el" href="classTriangulation.html">Triangulation</a> class sets up to describe a mesh.</p>
<p>Accessing data that characterizes a cell is always done through the Accessor, i.e. the expression <code>i-&gt;xxx()</code> grants access to <b>all</b> attributes of this Accessor. Examples of properties you can query from an iterator are </p>
<div class="fragment"><div class="line">cell-&gt;vertex(1);</div>
<div class="line">line-&gt;child(0);</div>
<div class="line">hex-&gt;face(3);</div>
<div class="line">cell-&gt;at_boundary();</div>
<div class="line">face-&gt;boundary_indicator();</div>
</div><!-- fragment --><p>Since dereferencing iterators yields accessor objects, these calls are to member functions <code>Accesor::vertex()</code>, <code>Accessor::child()</code> etc. These in turn figure out the relevant data from the various data structures that store this data. How this is actually done and what data structures are used is not really of concern to authors of applications in deal.II. In particular, by hiding the actual data structures we are able to store data in an efficient way, not necessarily in a way that makes it easily accessible or understandable to application writers.</p>
<h1><a class="anchor" id="IteratorsTypedefs"></a>
Kinds of accessors</h1>
<p>Depending on what sort of data you want to access, there are different kinds of accessor classes:</p>
<ul>
<li>The <a class="el" href="classTriaAccessor.html">TriaAccessor</a> class provides you with data that identifies the geometric properties of cells, faces, lines, quads, and hexes that make up a triangulation, as well as mother-child relationships.</li>
<li>The <a class="el" href="classCellAccessor.html">CellAccessor</a> class is derived from the <a class="el" href="classTriaAccessor.html">TriaAccessor</a> class for cases where an object has full dimension, i.e. is a cell rather than for example a line bounding a cell. In that case, additional information about the topological connection of a mesh is available from an accessor such as to request iterators pointing to neighbors of a cell.</li>
<li>The <a class="el" href="classDoFAccessor.html">DoFAccessor</a> class lets you access information related to degrees of freedom associated with cells, faces, etc; it does so for both <a class="el" href="classDoFHandler.html">DoFHandler</a> and <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a> objects. Note that the <a class="el" href="classDoFAccessor.html">DoFAccessor</a> class is derived from either <a class="el" href="classTriaAccessor.html">TriaAccessor</a> or <a class="el" href="classCellAccessor.html">CellAccessor</a> (depending on whether the <a class="el" href="classDoFAccessor.html">DoFAccessor</a> points to an object of full dimension or not) and so is able to provide a superset of information over its base classes. Additionally, the <a class="el" href="classDoFAccessor.html">DoFAccessor</a> class comes in two flavors, one accessing degrees of freedom on the level of a cell and the other accessing the active dofs of an active cell.</li>
<li>The <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a> class has the same purpose and relation to <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a> as the <a class="el" href="classCellAccessor.html">CellAccessor</a> has to <a class="el" href="classTriaAccessor.html">TriaAccessor</a>.</li>
</ul>
<p>Except to look up member documentation, you will not usually have to deal with the actual class names listed above. Rather, one uses the typedefs provided by the container classes <a class="el" href="classTriangulation.html">Triangulation</a>, <a class="el" href="classDoFHandler.html">DoFHandler</a>, <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a> and <a class="el" href="classMGDoFHandler.html">MGDoFHandler</a>, as well as the function that generate such objects:</p>
<table  border="1">
<tr>
<th>Container </th><th>cell_iterator type </th><th><p class="starttd">function call </p>
<p class="endtd"></p>
</th></tr>
<tr>
<th><a class="el" href="classTriangulation.html">Triangulation</a> </th><td>typename Triangulation::cell_iterator </td><td><p class="starttd">triangulation.begin() </p>
<p class="endtd"></p>
</td></tr>
<tr>
<th><a class="el" href="classDoFHandler.html">DoFHandler</a> </th><td>typename DoFHandler::cell_iterator </td><td><p class="starttd">dof_handler.begin() </p>
<p class="endtd"></p>
</td></tr>
<tr>
<th><a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a> </th><td>typename hp::DoFHandler::cell_iterator </td><td><p class="starttd">hp_dof_handler.begin() </p>
<p class="endtd"></p>
</td></tr>
<tr>
<th><a class="el" href="classMGDoFHandler.html">MGDoFHandler</a> </th><td>typename MGDoFHandler::cell_iterator </td><td>mg_dof_handler.begin()  </td></tr>
</table>
<table  border="1">
<tr>
<th>Container </th><th>face_iterator type </th><th><p class="starttd">function call </p>
<p class="endtd"></p>
</th></tr>
<tr>
<th><a class="el" href="classTriangulation.html">Triangulation</a> </th><td>typename Triangulation::face_iterator </td><td><p class="starttd">triangulation.begin_face() </p>
<p class="endtd"></p>
</td></tr>
<tr>
<th><a class="el" href="classDoFHandler.html">DoFHandler</a> </th><td>typename DoFHandler::face_iterator </td><td><p class="starttd">dof_handler.begin_face() </p>
<p class="endtd"></p>
</td></tr>
<tr>
<th><a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a> </th><td>typename hp::DoFHandler::face_iterator </td><td><p class="starttd">hp_dof_handler.begin_face() </p>
<p class="endtd"></p>
</td></tr>
<tr>
<th><a class="el" href="classMGDoFHandler.html">MGDoFHandler</a> </th><td>typename MGDoFHandler::face_iterator </td><td>mg_dof_handler.begin_face()  </td></tr>
</table>
<p>Likewise, active iterators have the following properties:</p>
<table  border="1">
<tr>
<th>Container </th><th>cell_iterator type </th><th><p class="starttd">function call </p>
<p class="endtd"></p>
</th></tr>
<tr>
<th><a class="el" href="classTriangulation.html">Triangulation</a> </th><td>typename Triangulation::active_cell_iterator </td><td><p class="starttd">triangulation.begin_active() </p>
<p class="endtd"></p>
</td></tr>
<tr>
<th><a class="el" href="classDoFHandler.html">DoFHandler</a> </th><td>typename DoFHandler::active_cell_iterator </td><td><p class="starttd">dof_handler.begin_active() </p>
<p class="endtd"></p>
</td></tr>
<tr>
<th><a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a> </th><td>typename hp::DoFHandler::active_cell_iterator </td><td><p class="starttd">hp_dof_handler.begin_active() </p>
<p class="endtd"></p>
</td></tr>
<tr>
<th><a class="el" href="classMGDoFHandler.html">MGDoFHandler</a> </th><td>typename MGDoFHandler::active_cell_iterator </td><td>mg_dof_handler.begin_active()  </td></tr>
</table>
<table  border="1">
<tr>
<th>Container </th><th>face_iterator type </th><th><p class="starttd">function call </p>
<p class="endtd"></p>
</th></tr>
<tr>
<th><a class="el" href="classTriangulation.html">Triangulation</a> </th><td>typename Triangulation::active_face_iterator </td><td><p class="starttd">triangulation.begin_active_face() </p>
<p class="endtd"></p>
</td></tr>
<tr>
<th><a class="el" href="classDoFHandler.html">DoFHandler</a> </th><td>typename DoFHandler::active_face_iterator </td><td><p class="starttd">dof_handler.begin_active_face() </p>
<p class="endtd"></p>
</td></tr>
<tr>
<th><a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a> </th><td>typename hp::DoFHandler::active_face_iterator </td><td><p class="starttd">hp_dof_handler.begin_active_face() </p>
<p class="endtd"></p>
</td></tr>
<tr>
<th><a class="el" href="classMGDoFHandler.html">MGDoFHandler</a> </th><td>typename MGDoFHandler::active_face_iterator </td><td>mg_dof_handler.begin_active_face()  </td></tr>
</table>
<p>In addition to these types and calls that act on cells and faces (logical concepts that depend on the dimension: a cell is a quadrilateral in 2d, but a hexahedron in 3d), there are corresponding types and calls like <code>begin_active_quad()</code> or <code>end_quad()</code> that act on the dimension independent geometric objects line, quad, and hex. These calls, just as the ones above, exist in active and non-active forms.</p>
<p>The actual definition of all the typedefs local to the container classes are stated in the</p>
<ul>
<li><a class="el" href="structinternal_1_1Triangulation_1_1Iterators_3_011_00_01spacedim_01_4.html">internal::Triangulation::Iterators&lt;1,spacedim&gt;</a>, <a class="el" href="structinternal_1_1Triangulation_1_1Iterators_3_012_00_01spacedim_01_4.html">internal::Triangulation::Iterators&lt;2,spacedim&gt;</a>, and <a class="el" href="structinternal_1_1Triangulation_1_1Iterators_3_013_00_01spacedim_01_4.html">internal::Triangulation::Iterators&lt;3,spacedim&gt;</a> classes for <a class="el" href="classTriangulation.html">Triangulation</a> iterators,</li>
<li><a class="el" href="structinternal_1_1DoFHandler_1_1Iterators.html">internal::DoFHandler::Iterators</a>&lt;DH&lt;1,spacedim&gt; &gt;, <a class="el" href="structinternal_1_1DoFHandler_1_1Iterators.html">internal::DoFHandler::Iterators</a>&lt;DH&lt;2,spacedim&gt; &gt;, and <a class="el" href="structinternal_1_1DoFHandler_1_1Iterators.html">internal::DoFHandler::Iterators</a>&lt;DH&lt;3,spacedim&gt; &gt; classes for <a class="el" href="classDoFHandler.html">DoFHandler</a> and <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a> iterators,</li>
<li><a class="el" href="classinternal_1_1MGDoFHandler_1_1Iterators_3_011_00_01spacedim_01_4.html">internal::MGDoFHandler::Iterators&lt;1,spacedim&gt;</a>, <a class="el" href="classinternal_1_1MGDoFHandler_1_1Iterators_3_012_00_01spacedim_01_4.html">internal::MGDoFHandler::Iterators&lt;2,spacedim&gt;</a>, and <a class="el" href="classinternal_1_1MGDoFHandler_1_1Iterators_3_013_00_01spacedim_01_4.html">internal::MGDoFHandler::Iterators&lt;3,spacedim&gt;</a> classes for <a class="el" href="classMGDoFHandler.html">MGDoFHandler</a> iterators.</li>
</ul>
<h1><a class="anchor" id="IteratorAccessorInternals"></a>
Iterator and accessor internals</h1>
<p>Iterators, being like pointers, act as if they pointed to an actual object, but in reality all they do is to return an accessor when dereferenced. The accessor object contains the state, i.e. it knows which object it represents, by storing for example which <a class="el" href="classTriangulation.html">Triangulation</a> it belongs to, and the level and index within this level of a cell. It is therefore able to access the data that corresponds to the cell (or face, or edge) it represents</p>
<p>There is a representation of past-the-end-pointers, denoted by special values of the member variables <code>present_level</code> and <code>present_index</code> in the <a class="el" href="classTriaAccessor.html">TriaAccessor</a> class: If <code>present_level</code> &gt; =0 and <code>present_index</code> &gt; =0, then the object is valid; if <code>present_level</code>==-1 and <code>present_index</code>==-1, then the iterator points past the end; in all other cases, the iterator is considered invalid. You can check this by calling the <a class="el" href="classTriaAccessorBase.html#a957c6410e9d99a54641b7df806cd09cb">TriaAccessorBase::state()</a> function.</p>
<p>Past-the-end iterators may also be used to compare an iterator with the before-the-start value, when running backwards. There is no distinction between the iterators pointing past the two ends of a vector.</p>
<p>Cells are stored based on a hierarchical structure of levels, therefore the above mentioned structure is useful. Faces however are not organized in levels, and accessors for objects of lower dimensionality do not have a <code>present_level</code> member variable. </p>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jan 27 2014 15:27:15 for The deal.II Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
