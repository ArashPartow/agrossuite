<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>The deal.II Library: The step-45 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="http://www.dealii.org/deal.ico"></link>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2014 by the deal.II authors"></meta>
<meta name="deal.II-version" content="8.1.0"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 8.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The step-45 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#ThecodeLaplaceProblemcodeclass">The <code>LaplaceProblem</code> class</a>
        <li><a href="#ThecodeRightHandSidecodeclass">The <code>RightHandSide</code> class</a>
        <li><a href="#ImplementationofthecodeLaplaceProblemcodeclass">Implementation of the <code>LaplaceProblem</code> class</a>
      <ul>
        <li><a href="#LaplaceProblemmake_grid_and_dofs">LaplaceProblem::make_grid_and_dofs</a>
        <li><a href="#LaplaceProblemmake_periodicity_constraints">LaplaceProblem::make_periodicity_constraints</a>
        <li><a href="#LaplaceProblemassemble_system">LaplaceProblem::assemble_system</a>
        <li><a href="#LaplaceProblemsolve">LaplaceProblem::solve</a>
        <li><a href="#LaplaceProblemoutput_results">LaplaceProblem::output_results</a>
        <li><a href="#LaplaceProblemrun">LaplaceProblem::run</a>
      </ul>
        <li><a href="#Thecodemaincodefunction">The <code>main</code> function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Possibilitiesforextensions">Possibilities for extensions</a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <br/>
</p>
<p><em>This program was contributed by Markus B&uuml;rg.</em> <br/>
</p>
<p><a class="anchor" id="Intro"></a> <a class="anchor" id="Introduction"></a></p>
<h1>Introduction</h1>
<p>In this example we consider how to use periodic boundary conditions in deal.II. Periodic boundary conditions are a typical approach when one wants to solve some equation on a representative piece of a larger domain that repeats in one or more direction; an example is the simulation of the electronic structure of photonic crystals, because they have a lattice-like structure and, thus, it often suffices to do the actual computation on only one cell of the lattice. To be able to proceed this way one has to assume that the computation can be periodically extended to the other cells. This requires the solution to be periodic with respect to the cells. Hence the solution has to obtain the same nodal values on opposite parts of the boundary. In the figure below we show this concept in two space-dimensions. There, all dashed faces with the same color should have the same boundary values:</p>
<div class="image">
<img src="images/step-45.periodic_cells.png" />
</div>
<p>To keep things simple, in this tutorial we will consider an academic, simplified problem that allows us to focus on only that part that we are interested in here, namely how to set up periodic boundary conditions. Specifically, we solve the Poisson problem on a domain, where the left and right parts of the boundary are identified. Let <img class="formulaInl" alt="$\Omega=(0,1)^2$" src="form_2030.png"/> and consider the problem </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} -\Delta u &amp;= \cos(2\pi x)e^{-2x}\cos(2\pi y)e^{-2y} \qquad &amp;&amp;\text{in }\Omega \\ u(x,0) &amp;= 0 \qquad &amp;&amp;\text{for }x\in(0,1)\qquad &amp;&amp;\text{(bottom boundary)} \\ u(x,1) &amp;= 0 \qquad &amp;&amp;\text{for }x\in(0,1)\qquad &amp;&amp;\text{(top boundary)} \\ u(0,y) &amp;= u(1,y) \qquad &amp;&amp;\text{for }y\in(0,1) \qquad &amp;&amp; \text{(left and right boundaries)} \end{align*}" src="form_2031.png"/>
</p>
<p> Note that the source term is not symmetric and so the solution would not be periodic unless this is explicitly enforced.</p>
<p>The way one has to see these periodic boundary conditions <img class="formulaInl" alt="$u(x,0) = u(x,1)$" src="form_2032.png"/> is as follows: Assume for a moment (as we do in this program) that we have a uniformly refined mesh. Then, after discretization there are a number of nodes (degrees of freedom) with indices <img class="formulaInl" alt="$i \in {\cal I}_l$" src="form_2033.png"/> on the left boundary of the domain, and a second set of nodes at the right boundary <img class="formulaInl" alt="$j \in {\cal I}_r$" src="form_2034.png"/>. Since we have assumed that the mesh is uniformly refined, there is exactly one node <img class="formulaInl" alt="$j \in {\cal I}_r$" src="form_2034.png"/> for each <img class="formulaInl" alt="$i \in {\cal I}_l$" src="form_2033.png"/> so that <img class="formulaInl" alt="${\mathrm x}_j = {\mathrm x}_i + (1,0)^T$" src="form_2035.png"/>, i.e. the two of them match with respect to the periodicity. We will then write that <img class="formulaInl" alt="$j=\text{periodic}(i)$" src="form_2036.png"/> (and, if you want, <img class="formulaInl" alt="$i=\text{periodic}(j)$" src="form_2037.png"/>). If now <img class="formulaInl" alt="$U_k, k=0,\ldots,N-1,$" src="form_2038.png"/> are the unknowns of our discretized problem, then the periodic boundary condition boils down to the following set of constraints: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} U_{\text{periodic}(i)} = U_i, \qquad \forall i \in {\cal I}_l. \end{align*}" src="form_2039.png"/>
</p>
<p> Now, this is exactly the sort of constraint that the <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> class, first introduced in <a class="el" href="step_6.html">step-6</a>, handles and can enforce in a linear system. Consequently, the main point of this program is how we fill the <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> object that stores these constraints, and how this is applied to the resulting linear system.</p>
<p>The code for solving this problem is simple and based on <a class="el" href="step_3.html">step-3</a> since we want to focus on the implementation of the periodic boundary conditions. The code could be much more sophisticated, of course. For example, we could want to enforce periodic boundary conditions for adaptively refined meshes in which there is no longer a one-to-one relationship between degrees of freedom. We will discuss this at the end of the results section of this program. <a class="anchor" id="CommProg"></a> </p>
<h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p>
<h3>Include files</h3>
<p>The include files are already known. The one critical for the current program is the one that contains the <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> in the <code>lac/</code> directory:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/base/function.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/base/quadrature_lib.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/lac/constraint_matrix.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/lac/precondition.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/lac/solver_cg.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/lac/solver_control.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/lac/sparse_matrix.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/lac/sparsity_pattern.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/lac/compressed_sparsity_pattern.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_generator.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_accessor.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_handler.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_tools.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_q.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_values.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/data_out.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/vector_tools.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span>Step45</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">using namespace </span>dealii;</div>
</div><!-- fragment --><p><a class="anchor" id="ThecodeLaplaceProblemcodeclass"></a> </p>
<h3>The <code>LaplaceProblem</code> class</h3>
<p>The class <code>LaplaceProblem</code> is the main class of this problem. As mentioned in the introduction, it is fashioned after the corresponding class in <a class="el" href="step_3.html">step-3</a>. Correspondingly, the documentation from that tutorial program applies here as well. The only new member variable is the <code>constraints</code> variables that will hold the constraints from the periodic boundary condition. We will initialize it in the <code>make_periodicity_constraints()</code> function which we call from <code>make_grid_and_dofs()</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>LaplaceProblem</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  LaplaceProblem ();</div>
<div class="line">  <span class="keywordtype">void</span> run ();</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> triangulation;</div>
<div class="line"></div>
<div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;2&gt;</a> fe;</div>
<div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;2&gt;</a> dof_handler;</div>
<div class="line"></div>
<div class="line">  <a class="code" href="classConstraintMatrix.html">ConstraintMatrix</a> constraints;</div>
<div class="line"></div>
<div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a> sparsity_pattern;</div>
<div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div>
<div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> system_rhs;</div>
<div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> solution;</div>
<div class="line"></div>
<div class="line">  <span class="keywordtype">void</span> assemble_system ();</div>
<div class="line">  <span class="keywordtype">void</span> output_results ();</div>
<div class="line">  <span class="keywordtype">void</span> make_grid_and_dofs ();</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceDoFTools.html#ae23173d20bc1b6c56c6d3a4aa2cbae73">make_periodicity_constraints</a> ();</div>
<div class="line">  <span class="keywordtype">void</span> solve ();</div>
<div class="line">};</div>
</div><!-- fragment --><p><a class="anchor" id="ThecodeRightHandSidecodeclass"></a> </p>
<h3>The <code>RightHandSide</code> class</h3>
<p>The following implements the right hand side function discussed in the introduction. Its implementation is obvious given what has been shown in <a class="el" href="step_4.html">step-4</a> before:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>RightHandSide: <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;2&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  RightHandSide ();</div>
<div class="line"></div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#a9783cc12b6b205d4019379b0cc6f3956">value</a> (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> &amp;p,</div>
<div class="line">                        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const</span>;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">RightHandSide::RightHandSide ()</div>
<div class="line">  :</div>
<div class="line">  <a class="code" href="classFunction.html">Function</a>&lt;2&gt; ()</div>
<div class="line">{}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">double</span></div>
<div class="line">RightHandSide::value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> &amp;p,</div>
<div class="line">                      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  <span class="keywordflow">return</span> (std::cos (2 * <a class="code" href="namespacenumbers.html#a5ee2b45bb5bf8e0ab30d95a6afd0a4e8">numbers::PI</a> * p(0)) *</div>
<div class="line">          std::exp (- 2 * p(0)) *</div>
<div class="line">          std::cos (2 * <a class="code" href="namespacenumbers.html#a5ee2b45bb5bf8e0ab30d95a6afd0a4e8">numbers::PI</a> * p(1)) *</div>
<div class="line">          std::exp (- 2 * p(1)));</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="ImplementationofthecodeLaplaceProblemcodeclass"></a> </p>
<h3>Implementation of the <code>LaplaceProblem</code> class</h3>
<p>The first part of implementing the main class is the constructor. It is unchanged from <a class="el" href="step_3.html">step-3</a> and <a class="el" href="step_4.html">step-4</a>:</p>
<div class="fragment"><div class="line">LaplaceProblem::LaplaceProblem ()</div>
<div class="line">  :</div>
<div class="line">  fe (1),</div>
<div class="line">  dof_handler (triangulation)</div>
<div class="line">{}</div>
</div><!-- fragment --><p><a class="anchor" id="LaplaceProblemmake_grid_and_dofs"></a> </p>
<h4>LaplaceProblem::make_grid_and_dofs</h4>
<p>The following is the first function to be called in <code>run()</code>. It sets up the mesh and degrees of freedom.</p>
<p>We start by creating the usual square mesh and changing the boundary indicator on the parts of the boundary where we have Dirichlet boundary conditions (top and bottom, i.e. faces two and three of the reference cell as defined by <a class="el" href="structGeometryInfo.html">GeometryInfo</a>), so that we can distinguish between the parts of the boundary where periodic and where Dirichlet boundary conditions hold. We then refine the mesh a fixed number of times, with child faces inheriting the boundary indicators previously set on the coarse mesh from their parents.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> LaplaceProblem::make_grid_and_dofs ()</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="namespaceGridGenerator.html#a7149c59cefa805a132177cfa6cb953bd">GridGenerator::hyper_cube</a> (triangulation);</div>
<div class="line">  triangulation.<a class="code" href="classTriangulation.html#af99e25cc64755f18659c0fbc46c3d87d">begin_active</a> ()-&gt;face (2)-&gt;set_boundary_indicator (1);</div>
<div class="line">  triangulation.<a class="code" href="classTriangulation.html#af99e25cc64755f18659c0fbc46c3d87d">begin_active</a> ()-&gt;face (3)-&gt;set_boundary_indicator (1);</div>
<div class="line">  triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a> (5);</div>
</div><!-- fragment --><p>The next step is to distribute the degrees of freedom and produce a little bit of graphical output:</p>
<div class="fragment"><div class="line">dof_handler.<a class="code" href="classDoFHandler.html#afcfcc3b473f444f50d206ae62dfe3694">distribute_dofs</a> (fe);</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Number of active cells: &quot;</span></div>
<div class="line">          &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#aa21f25016ce1b9d70d2003a128985870">n_active_cells</a> ()</div>
<div class="line">          &lt;&lt; std::endl</div>
<div class="line">          &lt;&lt; <span class="stringliteral">&quot;Degrees of freedom: &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#a54e7270f2ba6206604f794114b39a2aa">n_dofs</a> ()</div>
<div class="line">          &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>Now it is the time for the constraints that come from the periodicity constraints. We do this in the following, separate function, after clearing any possible prior content from the constraints object:</p>
<div class="fragment"><div class="line">constraints.<a class="code" href="classConstraintMatrix.html#a24120d0331183f9a63cbe41493a19f6b">clear</a> ();</div>
<div class="line"><a class="code" href="namespaceDoFTools.html#ae23173d20bc1b6c56c6d3a4aa2cbae73">make_periodicity_constraints</a> ();</div>
</div><!-- fragment --><p>We also incorporate the homogeneous Dirichlet boundary conditions on the upper and lower parts of the boundary (i.e. the ones with boundary indicator 1) and close the <code><a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a></code> object:</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceVectorTools.html#a199f38e07822b47e5b5957c21ce35d1b">VectorTools::interpolate_boundary_values</a> (dof_handler, 1,</div>
<div class="line">                                          <a class="code" href="classZeroFunction.html">ZeroFunction&lt;2&gt;</a> (),</div>
<div class="line">                                          constraints);</div>
<div class="line">constraints.<a class="code" href="classConstraintMatrix.html#a8056d07faa2a7ed3f158c1b42d56abc8">close</a> ();</div>
</div><!-- fragment --><p>Then we create the sparsity pattern and the system matrix and initialize the solution and right-hand side vectors. This is again as in <a class="el" href="step_3.html">step-3</a> or <a class="el" href="step_6.html">step-6</a>, for example:</p>
<div class="fragment"><div class="line">  <a class="code" href="classCompressedSparsityPattern.html">CompressedSparsityPattern</a> c_sparsity_pattern (dof_handler.<a class="code" href="classDoFHandler.html#a54e7270f2ba6206604f794114b39a2aa">n_dofs</a>(),</div>
<div class="line">                                                dof_handler.<a class="code" href="classDoFHandler.html#a54e7270f2ba6206604f794114b39a2aa">n_dofs</a>());</div>
<div class="line">  <a class="code" href="group__constraints.html#gab627b1d4845c9526521dbd1be83469dc">DoFTools::make_sparsity_pattern</a> (dof_handler,</div>
<div class="line">                                   c_sparsity_pattern,</div>
<div class="line">                                   constraints,</div>
<div class="line">                                   <span class="keyword">false</span>);</div>
<div class="line">  c_sparsity_pattern.compress ();</div>
<div class="line">  sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a59b573e5a6c1c92fc768e36db2731cf4">copy_from</a> (c_sparsity_pattern);</div>
<div class="line"></div>
<div class="line">  system_matrix.reinit (sparsity_pattern);</div>
<div class="line">  system_rhs.<a class="code" href="classBlockVector.html#a4caa9be7a7053fd6ae9fac1da74e564b">reinit</a> (dof_handler.<a class="code" href="classDoFHandler.html#a54e7270f2ba6206604f794114b39a2aa">n_dofs</a>());</div>
<div class="line">  solution.<a class="code" href="classVector.html#ac3adfcf8cf35943558fc27ef989b7263">reinit</a> (dof_handler.<a class="code" href="classDoFHandler.html#a54e7270f2ba6206604f794114b39a2aa">n_dofs</a>());</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="LaplaceProblemmake_periodicity_constraints"></a> </p>
<h4>LaplaceProblem::make_periodicity_constraints</h4>
<p>This is the function that provides the new material of this tutorial program. The general outline of the algorithm is as follows: we first loop over all the degrees of freedom on the right boundary and record their <img class="formulaInl" alt="$y$" src="form_10.png"/>-locations in a map together with their global indices. Then we go along the left boundary, find matching <img class="formulaInl" alt="$y$" src="form_10.png"/>-locations for each degree of freedom, and then add constraints that identify these matched degrees of freedom.</p>
<p>In this function, we make use of the fact that we have a scalar element (i.e. the only valid vector component that can be passed to <a class="el" href="classDoFAccessor.html#ae244ade8078f825e44abdbc2d9e81af5">DoFAccessor::vertex_dof_index</a> is zero) and that we have a <img class="formulaInl" alt="$Q_1$" src="form_37.png"/> element for which all degrees of freedom live in the vertices of the cell. Furthermore, we have assumed that we are in 2d and that meshes were not refined adaptively &mdash; the latter assumption would imply that there may be vertices that aren't matched one-to-one and for which we won't be able to compute constraints this easily. We will discuss in the "outlook" part of the results section below other strategies to write the current function that can work in cases like this as well.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> LaplaceProblem::make_periodicity_constraints ()</div>
<div class="line">{</div>
</div><!-- fragment --><p>To start with the actual implementation, we loop over all active cells and check whether the cell is located at the right boundary (i.e. face 1 &mdash; the one at the right end of the cell &mdash; is at the boundary). If that is so, then we use that for the currently used finite element, each degree of freedom of the face is located on one vertex, and store their <img class="formulaInl" alt="$y$" src="form_10.png"/>-coordinate along with the global number of this degree of freedom in the following map:</p>
<div class="fragment"><div class="line">std::map&lt;unsigned int, double&gt; dof_locations;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (DoFHandler&lt;2&gt;::active_cell_iterator cell = dof_handler.<a class="code" href="classDoFHandler.html#a6f2aa9c61385cbb749ed3d2e7bfe3de1">begin_active</a> ();</div>
<div class="line">     cell != dof_handler.<a class="code" href="classDoFHandler.html#abf64c3734383b6fb1bed4888935f2edf">end</a> (); ++cell)</div>
<div class="line">  <span class="keywordflow">if</span> (cell-&gt;at_boundary ()</div>
<div class="line">      &amp;&amp;</div>
<div class="line">      cell-&gt;face(1)-&gt;at_boundary ())</div>
<div class="line">    {</div>
<div class="line">      dof_locations[cell-&gt;face(1)-&gt;vertex_dof_index(0, 0)]</div>
<div class="line">        = cell-&gt;face(1)-&gt;vertex(0)[1];</div>
<div class="line">      dof_locations[cell-&gt;face(1)-&gt;vertex_dof_index(1, 0)]</div>
<div class="line">        = cell-&gt;face(1)-&gt;vertex(1)[1];</div>
<div class="line">    }</div>
</div><!-- fragment --><p>Note that in the above block, we add vertices zero and one of the affected face to the map. This means that we will add each vertex twice, once from each of the two adjacent cells (unless the vertex is a corner of the domain). Since the coordinates of the vertex are the same both times of course, there is no harm: we replace one value in the map with itself the second time we visit an entry.</p>
<p>The same will be true below where we add the same constraint twice to the <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &mdash; again, we will overwrite the constraint with itself, and no harm is done.</p>
<p>Now we have to find the corresponding degrees of freedom on the left part of the boundary. Therefore we loop over all cells again and choose the ones where face 0 is at the boundary:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (DoFHandler&lt;2&gt;::active_cell_iterator cell = dof_handler.<a class="code" href="classDoFHandler.html#a6f2aa9c61385cbb749ed3d2e7bfe3de1">begin_active</a> ();</div>
<div class="line">     cell != dof_handler.<a class="code" href="classDoFHandler.html#abf64c3734383b6fb1bed4888935f2edf">end</a> (); ++cell)</div>
<div class="line">  <span class="keywordflow">if</span> (cell-&gt;at_boundary ()</div>
<div class="line">      &amp;&amp;</div>
<div class="line">      cell-&gt;face (0)-&gt;at_boundary ())</div>
<div class="line">    {</div>
</div><!-- fragment --><p>Every degree of freedom on this face needs to have a corresponding one on the right side of the face, and our goal is to add a constraint for the one on the left in terms of the one on the right. To this end we first add a new line to the constraint matrix for this one degree of freedom. Then we identify it with the corresponding degree of freedom on the right part of the boundary by constraining the degree of freedom on the left with the one on the right times a weight of 1.0.</p>
<p>Consequently, we loop over the two vertices of each face we find and then loop over all the <img class="formulaInl" alt="$y$" src="form_10.png"/>-locations we've previously recorded to find which degree of freedom on the right boundary corresponds to the one we currently look at. Note that we have entered these into a map, and when looping over the iterators <code>p</code> of this map, <code>p-&gt;first</code> corresponds to the "key" of an entry (the global number of the degree of freedom), whereas <code>p-&gt;second</code> is the "value" (the <img class="formulaInl" alt="$y$" src="form_10.png"/>-location we have entered above).</p>
<p>We are quite sure here that we should be finding such a corresponding degree of freedom. However, sometimes stuff happens and so the bottom of the block contains an assertion that our assumption was indeed correct and that a vertex was found.</p>
<div class="fragment"><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face_vertex = 0; face_vertex&lt;2; ++face_vertex)</div>
<div class="line">          {</div>
<div class="line">            constraints.<a class="code" href="classConstraintMatrix.html#a24eb022f65797389badbb6d21da5b708">add_line</a> (cell-&gt;face(0)-&gt;vertex_dof_index (face_vertex, 0));</div>
<div class="line"></div>
<div class="line">            std::map&lt;unsigned int, double&gt;::const_iterator p = dof_locations.begin();</div>
<div class="line">            <span class="keywordflow">for</span> (; p != dof_locations.end(); ++p)</div>
<div class="line">              <span class="keywordflow">if</span> (std::fabs(p-&gt;second - cell-&gt;face(0)-&gt;vertex(face_vertex)[1]) &lt; 1e-8)</div>
<div class="line">                {</div>
<div class="line">                  constraints.<a class="code" href="classConstraintMatrix.html#a4cd323a407cb379510a68c26e842304e">add_entry</a> (cell-&gt;face(0)-&gt;vertex_dof_index (face_vertex, 0),</div>
<div class="line">                                         p-&gt;first, 1.0);</div>
<div class="line">                  <span class="keywordflow">break</span>;</div>
<div class="line">                }</div>
<div class="line">            <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (p != dof_locations.end(),</div>
<div class="line">                    <a class="code" href="group__Exceptions.html#ga7e124f28261be534af7e3399945c5e68">ExcMessage</a> (<span class="stringliteral">&quot;No corresponding degree of freedom was found!&quot;</span>));</div>
<div class="line">          }</div>
<div class="line">      }</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="LaplaceProblemassemble_system"></a> </p>
<h4>LaplaceProblem::assemble_system</h4>
<p>Assembling the system matrix and the right-hand side vector is done as in other tutorials before.</p>
<p>The only difference here is that we don't copy elements from local contributions into the global matrix and later fix up constrained degrees of freedom, but that we let the <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> do this job in one swoop for us using the <a class="el" href="classConstraintMatrix.html#aa9f3612a8fc51eafa34252bb436e8ae4">ConstraintMatrix::distribute_local_to_global</a> function(). This was previously already demonstrated in <a class="el" href="step_16.html">step-16</a>, <a class="el" href="step_22.html">step-22</a>, for example, along with a discussion in the introduction of <a class="el" href="step_27.html">step-27</a>.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> LaplaceProblem::assemble_system ()</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classQGauss.html">QGauss&lt;2&gt;</a>  quadrature_formula(2);</div>
<div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;2&gt;</a> fe_values (fe, quadrature_formula,</div>
<div class="line">                         <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>   | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div>
<div class="line">                         <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div>
<div class="line"></div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   dofs_per_cell = fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>;</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#a4d64837b1d374e9c46f07af8f094b29b">size</a>();</div>
<div class="line"></div>
<div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>   cell_matrix (dofs_per_cell, dofs_per_cell);</div>
<div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       cell_rhs (dofs_per_cell);</div>
<div class="line"></div>
<div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices (dofs_per_cell);</div>
<div class="line"></div>
<div class="line">  <span class="keyword">const</span> RightHandSide right_hand_side;</div>
<div class="line"></div>
<div class="line">  DoFHandler&lt;2&gt;::active_cell_iterator cell = dof_handler.<a class="code" href="classDoFHandler.html#a6f2aa9c61385cbb749ed3d2e7bfe3de1">begin_active</a>(),</div>
<div class="line">                                      endc = dof_handler.<a class="code" href="classDoFHandler.html#abf64c3734383b6fb1bed4888935f2edf">end</a>();</div>
<div class="line">  <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div>
<div class="line">    {</div>
<div class="line">      fe_values.<a class="code" href="classFEValues.html#afde502903642c57ade24dfcebf5c1650">reinit</a> (cell);</div>
<div class="line">      cell_matrix = 0;</div>
<div class="line">      cell_rhs = 0;</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point=0; q_point&lt;n_q_points; ++q_point)</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div>
<div class="line">          {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div>
<div class="line">              cell_matrix(i,j) += (fe_values.<a class="code" href="classFEValuesBase.html#ac4cee7628c2903a89c5c399fddeb00a5">shape_grad</a> (i, q_point) *</div>
<div class="line">                                   fe_values.<a class="code" href="classFEValuesBase.html#ac4cee7628c2903a89c5c399fddeb00a5">shape_grad</a> (j, q_point) *</div>
<div class="line">                                   fe_values.<a class="code" href="classFEValuesBase.html#ad097580a2f71878695096cc73b271b9d">JxW</a> (q_point));</div>
<div class="line"></div>
<div class="line">            cell_rhs(i) += (fe_values.<a class="code" href="classFEValuesBase.html#abe4de48ff59778bb82a0ec13037804aa">shape_value</a> (i, q_point) *</div>
<div class="line">                            right_hand_side.value (fe_values.<a class="code" href="classFEValuesBase.html#a75b6f2cb7c735b51b20093d90b1930b0">quadrature_point</a> (q_point)) *</div>
<div class="line">                            fe_values.<a class="code" href="classFEValuesBase.html#ad097580a2f71878695096cc73b271b9d">JxW</a> (q_point));</div>
<div class="line">          }</div>
<div class="line"></div>
<div class="line">      cell-&gt;get_dof_indices (local_dof_indices);</div>
<div class="line">      constraints.<a class="code" href="classConstraintMatrix.html#aa9f3612a8fc51eafa34252bb436e8ae4">distribute_local_to_global</a> (cell_matrix, cell_rhs,</div>
<div class="line">                                              local_dof_indices,</div>
<div class="line">                                              system_matrix, system_rhs);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="LaplaceProblemsolve"></a> </p>
<h4>LaplaceProblem::solve</h4>
<p>To solve the linear system of equations <img class="formulaInl" alt="$Au=b$" src="form_2040.png"/> we use the CG solver with an SSOR-preconditioner. This is, again, copied almost verbatim from <a class="el" href="step_6.html">step-6</a>. As in <a class="el" href="step_6.html">step-6</a>, we need to make sure that constrained degrees of freedom get their correct values after solving by calling the <a class="el" href="classConstraintMatrix.html#a7cf6b84c47aa32408f412ae769085bd6">ConstraintMatrix::distribute</a> function:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> LaplaceProblem::solve ()</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a> solver_control (dof_handler.<a class="code" href="classDoFHandler.html#a54e7270f2ba6206604f794114b39a2aa">n_dofs</a> (), 1e-12);</div>
<div class="line">  <a class="code" href="classPreconditionSSOR.html">PreconditionSSOR&lt;SparseMatrix&lt;double&gt;</a> &gt; precondition;</div>
<div class="line"></div>
<div class="line">  precondition.<a class="code" href="classPreconditionSSOR.html#aa564d2dbcdcf09c6ceed549f319b5465">initialize</a> (system_matrix);</div>
<div class="line"></div>
<div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;&gt;</a> cg (solver_control);</div>
<div class="line"></div>
<div class="line">  cg.solve (system_matrix, solution, system_rhs, precondition);</div>
<div class="line">  constraints.<a class="code" href="classConstraintMatrix.html#a7cf6b84c47aa32408f412ae769085bd6">distribute</a> (solution);</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="LaplaceProblemoutput_results"></a> </p>
<h4>LaplaceProblem::output_results</h4>
<p>This is another function copied from previous tutorial programs. It generates graphical output in VTK format:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> LaplaceProblem::output_results ()</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;2&gt;</a> data_out;</div>
<div class="line"></div>
<div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a5e63bad650805ce93cd74c6dc3b29b11">attach_dof_handler</a> (dof_handler);</div>
<div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a59a6b70a4b909e0229a20487dd68cc43">add_data_vector</a> (solution, <span class="stringliteral">&quot;u&quot;</span>);</div>
<div class="line">  data_out.<a class="code" href="classDataOut.html#ab3d44201acb97fba286a897452236b51">build_patches</a> ();</div>
<div class="line"></div>
<div class="line">  std::ofstream output (<span class="stringliteral">&quot;solution.vtk&quot;</span>);</div>
<div class="line"></div>
<div class="line">  data_out.<a class="code" href="classDataOutInterface.html#ab43da05fc9809b3eec1436c4962f8d77">write_vtk</a> (output);</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="LaplaceProblemrun"></a> </p>
<h4>LaplaceProblem::run</h4>
<p>And another function copied from previous programs:</p>
<div class="fragment"><div class="line">  <span class="keywordtype">void</span> LaplaceProblem::run ()</div>
<div class="line">  {</div>
<div class="line">    make_grid_and_dofs();</div>
<div class="line">    assemble_system ();</div>
<div class="line">    solve ();</div>
<div class="line">    output_results ();</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="Thecodemaincodefunction"></a> </p>
<h3>The <code>main</code> function</h3>
<p>And at the end we have the main function as usual, this time copied from <a class="el" href="step_6.html">step-6</a>:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code" href="group__ParameterGui.html#ga0ddf1224851353fc92bfbff6f499fa97">main</a> ()</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">try</span></div>
<div class="line">    {</div>
<div class="line">      <span class="keyword">using namespace </span>dealii;</div>
<div class="line">      <span class="keyword">using namespace </span>Step45;</div>
<div class="line"></div>
<div class="line">      deallog.<a class="code" href="classLogStream.html#a8028e970ad8388596d625ed463894e98">depth_console</a> (0);</div>
<div class="line"></div>
<div class="line">      LaplaceProblem laplace_problem;</div>
<div class="line">      laplace_problem.run ();</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div>
<div class="line">    {</div>
<div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">catch</span> (...)</div>
<div class="line">    {</div>
<div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p> <a class="anchor" id="Results"></a></p>
<h1>Results</h1>
<p>The textual output the program generates is not very surprising. It just prints out the usual information on degrees of freedom and active cells, in much the same way as <a class="el" href="step_3.html">step-3</a> did:</p>
<div class="fragment"><div class="line">Number of active cells: 1024</div>
<div class="line">Degrees of freedom: 1089</div>
</div><!-- fragment --><p>The plot of the solution can be found in the figure below. We can see that the solution is constant zero on the upper and the lower part of the boundary as required by the homogeneous Dirichlet boundary conditions. On the left and right parts the values coincide with each other, just as we wanted:</p>
<div class="image">
<img src="images/step-45.solution.png" />
</div>
<p>Note also that the solution is clearly not left-right symmetric and so would not likely have been periodic had we prescribed, for example, homogeneous Neumann boundary condition. However, it is periodic thanks to the constraints imposed.</p>
<p><a class="anchor" id="extensions"></a> <a class="anchor" id="Possibilitiesforextensions"></a></p>
<h3>Possibilities for extensions</h3>
<p>The function <code>LaplaceProblem::make_periodicity_constraints</code> is relatively simple in that it just matches the location of degrees of freedom. This makes it flexible when the periodicity boundary conditions are posed not just on opposite faces of the unit rectangle but on separate parts of a possibly more complicated domain. Or, if one wanted to "twist" the boundary condition by prescribing, for example, </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} u(0,y) &amp;= u(1,1-y) \qquad &amp;\text{for }y\in(0,1). \end{align*}" src="form_2041.png"/>
</p>
<p>On the other hand, the function is somewhat limited by the assumption that the domain is two-dimensional and that we only use <img class="formulaInl" alt="$Q_1$" src="form_37.png"/> elements. The former assumption is easily lifted by looping over all four vertices of a face in 3d, but the latter is somewhat more complicated to lift because we have assumed that degrees of freedom are only located in vertices. In the following, therefore, let us describe a function that computes the same constraints but in a dimension-independent way and for any finite element one may want to consider.</p>
<dl class="section note"><dt>Note</dt><dd>The discussion below is meant as an explanation of how one might approach this kind of problem. If you need this functionality, you may also want to take a look at <a class="el" href="namespaceDoFTools.html#ae23173d20bc1b6c56c6d3a4aa2cbae73">DoFTools::make_periodicity_constraints()</a> that already provides some of it.</dd></dl>
<p>The idea is to work recursively on pairs of faces. For example, let us start with the left and right face of the (single) coarse mesh cell. They need to match, but they are not active (i.e. they are further refined) and so there are no degrees of freedom associated with these faces. However, if the two current faces are periodic, then so are the zeroth children of the two as well as the respective first children, etc. We can then in turn work on each of these pairs of faces. If they are not active, we may recurse further into this refinement tree until we find a pair of active faces. In that case, we enter equivalences between matching degrees of freedom on the two active faces.</p>
<p>An implementation of this idea would look like follows (with the <code>make_periodicity_constraint_recursively()</code> function &mdash; an implementation detail, not an external interface &mdash; put into an anonymous namespace): </p>
<div class="fragment"><div class="line"><span class="keyword">namespace</span></div>
<div class="line">{</div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span></div>
<div class="line">  make_periodicity_constraints_recursively</div>
<div class="line">  (<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::face_iterator</a> &amp;face_1,</div>
<div class="line">   <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::face_iterator</a> &amp;face_2,</div>
<div class="line">   <a class="code" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints)</div>
<div class="line">  {</div>
<div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (face_1-&gt;n_children() == face_2-&gt;n_children(),</div>
<div class="line">            <a class="code" href="group__Exceptions.html#gac43116aa5c4896cb376bf817ee854e70">ExcNotImplemented</a>());</div>
<div class="line">    <span class="keywordflow">if</span> (face_1-&gt;has_children())</div>
<div class="line">      {</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c=0; c&lt;face_1-&gt;n_children(); ++c)</div>
<div class="line">          make_periodicity_constraints_recursively&lt;dim&gt; (face_1-&gt;child(c),</div>
<div class="line">                                                         face_2-&gt;child(c),</div>
<div class="line">                                                         constraints);</div>
<div class="line">      }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">      {</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_face</div>
<div class="line">          = face_1-&gt;get_dof_handler().<a class="code" href="classDoFHandler.html#a3f667f0151bf00e5a364cb65ef2672ab">get_fe</a>().dofs_per_face;</div>
<div class="line"></div>
<div class="line">        std::vector&lt;unsigned int&gt; local_dof_indices_1 (dofs_per_face);</div>
<div class="line">        face_1-&gt;get_dof_indices (local_dof_indices_1);</div>
<div class="line"></div>
<div class="line">        std::vector&lt;unsigned int&gt; local_dof_indices_2 (dofs_per_face);</div>
<div class="line">        face_2-&gt;get_dof_indices (local_dof_indices_2);</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_face; ++i)</div>
<div class="line">          {</div>
<div class="line">            constraints.<a class="code" href="classConstraintMatrix.html#a24eb022f65797389badbb6d21da5b708">add_line</a> (local_dof_indices_1[i]);</div>
<div class="line">            constraints.<a class="code" href="classConstraintMatrix.html#a4cd323a407cb379510a68c26e842304e">add_entry</a> (local_dof_indices_1[i],</div>
<div class="line">                                   local_dof_indices_2[i],</div>
<div class="line">                                   1.0);</div>
<div class="line">          }</div>
<div class="line">      }</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> LaplaceProblem::make_periodicity_constraints ()</div>
<div class="line">{</div>
<div class="line">  make_periodicity_constraints_recursively&lt;2&gt; (dof_handler.<a class="code" href="classDoFHandler.html#a0f72091ff71f88c939915dd0d76df4a1">begin</a>(0)-&gt;face(0),</div>
<div class="line">                                               dof_handler.<a class="code" href="classDoFHandler.html#a0f72091ff71f88c939915dd0d76df4a1">begin</a>(0)-&gt;face(1),</div>
<div class="line">                                               constraints);</div>
<div class="line">}</div>
</div><!-- fragment --><p>The implementation of the recursive function should be mostly self explanatory given the discussion above. The <code>LaplaceProblem::make_periodicity_constraints()</code> function simply calls the former with matching faces of the first (and only) coarse mesh cell on refinement level 0. Note that when calling the recursive function we have to explicitly specify the template argument since the compiler can not deduce it (the template argument is only used in a "non-deducible context").</p>
<p>This function is now dimension and finite element independent, but it still has the restriction that it assumes that the mesh is uniformly refined (or, in fact, only that matching periodic faces are refined equally). We check this at the beginning by asserting that both faces have the same number of children (that includes that neither have any children, i.e. that both are active). On the other hand, the function above can be extended to also allow this sort of thing. In that case, if we encounter the situation that only one cell is refined, we would have to recurse into its children and interpolate their degrees of freedom with respect to the degrees of freedom to the coarser matching face. This can use the same facilities the finite element classes already provide for computing constraints based on hanging nodes. We leave implementing this as an exercise, however.</p>
<dl class="section note"><dt>Note</dt><dd>The functions above make one assumption, namely that the degrees of freedom on one face match one-to-one to the corresponding other face. This is sometimes difficult to establish, especially in 3d. For example, consider a long string of cube cells where we want to match the far left face with the far right face for periodicity. If the cells are all undistorted cubes, then everything will work as expected. But imagine we have twisted our cells so that the string as a whole now has a 90 degree twist; in that case, the coordinate systems of the far left and far right face are also rotated relative to each other, and the first DoF on the far left face will no longer be at the same location as the first DoF on the far right face. To make things a bit worse, the 3d case also allows for pathological cases where mesh cells are no longer orientable in the standard order (see the <a class="el" href="DEALGlossary.html#GlossFaceOrientation">Face orientation</a> glossary entry), making matching coordinate systems difficult. Ultimately, whether you will encounter these cases depends on the kind of mesh you have: if your coarse mesh is just the unit cube or a subdivided hyper rectangle, you are definitely on the safe side. In other cases, if in doubt, verify the locations of degrees of freedom by printing the kind of information we have used in the tutorial's own implementation. <a class="anchor" id="PlainProg"></a> <h1>The plain program</h1>
</dd></dl>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div>
<div class="line"><span class="comment"> * @f$Id: @ref step_45 &quot;step-45&quot;.cc 30147 2013-07-24 09:28:41Z maier @f$</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * Copyright (C) 2010 - 2013 by the deal.II authors</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div>
<div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div>
<div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div>
<div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div>
<div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE at</span></div>
<div class="line"><span class="comment"> * the top level of the deal.II distribution.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * Author: Markus Buerg, University of Karlsruhe, 2010</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/base/function.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/base/quadrature_lib.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/lac/constraint_matrix.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/lac/precondition.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/lac/solver_cg.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/lac/solver_control.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/lac/sparse_matrix.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/lac/sparsity_pattern.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/lac/compressed_sparsity_pattern.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_generator.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_accessor.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_handler.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_tools.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_q.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_values.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/data_out.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/vector_tools.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span>Step45</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">using namespace </span>dealii;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="keyword">class </span>LaplaceProblem</div>
<div class="line">  {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    LaplaceProblem ();</div>
<div class="line">    <span class="keywordtype">void</span> run ();</div>
<div class="line"></div>
<div class="line">  <span class="keyword">private</span>:</div>
<div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> triangulation;</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classFE__Q.html">FE_Q&lt;2&gt;</a> fe;</div>
<div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;2&gt;</a> dof_handler;</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classConstraintMatrix.html">ConstraintMatrix</a> constraints;</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a> sparsity_pattern;</div>
<div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div>
<div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a> system_rhs;</div>
<div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a> solution;</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> assemble_system ();</div>
<div class="line">    <span class="keywordtype">void</span> output_results ();</div>
<div class="line">    <span class="keywordtype">void</span> make_grid_and_dofs ();</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceDoFTools.html#ae23173d20bc1b6c56c6d3a4aa2cbae73">make_periodicity_constraints</a> ();</div>
<div class="line">    <span class="keywordtype">void</span> solve ();</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="keyword">class </span>RightHandSide: <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;2&gt;</div>
<div class="line">  {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    RightHandSide ();</div>
<div class="line"></div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> &amp;p,</div>
<div class="line">                          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const</span>;</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  RightHandSide::RightHandSide ()</div>
<div class="line">    :</div>
<div class="line">    <a class="code" href="classFunction.html">Function</a>&lt;2&gt; ()</div>
<div class="line">  {}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="keywordtype">double</span></div>
<div class="line">  RightHandSide::value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> &amp;p,</div>
<div class="line">                        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <span class="keywordflow">return</span> (std::cos (2 * <a class="code" href="namespacenumbers.html#a5ee2b45bb5bf8e0ab30d95a6afd0a4e8">numbers::PI</a> * p(0)) *</div>
<div class="line">            std::exp (- 2 * p(0)) *</div>
<div class="line">            std::cos (2 * <a class="code" href="namespacenumbers.html#a5ee2b45bb5bf8e0ab30d95a6afd0a4e8">numbers::PI</a> * p(1)) *</div>
<div class="line">            std::exp (- 2 * p(1)));</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  LaplaceProblem::LaplaceProblem ()</div>
<div class="line">    :</div>
<div class="line">    fe (1),</div>
<div class="line">    dof_handler (triangulation)</div>
<div class="line">  {}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="keywordtype">void</span> LaplaceProblem::make_grid_and_dofs ()</div>
<div class="line">  {</div>
<div class="line">    <a class="code" href="namespaceGridGenerator.html#a7149c59cefa805a132177cfa6cb953bd">GridGenerator::hyper_cube</a> (triangulation);</div>
<div class="line">    triangulation.<a class="code" href="classTriangulation.html#af99e25cc64755f18659c0fbc46c3d87d">begin_active</a> ()-&gt;face (2)-&gt;set_boundary_indicator (1);</div>
<div class="line">    triangulation.<a class="code" href="classTriangulation.html#af99e25cc64755f18659c0fbc46c3d87d">begin_active</a> ()-&gt;face (3)-&gt;set_boundary_indicator (1);</div>
<div class="line">    triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a> (5);</div>
<div class="line"></div>
<div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#afcfcc3b473f444f50d206ae62dfe3694">distribute_dofs</a> (fe);</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Number of active cells: &quot;</span></div>
<div class="line">              &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#aa21f25016ce1b9d70d2003a128985870">n_active_cells</a> ()</div>
<div class="line">              &lt;&lt; std::endl</div>
<div class="line">              &lt;&lt; <span class="stringliteral">&quot;Degrees of freedom: &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#a54e7270f2ba6206604f794114b39a2aa">n_dofs</a> ()</div>
<div class="line">              &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line">    constraints.<a class="code" href="classConstraintMatrix.html#a24120d0331183f9a63cbe41493a19f6b">clear</a> ();</div>
<div class="line">    <a class="code" href="namespaceDoFTools.html#ae23173d20bc1b6c56c6d3a4aa2cbae73">make_periodicity_constraints</a> ();</div>
<div class="line"></div>
<div class="line">    <a class="code" href="namespaceVectorTools.html#a199f38e07822b47e5b5957c21ce35d1b">VectorTools::interpolate_boundary_values</a> (dof_handler, 1,</div>
<div class="line">                                              <a class="code" href="classZeroFunction.html">ZeroFunction&lt;2&gt;</a> (),</div>
<div class="line">                                              constraints);</div>
<div class="line">    constraints.<a class="code" href="classConstraintMatrix.html#a8056d07faa2a7ed3f158c1b42d56abc8">close</a> ();</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classCompressedSparsityPattern.html">CompressedSparsityPattern</a> c_sparsity_pattern (dof_handler.<a class="code" href="classDoFHandler.html#a54e7270f2ba6206604f794114b39a2aa">n_dofs</a>(),</div>
<div class="line">                                                  dof_handler.<a class="code" href="classDoFHandler.html#a54e7270f2ba6206604f794114b39a2aa">n_dofs</a>());</div>
<div class="line">    <a class="code" href="group__constraints.html#gab627b1d4845c9526521dbd1be83469dc">DoFTools::make_sparsity_pattern</a> (dof_handler,</div>
<div class="line">                                     c_sparsity_pattern,</div>
<div class="line">                                     constraints,</div>
<div class="line">                                     <span class="keyword">false</span>);</div>
<div class="line">    c_sparsity_pattern.compress ();</div>
<div class="line">    sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a59b573e5a6c1c92fc768e36db2731cf4">copy_from</a> (c_sparsity_pattern);</div>
<div class="line"></div>
<div class="line">    system_matrix.reinit (sparsity_pattern);</div>
<div class="line">    system_rhs.<a class="code" href="classBlockVector.html#a4caa9be7a7053fd6ae9fac1da74e564b">reinit</a> (dof_handler.<a class="code" href="classDoFHandler.html#a54e7270f2ba6206604f794114b39a2aa">n_dofs</a>());</div>
<div class="line">    solution.<a class="code" href="classVector.html#ac3adfcf8cf35943558fc27ef989b7263">reinit</a> (dof_handler.<a class="code" href="classDoFHandler.html#a54e7270f2ba6206604f794114b39a2aa">n_dofs</a>());</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="keywordtype">void</span> LaplaceProblem::make_periodicity_constraints ()</div>
<div class="line">  {</div>
<div class="line">    std::map&lt;unsigned int, double&gt; dof_locations;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> (DoFHandler&lt;2&gt;::active_cell_iterator cell = dof_handler.<a class="code" href="classDoFHandler.html#a6f2aa9c61385cbb749ed3d2e7bfe3de1">begin_active</a> ();</div>
<div class="line">         cell != dof_handler.<a class="code" href="classDoFHandler.html#abf64c3734383b6fb1bed4888935f2edf">end</a> (); ++cell)</div>
<div class="line">      <span class="keywordflow">if</span> (cell-&gt;at_boundary ()</div>
<div class="line">          &amp;&amp;</div>
<div class="line">          cell-&gt;face(1)-&gt;at_boundary ())</div>
<div class="line">        {</div>
<div class="line">          dof_locations[cell-&gt;face(1)-&gt;vertex_dof_index(0, 0)]</div>
<div class="line">            = cell-&gt;face(1)-&gt;vertex(0)[1];</div>
<div class="line">          dof_locations[cell-&gt;face(1)-&gt;vertex_dof_index(1, 0)]</div>
<div class="line">            = cell-&gt;face(1)-&gt;vertex(1)[1];</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> (DoFHandler&lt;2&gt;::active_cell_iterator cell = dof_handler.<a class="code" href="classDoFHandler.html#a6f2aa9c61385cbb749ed3d2e7bfe3de1">begin_active</a> ();</div>
<div class="line">         cell != dof_handler.<a class="code" href="classDoFHandler.html#abf64c3734383b6fb1bed4888935f2edf">end</a> (); ++cell)</div>
<div class="line">      <span class="keywordflow">if</span> (cell-&gt;at_boundary ()</div>
<div class="line">          &amp;&amp;</div>
<div class="line">          cell-&gt;face (0)-&gt;at_boundary ())</div>
<div class="line">        {</div>
<div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face_vertex = 0; face_vertex&lt;2; ++face_vertex)</div>
<div class="line">            {</div>
<div class="line">              constraints.<a class="code" href="classConstraintMatrix.html#a24eb022f65797389badbb6d21da5b708">add_line</a> (cell-&gt;face(0)-&gt;vertex_dof_index (face_vertex, 0));</div>
<div class="line"></div>
<div class="line">              std::map&lt;unsigned int, double&gt;::const_iterator p = dof_locations.begin();</div>
<div class="line">              <span class="keywordflow">for</span> (; p != dof_locations.end(); ++p)</div>
<div class="line">                <span class="keywordflow">if</span> (std::fabs(p-&gt;second - cell-&gt;face(0)-&gt;vertex(face_vertex)[1]) &lt; 1e-8)</div>
<div class="line">                  {</div>
<div class="line">                    constraints.<a class="code" href="classConstraintMatrix.html#a4cd323a407cb379510a68c26e842304e">add_entry</a> (cell-&gt;face(0)-&gt;vertex_dof_index (face_vertex, 0),</div>
<div class="line">                                           p-&gt;first, 1.0);</div>
<div class="line">                    <span class="keywordflow">break</span>;</div>
<div class="line">                  }</div>
<div class="line">              <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (p != dof_locations.end(),</div>
<div class="line">                      <a class="code" href="group__Exceptions.html#ga7e124f28261be534af7e3399945c5e68">ExcMessage</a> (<span class="stringliteral">&quot;No corresponding degree of freedom was found!&quot;</span>));</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="keywordtype">void</span> LaplaceProblem::assemble_system ()</div>
<div class="line">  {</div>
<div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;2&gt;</a>  quadrature_formula(2);</div>
<div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;2&gt;</a> fe_values (fe, quadrature_formula,</div>
<div class="line">                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>   | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div>
<div class="line">                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   dofs_per_cell = fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#a4d64837b1d374e9c46f07af8f094b29b">size</a>();</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>   cell_matrix (dofs_per_cell, dofs_per_cell);</div>
<div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       cell_rhs (dofs_per_cell);</div>
<div class="line"></div>
<div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices (dofs_per_cell);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> RightHandSide right_hand_side;</div>
<div class="line"></div>
<div class="line">    DoFHandler&lt;2&gt;::active_cell_iterator cell = dof_handler.<a class="code" href="classDoFHandler.html#a6f2aa9c61385cbb749ed3d2e7bfe3de1">begin_active</a>(),</div>
<div class="line">                                        endc = dof_handler.<a class="code" href="classDoFHandler.html#abf64c3734383b6fb1bed4888935f2edf">end</a>();</div>
<div class="line">    <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div>
<div class="line">      {</div>
<div class="line">        fe_values.<a class="code" href="classFEValues.html#afde502903642c57ade24dfcebf5c1650">reinit</a> (cell);</div>
<div class="line">        cell_matrix = 0;</div>
<div class="line">        cell_rhs = 0;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point=0; q_point&lt;n_q_points; ++q_point)</div>
<div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div>
<div class="line">            {</div>
<div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div>
<div class="line">                cell_matrix(i,j) += (fe_values.<a class="code" href="classFEValuesBase.html#ac4cee7628c2903a89c5c399fddeb00a5">shape_grad</a> (i, q_point) *</div>
<div class="line">                                     fe_values.<a class="code" href="classFEValuesBase.html#ac4cee7628c2903a89c5c399fddeb00a5">shape_grad</a> (j, q_point) *</div>
<div class="line">                                     fe_values.<a class="code" href="classFEValuesBase.html#ad097580a2f71878695096cc73b271b9d">JxW</a> (q_point));</div>
<div class="line"></div>
<div class="line">              cell_rhs(i) += (fe_values.<a class="code" href="classFEValuesBase.html#abe4de48ff59778bb82a0ec13037804aa">shape_value</a> (i, q_point) *</div>
<div class="line">                              right_hand_side.value (fe_values.<a class="code" href="classFEValuesBase.html#a75b6f2cb7c735b51b20093d90b1930b0">quadrature_point</a> (q_point)) *</div>
<div class="line">                              fe_values.<a class="code" href="classFEValuesBase.html#ad097580a2f71878695096cc73b271b9d">JxW</a> (q_point));</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">        cell-&gt;get_dof_indices (local_dof_indices);</div>
<div class="line">        constraints.<a class="code" href="classConstraintMatrix.html#aa9f3612a8fc51eafa34252bb436e8ae4">distribute_local_to_global</a> (cell_matrix, cell_rhs,</div>
<div class="line">                                                local_dof_indices,</div>
<div class="line">                                                system_matrix, system_rhs);</div>
<div class="line">      }</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="keywordtype">void</span> LaplaceProblem::solve ()</div>
<div class="line">  {</div>
<div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a> solver_control (dof_handler.<a class="code" href="classDoFHandler.html#a54e7270f2ba6206604f794114b39a2aa">n_dofs</a> (), 1e-12);</div>
<div class="line">    <a class="code" href="classPreconditionSSOR.html">PreconditionSSOR&lt;SparseMatrix&lt;double&gt;</a> &gt; precondition;</div>
<div class="line"></div>
<div class="line">    precondition.<a class="code" href="classPreconditionSSOR.html#aa564d2dbcdcf09c6ceed549f319b5465">initialize</a> (system_matrix);</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;&gt;</a> cg (solver_control);</div>
<div class="line"></div>
<div class="line">    cg.solve (system_matrix, solution, system_rhs, precondition);</div>
<div class="line">    constraints.<a class="code" href="classConstraintMatrix.html#a7cf6b84c47aa32408f412ae769085bd6">distribute</a> (solution);</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="keywordtype">void</span> LaplaceProblem::output_results ()</div>
<div class="line">  {</div>
<div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;2&gt;</a> data_out;</div>
<div class="line"></div>
<div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a5e63bad650805ce93cd74c6dc3b29b11">attach_dof_handler</a> (dof_handler);</div>
<div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a59a6b70a4b909e0229a20487dd68cc43">add_data_vector</a> (solution, <span class="stringliteral">&quot;u&quot;</span>);</div>
<div class="line">    data_out.<a class="code" href="classDataOut.html#ab3d44201acb97fba286a897452236b51">build_patches</a> ();</div>
<div class="line"></div>
<div class="line">    std::ofstream output (<span class="stringliteral">&quot;solution.vtk&quot;</span>);</div>
<div class="line"></div>
<div class="line">    data_out.<a class="code" href="classDataOutInterface.html#ab43da05fc9809b3eec1436c4962f8d77">write_vtk</a> (output);</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="keywordtype">void</span> LaplaceProblem::run ()</div>
<div class="line">  {</div>
<div class="line">    make_grid_and_dofs();</div>
<div class="line">    assemble_system ();</div>
<div class="line">    solve ();</div>
<div class="line">    output_results ();</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> <a class="code" href="group__ParameterGui.html#ga0ddf1224851353fc92bfbff6f499fa97">main</a> ()</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">try</span></div>
<div class="line">    {</div>
<div class="line">      <span class="keyword">using namespace </span>dealii;</div>
<div class="line">      <span class="keyword">using namespace </span>Step45;</div>
<div class="line"></div>
<div class="line">      deallog.<a class="code" href="classLogStream.html#a8028e970ad8388596d625ed463894e98">depth_console</a> (0);</div>
<div class="line"></div>
<div class="line">      LaplaceProblem laplace_problem;</div>
<div class="line">      laplace_problem.run ();</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div>
<div class="line">    {</div>
<div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">catch</span> (...)</div>
<div class="line">    {</div>
<div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jan 27 2014 15:26:22 for The deal.II Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
