<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>The deal.II Library: Boundary description for triangulations</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="http://www.dealii.org/deal.ico"></link>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2014 by the deal.II authors"></meta>
<meta name="deal.II-version" content="8.1.0"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 8.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Boundary description for triangulations<div class="ingroups"><a class="el" href="group__grid.html">Grid classes</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Boundary description for triangulations:</div>
<div class="dyncontent">
<center><table><tr><td><div class="center"><iframe scrolling="no" frameborder="0" src="group__boundary.svg" width="299" height="56"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBoundary.html">Boundary&lt; dim, spacedim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStraightBoundary.html">StraightBoundary&lt; dim, spacedim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCylinderBoundary.html">CylinderBoundary&lt; dim, spacedim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHyperBallBoundary.html">HyperBallBoundary&lt; dim, spacedim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHalfHyperBallBoundary.html">HalfHyperBallBoundary&lt; dim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHyperShellBoundary.html">HyperShellBoundary&lt; dim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHalfHyperShellBoundary.html">HalfHyperShellBoundary&lt; dim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga0509d862f0e07071dcff837bd58fd082"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga0509d862f0e07071dcff837bd58fd082">Triangulation&lt; dim, spacedim &gt;::set_boundary</a> (const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> number, const <a class="el" href="classBoundary.html">Boundary</a>&lt; dim, spacedim &gt; &amp;boundary_object)</td></tr>
<tr class="separator:ga0509d862f0e07071dcff837bd58fd082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad20f248873a8f12785b2043a35633fdc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#gad20f248873a8f12785b2043a35633fdc">Triangulation&lt; dim, spacedim &gt;::set_boundary</a> (const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> number)</td></tr>
<tr class="separator:gad20f248873a8f12785b2043a35633fdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9fc7cf1ddf0db399d6790ba390110eb2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classBoundary.html">Boundary</a>&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga9fc7cf1ddf0db399d6790ba390110eb2">Triangulation&lt; dim, spacedim &gt;::get_boundary</a> (const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> number) const </td></tr>
<tr class="separator:ga9fc7cf1ddf0db399d6790ba390110eb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ca82f769e668f1fa559c9e381c7af2a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga4ca82f769e668f1fa559c9e381c7af2a">Triangulation&lt; dim, spacedim &gt;::get_boundary_indicators</a> () const </td></tr>
<tr class="separator:ga4ca82f769e668f1fa559c9e381c7af2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Dealing with boundary indicators</h2></td></tr>
<tr class="memitem:ga0d873908eff8fd51e88be26e51ab5f88"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga0d873908eff8fd51e88be26e51ab5f88">TriaAccessor&lt; int, int, int &gt;::set_boundary_indicator</a> (const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>) const </td></tr>
<tr class="separator:ga0d873908eff8fd51e88be26e51ab5f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6a1193fe49dddcf65e927641fbc375b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#gac6a1193fe49dddcf65e927641fbc375b">TriaAccessor&lt; int, int, int &gt;::set_all_boundary_indicators</a> (const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>) const </td></tr>
<tr class="separator:gac6a1193fe49dddcf65e927641fbc375b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Dealing with boundary indicators</h2></td></tr>
<tr class="memitem:ga1a911a4d1b005970973d5e90b6e06005"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga1a911a4d1b005970973d5e90b6e06005">TriaAccessor&lt; 0, 1, spacedim &gt;::set_boundary_indicator</a> (const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>)</td></tr>
<tr class="separator:ga1a911a4d1b005970973d5e90b6e06005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52dcdf6f0bcfd867f8e048ad0c9728e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga52dcdf6f0bcfd867f8e048ad0c9728e4">TriaAccessor&lt; 0, 1, spacedim &gt;::set_all_boundary_indicators</a> (const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>)</td></tr>
<tr class="separator:ga52dcdf6f0bcfd867f8e048ad0c9728e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The classes in this module are concerned with the description of the boundary of a domain in which a <a class="el" href="classTriangulation.html">Triangulation</a> lives. This boundary description is necessary in three contexts: </p>
<ul>
<li>
<p class="startli">Mesh refinement: Whenever a cell at the boundary is refined, it is necessary to introduce at least one new vertex on the boundary. In the simplest case, one assumes that the boundary consists of straight line segments (in 2d) or a bilinear surface (in 3d) between the vertices of the original, coarsest mesh, and the next vertex is simply put into the middle of the old ones. This is the default behavior of the <a class="el" href="classTriangulation.html">Triangulation</a> class, and is described by the <a class="el" href="classStraightBoundary.html">StraightBoundary</a> class.</p>
<p>On the other hand, if one deals with curved boundaries, this is not the appropriate thing to do. The classes derived from the <a class="el" href="classBoundary.html">Boundary</a> base class therefore describe the geometry of a domain. One can then attach an object of a class derived from this base class to the <a class="el" href="classTriangulation.html">Triangulation</a> object using the <a class="el" href="group__boundary.html#ga0509d862f0e07071dcff837bd58fd082">Triangulation::set_boundary()</a> function, and the <a class="el" href="classTriangulation.html">Triangulation</a> will ask the boundary object where a new vertex should be located upon mesh refinement. Several classes already exist to support the most common geometries, e.g., <a class="el" href="classCylinderBoundary.html">CylinderBoundary</a>, <a class="el" href="classHyperBallBoundary.html">HyperBallBoundary</a>, or <a class="el" href="classHyperShellBoundary.html">HyperShellBoundary</a>.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Integration: When using higher order finite element methods, it is often necessary to compute cell terms (like cell contributions to the matrix and right hand side of the linear system) using curved approximations of the boundary, rather than the straight line approximation. The actual implementation of such curved elements happens in the <a class="el" href="classMapping.html">Mapping</a> class (see the <a class="el" href="group__mapping.html">Mappings between reference and real cell</a> module), which however obtains its information about the boundary of the domain from the classes described here. The same is, of course, true when integrating boundary terms (e.g., inhomogenous Neumann boundary conditions).</p>
<p class="endli"></p>
</li>
<li>
In cases where a <a class="el" href="classTriangulation.html">Triangulation</a> is embedded into a higher dimensional space, i.e., whenever the second template argument of the <a class="el" href="classTriangulation.html">Triangulation</a> class is explicitly specified and larger than the first (for an example, see <a class="el" href="step_34.html">step-34</a>), the boundary description objects also serve as a tool to describe the geometry not only of the boundary of the domain but of the domain itself, in case the domain is a manifold that is in fact curved. </li>
</ul>
<p>In the context of triangulations, each face of a cell that is located at the boundary of the domain stores a number called <code>boundary_id</code> that uniquely identifies which part of the boundary this face is on. If nothing is specified at creation time, each boundary face has a zero boundary id. On the other hand, the boundary id of faces can be set either at creation time or later by looping over all cells and querying their faces.</p>
<p>It is then possible to associate objects describing the boundary to certain boundary_id values used in a triangulation. Note that this is not necessary: in some cases one may want to use the default straight boundary approximation, and use non-zero boundary indicators for completely different purposes, for example to indicate that a part of the boundary has a different kind of boundary condition in the partial differential equation.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a></dd></dl>
<dl class="section author"><dt>Author</dt><dd>Wolfgang Bangerth, 1998-2006 </dd></dl>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga0509d862f0e07071dcff837bd58fd082"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::set_boundary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBoundary.html">Boundary</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If <code>dim==spacedim</code>, assign a boundary object to a certain part of the boundary of a the triangulation. If a face with boundary number <code>number</code> is refined, this object is used to find the location of new vertices on the boundary (see the results section of <a class="el" href="step_49.html">step-49</a> for a more in-depth discussion of this, with examples). It is also used for non-linear (i.e.: non-Q1) transformations of cells to the unit cell in shape function calculations.</p>
<p>If <code>dim!=spacedim</code> the boundary object is in fact the exact manifold that the triangulation is approximating (for example a circle approximated by a polygon triangulation). As above, the refinement is made in such a way that the new points are located on the exact manifold.</p>
<p>Numbers of boundary objects correspond to material numbers of faces at the boundary, for instance the material id in a UCD input file. They are not necessarily consecutive but must be in the range 0-(<a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>-1). Material IDs on boundaries are also called boundary indicators and are accessed with accessor functions of that name.</p>
<p>The <code>boundary_object</code> is not copied and MUST persist until the triangulation is destroyed. This is also true for triangulations generated from this one by <code>copy_triangulation</code>.</p>
<p>It is possible to remove or replace the boundary object during the lifetime of a non-empty triangulation. Usually, this is done before the first refinement and is dangerous afterwards. Removal of a boundary object is done by <code>set_boundary(number)</code>, i.e. the function of same name but only one argument. This operation then replaces the boundary object given before by a straight boundary approximation.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gad20f248873a8f12785b2043a35633fdc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::set_boundary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>number</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reset those parts of the boundary with the given number to use a straight boundary approximation. This is the default state of a triangulation, and undoes assignment of a different boundary object by the function of same name and two arguments.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga9fc7cf1ddf0db399d6790ba390110eb2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classBoundary.html">Boundary</a>&lt;dim,spacedim&gt;&amp; <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::get_boundary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>number</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a constant reference to a boundary object used for this triangulation. Number is the same as in <code>set_boundary</code> </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga4ca82f769e668f1fa559c9e381c7af2a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>&gt; <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::get_boundary_indicators </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a vector containing all boundary indicators assigned to boundary faces of this <a class="el" href="classTriangulation.html">Triangulation</a> object. Note, that each boundary indicator is reported only once. The size of the return vector will represent the number of different indicators (which is greater or equal one).</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga0d873908eff8fd51e88be26e51ab5f88"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::set_boundary_indicator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>boundary_ind</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the boundary indicator. The same applies as for the <code><a class="el" href="classTriaAccessor.html#a675e7545c66f35f80fdc113cdcf1a632">boundary_indicator()</a></code> function.</p>
<p>Note that it only sets the boundary object of the current object itself, not the indicators of the ones that bound it. For example, in 3d, if this function is called on a face, then the boundary indicator of the 4 edges that bound the face remain unchanged. If you want to set the boundary indicators of face and edges at the same time, use the <a class="el" href="group__boundary.html#gac6a1193fe49dddcf65e927641fbc375b">set_all_boundary_indicators()</a> function. You can see the result of not using the correct function in the results section of <a class="el" href="step_49.html">step-49</a>.</p>
<dl class="section warning"><dt>Warning</dt><dd>You should never set the boundary indicator of an interior face (a face not at the boundary of the domain), or set set the boundary indicator of an exterior face to <a class="el" href="namespacenumbers.html#a4e5d3fa25689151c833ba46dcc96fa5b">numbers::internal_face_boundary_id</a> (this value is reserved for another purpose). <a class="el" href="namespaceAlgorithms.html">Algorithms</a> may not work or produce very confusing results if boundary cells have a boundary indicator of <a class="el" href="namespacenumbers.html#a4e5d3fa25689151c833ba46dcc96fa5b">numbers::internal_face_boundary_id</a> or if interior cells have boundary indicators other than <a class="el" href="namespacenumbers.html#a4e5d3fa25689151c833ba46dcc96fa5b">numbers::internal_face_boundary_id</a>. Unfortunately, the current object has no means of finding out whether it really is at the boundary of the domain and so cannot determine whether the value you are trying to set makes sense under the current circumstances.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a> </dd></dl>

<p>Definition at line <a class="el" href="tria__accessor_8templates_8h_source.html#l01889">1889</a> of file <a class="el" href="tria__accessor_8templates_8h_source.html">tria_accessor.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="gac6a1193fe49dddcf65e927641fbc375b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::set_all_boundary_indicators </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>boundary_ind</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Do as <a class="el" href="group__boundary.html#ga0d873908eff8fd51e88be26e51ab5f88">set_boundary_indicator()</a> but also set the boundary indicators of the objects that bound the current object. For example, in 3d, if <a class="el" href="group__boundary.html#ga0d873908eff8fd51e88be26e51ab5f88">set_boundary_indicator()</a> is called on a face, then the boundary indicator of the 4 edges that bound the face remain unchanged. In contrast, if you call the current function, the boundary indicators of face and edges are all set to the given value.</p>
<p>This function is useful if you set boundary indicators of faces in 3d (in 2d, the function does the same as <a class="el" href="group__boundary.html#ga0d873908eff8fd51e88be26e51ab5f88">set_boundary_indicator()</a>) and you do so because you want a curved boundary object to represent the part of the boundary that corresponds to the current face. In that case, the <a class="el" href="classTriangulation.html">Triangulation</a> class needs to figure out where to put new vertices upon mesh refinement, and higher order <a class="el" href="classMapping.html">Mapping</a> objects also need to figure out where new interpolation points for a curved boundary approximation should be. In either case, the two classes first determine where interpolation points on the edges of a boundary face should be, asking the boundary object, before asking the boundary object for the interpolation points corresponding to the interior of the boundary face. For this to work properly, it is not sufficient to have set the boundary indicator for the face alone, but you also need to set the boundary indicators of the edges that bound the face. This function does all of this at once. You can see the result of not using the correct function in the results section of <a class="el" href="step_49.html">step-49</a>.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a> </dd></dl>

<p>Definition at line <a class="el" href="tria__accessor_8templates_8h_source.html#l01902">1902</a> of file <a class="el" href="tria__accessor_8templates_8h_source.html">tria_accessor.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga1a911a4d1b005970973d5e90b6e06005"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; 0, 1, spacedim &gt;::set_boundary_indicator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the boundary indicator. The same applies as for the <code><a class="el" href="classTriaAccessor_3_010_00_011_00_01spacedim_01_4.html#ac15c20fe7ef5370a738f4acf54e8468e">boundary_indicator()</a></code> function.</p>
<dl class="section warning"><dt>Warning</dt><dd>You should never set the boundary indicator of an interior face (a face not at the boundary of the domain), or set set the boundary indicator of an exterior face to <a class="el" href="namespacenumbers.html#a4e5d3fa25689151c833ba46dcc96fa5b">numbers::internal_face_boundary_id</a> (this value is reserved for another purpose). <a class="el" href="namespaceAlgorithms.html">Algorithms</a> may not work or produce very confusing results if boundary cells have a boundary indicator of <a class="el" href="namespacenumbers.html#a4e5d3fa25689151c833ba46dcc96fa5b">numbers::internal_face_boundary_id</a> or if interior cells have boundary indicators other than <a class="el" href="namespacenumbers.html#a4e5d3fa25689151c833ba46dcc96fa5b">numbers::internal_face_boundary_id</a>. Unfortunately, the current object has no means of finding out whether it really is at the boundary of the domain and so cannot determine whether the value you are trying to set makes sense under the current circumstances.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a> </dd></dl>

<p>Definition at line <a class="el" href="tria__accessor_8templates_8h_source.html#l02436">2436</a> of file <a class="el" href="tria__accessor_8templates_8h_source.html">tria_accessor.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga52dcdf6f0bcfd867f8e048ad0c9728e4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; 0, 1, spacedim &gt;::set_all_boundary_indicators </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Since this object only represents a single vertex, call set_boundary_indicator with the same argument.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a> </dd></dl>

<p>Definition at line <a class="el" href="tria__accessor_8templates_8h_source.html#l02449">2449</a> of file <a class="el" href="tria__accessor_8templates_8h_source.html">tria_accessor.templates.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jan 27 2014 15:27:14 for The deal.II Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
