<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>The deal.II Library: Constraints on degrees of freedom</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="http://www.dealii.org/deal.ico"></link>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2014 by the deal.II authors"></meta>
<meta name="deal.II-version" content="8.1.0"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 8.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Constraints on degrees of freedom<div class="ingroups"><a class="el" href="group__dofs.html">Degrees of Freedom</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Constraints on degrees of freedom:</div>
<div class="dyncontent">
<center><table><tr><td><div class="center"><iframe scrolling="no" frameborder="0" src="group__constraints.svg" width="456" height="56"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga2a8572710e0cbec24e8497dd79e15a87"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, template&lt; int, int &gt; class DH&gt; </td></tr>
<tr class="memitem:ga2a8572710e0cbec24e8497dd79e15a87"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga2a8572710e0cbec24e8497dd79e15a87">DoFTools::make_zero_boundary_constraints</a> (const DH&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> boundary_indicator, <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;zero_boundary_constraints, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:ga2a8572710e0cbec24e8497dd79e15a87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e92f453a12cc02226a476ffdac6af3a"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, template&lt; int, int &gt; class DH&gt; </td></tr>
<tr class="memitem:ga0e92f453a12cc02226a476ffdac6af3a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga0e92f453a12cc02226a476ffdac6af3a">DoFTools::make_zero_boundary_constraints</a> (const DH&lt; dim, spacedim &gt; &amp;dof, <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;zero_boundary_constraints, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:ga0e92f453a12cc02226a476ffdac6af3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Sparsity Pattern Generation</h2></td></tr>
<tr class="memitem:gab627b1d4845c9526521dbd1be83469dc"><td class="memTemplParams" colspan="2">template&lt;class DH , class SparsityPattern &gt; </td></tr>
<tr class="memitem:gab627b1d4845c9526521dbd1be83469dc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#gab627b1d4845c9526521dbd1be83469dc">DoFTools::make_sparsity_pattern</a> (const DH &amp;dof, <a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;sparsity_pattern, const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints=<a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a>(), const <a class="el" href="classbool.html">bool</a> keep_constrained_dofs=true, const <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a> subdomain_id=<a class="el" href="namespacenumbers.html#a6fe5acece133d890bee8cc49ccd8ebfb">numbers::invalid_subdomain_id</a>)</td></tr>
<tr class="separator:gab627b1d4845c9526521dbd1be83469dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga250c261f4dba6c77834b2fa8d3bf7f5c"><td class="memTemplParams" colspan="2">template&lt;class DH , class SparsityPattern &gt; </td></tr>
<tr class="memitem:ga250c261f4dba6c77834b2fa8d3bf7f5c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga250c261f4dba6c77834b2fa8d3bf7f5c">DoFTools::make_sparsity_pattern</a> (const DH &amp;dof, const <a class="el" href="classTable.html">Table</a>&lt; 2, Coupling &gt; &amp;coupling, <a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;sparsity_pattern, const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints=<a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a>(), const <a class="el" href="classbool.html">bool</a> keep_constrained_dofs=true, const <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a> subdomain_id=<a class="el" href="namespacenumbers.html#a6fe5acece133d890bee8cc49ccd8ebfb">numbers::invalid_subdomain_id</a>)</td></tr>
<tr class="separator:ga250c261f4dba6c77834b2fa8d3bf7f5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7e3920b3d248d53e65997d8bce110a2"><td class="memTemplParams" colspan="2">template&lt;class DH , class SparsityPattern &gt; </td></tr>
<tr class="memitem:gaf7e3920b3d248d53e65997d8bce110a2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#gaf7e3920b3d248d53e65997d8bce110a2">DoFTools::make_flux_sparsity_pattern</a> (const DH &amp;dof_handler, <a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;sparsity_pattern, const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints, const <a class="el" href="classbool.html">bool</a> keep_constrained_dofs=true, const <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a> subdomain_id=<a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>)</td></tr>
<tr class="separator:gaf7e3920b3d248d53e65997d8bce110a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9fe6189e8235d2fcaa0b6e4f5c249620"><td class="memTemplParams" colspan="2">template&lt;class DH , class SparsityPattern &gt; </td></tr>
<tr class="memitem:ga9fe6189e8235d2fcaa0b6e4f5c249620"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga9fe6189e8235d2fcaa0b6e4f5c249620">DoFTools::make_sparsity_pattern</a> (const DH &amp;dof, const std::vector&lt; std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &gt; &amp;mask, <a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;sparsity_pattern) <a class="el" href="group__Sparsity.html#ga0849dabf81f46d4d964e251c286784dd">DEAL_II_DEPRECATED</a></td></tr>
<tr class="separator:ga9fe6189e8235d2fcaa0b6e4f5c249620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3473fa2eb6d555499a53d1f59600beff"><td class="memTemplParams" colspan="2">template&lt;class DH , class SparsityPattern &gt; </td></tr>
<tr class="memitem:ga3473fa2eb6d555499a53d1f59600beff"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga3473fa2eb6d555499a53d1f59600beff">DoFTools::make_sparsity_pattern</a> (const DH &amp;dof_row, const DH &amp;dof_col, <a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;sparsity)</td></tr>
<tr class="separator:ga3473fa2eb6d555499a53d1f59600beff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60b493fa4c36d86a15c8599eef8c0e32"><td class="memTemplParams" colspan="2">template&lt;class DH , class SparsityPattern &gt; </td></tr>
<tr class="memitem:ga60b493fa4c36d86a15c8599eef8c0e32"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga60b493fa4c36d86a15c8599eef8c0e32">DoFTools::make_boundary_sparsity_pattern</a> (const DH &amp;dof, const std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;dof_to_boundary_mapping, <a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;sparsity_pattern)</td></tr>
<tr class="separator:ga60b493fa4c36d86a15c8599eef8c0e32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0f7a1d36c8b92a17bf8c4d939d56fb1"><td class="memTemplParams" colspan="2">template&lt;class DH , class SparsityPattern &gt; </td></tr>
<tr class="memitem:gae0f7a1d36c8b92a17bf8c4d939d56fb1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#gae0f7a1d36c8b92a17bf8c4d939d56fb1">DoFTools::make_boundary_sparsity_pattern</a> (const DH &amp;dof, const typename <a class="el" href="structFunctionMap.html">FunctionMap</a>&lt; DH::space_dimension &gt;::type &amp;boundary_indicators, const std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;dof_to_boundary_mapping, <a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;sparsity)</td></tr>
<tr class="separator:gae0f7a1d36c8b92a17bf8c4d939d56fb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c77cf114c08113c66eb68904dab7f02"><td class="memTemplParams" colspan="2">template&lt;class DH , class SparsityPattern &gt; </td></tr>
<tr class="memitem:ga3c77cf114c08113c66eb68904dab7f02"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga3c77cf114c08113c66eb68904dab7f02">DoFTools::make_flux_sparsity_pattern</a> (const DH &amp;dof_handler, <a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;sparsity_pattern)</td></tr>
<tr class="separator:ga3c77cf114c08113c66eb68904dab7f02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3fda57552521d870cc7737b1fde71014"><td class="memTemplParams" colspan="2">template&lt;class DH , class SparsityPattern &gt; </td></tr>
<tr class="memitem:ga3fda57552521d870cc7737b1fde71014"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga3fda57552521d870cc7737b1fde71014">DoFTools::make_flux_sparsity_pattern</a> (const DH &amp;dof, <a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;sparsity, const <a class="el" href="classTable.html">Table</a>&lt; 2, Coupling &gt; &amp;int_mask, const <a class="el" href="classTable.html">Table</a>&lt; 2, Coupling &gt; &amp;flux_mask)</td></tr>
<tr class="separator:ga3fda57552521d870cc7737b1fde71014"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Hanging Nodes</h2></td></tr>
<tr class="memitem:gabe9d21d4bb33ce556a6e6e80c2bf4b41"><td class="memTemplParams" colspan="2">template&lt;class DH &gt; </td></tr>
<tr class="memitem:gabe9d21d4bb33ce556a6e6e80c2bf4b41"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#gabe9d21d4bb33ce556a6e6e80c2bf4b41">DoFTools::make_hanging_node_constraints</a> (const DH &amp;dof_handler, <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints)</td></tr>
<tr class="separator:gabe9d21d4bb33ce556a6e6e80c2bf4b41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86bd4cc354a5278005202d57257c178c"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ga86bd4cc354a5278005202d57257c178c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga86bd4cc354a5278005202d57257c178c">DoFTools::extract_hanging_node_dofs</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;selected_dofs)</td></tr>
<tr class="separator:ga86bd4cc354a5278005202d57257c178c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Interpolation and projection</h2></td></tr>
<tr class="memitem:ga7f3e96634dbdd78c9a5b0674af496559"><td class="memTemplParams" colspan="2">template&lt;class DH &gt; </td></tr>
<tr class="memitem:ga7f3e96634dbdd78c9a5b0674af496559"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga7f3e96634dbdd78c9a5b0674af496559">VectorTools::interpolate_boundary_values</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; DH::dimension, DH::space_dimension &gt; &amp;mapping, const DH &amp;dof, const typename <a class="el" href="structFunctionMap.html">FunctionMap</a>&lt; DH::space_dimension &gt;::type &amp;function_map, <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask_)</td></tr>
<tr class="separator:ga7f3e96634dbdd78c9a5b0674af496559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22711fb5e71f2ae7c8b117209b4af397"><td class="memTemplParams" colspan="2">template&lt;class DH &gt; </td></tr>
<tr class="memitem:ga22711fb5e71f2ae7c8b117209b4af397"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga22711fb5e71f2ae7c8b117209b4af397">VectorTools::interpolate_boundary_values</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; DH::dimension, DH::space_dimension &gt; &amp;mapping, const DH &amp;dof, const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> boundary_component, const <a class="el" href="classFunction.html">Function</a>&lt; DH::space_dimension &gt; &amp;boundary_function, <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask)</td></tr>
<tr class="separator:ga22711fb5e71f2ae7c8b117209b4af397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2b32c11445e5d5fec898781dddaaf80"><td class="memTemplParams" colspan="2">template&lt;class DH &gt; </td></tr>
<tr class="memitem:gaf2b32c11445e5d5fec898781dddaaf80"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#gaf2b32c11445e5d5fec898781dddaaf80">VectorTools::interpolate_boundary_values</a> (const DH &amp;dof, const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> boundary_component, const <a class="el" href="classFunction.html">Function</a>&lt; DH::space_dimension &gt; &amp;boundary_function, <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask)</td></tr>
<tr class="separator:gaf2b32c11445e5d5fec898781dddaaf80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga765f05b664f0f3f3090d6526f9384430"><td class="memTemplParams" colspan="2">template&lt;class DH &gt; </td></tr>
<tr class="memitem:ga765f05b664f0f3f3090d6526f9384430"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga765f05b664f0f3f3090d6526f9384430">VectorTools::interpolate_boundary_values</a> (const DH &amp;dof, const typename <a class="el" href="structFunctionMap.html">FunctionMap</a>&lt; DH::space_dimension &gt;::type &amp;function_map, <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask)</td></tr>
<tr class="separator:ga765f05b664f0f3f3090d6526f9384430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe6c2a3531280b809c791c4e90f984d8"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:gabe6c2a3531280b809c791c4e90f984d8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#gabe6c2a3531280b809c791c4e90f984d8">VectorTools::project_boundary_values</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const typename <a class="el" href="structFunctionMap.html">FunctionMap</a>&lt; spacedim &gt;::type &amp;boundary_functions, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt; &amp;q, <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints, std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; component_mapping)</td></tr>
<tr class="separator:gabe6c2a3531280b809c791c4e90f984d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga587d0c6d8f1632fb757cf16594f527d0"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ga587d0c6d8f1632fb757cf16594f527d0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga587d0c6d8f1632fb757cf16594f527d0">VectorTools::project_boundary_values</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const typename <a class="el" href="structFunctionMap.html">FunctionMap</a>&lt; spacedim &gt;::type &amp;boundary_functions, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt; &amp;q, <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints, std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; component_mapping)</td></tr>
<tr class="separator:ga587d0c6d8f1632fb757cf16594f527d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed484d7530047b55d6f7a04d41347a4e"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:gaed484d7530047b55d6f7a04d41347a4e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#gaed484d7530047b55d6f7a04d41347a4e">VectorTools::project_boundary_values_curl_conforming</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; &amp;dof_handler, const unsigned <a class="el" href="classint.html">int</a> first_vector_component, const <a class="el" href="classFunction.html">Function</a>&lt; dim &gt; &amp;boundary_function, const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> boundary_component, <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim &gt; &amp;mapping)</td></tr>
<tr class="separator:gaed484d7530047b55d6f7a04d41347a4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31b221caf4d1f4835a833ac3f578378f"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:ga31b221caf4d1f4835a833ac3f578378f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga31b221caf4d1f4835a833ac3f578378f">VectorTools::project_boundary_values_curl_conforming</a> (const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim &gt; &amp;dof_handler, const unsigned <a class="el" href="classint.html">int</a> first_vector_component, const <a class="el" href="classFunction.html">Function</a>&lt; dim &gt; &amp;boundary_function, const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> boundary_component, <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints, const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, dim &gt; &amp;mapping_collection=<a class="el" href="structhp_1_1StaticMappingQ1.html">hp::StaticMappingQ1</a>&lt; dim &gt;::mapping_collection)</td></tr>
<tr class="separator:ga31b221caf4d1f4835a833ac3f578378f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a13fe1b8306a0a6f1fed5009a5f99ab"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:ga8a13fe1b8306a0a6f1fed5009a5f99ab"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga8a13fe1b8306a0a6f1fed5009a5f99ab">VectorTools::project_boundary_values_div_conforming</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; &amp;dof_handler, const unsigned <a class="el" href="classint.html">int</a> first_vector_component, const <a class="el" href="classFunction.html">Function</a>&lt; dim &gt; &amp;boundary_function, const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> boundary_component, <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim &gt; &amp;mapping)</td></tr>
<tr class="separator:ga8a13fe1b8306a0a6f1fed5009a5f99ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4b3a415d08d0bc2b52308ff9eaa79eb"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:gaa4b3a415d08d0bc2b52308ff9eaa79eb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#gaa4b3a415d08d0bc2b52308ff9eaa79eb">VectorTools::project_boundary_values_div_conforming</a> (const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim &gt; &amp;dof_handler, const unsigned <a class="el" href="classint.html">int</a> first_vector_component, const <a class="el" href="classFunction.html">Function</a>&lt; dim &gt; &amp;boundary_function, const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> boundary_component, <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints, const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, dim &gt; &amp;mapping_collection)</td></tr>
<tr class="separator:gaa4b3a415d08d0bc2b52308ff9eaa79eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac705b8be8d8abc9ec2f3d6ca17f2ed20"><td class="memTemplParams" colspan="2">template&lt;int dim, template&lt; int, int &gt; class DH, int spacedim&gt; </td></tr>
<tr class="memitem:gac705b8be8d8abc9ec2f3d6ca17f2ed20"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#gac705b8be8d8abc9ec2f3d6ca17f2ed20">VectorTools::compute_no_normal_flux_constraints</a> (const DH&lt; dim, spacedim &gt; &amp;dof_handler, const unsigned <a class="el" href="classint.html">int</a> first_vector_component, const std::set&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> &gt; &amp;boundary_ids, <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping)</td></tr>
<tr class="separator:gac705b8be8d8abc9ec2f3d6ca17f2ed20"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This module deals with constraints on degrees of freedom. The central class to deal with constraints is the <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> class.</p>
<p>Constraints typically come from several sources, for example:</p>
<ul>
<li>If you have Dirichlet-type boundary conditions, <img class="formulaInl" alt="$u|_{\partial\Omega}=g$" src="form_2.png"/>, one usually enforces them by requiring that degrees of freedom on the boundary have particular values, for example <img class="formulaInl" alt="$x_{12}=42$" src="form_3.png"/> if the boundary condition <img class="formulaInl" alt="$g(\mathbf x)$" src="form_4.png"/> requires that the finite element solution <img class="formulaInl" alt="$u(\mathbf x)$" src="form_5.png"/> at the location of degree of freedom 12 has the value 42. Such constraints are generated by those versions of the <a class="el" href="namespaceVectorTools.html#a199f38e07822b47e5b5957c21ce35d1b">VectorTools::interpolate_boundary_values</a> function that take a <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> argument (though there are also other ways of dealing with Dirichlet conditions, using <a class="el" href="namespaceMatrixTools.html#a41a069894610445f84840d712d4f891e">MatrixTools::apply_boundary_values</a>, see for example <a class="el" href="step_3.html">step-3</a> and <a class="el" href="step_4.html">step-4</a>).</li>
<li>If you have boundary conditions that set a certain part of the solution's value, for example no normal flux, <img class="formulaInl" alt="$\mathbf n \cdot \mathbf u=0$" src="form_6.png"/> (as happens in flow problems and is handled by the <a class="el" href="group__constraints.html#gac705b8be8d8abc9ec2f3d6ca17f2ed20">VectorTools::compute_no_normal_flux_constraints</a> function) or prescribed tangential components, <img class="formulaInl" alt="$\vec{n}\times\vec{u}= \vec{n}\times\vec{f}$" src="form_7.png"/> (as happens in electromagnetic problems and is handled by the <a class="el" href="group__constraints.html#gaed484d7530047b55d6f7a04d41347a4e">VectorTools::project_boundary_values_curl_conforming</a> function). For the former case, imagine for example that we are at at vertex where the normal vector has the form <img class="formulaInl" alt="$\frac 1{\sqrt{14}} (1,2,3)^T$" src="form_8.png"/> and that the <img class="formulaInl" alt="$x$" src="form_9.png"/>-, <img class="formulaInl" alt="$y$" src="form_10.png"/>- and <img class="formulaInl" alt="$z$" src="form_11.png"/>-components of the flow field at this vertex are associated with degrees of freedom 12, 28, and 40. Then the no-normal-flux condition means that we need to have the condition <img class="formulaInl" alt="$\frac 1{\sqrt{14}} (x_{12}+2x_{28}+3x_{40})=0$" src="form_12.png"/>. The prescribed tangential component leads to similar constraints though there is often something on the right hand side.</li>
<li>If you have hanging node constraints, for example in a mesh like this: <div class="image">
<img src="hanging_nodes.png" alt="hanging_nodes.png"/>
</div>
 Let's assume the bottom right one of the two red degrees of freedom is <img class="formulaInl" alt="$x_{12}$" src="form_13.png"/> and that the two yellow neighbors on its left and right are <img class="formulaInl" alt="$x_{28}$" src="form_14.png"/> and <img class="formulaInl" alt="$x_{40}$" src="form_15.png"/>. Then, requiring that the finite element function be continuous is equivalent to requiring that <img class="formulaInl" alt="$x_{12}= \frac 12 (x_{28}+x_{40})$" src="form_16.png"/>. A similar situation occurs in the context of hp adaptive finite element methods. For example, when using Q1 and Q2 elements (i.e. using <a class="el" href="classFE__Q.html">FE_Q(1)</a> and <a class="el" href="classFE__Q.html">FE_Q(2)</a>) on the two marked cells of the mesh <div class="image">
<img src="hp-refinement-simple.png" alt="hp-refinement-simple.png"/>
</div>
 there are three constraints: first <img class="formulaInl" alt="$x_2=\frac 12 x_0 + \frac 12 x_1$" src="form_17.png"/>, then <img class="formulaInl" alt="$x_4=\frac 14 x_0 + \frac 34 x_1$" src="form_18.png"/>, and finally the identity <img class="formulaInl" alt="$x_3=x_1$" src="form_19.png"/>. Similar constraints occur as hanging nodes even if all cells used the same finite elements. In all of these cases, you would use the <a class="el" href="group__constraints.html#gabe9d21d4bb33ce556a6e6e80c2bf4b41">DoFTools::make_hanging_node_constraints</a> function to compute such constraints.</li>
<li>Other linear constraints, for example when you try to impose a certain average value for a problem that would otherwise not have a unique solution. An example of this is given in the <a class="el" href="step_11.html">step-11</a> tutorial program.</li>
</ul>
<p>In all of these examples, constraints on degrees of freedom are linear and possibly inhomogeneous. In other words, the always have the form <img class="formulaInl" alt="$x_{i_1} = \sum_{j=2}^M a_{i_j} x_{i_j} + b_i$" src="form_20.png"/>. The deal.II class that deals with storing and using these constraints is <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a>. The naming stems from the fact that the class originally only stored the (sparse) matrix <img class="formulaInl" alt="$a_{i_j}$" src="form_21.png"/>. The class name component "matrix" no longer makes much sense today since the class has learned to also deal with inhomogeneities <img class="formulaInl" alt="$b_i$" src="form_22.png"/>.</p>
<h3>Eliminating constraints</h3>
<p>When building the global system matrix and the right hand sides, one can build them without taking care of the constraints, i.e. by simply looping over cells and adding the local contributions to the global matrix and right hand side objects. In order to do actual calculations, you have to 'condense' the linear system: eliminate constrained degrees of freedom and distribute the appropriate values to the unconstrained dofs. This changes the sparsity pattern of the sparse matrices used in finite element calculations and is thus a quite expensive operation. The general scheme of things is then that you build your system, you eliminate (condense) away constrained nodes using the <a class="el" href="classConstraintMatrix.html#a66337316e8fbbc786c9f0383d085ab01">ConstraintMatrix::condense()</a> functions, then you solve the remaining system, and finally you compute the values of constrained nodes from the values of the unconstrained ones using the <a class="el" href="classConstraintMatrix.html#a7cf6b84c47aa32408f412ae769085bd6">ConstraintMatrix::distribute()</a> function. Note that the <a class="el" href="classConstraintMatrix.html#a66337316e8fbbc786c9f0383d085ab01">ConstraintMatrix::condense()</a> function is applied to matrix and right hand side of the linear system, while the <a class="el" href="classConstraintMatrix.html#a7cf6b84c47aa32408f412ae769085bd6">ConstraintMatrix::distribute()</a> function is applied to the solution vector. This is the method used in the first few tutorial programs, see for example <a class="el" href="step_6.html">step-6</a>.</p>
<p>This scheme of first building a linear system and then eliminating constrained degrees of freedom is inefficient, and a bottleneck if there are many constraints and matrices are full, i.e. especially for 3d and/or higher order or hp finite elements. Furthermore, it is impossible to implement for parallel computations where a process may not have access to elements of the matrix. We therefore offer a second way of building linear systems, using the <a class="el" href="classConstraintMatrix.html#a646ac6aabbc957e439971b8a14d0add8">ConstraintMatrix::add_entries_local_to_global()</a> and <a class="el" href="classConstraintMatrix.html#aa9f3612a8fc51eafa34252bb436e8ae4">ConstraintMatrix::distribute_local_to_global()</a> functions discussed below. The resulting linear systems are equivalent to those one gets after calling the <a class="el" href="classConstraintMatrix.html#a66337316e8fbbc786c9f0383d085ab01">ConstraintMatrix::condense()</a> functions.</p>
<dl class="section note"><dt>Note</dt><dd>Both ways of applying constraints set the value of the matrix diagonals to constrained entries to a <em>positive</em> entry of the same magnitude as the other entries in the matrix. As a consequence, you need to set up your problem such that the weak form describing the main matrix contribution is not <em>negative definite</em>. Otherwise, iterative solvers such as CG will break down or be considerably slower as GMRES.</dd>
<dd>
While these two ways are <em>equivalent</em>, i.e., the solution of linear systems computed via either approach is the same, the linear systems themselves do not necessarily have the same matrix and right hand side vector entries. Specifically, the matrix diagonal and right hand side entries corresponding to constrained degrees of freedom may be different as a result of the way in which we compute them; they are, however, always chosen in such a way that the solution to the linear system is the same.</dd></dl>
<h4>Condensing matrices and sparsity patterns</h4>
<p>As mentioned above, the first way of using constraints is to build linear systems without regards to constraints and then "condensing" them away. Condensation of a matrix is done in four steps:</p>
<ul>
<li>first one builds the sparsity pattern (e.g. using <a class="el" href="group__constraints.html#gab627b1d4845c9526521dbd1be83469dc">DoFTools::make_sparsity_pattern()</a>);</li>
<li>then the sparsity pattern of the condensed matrix is made out of the original sparsity pattern and the constraints;</li>
<li>third, the global matrix is assembled;</li>
<li>and fourth, the matrix is finally condensed.</li>
</ul>
<p>To do these steps, you have (at least) two possibilities:</p>
<ul>
<li>
<p class="startli">Use two different sparsity patterns and two different matrices: you may eliminate the rows and columns associated with a constrained degree of freedom, and create a totally new sparsity pattern and a new system matrix. This has the advantage that the resulting system of equations is smaller and free from artifacts of the condensation process and is therefore faster in the solution process since no unnecessary multiplications occur (see below). However, there are two major drawbacks: keeping two matrices at the same time can be quite unacceptable if you're short of memory. Secondly, the condensation process is expensive, since <em>all</em> entries of the matrix have to be copied, not only those which are subject to constraints.</p>
<p>This procedure is therefore not advocated and not discussed in the <a class="el" href="Tutorial.html">Tutorial programs</a>. deal.II used to have functions that could perform these shrinking operations, but for the reasons outlined above they were inefficient, rarely used and consequently removed in version 8.0.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Use only one sparsity pattern and one matrix: doing it this way, the condense functions add nonzero entries to the sparsity pattern of the large matrix (with constrained nodes in it) where the condensation process of the matrix will create additional nonzero elements. In the condensation process itself, rows and columns subject to constraints are distributed to the rows and columns of unconstrained nodes. The constrained degrees of freedom remain in place, however, unlike in the first possibility described above. In order not to disturb the solution process, these rows and columns are filled with zeros and an appropriate positive value on the main diagonal (we choose an average of the magnitudes of the other diagonal elements, so as to make sure that the new diagonal entry has the same order of magnitude as the other entries; this preserves the scaling properties of the matrix). The corresponding value in the right hand sides is set to zero. This way, the constrained node will always get the value zero upon solution of the equation system and will not couple to other nodes any more.</p>
<p>This method has the advantage that only one matrix and sparsity pattern is needed thus using less memory. Additionally, the condensation process is less expensive, since not all but only constrained values in the matrix have to be copied. On the other hand, the solution process will take a bit longer, since matrix vector multiplications will incur multiplications with zeroes in the lines subject to constraints. Additionally, the vector size is larger than in the first possibility, resulting in more memory consumption for those iterative solution methods using a larger number of auxiliary vectors (e.g. methods using explicit orthogonalization procedures).</p>
<p class="endli">Nevertheless, this process is overall more efficient due to its lower memory consumption and is the one discussed in the first few programs of the <a class="el" href="Tutorial.html">Tutorial programs</a> , for example in <a class="el" href="step_6.html">step-6</a>. </p>
</li>
</ul>
<p>The <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> class provides two sets of <code>condense</code> functions: those taking two arguments refer to the first possibility above, those taking only one do their job in-place and refer to the second possibility.</p>
<p>The condensation functions exist for different argument types. The in-place functions (i.e. those following the second way) exist for arguments of type <a class="el" href="classSparsityPattern.html">SparsityPattern</a>, <a class="el" href="classSparseMatrix.html">SparseMatrix</a> and <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>. Note that there are no versions for arguments of type <a class="el" href="classPETScWrappers_1_1SparseMatrix.html">PETScWrappers::SparseMatrix()</a> or any of the other PETSc or Trilinos matrix wrapper classes. This is due to the fact that it is relatively hard to get a representation of the sparsity structure of PETSc matrices, and to modify them; this holds in particular, if the matrix is actually distributed across a cluster of computers. If you want to use PETSc/Trilinos matrices, you can either copy an already condensed deal.II matrix, or assemble the PETSc/Trilinos matrix in the already condensed form, see the discussion below.</p>
<h5>Condensing vectors</h5>
<p>Condensing vectors works exactly as described above for matrices. Note that condensation is an idempotent operation, i.e. doing it more than once on a vector or matrix yields the same result as doing it only once: once an object has been condensed, further condensation operations don't change it any more.</p>
<p>In contrast to the matrix condensation functions, the vector condensation functions exist in variants for PETSc and Trilinos vectors. However, using them is typically expensive, and should be avoided. You should use the same techniques as mentioned above to avoid their use.</p>
<h4>Avoiding explicit condensation</h4>
<p>Sometimes, one wants to avoid explicit condensation of a linear system after it has been built at all. There are two main reasons for wanting to do so:</p>
<ul>
<li>
<p class="startli">Condensation is an expensive operation, in particular if there are many constraints and/or if the matrix has many nonzero entries. Both is typically the case for 3d, or high polynomial degree computations, as well as for hp finite element methods, see for example the <a class="el" href="DEALGlossary.html#hp_paper">hp paper</a>. This is the case discussed in the hp tutorial program, <a class="el" href="step_27.html">step-27</a>, as well as in <a class="el" href="step_22.html">step-22</a> and <a class="el" href="step_31.html">step-31</a>.</p>
<p class="endli"></p>
</li>
<li>
There may not be a <a class="el" href="classConstraintMatrix.html#a66337316e8fbbc786c9f0383d085ab01">ConstraintMatrix::condense()</a> function for the matrix you use (this is, for example, the case for the PETSc and Trilinos wrapper classes where we have no access to the underlying representation of the matrix, and therefore cannot efficiently implement the <a class="el" href="classConstraintMatrix.html#a66337316e8fbbc786c9f0383d085ab01">ConstraintMatrix::condense()</a> operation). This is the case discussed in <a class="el" href="step_17.html">step-17</a>, <a class="el" href="step_18.html">step-18</a>, <a class="el" href="step_31.html">step-31</a>, and <a class="el" href="step_32.html">step-32</a>. </li>
</ul>
<p>In this case, one possibility is to distribute local entries to the final destinations right at the moment of transferring them into the global matrices and vectors, and similarly build a sparsity pattern in the condensed form at the time it is set up originally.</p>
<p>The <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> class offers support for these operations as well. For example, the <a class="el" href="classConstraintMatrix.html#a646ac6aabbc957e439971b8a14d0add8">ConstraintMatrix::add_entries_local_to_global()</a> function adds nonzero entries to a sparsity pattern object. It not only adds a given entry, but also all entries that we will have to write to if the current entry corresponds to a constrained degree of freedom that will later be eliminated. Similarly, one can use the <a class="el" href="classConstraintMatrix.html#aa9f3612a8fc51eafa34252bb436e8ae4">ConstraintMatrix::distribute_local_to_global()</a> functions to directly distribute entries in vectors and matrices when copying local contributions into a global matrix or vector. These calls make a subsequent call to <a class="el" href="classConstraintMatrix.html#a66337316e8fbbc786c9f0383d085ab01">ConstraintMatrix::condense()</a> unnecessary. For examples of their use see the tutorial programs referenced above.</p>
<p>Note that, despite their name which describes what the function really does, the <a class="el" href="classConstraintMatrix.html#aa9f3612a8fc51eafa34252bb436e8ae4">ConstraintMatrix::distribute_local_to_global()</a> functions has to be applied to matrices and right hand side vectors, whereas the <a class="el" href="classConstraintMatrix.html#a7cf6b84c47aa32408f412ae769085bd6">ConstraintMatrix::distribute()</a> function discussed below is applied to the solution vector after solving the linear system.</p>
<h3>Distributing constraints</h3>
<p>After solving the condensed system of equations, the solution vector has to be "distributed": the modification to the original linear system that results from calling <a class="el" href="classConstraintMatrix.html#a66337316e8fbbc786c9f0383d085ab01">ConstraintMatrix::condense</a> leads to a linear system that solves correctly for all degrees of freedom that are unconstrained but leaves the values of constrained degrees of freedom undefined. To get the correct values also for these degrees of freedom, you need to "distribute" the unconstrained values also to their constrained colleagues. This is done by the two <a class="el" href="classConstraintMatrix.html#a7cf6b84c47aa32408f412ae769085bd6">ConstraintMatrix::distribute()</a> functions, one working with two vectors, one working in-place. The operation of distribution undoes the condensation process in some sense, but it should be noted that it is not the inverse operation. Basically, distribution sets the values of the constrained nodes to the value that is computed from the constraint given the values of the unconstrained nodes plus possible inhomogeneities.</p>
<h3>Treatment of inhomogeneous constraints</h3>
<p>In case some constraint lines have inhomogeneities (which is typically the case if the constraint comes from implementation of inhomogeneous boundary conditions), the situation is a bit more complicated than if the only constraints were due to hanging nodes alone. This is because the elimination of the non-diagonal values in the matrix generate contributions in the eliminated rows in the vector. This means that inhomogeneities can only be handled with functions that act simultaneously on a matrix and a vector. This means that all inhomogeneities are ignored in case the respective condense function is called without any matrix (or if the matrix has already been condensed before).</p>
<p>The use of <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> for implementing Dirichlet boundary conditions is discussed in the <a class="el" href="step_22.html">step-22</a> tutorial program. A further example that applies the <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> is <a class="el" href="step_41.html">step-41</a>. The situation here is little more complicated, because there we have some constraints which are not at the boundary. There are two ways to apply inhomogeneous constraints after creating the <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a>:</p>
<p>First approach:</p>
<ul>
<li>Apply the <a class="el" href="classConstraintMatrix.html#aa9f3612a8fc51eafa34252bb436e8ae4">ConstraintMatrix::distribute_local_to_global()</a> function to the system matrix and the right-hand-side with the parameter use_inhomogeneities_for_rhs = false (i.e., the default)</li>
<li>Set the solution to zero in the inhomogeneous constrained components using the <a class="el" href="classConstraintMatrix.html#a0a3e683ed07b7811be4522fc187d811e">ConstraintMatrix::set_zero()</a> function (or start with a solution vector equal to zero)</li>
<li>solve() the linear system</li>
<li>Apply <a class="el" href="classConstraintMatrix.html#a7cf6b84c47aa32408f412ae769085bd6">ConstraintMatrix::distribute()</a> to the solution</li>
</ul>
<p>Second approach:</p>
<ul>
<li>Use the <a class="el" href="classConstraintMatrix.html#aa9f3612a8fc51eafa34252bb436e8ae4">ConstraintMatrix::distribute_local_to_global()</a> function with the parameter use_inhomogeneities_for_rhs = true and apply it to the system matrix and the right-hand-side</li>
<li>Set the concerning components of the solution to the inhomogeneous constrained values (for example using <a class="el" href="classConstraintMatrix.html#a7cf6b84c47aa32408f412ae769085bd6">ConstraintMatrix::distribute()</a>)</li>
<li>solve() the linear system</li>
<li>Depending on the solver now you have to apply the <a class="el" href="classConstraintMatrix.html#a7cf6b84c47aa32408f412ae769085bd6">ConstraintMatrix::distribute()</a> function to the solution, because the solver could change the constrained values in the solution. For a Krylov based solver this should not be strictly necessary, but it is still possible that there is a difference between the inhomogeneous value and the solution value in the order of machine precision, and you may want to call <a class="el" href="classConstraintMatrix.html#a7cf6b84c47aa32408f412ae769085bd6">ConstraintMatrix::distribute()</a> anyway if you have additional constraints such as from hanging nodes.</li>
</ul>
<p>Of course, both approaches lead to the same final answer but in different ways. Using approach (i.e., when using use_inhomogeneities_for_rhs = false in <a class="el" href="classConstraintMatrix.html#aa9f3612a8fc51eafa34252bb436e8ae4">ConstraintMatrix::distribute_local_to_global()</a>), the linear system we build has zero entries in the right hand side in all those places where a degree of freedom is constrained, and some positive value on the matrix diagonal of these lines. Consequently, the solution vector of the linear system will have a zero value for inhomogeneously constrained degrees of freedom and we need to call <a class="el" href="classConstraintMatrix.html#a7cf6b84c47aa32408f412ae769085bd6">ConstraintMatrix::distribute()</a> to give these degrees of freedom their correct nonzero values.</p>
<p>On the other hand, in the second approach, the matrix diagonal element and corresponding right hand side entry for inhomogeneously constrained degrees of freedom are so that the solution of the linear system already has the correct value (e.g., if the constraint is that <img class="formulaInl" alt="$x_{13}=42$" src="form_23.png"/> then row <img class="formulaInl" alt="$13$" src="form_24.png"/> if the matrix is empty with the exception of the diagonal entry, and <img class="formulaInl" alt="$b_{13}/A_{13,13}=42$" src="form_25.png"/> so that the solution of <img class="formulaInl" alt="$Ax=b$" src="form_26.png"/> must satisfy <img class="formulaInl" alt="$x_{13}=42$" src="form_23.png"/> as desired). As a consequence, we do not need to call <a class="el" href="classConstraintMatrix.html#a7cf6b84c47aa32408f412ae769085bd6">ConstraintMatrix::distribute()</a> after solving to fix up inhomogeneously constrained components of the solution, though there is also no harm in doing so.</p>
<p>There remains the question of which of the approaches to take and why we need to set to zero the values of the solution vector in the first approach. The answer to both questions has to do with how iterative solvers solve the linear system. To this end, consider that we typically stop iterations when the residual has dropped below a certain fraction of the norm of the right hand side, or, alternatively, a certain fraction of the norm of the initial residual. Now consider this:</p>
<ul>
<li>In the first approach, the right hand side entries for constrained degrees of freedom are zero, i.e., the norm of the right hand side really only consists of those parts that we care about. On the other hand, if we start with a solution vector that is not zero in constrained entries, then the initial residual is very large because the value that is currently in the solution vector does not match the solution of the linear system (which is zero in these components). Thus, if we stop iterations once we have reduced the initial residual by a certain factor, we may reach the threshold after a single iteration because constrained degrees of freedom are resolved by iterative solvers in just one iteration. If the initial residual was dominated by these degrees of freedom, then we see a steep reduction in the first step although we did not really make much progress on the remainder of the linear system in this just one iteration. We can avoid this problem by either stopping iterations once the norm of the residual reaches a certain fraction of the <em>norm of the right hand side</em>, or we can set the solution components to zero (thus reducing the initial residual) and iterating until we hit a certain fraction of the <em>norm of the initial residual</em>.</li>
<li>In the second approach, we get the same problem if the starting vector in the iteration is zero, since then then the residual may be dominated by constrained degrees of freedom having values that do not match the values we want for them at the solution. We can again circumvent this problem by setting the corresponding elements of the solution vector to their correct values, by calling <a class="el" href="classConstraintMatrix.html#a7cf6b84c47aa32408f412ae769085bd6">ConstraintMatrix::distribute()</a> <em>before</em> solving the linear system (and then, as necessary, a second time after solving).</li>
</ul>
<p>In addition to these considerations, consider the case where we have inhomogeneous constraints of the kind <img class="formulaInl" alt="$x_{3}=\tfrac 12 x_1 + \tfrac 12$" src="form_27.png"/>, e.g., from a hanging node constraint of the form <img class="formulaInl" alt="$x_{3}=\tfrac 12 (x_1 + x_2)$" src="form_28.png"/> where <img class="formulaInl" alt="$x_2$" src="form_29.png"/> is itself constrained by boundary values to <img class="formulaInl" alt="$x_2=1$" src="form_30.png"/>. In this case, the <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> can of course not figure out what the final value of <img class="formulaInl" alt="$x_3$" src="form_31.png"/> should be and, consequently, can not set the solution vector's third component correctly. Thus, the second approach will not work and you should take the first.</p>
<h3>Dealing with conflicting constraints</h3>
<p>There are situations where degrees of freedom are constrained in more than one way, and sometimes in conflicting ways. Consider, for example the following situation: </p>
<div class="image">
<img src="conflicting_constraints.png" alt="conflicting_constraints.png"/>
</div>
<p>Here, degree of freedom <img class="formulaInl" alt="$x_0$" src="form_32.png"/> marked in blue is a hanging node. If we used trilinear finite elements, i.e. <a class="el" href="classFE__Q.html">FE_Q(1)</a>, then it would carry the constraint <img class="formulaInl" alt="$x_0=\frac 12 (x_{1}+x_{2})$" src="form_33.png"/>. On the other hand, it is at the boundary, and if we have imposed boundary conditions <img class="formulaInl" alt="$u|_{\partial\Omega}=g$" src="form_2.png"/> then we will have the constraint <img class="formulaInl" alt="$x_0=g_0$" src="form_34.png"/> where <img class="formulaInl" alt="$g_0$" src="form_35.png"/> is the value of the boundary function <img class="formulaInl" alt="$g(\mathbf x)$" src="form_4.png"/> at the location of this degree of freedom.</p>
<p>So, which one will win? Or maybe: which one <em>should</em> win? There is no good answer to this question:</p>
<ul>
<li>If the hanging node constraint is the one that is ultimately enforced, then the resulting solution does not satisfy boundary conditions any more for general boundary functions <img class="formulaInl" alt="$g$" src="form_36.png"/>.</li>
<li>If it had been done the other way around, the solution would not satisfy hanging node constraints at this point and consequently would not satisfy the regularity properties of the element chosen (e.g. would not be continuous despite using a <img class="formulaInl" alt="$Q_1$" src="form_37.png"/> element).</li>
<li>The situation becomes completely hopeless if you consider curved boundaries since then the edge midpoint (i.e. the hanging node) does in general not lie on the mother edge. Consequently, the solution will not be <img class="formulaInl" alt="$H^1$" src="form_38.png"/> conforming anyway, regardless of the priority of the two competing constraints. If the hanging node constraint wins, then the solution will be neither conforming, nor have the right boundary values. In other words, it is not entirely clear what the "correct" solution would be. In most cases, it will not matter much: in either case, the error introduced either by the non-conformity or the incorrect boundary values will be at worst at the same order as the discretization's overall error.</li>
</ul>
<p>That said, what should you do if you know what you want is this:</p>
<ul>
<li>If you want the hanging node constraints to win, then first build these through the <a class="el" href="group__constraints.html#gabe9d21d4bb33ce556a6e6e80c2bf4b41">DoFTools::make_hanging_node_constraints()</a> function. Then interpolate the boundary values using <a class="el" href="namespaceVectorTools.html#a199f38e07822b47e5b5957c21ce35d1b">VectorTools::interpolate_boundary_values()</a> into the same <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> object. If the latter function encounters a boundary node that already is constrained, it will simply ignore the boundary values at this node and leave the constraint untouched.</li>
<li>If you want the boundary value constraint to win, build the hanging node constraints as above and use these to assemble the matrix using the <a class="el" href="classConstraintMatrix.html#aa9f3612a8fc51eafa34252bb436e8ae4">ConstraintMatrix::distribute_local_to_global()</a> function (or, alternatively, assemble the matrix and then use <a class="el" href="classConstraintMatrix.html#a66337316e8fbbc786c9f0383d085ab01">ConstraintMatrix::condense()</a> on it). In a second step, use the <a class="el" href="namespaceVectorTools.html#a199f38e07822b47e5b5957c21ce35d1b">VectorTools::interpolate_boundary_values()</a> function that returns a std::map and use it as input for <a class="el" href="namespaceMatrixTools.html#a41a069894610445f84840d712d4f891e">MatrixTools::apply_boundary_values()</a> to set boundary nodes to their correct value.</li>
</ul>
<p>Either behavior can also be achieved by building two separate <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> objects and calling <a class="el" href="classConstraintMatrix.html#a08b5378ad8b23e5fb86c71a2c66bff13">ConstraintMatrix::merge</a> function with a particular second argument. </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gab627b1d4845c9526521dbd1be83469dc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DH , class SparsityPattern &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::make_sparsity_pattern </td>
          <td>(</td>
          <td class="paramtype">const DH &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>sparsity_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints</em> = <code><a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>keep_constrained_dofs</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a>&#160;</td>
          <td class="paramname"><em>subdomain_id</em> = <code><a class="el" href="namespacenumbers.html#a6fe5acece133d890bee8cc49ccd8ebfb">numbers::invalid_subdomain_id</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Locate non-zero entries of the system matrix.</p>
<p>This function computes the possible positions of non-zero entries in the global system matrix. We assume that a certain finite element basis function is non-zero on a cell only if its degree of freedom is associated with the interior, a face, an edge or a vertex of this cell. As a result, the matrix entry between two basis functions can be non-zero only if they correspond to degrees of freedom of at least one common cell. Therefore, <code>make_sparsity_pattern</code> just loops over all cells and enters all couplings local to that cell. As the generation of the sparsity pattern is irrespective of the equation which is solved later on, the resulting sparsity pattern is symmetric.</p>
<p>Remember using <a class="el" href="classSparsityPattern.html#ad15d36e4bfe7c97b55d155541e723284">SparsityPattern::compress()</a> after generating the pattern.</p>
<p>The actual type of the sparsity pattern may be <a class="el" href="classSparsityPattern.html">SparsityPattern</a>, <a class="el" href="classCompressedSparsityPattern.html">CompressedSparsityPattern</a>, <a class="el" href="classBlockSparsityPattern.html">BlockSparsityPattern</a>, <a class="el" href="classBlockCompressedSparsityPattern.html">BlockCompressedSparsityPattern</a>, <a class="el" href="classBlockCompressedSetSparsityPattern.html">BlockCompressedSetSparsityPattern</a>, <a class="el" href="classBlockCompressedSimpleSparsityPattern.html">BlockCompressedSimpleSparsityPattern</a>, or any other class that satisfies similar requirements. It is assumed that the size of the sparsity pattern matches the number of degrees of freedom and that enough unused nonzero entries are left to fill the sparsity pattern. The nonzero entries generated by this function are overlaid to possible previous content of the object, that is previously added entries are not deleted.</p>
<p>Since this process is purely local, the sparsity pattern does not provide for entries introduced by the elimination of hanging nodes. They have to be taken care of by a call to <a class="el" href="classConstraintMatrix.html#a66337316e8fbbc786c9f0383d085ab01">ConstraintMatrix::condense()</a> afterwards.</p>
<p>Alternatively, the constraints on degrees of freedom can already be taken into account at the time of creating the sparsity pattern. For this, pass the <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> object as the third argument to the current function. No call to <a class="el" href="classConstraintMatrix.html#a66337316e8fbbc786c9f0383d085ab01">ConstraintMatrix::condense()</a> is then necessary. This process is explained in <a class="el" href="step_27.html">step-27</a>.</p>
<p>In case the constraints are already taken care of in this function, it is possible to neglect off-diagonal entries in the sparsity pattern. When using <a class="el" href="classConstraintMatrix.html#aa9f3612a8fc51eafa34252bb436e8ae4">ConstraintMatrix::distribute_local_to_global</a> during assembling, no entries will ever be written into these matrix position, so that one can save some computing time in matrix-vector products by not even creating these elements. In that case, the variable <code>keep_constrained_dofs</code> needs to be set to <code>false</code>.</p>
<p>If the <code>subdomain_id</code> parameter is given, the sparsity pattern is built only on cells that have a subdomain_id equal to the given argument. This is useful in parallel contexts where the matrix and sparsity pattern (for example a <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html">TrilinosWrappers::SparsityPattern</a>) may be distributed and not every MPI process needs to build the entire sparsity pattern; in that case, it is sufficient if every process only builds that part of the sparsity pattern that corresponds to the subdomain_id for which it is responsible. This feature is used in <a class="el" href="step_32.html">step-32</a>. </p>

</div>
</div>
<a class="anchor" id="ga250c261f4dba6c77834b2fa8d3bf7f5c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DH , class SparsityPattern &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::make_sparsity_pattern </td>
          <td>(</td>
          <td class="paramtype">const DH &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTable.html">Table</a>&lt; 2, Coupling &gt; &amp;&#160;</td>
          <td class="paramname"><em>coupling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>sparsity_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints</em> = <code><a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>keep_constrained_dofs</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a>&#160;</td>
          <td class="paramname"><em>subdomain_id</em> = <code><a class="el" href="namespacenumbers.html#a6fe5acece133d890bee8cc49ccd8ebfb">numbers::invalid_subdomain_id</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Locate non-zero entries for vector valued finite elements. This function does mostly the same as the previous <a class="el" href="group__constraints.html#gab627b1d4845c9526521dbd1be83469dc">make_sparsity_pattern()</a>, but it is specialized for vector finite elements and allows to specify which variables couple in which equation. For example, if wanted to solve the Stokes equations,</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} -\Delta \mathbf u + \nabla p &amp;= 0,\\ \text{div}\ u &amp;= 0 \end{align*}" src="form_405.png"/>
</p>
<p>in two space dimensions, using stable Q2/Q1 mixed elements (using the <a class="el" href="classFESystem.html">FESystem</a> class), then you don't want all degrees of freedom to couple in each equation. You rather may want to give the following pattern of couplings:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \left[ \begin{array}{ccc} 1 &amp; 0 &amp; 1 \\ 0 &amp; 1 &amp; 1 \\ 1 &amp; 1 &amp; 0 \end{array} \right] \]" src="form_406.png"/>
</p>
<p>where "1" indicates that two variables (i.e. components of the <a class="el" href="classFESystem.html">FESystem</a>) couple in the respective equation, and a "0" means no coupling, in which case it is not necessary to allocate space in the matrix structure. Obviously, the mask refers to components of the composed <a class="el" href="classFESystem.html">FESystem</a>, rather than to the degrees of freedom contained in there.</p>
<p>This function is designed to accept a coupling pattern, like the one shown above, through the <code>couplings</code> parameter, which contains values of type <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a>. It builds the matrix structure just like the previous function, but does not create matrix elements if not specified by the coupling pattern. If the couplings are symmetric, then so will be the resulting sparsity pattern.</p>
<p>The actual type of the sparsity pattern may be <a class="el" href="classSparsityPattern.html">SparsityPattern</a>, <a class="el" href="classCompressedSparsityPattern.html">CompressedSparsityPattern</a>, <a class="el" href="classBlockSparsityPattern.html">BlockSparsityPattern</a>, <a class="el" href="classBlockCompressedSparsityPattern.html">BlockCompressedSparsityPattern</a>, <a class="el" href="classBlockCompressedSetSparsityPattern.html">BlockCompressedSetSparsityPattern</a>, or any other class that satisfies similar requirements.</p>
<p>There is a complication if some or all of the shape functions of the finite element in use are non-zero in more than one component (in deal.II speak: they are non-primitive). In this case, the coupling element correspoding to the first non-zero component is taken and additional ones for this component are ignored.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000030">Todo:</a></b></dt><dd>Not implemented for <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>.</dd></dl>
<p>As mentioned before, the creation of the sparsity pattern is a purely local process and the sparsity pattern does not provide for entries introduced by the elimination of hanging nodes. They have to be taken care of by a call to <a class="el" href="classConstraintMatrix.html#a66337316e8fbbc786c9f0383d085ab01">ConstraintMatrix::condense()</a> afterwards.</p>
<p>Alternatively, the constraints on degrees of freedom can already be taken into account at the time of creating the sparsity pattern. For this, pass the <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> object as the third argument to the current function. No call to <a class="el" href="classConstraintMatrix.html#a66337316e8fbbc786c9f0383d085ab01">ConstraintMatrix::condense()</a> is then necessary. This process is explained in <a class="el" href="step_27.html">step-27</a>.</p>
<p>In case the constraints are already taken care of in this function, it is possible to neglect off-diagonal entries in the sparsity pattern. When using <a class="el" href="classConstraintMatrix.html#aa9f3612a8fc51eafa34252bb436e8ae4">ConstraintMatrix::distribute_local_to_global</a> during assembling, no entries will ever be written into these matrix position, so that one can save some computing time in matrix-vector products by not even creating these elements. In that case, the variable <code>keep_constrained_dofs</code> needs to be set to <code>false</code>.</p>
<p>If the <code>subdomain_id</code> parameter is given, the sparsity pattern is built only on cells that have a subdomain_id equal to the given argument. This is useful in parallel contexts where the matrix and sparsity pattern (for example a <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html">TrilinosWrappers::SparsityPattern</a>) may be distributed and not every MPI process needs to build the entire sparsity pattern; in that case, it is sufficient if every process only builds that part of the sparsity pattern that corresponds to the subdomain_id for which it is responsible. This feature is used in <a class="el" href="step_32.html">step-32</a>. </p>

</div>
</div>
<a class="anchor" id="gaf7e3920b3d248d53e65997d8bce110a2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DH , class SparsityPattern &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::make_flux_sparsity_pattern </td>
          <td>(</td>
          <td class="paramtype">const DH &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>sparsity_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>keep_constrained_dofs</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a>&#160;</td>
          <td class="paramname"><em>subdomain_id</em> = <code><a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function does the same as the other with the same name, but it gets a <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> additionally. This is for the case where you have fluxes but constraints as well. </p>

</div>
</div>
<a class="anchor" id="gabe9d21d4bb33ce556a6e6e80c2bf4b41"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DH &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::make_hanging_node_constraints </td>
          <td>(</td>
          <td class="paramtype">const DH &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the constraints resulting from the presence of hanging nodes. Hanging nodes are best explained using a small picture:</p>
<div class="image">
<img src="hanging_nodes.png" alt="hanging_nodes.png"/>
</div>
<p>In order to make a finite element function globally continuous, we have to make sure that the dark red nodes have values that are compatible with the adjacent yellow nodes, so that the function has no jump when coming from the small cells to the large one at the top right. We therefore have to add conditions that constrain those "hanging nodes".</p>
<p>The object into which these are inserted is later used to condense the global system matrix and right hand side, and to extend the solution vectors from the true degrees of freedom also to the constraint nodes. This function is explained in detail in the <a class="el" href="step_6.html">step-6</a> tutorial program and is used in almost all following programs as well.</p>
<p>This function does not clear the constraint matrix object before use, in order to allow adding constraints from different sources to the same object. You therefore need to make sure it contains only constraints you still want; otherwise call the <a class="el" href="classConstraintMatrix.html#a24120d0331183f9a63cbe41493a19f6b">ConstraintMatrix::clear()</a> function. Likewise, this function does not close the object since you may want to enter other constraints later on yourself.</p>
<p>In the hp-case, i.e. when the argument is of type <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>, we consider constraints due to different finite elements used on two sides of a face between cells as hanging nodes as well. In other words, for hp finite elements, this function computes all constraints due to differing mesh sizes (h) or polynomial degrees (p) between adjacent cells.</p>
<p>The template argument (and by consequence the type of the first argument to this function) can be either <a class="el" href="classDoFHandler.html">DoFHandler</a> or <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>. </p>

</div>
</div>
<a class="anchor" id="ga2a8572710e0cbec24e8497dd79e15a87"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, template&lt; int, int &gt; class DH&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::make_zero_boundary_constraints </td>
          <td>(</td>
          <td class="paramtype">const DH&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>boundary_indicator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>zero_boundary_constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make a constraint matrix for the constraints that result from zero boundary values on the given boundary indicator.</p>
<p>This function constrains all degrees of freedom on the given part of the boundary.</p>
<p>A variant of this function with different arguments is used in <a class="el" href="step_36.html">step-36</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dof</td><td>The <a class="el" href="classDoFHandler.html">DoFHandler</a> to work on. </td></tr>
    <tr><td class="paramname">boundary_indicator</td><td>The indicator of that part of the boundary for which constraints should be computed. If this number equals <a class="el" href="namespacenumbers.html#a1745778880e38cde9ef045471f4757fd">numbers::invalid_boundary_id</a> then all boundaries of the domain will be treated. </td></tr>
    <tr><td class="paramname">zero_boundary_constraints</td><td>The constraint object into which the constraints will be written. The new constraints due to zero boundary values will simply be added, preserving any other constraints previously present. However, this will only work if the previous content of that object consists of constraints on degrees of freedom that are not located on the boundary treated here. If there are previously existing constraints for degrees of freedom located on the boundary, then this would constitute a conflict. See the <a class="el" href="group__constraints.html">Constraints on degrees of freedom</a> module for handling the case where there are conflicting constraints on individual degrees of freedom. </td></tr>
    <tr><td class="paramname">component_mask</td><td>An optional component mask that restricts the functionality of this function to a subset of an <a class="el" href="classFESystem.html">FESystem</a>. For non-<a class="el" href="DEALGlossary.html#GlossPrimitive">primitive</a> shape functions, any degree of freedom is affected that belongs to a shape function where at least one of its nonzero components is affected by the component mask (see <a class="el" href="DEALGlossary.html#GlossComponentMask">GlossComponentMask</a>). If this argument is omitted, all components of the finite element with degrees of freedom at the boundary will be considered.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga0e92f453a12cc02226a476ffdac6af3a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, template&lt; int, int &gt; class DH&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::make_zero_boundary_constraints </td>
          <td>(</td>
          <td class="paramtype">const DH&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>zero_boundary_constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Do the same as the previous function, except do it for all parts of the boundary, not just those with a particular boundary indicator. This function is then equivalent to calling the previous one with <a class="el" href="namespacenumbers.html#a1745778880e38cde9ef045471f4757fd">numbers::invalid_boundary_id</a> as second argument.</p>
<p>This function is used in <a class="el" href="step_36.html">step-36</a>, for example. </p>

</div>
</div>
<a class="anchor" id="ga7f3e96634dbdd78c9a5b0674af496559"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DH &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::interpolate_boundary_values </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; DH::dimension, DH::space_dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DH &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="structFunctionMap.html">FunctionMap</a>&lt; DH::space_dimension &gt;::type &amp;&#160;</td>
          <td class="paramname"><em>function_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Insert the (algebraic) constraints due to Dirichlet boundary conditions into a <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> <code>constraints</code>. This function identifies the degrees of freedom subject to Dirichlet boundary conditions, adds them to the list of constrained DoFs in <code>constraints</code> and sets the respective inhomogeneity to the value interpolated around the boundary. If this routine encounters a DoF that already is constrained (for instance by a hanging node constraint, see below, or any other type of constraint, e.g. from periodic boundary conditions), the old setting of the constraint (dofs the entry is constrained to, inhomogeneities) is kept and nothing happens.</p>
<dl class="section note"><dt>Note</dt><dd>When combining adaptively refined meshes with hanging node constraints and boundary conditions like from the current function within one <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> object, the hanging node constraints should always be set first, and then the boundary conditions since boundary conditions are not set in the second operation on degrees of freedom that are already constrained. This makes sure that the discretization remains conforming as is needed. See the discussion on conflicting constraints in the module on <a class="el" href="group__constraints.html">Constraints on degrees of freedom</a> .</dd></dl>
<p>The parameter <code>boundary_component</code> corresponds to the number <code>boundary_indicator</code> of the face.</p>
<p>The flags in the last parameter, <code>component_mask</code> denote which components of the finite element space shall be interpolated. If it is left as specified by the default value (i.e. an empty array), all components are interpolated. If it is different from the default value, it is assumed that the number of entries equals the number of components in the boundary functions and the finite element, and those components in the given boundary function will be used for which the respective flag was set in the component mask. See also <a class="el" href="DEALGlossary.html#GlossComponentMask">GlossComponentMask</a>. As an example, assume that you are solving the Stokes equations in 2d, with variables <img class="formulaInl" alt="$(u,v,p)$" src="form_611.png"/> and that you only want to interpolate boundary values for the pressure, then the component mask should correspond to <code>(true,true,false)</code>.</p>
<dl class="section note"><dt>Note</dt><dd>Whether a component mask has been specified or not, the number of components of the functions in <code>function_map</code> must match that of the finite element used by <code>dof</code>. In other words, for the example above, you need to provide a <a class="el" href="classFunction.html">Function</a> object that has 3 components (the two velocities and the pressure), even though you are only interested in the first two of them. <a class="el" href="namespaceVectorTools.html#a199f38e07822b47e5b5957c21ce35d1b">interpolate_boundary_values()</a> will then call this function to obtain a vector of 3 values at each interpolation point but only take the first two and discard the third. In other words, you are free to return whatever you like in the third component of the vector returned by <a class="el" href="classFunction.html#a1fa27ec3204c0929a0b33ae34a97ef8f">Function::vector_value</a>, but the <a class="el" href="classFunction.html">Function</a> object must state that it has 3 components.</dd></dl>
<p>If the finite element used has shape functions that are non-zero in more than one component (in deal.II speak: they are non-primitive), then these components can presently not be used for interpolating boundary values. Thus, the elements in the component mask corresponding to the components of these non-primitive shape functions must be <code>false</code>.</p>
<p>See the general documentation of this class for more information. </p>

<p>Definition at line <a class="el" href="vector__tools_8templates_8h_source.html#l01888">1888</a> of file <a class="el" href="vector__tools_8templates_8h_source.html">vector_tools.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga22711fb5e71f2ae7c8b117209b4af397"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DH &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::interpolate_boundary_values </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; DH::dimension, DH::space_dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DH &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>boundary_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; DH::space_dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same function as above, but taking only one pair of boundary indicator and corresponding boundary function. The same comments apply as for the previous function, in particular about the use of the component mask and the requires size of the function object.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a> </dd></dl>

<p>Definition at line <a class="el" href="vector__tools_8templates_8h_source.html#l01917">1917</a> of file <a class="el" href="vector__tools_8templates_8h_source.html">vector_tools.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaf2b32c11445e5d5fec898781dddaaf80"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DH &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::interpolate_boundary_values </td>
          <td>(</td>
          <td class="paramtype">const DH &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>boundary_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; DH::space_dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calls the other <a class="el" href="namespaceVectorTools.html#a199f38e07822b47e5b5957c21ce35d1b">interpolate_boundary_values()</a> function, see above, with <code>mapping=<a class="el" href="classMappingQ1.html">MappingQ1</a>&lt;dim&gt;()</code>. The same comments apply as for the previous function, in particular about the use of the component mask and the requires size of the function object.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a> </dd></dl>

<p>Definition at line <a class="el" href="vector__tools_8templates_8h_source.html#l01935">1935</a> of file <a class="el" href="vector__tools_8templates_8h_source.html">vector_tools.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga765f05b664f0f3f3090d6526f9384430"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DH &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::interpolate_boundary_values </td>
          <td>(</td>
          <td class="paramtype">const DH &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="structFunctionMap.html">FunctionMap</a>&lt; DH::space_dimension &gt;::type &amp;&#160;</td>
          <td class="paramname"><em>function_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calls the other <a class="el" href="namespaceVectorTools.html#a199f38e07822b47e5b5957c21ce35d1b">interpolate_boundary_values()</a> function, see above, with <code>mapping=<a class="el" href="classMappingQ1.html">MappingQ1</a>&lt;dim&gt;()</code>. The same comments apply as for the previous function, in particular about the use of the component mask and the requires size of the function object. </p>

<p>Definition at line <a class="el" href="vector__tools_8templates_8h_source.html#l01951">1951</a> of file <a class="el" href="vector__tools_8templates_8h_source.html">vector_tools.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="gabe6c2a3531280b809c791c4e90f984d8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::project_boundary_values </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="structFunctionMap.html">FunctionMap</a>&lt; spacedim &gt;::type &amp;&#160;</td>
          <td class="paramname"><em>boundary_functions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td>
          <td class="paramname"><em>component_mapping</em> = <code>std::vector&lt;&#160;unsigned&#160;<a class="el" href="classint.html">int</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Project a function to the boundary of the domain, using the given quadrature formula for the faces. This function identifies the degrees of freedom subject to Dirichlet boundary conditions, adds them to the list of constrained DoFs in <code>constraints</code> and sets the respective inhomogeneity to the value resulting from the projection operation. If this routine encounters a DoF that already is constrained (for instance by a hanging node constraint, see below, or any other type of constraint, e.g. from periodic boundary conditions), the old setting of the constraint (dofs the entry is constrained to, inhomogeneities) is kept and nothing happens.</p>
<dl class="section note"><dt>Note</dt><dd>When combining adaptively refined meshes with hanging node constraints and boundary conditions like from the current function within one <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> object, the hanging node constraints should always be set first, and then the boundary conditions since boundary conditions are not set in the second operation on degrees of freedom that are already constrained. This makes sure that the discretization remains conforming as is needed. See the discussion on conflicting constraints in the module on <a class="el" href="group__constraints.html">Constraints on degrees of freedom</a> .</dd></dl>
<p>If <code>component_mapping</code> is empty, it is assumed that the number of components of <code>boundary_function</code> matches that of the finite element used by <code>dof</code>.</p>
<p>In 1d, projection equals interpolation. Therefore, interpolate_boundary_values is called.</p>
<ul>
<li><code>component_mapping:</code> if the components in <code>boundary_functions</code> and <code>dof</code> do not coincide, this vector allows them to be remapped. If the vector is not empty, it has to have one entry for each component in <code>dof</code>. This entry is the component number in <code>boundary_functions</code> that should be used for this component in <code>dof</code>. By default, no remapping is applied. </li>
</ul>

<p>Definition at line <a class="el" href="vector__tools_8templates_8h_source.html#l02215">2215</a> of file <a class="el" href="vector__tools_8templates_8h_source.html">vector_tools.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga587d0c6d8f1632fb757cf16594f527d0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::project_boundary_values </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="structFunctionMap.html">FunctionMap</a>&lt; spacedim &gt;::type &amp;&#160;</td>
          <td class="paramname"><em>boundary_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td>
          <td class="paramname"><em>component_mapping</em> = <code>std::vector&lt;&#160;unsigned&#160;<a class="el" href="classint.html">int</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calls the <a class="el" href="namespaceVectorTools.html#aebbe1c685f39b991ca3eba870787ee68">project_boundary_values()</a> function, see above, with <code>mapping=<a class="el" href="classMappingQ1.html">MappingQ1</a>&lt;dim&gt;()</code>. </p>

<p>Definition at line <a class="el" href="vector__tools_8templates_8h_source.html#l02242">2242</a> of file <a class="el" href="vector__tools_8templates_8h_source.html">vector_tools.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaed484d7530047b55d6f7a04d41347a4e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::project_boundary_values_curl_conforming </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>first_vector_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>boundary_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em> = <code><a class="el" href="structStaticMappingQ1.html">StaticMappingQ1</a>&lt;&#160;dim&#160;&gt;::mapping</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute constraints that correspond to boundary conditions of the form <img class="formulaInl" alt="$\vec{n}\times\vec{u}=\vec{n}\times\vec{f}$" src="form_612.png"/>, i.e. the tangential components of <img class="formulaInl" alt="$u$" src="form_594.png"/> and <img class="formulaInl" alt="$f$" src="form_451.png"/> shall coincide.</p>
<p>If the <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> <code>constraints</code> contained values or other constraints before, the new ones are added or the old ones overwritten, if a node of the boundary part to be used was already in the list of constraints. This is handled by using inhomogeneous constraints. Please note that when combining adaptive meshes and this kind of constraints, the Dirichlet conditions should be set first, and then completed by hanging node constraints, in order to make sure that the discretization remains consistent. See the discussion on conflicting constraints in the module on <a class="el" href="group__constraints.html">Constraints on degrees of freedom</a> .</p>
<p>This function is explecitly written to use with the <a class="el" href="classFE__Nedelec.html">FE_Nedelec</a> elements. Thus it throws an exception, if it is called with other finite elements.</p>
<p>The second argument of this function denotes the first vector component in the finite element that corresponds to the vector function that you want to constrain. For example, if we want to solve Maxwell's equations in 3d and the finite element has components <img class="formulaInl" alt="$(E_x,E_y,E_z,B_x,B_y,B_z)$" src="form_613.png"/> and we want the boundary conditions <img class="formulaInl" alt="$\vec{n}\times\vec{B}=\vec{n}\times\vec{f}$" src="form_614.png"/>, then <code>first_vector_component</code> would be 3. Vectors are implicitly assumed to have exactly <code>dim</code> components that are ordered in the same way as we usually order the coordinate directions, i.e. <img class="formulaInl" alt="$x$" src="form_9.png"/>-, <img class="formulaInl" alt="$y$" src="form_10.png"/>-, and finally <img class="formulaInl" alt="$z$" src="form_11.png"/>-component.</p>
<p>The parameter <code>boundary_component</code> corresponds to the number <code>boundary_indicator</code> of the face. <a class="el" href="namespacenumbers.html#a4e5d3fa25689151c833ba46dcc96fa5b">numbers::internal_face_boundary_id</a> is an illegal value, since it is reserved for interior faces.</p>
<p>The last argument is denoted to compute the normal vector <img class="formulaInl" alt="$\vec{n}$" src="form_615.png"/> at the boundary points.</p>
<h4>Computing constraints</h4>
<p>To compute the constraints we use projection-based interpolation as proposed in Solin, Segeth and Dolezel (Higher order finite elements, Chapman&amp;Hall, 2004) on every face located at the boundary.</p>
<p>First one projects <img class="formulaInl" alt="$\vec{f}$" src="form_616.png"/> on the lowest-order edge shape functions. Then the remaining part <img class="formulaInl" alt="$(I-P_0)\vec{f}$" src="form_617.png"/> of the function is projected on the remaining higher-order edge shape functions. In the last step we project <img class="formulaInl" alt="$(I-P_0-P_e)\vec{f}$" src="form_618.png"/> on the bubble shape functions defined on the face.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a> </dd></dl>

<p>Definition at line <a class="el" href="vector__tools_8templates_8h_source.html#l03224">3224</a> of file <a class="el" href="vector__tools_8templates_8h_source.html">vector_tools.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga31b221caf4d1f4835a833ac3f578378f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::project_boundary_values_curl_conforming </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>first_vector_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>boundary_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping_collection</em> = <code><a class="el" href="structhp_1_1StaticMappingQ1.html">hp::StaticMappingQ1</a>&lt;&#160;dim&#160;&gt;::mapping_collection</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above for the hp-namespace.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga8a13fe1b8306a0a6f1fed5009a5f99ab"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::project_boundary_values_div_conforming </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>first_vector_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>boundary_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em> = <code><a class="el" href="structStaticMappingQ1.html">StaticMappingQ1</a>&lt;&#160;dim&#160;&gt;::mapping</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute constraints that correspond to boundary conditions of the form <img class="formulaInl" alt="$\vec{n}^T\vec{u}=\vec{n}^T\vec{f}$" src="form_619.png"/>, i.e. the normal components of <img class="formulaInl" alt="$u$" src="form_594.png"/> and <img class="formulaInl" alt="$f$" src="form_451.png"/> shall coincide.</p>
<p>If the <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> <code>constraints</code> contained values or other constraints before, the new ones are added or the old ones overwritten, if a node of the boundary part to be used was already in the list of constraints. This is handled by using inhomogeneous constraints. Please note that when combining adaptive meshes and this kind of constraints, the Dirichlet conditions should be set first, and then completed by hanging node constraints, in order to make sure that the discretization remains consistent. See the discussion on conflicting constraints in the module on <a class="el" href="group__constraints.html">Constraints on degrees of freedom</a> .</p>
<p>This function is explecitly written to use with the <a class="el" href="classFE__RaviartThomas.html">FE_RaviartThomas</a> elements. Thus it throws an exception, if it is called with other finite elements.</p>
<p>The second argument of this function denotes the first vector component in the finite element that corresponds to the vector function that you want to constrain. Vectors are implicitly assumed to have exactly <code>dim</code> components that are ordered in the same way as we usually order the coordinate directions, i.e. <img class="formulaInl" alt="$x$" src="form_9.png"/>-, <img class="formulaInl" alt="$y$" src="form_10.png"/>-, and finally <img class="formulaInl" alt="$z$" src="form_11.png"/>-component.</p>
<p>The parameter <code>boundary_component</code> corresponds to the number <code>boundary_indicator</code> of the face. <a class="el" href="namespacenumbers.html#a4e5d3fa25689151c833ba46dcc96fa5b">numbers::internal_face_boundary_id</a> is an illegal value, since it is reserved for interior faces.</p>
<p>The last argument is denoted to compute the normal vector <img class="formulaInl" alt="$\vec{n}$" src="form_615.png"/> at the boundary points.</p>
<h4>Computing constraints</h4>
<p>To compute the constraints we use interpolation operator proposed in Brezzi, Fortin (Mixed and Hybrid (Finite Element Methods, Springer, 1991) on every face located at the boundary.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a> </dd></dl>

<p>Definition at line <a class="el" href="vector__tools_8templates_8h_source.html#l03805">3805</a> of file <a class="el" href="vector__tools_8templates_8h_source.html">vector_tools.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaa4b3a415d08d0bc2b52308ff9eaa79eb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::project_boundary_values_div_conforming </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>first_vector_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>boundary_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping_collection</em> = <code><a class="el" href="structhp_1_1StaticMappingQ1.html">hp::StaticMappingQ1</a>&lt;&#160;dim&#160;&gt;::mapping_collection</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above for the hp-namespace.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a> </dd></dl>

<p>Definition at line <a class="el" href="vector__tools_8templates_8h_source.html#l03971">3971</a> of file <a class="el" href="vector__tools_8templates_8h_source.html">vector_tools.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="gac705b8be8d8abc9ec2f3d6ca17f2ed20"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, template&lt; int, int &gt; class DH, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::compute_no_normal_flux_constraints </td>
          <td>(</td>
          <td class="paramtype">const DH&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>first_vector_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em> = <code><a class="el" href="structStaticMappingQ1.html">StaticMappingQ1</a>&lt;&#160;dim&#160;&gt;::mapping</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function computes the constraints that correspond to boundary conditions of the form <img class="formulaInl" alt="$\vec n \cdot \vec u=0$" src="form_620.png"/>, i.e. no normal flux if <img class="formulaInl" alt="$\vec u$" src="form_602.png"/> is a vector-valued quantity. These conditions have exactly the form handled by the <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> class, so instead of creating a map between boundary degrees of freedom and corresponding value, we here create a list of constraints that are written into a <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a>. This object may already have some content, for example from hanging node constraints, that remains untouched. These constraints have to be applied to the linear system like any other such constraints, i.e. you have to condense the linear system with the constraints before solving, and you have to distribute the solution vector afterwards.</p>
<p>The use of this function is explained in more detail in <a class="el" href="step_31.html">step-31</a>. It doesn't make much sense in 1d, so the function throws an exception in that case.</p>
<p>The second argument of this function denotes the first vector component in the finite element that corresponds to the vector function that you want to constrain. For example, if we were solving a Stokes equation in 2d and the finite element had components <img class="formulaInl" alt="$(u,v,p)$" src="form_611.png"/>, then <code>first_vector_component</code> would be zero. On the other hand, if we solved the Maxwell equations in 3d and the finite element has components <img class="formulaInl" alt="$(E_x,E_y,E_z,B_x,B_y,B_z)$" src="form_613.png"/> and we want the boundary condition <img class="formulaInl" alt="$\vec n\cdot \vec B=0$" src="form_621.png"/>, then <code>first_vector_component</code> would be 3. Vectors are implicitly assumed to have exactly <code>dim</code> components that are ordered in the same way as we usually order the coordinate directions, i.e. <img class="formulaInl" alt="$x$" src="form_9.png"/>-, <img class="formulaInl" alt="$y$" src="form_10.png"/>-, and finally <img class="formulaInl" alt="$z$" src="form_11.png"/>-component. The function assumes, but can't check, that the vector components in the range <code>[first_vector_component,first_vector_component+dim)</code> come from the same base finite element. For example, in the Stokes example above, it would not make sense to use a <code><a class="el" href="classFESystem.html">FESystem</a>&lt;dim&gt;(<a class="el" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(2), 1, <a class="el" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(1), dim)</code> (note that the first velocity vector component is a <img class="formulaInl" alt="$Q_2$" src="form_622.png"/> element, whereas all the other ones are <img class="formulaInl" alt="$Q_1$" src="form_37.png"/> elements) as there would be points on the boundary where the <img class="formulaInl" alt="$x$" src="form_9.png"/>-velocity is defined but no corresponding <img class="formulaInl" alt="$y$" src="form_10.png"/>- or <img class="formulaInl" alt="$z$" src="form_11.png"/>-velocities.</p>
<p>The third argument denotes the set of boundary indicators on which the boundary condition is to be enforced. Note that, as explained below, this is one of the few functions where it makes a difference where we call the function multiple times with only one boundary indicator, or whether we call the function onces with the whole set of boundary indicators at once.</p>
<p>The mapping argument is used to compute the boundary points where the function needs to request the normal vector <img class="formulaInl" alt="$\vec n$" src="form_603.png"/> from the boundary description.</p>
<dl class="section note"><dt>Note</dt><dd>When combining adaptively refined meshes with hanging node constraints and boundary conditions like from the current function within one <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> object, the hanging node constraints should always be set first, and then the boundary conditions since boundary conditions are not set in the second operation on degrees of freedom that are already constrained. This makes sure that the discretization remains conforming as is needed. See the discussion on conflicting constraints in the module on <a class="el" href="group__constraints.html">Constraints on degrees of freedom</a> .</dd></dl>
<h4>Computing constraints in 2d</h4>
<p>Computing these constraints requires some smarts. The main question revolves around the question what the normal vector is. Consider the following situation: </p>
<div class="image">
<img src="no_normal_flux_1.png" alt="no_normal_flux_1.png"/>
</div>
 <p>Here, we have two cells that use a bilinear mapping (i.e. <a class="el" href="classMappingQ1.html">MappingQ1</a>). Consequently, for each of the cells, the normal vector is perpendicular to the straight edge. If the two edges at the top and right are meant to approximate a curved boundary (as indicated by the dashed line), then neither of the two computed normal vectors are equal to the exact normal vector (though they approximate it as the mesh is refined further). What is worse, if we constrain <img class="formulaInl" alt="$\vec n \cdot \vec u=0$" src="form_620.png"/> at the common vertex with the normal vector from both cells, then we constrain the vector <img class="formulaInl" alt="$\vec u$" src="form_602.png"/> with respect to two linearly independent vectors; consequently, the constraint would be <img class="formulaInl" alt="$\vec u=0$" src="form_623.png"/> at this point (i.e. <em>all</em> components of the vector), which is not what we wanted.</p>
<p>To deal with this situation, the algorithm works in the following way: at each point where we want to constrain <img class="formulaInl" alt="$\vec u$" src="form_602.png"/>, we first collect all normal vectors that adjacent cells might compute at this point. We then do not constrain <img class="formulaInl" alt="$\vec n \cdot \vec u=0$" src="form_620.png"/> for <em>each</em> of these normal vectors but only for the <em>average</em> of the normal vectors. In the example above, we therefore record only a single constraint <img class="formulaInl" alt="$\vec n \cdot \vec {\bar u}=0$" src="form_624.png"/>, where <img class="formulaInl" alt="$\vec {\bar u}$" src="form_625.png"/> is the average of the two indicated normal vectors.</p>
<p>Unfortunately, this is not quite enough. Consider the situation here:</p>
<div class="image">
<img src="no_normal_flux_2.png" alt="no_normal_flux_2.png"/>
</div>
 <p>If again the top and right edges approximate a curved boundary, and the left boundary a separate boundary (for example straight) so that the exact boundary has indeed a corner at the top left vertex, then the above construction would not work: here, we indeed want the constraint that <img class="formulaInl" alt="$\vec u$" src="form_602.png"/> at this point (because the normal velocities with respect to both the left normal as well as the top normal vector should be zero), not that the velocity in the direction of the average normal vector is zero.</p>
<p>Consequently, we use the following heuristic to determine whether all normal vectors computed at one point are to be averaged: if two normal vectors for the same point are computed on <em>different</em> cells, then they are to be averaged. This covers the first example above. If they are computed from the same cell, then the fact that they are different is considered indication that they come from different parts of the boundary that might be joined by a real corner, and must not be averaged.</p>
<p>There is one problem with this scheme. If, for example, the same domain we have considered above, is discretized with the following mesh, then we get into trouble:</p>
<div class="image">
<img src="no_normal_flux_3.png" alt="no_normal_flux_3.png"/>
</div>
 <p>Here, the algorithm assumes that the boundary does not have a corner at the point where faces <img class="formulaInl" alt="$F1$" src="form_626.png"/> and <img class="formulaInl" alt="$F2$" src="form_627.png"/> join because at that point there are two different normal vectors computed from different cells. If you intend for there to be a corner of the exact boundary at this point, the only way to deal with this is to assign the two parts of the boundary different boundary indicators and call this function twice, once for each boundary indicators; doing so will yield only one normal vector at this point per invocation (because we consider only one boundary part at a time), with the result that the normal vectors will not be averaged. This situation also needs to be taken into account when using this function around reentrant corners on Cartesian meshes. If no-normal-flux boundary conditions are to be enforced on non-Cartesian meshes around reentrant corners, one may even get cycles in the constraints as one will in general constrain different components from the two sides. In that case, set a no-slip constraint on the reentrant vertex first.</p>
<h4>Computing constraints in 3d</h4>
<p>The situation is more complicated in 3d. Consider the following case where we want to compute the constraints at the marked vertex:</p>
<div class="image">
<img src="no_normal_flux_4.png" alt="no_normal_flux_4.png"/>
</div>
 <p>Here, we get four different normal vectors, one from each of the four faces that meet at the vertex. Even though they may form a complete set of vectors, it is not our intent to constrain all components of the vector field at this point. Rather, we would like to still allow tangential flow, where the term "tangential" has to be suitably defined.</p>
<p>In a case like this, the algorithm proceeds as follows: for each cell that has computed two tangential vectors at this point, we compute the unconstrained direction as the outer product of the two tangential vectors (if necessary multiplied by minus one). We then average these tangential vectors. Finally, we compute constraints for the two directions perpendicular to this averaged tangential direction.</p>
<p>There are cases where one cell contributes two tangential directions and another one only one; for example, this would happen if both top and front faces of the left cell belong to the boundary selected whereas only the top face of the right cell belongs to it, maybe indicating the the entire front part of the domain is a smooth manifold whereas the top really forms two separate manifolds that meet in a ridge, and that no-flux boundary conditions are only desired on the front manifold and the right one on top. In cases like these, it's difficult to define what should happen. The current implementation simply ignores the one contribution from the cell that only contributes one normal vector. In the example shown, this is acceptable because the normal vector for the front face of the left cell is the same as the normal vector provided by the front face of the right cell (the surface is planar) but it would be a problem if the front manifold would be curved. Regardless, it is unclear how one would proceed in this case and ignoring the single cell is likely the best one can do.</p>
<h4>Results</h4>
<p>Because it makes for good pictures, here are two images of vector fields on a circle and on a sphere to which the constraints computed by this function have been applied:</p>
<div class="image">
<img src="no_normal_flux_5.png" alt="no_normal_flux_5.png"/>
</div>
 <div class="image">
<img src="no_normal_flux_6.png" alt="no_normal_flux_6.png"/>
</div>
 <p>The vectors fields are not physically reasonable but the tangentiality constraint is clearly enforced. The fact that the vector fields are zero at some points on the boundary is an artifact of the way it is created, it is not constrained to be zero at these points.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a> </dd></dl>

<p>Definition at line <a class="el" href="vector__tools_8templates_8h_source.html#l04109">4109</a> of file <a class="el" href="vector__tools_8templates_8h_source.html">vector_tools.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga9fe6189e8235d2fcaa0b6e4f5c249620"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DH , class SparsityPattern &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::make_sparsity_pattern </td>
          <td>(</td>
          <td class="paramtype">const DH &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>sparsity_pattern</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000108">Deprecated:</a></b></dt><dd>This is the old form of the previous function. It generates a table of <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">DoFTools::Coupling</a> values (where a <code>true</code> value in the mask is translated into a Coupling::always value in the table) and calls the function above. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3473fa2eb6d555499a53d1f59600beff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DH , class SparsityPattern &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::make_sparsity_pattern </td>
          <td>(</td>
          <td class="paramtype">const DH &amp;&#160;</td>
          <td class="paramname"><em>dof_row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DH &amp;&#160;</td>
          <td class="paramname"><em>dof_col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>sparsity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct a sparsity pattern that allows coupling degrees of freedom on two different but related meshes.</p>
<p>The idea is that if the two given <a class="el" href="classDoFHandler.html">DoFHandler</a> objects correspond to two different meshes (and potentially to different finite elements used on these cells), but that if the two triangulations they are based on are derived from the same coarse mesh through hierarchical refinement, then one may set up a problem where one would like to test shape functions from one mesh against the shape functions from another mesh. In particular, this means that shape functions from a cell on the first mesh are tested against those on the second cell that are located on the corresponding cell; this correspondence is something that the IntergridMap class can determine.</p>
<p>This function then constructs a sparsity pattern for which the degrees of freedom that represent the rows come from the first given <a class="el" href="classDoFHandler.html">DoFHandler</a>, whereas the ones that correspond to columns come from the second <a class="el" href="classDoFHandler.html">DoFHandler</a>. </p>

</div>
</div>
<a class="anchor" id="ga60b493fa4c36d86a15c8599eef8c0e32"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DH , class SparsityPattern &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::make_boundary_sparsity_pattern </td>
          <td>(</td>
          <td class="paramtype">const DH &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_to_boundary_mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>sparsity_pattern</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create the sparsity pattern for boundary matrices. See the general documentation of this class for more information.</p>
<p>The actual type of the sparsity pattern may be <a class="el" href="classSparsityPattern.html">SparsityPattern</a>, <a class="el" href="classCompressedSparsityPattern.html">CompressedSparsityPattern</a>, <a class="el" href="classBlockSparsityPattern.html">BlockSparsityPattern</a>, <a class="el" href="classBlockCompressedSparsityPattern.html">BlockCompressedSparsityPattern</a>, <a class="el" href="classBlockCompressedSetSparsityPattern.html">BlockCompressedSetSparsityPattern</a>, or any other class that satisfies similar requirements. It is assumed that the size of the sparsity pattern is already correct. </p>

</div>
</div>
<a class="anchor" id="gae0f7a1d36c8b92a17bf8c4d939d56fb1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DH , class SparsityPattern &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::make_boundary_sparsity_pattern </td>
          <td>(</td>
          <td class="paramtype">const DH &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="structFunctionMap.html">FunctionMap</a>&lt; DH::space_dimension &gt;::type &amp;&#160;</td>
          <td class="paramname"><em>boundary_indicators</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_to_boundary_mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>sparsity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write the sparsity structure of the matrix composed of the basis functions on the boundary into the matrix structure. In contrast to the previous function, only those parts of the boundary are considered of which the boundary indicator is listed in the set of numbers passed to this function.</p>
<p>In fact, rather than a <code>set</code> of boundary indicators, a <code>map</code> needs to be passed, since most of the functions handling with boundary indicators take a mapping of boundary indicators and the respective boundary functions. The boundary function, however, is ignored in this function. If you have no functions at hand, but only the boundary indicators, set the function pointers to null pointers.</p>
<p>For the type of the sparsity pattern, the same holds as said above. </p>

</div>
</div>
<a class="anchor" id="ga3c77cf114c08113c66eb68904dab7f02"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DH , class SparsityPattern &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::make_flux_sparsity_pattern </td>
          <td>(</td>
          <td class="paramtype">const DH &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>sparsity_pattern</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate sparsity pattern for fluxes, i.e. formulations of the discrete problem with discontinuous elements which couple across faces of cells. This is a replacement of the function <code>make_sparsity_pattern</code> for discontinuous methods. Since the fluxes include couplings between neighboring elements, the normal couplings and these extra matrix entries are considered. </p>

</div>
</div>
<a class="anchor" id="ga3fda57552521d870cc7737b1fde71014"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DH , class SparsityPattern &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::make_flux_sparsity_pattern </td>
          <td>(</td>
          <td class="paramtype">const DH &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>sparsity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTable.html">Table</a>&lt; 2, Coupling &gt; &amp;&#160;</td>
          <td class="paramname"><em>int_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTable.html">Table</a>&lt; 2, Coupling &gt; &amp;&#160;</td>
          <td class="paramname"><em>flux_mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function does the same as the other with the same name, but it gets two additional coefficient matrices. A matrix entry will only be generated for two basis functions, if there is a non-zero entry linking their associated components in the coefficient matrix.</p>
<p>There is one matrix for couplings in a cell and one for the couplings occuring in fluxes.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000031">Todo:</a></b></dt><dd>Not implemented for <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga86bd4cc354a5278005202d57257c178c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::extract_hanging_node_dofs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>selected_dofs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Select all dofs that will be constrained by interface constraints, i.e. all hanging nodes.</p>
<p>The size of <code>selected_dofs</code> shall equal <code>dof_handler.n_dofs()</code>. Previous contents of this array or overwritten. </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jan 27 2014 15:27:14 for The deal.II Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
