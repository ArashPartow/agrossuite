<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>The deal.II Library: DataPostprocessor&lt; dim &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="http://www.dealii.org/deal.ico"></link>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2014 by the deal.II authors"></meta>
<meta name="deal.II-version" content="8.1.0"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 8.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classDataPostprocessor-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">DataPostprocessor&lt; dim &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group__output.html">Graphical output</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="data__postprocessor_8h_source.html">data_postprocessor.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for DataPostprocessor&lt; dim &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classDataPostprocessor__inherit__graph.svg" width="672" height="195"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad54b5476e500f6277d29b178075c3cb5"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPostprocessor.html#ad54b5476e500f6277d29b178075c3cb5">~DataPostprocessor</a> ()</td></tr>
<tr class="separator:ad54b5476e500f6277d29b178075c3cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e270c5c9b832a36b61f8a2ba7258f03"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPostprocessor.html#a0e270c5c9b832a36b61f8a2ba7258f03">compute_derived_quantities_scalar</a> (const std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;uh, const std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt; &gt; &amp;duh, const std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim &gt; &gt; &amp;dduh, const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;normals, std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt; &amp;computed_quantities) const <a class="el" href="group__Sparsity.html#ga0849dabf81f46d4d964e251c286784dd">DEAL_II_DEPRECATED</a></td></tr>
<tr class="separator:a0e270c5c9b832a36b61f8a2ba7258f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39c063fc47740952dc29cfcb861fbb4f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPostprocessor.html#a39c063fc47740952dc29cfcb861fbb4f">compute_derived_quantities_scalar</a> (const std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;uh, const std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt; &gt; &amp;duh, const std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim &gt; &gt; &amp;dduh, const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;normals, const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;evaluation_points, std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt; &amp;computed_quantities) const </td></tr>
<tr class="separator:a39c063fc47740952dc29cfcb861fbb4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc1d3c63c2f069689841782cfd68e1cc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPostprocessor.html#adc1d3c63c2f069689841782cfd68e1cc">compute_derived_quantities_vector</a> (const std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt; &amp;uh, const std::vector&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt; &gt; &gt; &amp;duh, const std::vector&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim &gt; &gt; &gt; &amp;dduh, const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;normals, std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt; &amp;computed_quantities) const <a class="el" href="group__Sparsity.html#ga0849dabf81f46d4d964e251c286784dd">DEAL_II_DEPRECATED</a></td></tr>
<tr class="separator:adc1d3c63c2f069689841782cfd68e1cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabfd7ef3eec0d636e0c69f8740af29f9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPostprocessor.html#aabfd7ef3eec0d636e0c69f8740af29f9">compute_derived_quantities_vector</a> (const std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt; &amp;uh, const std::vector&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt; &gt; &gt; &amp;duh, const std::vector&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim &gt; &gt; &gt; &amp;dduh, const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;normals, const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;evaluation_points, std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt; &amp;computed_quantities) const </td></tr>
<tr class="separator:aabfd7ef3eec0d636e0c69f8740af29f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a254f38bcdf4bdb5aa94231b695da7d55"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPostprocessor.html#a254f38bcdf4bdb5aa94231b695da7d55">get_names</a> () const =0</td></tr>
<tr class="separator:a254f38bcdf4bdb5aa94231b695da7d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfe096c6db118311a1389c31d7e2d773"><td class="memItemLeft" align="right" valign="top">virtual std::vector<br class="typebreak"/>
&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPostprocessor.html#abfe096c6db118311a1389c31d7e2d773">get_data_component_interpretation</a> () const </td></tr>
<tr class="separator:abfe096c6db118311a1389c31d7e2d773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadecdd040447b395164397ea1196f721"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPostprocessor.html#aadecdd040447b395164397ea1196f721">get_needed_update_flags</a> () const =0</td></tr>
<tr class="separator:aadecdd040447b395164397ea1196f721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSubscriptor"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSubscriptor')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSubscriptor.html">Subscriptor</a></td></tr>
<tr class="memitem:ae5541017c0966b0af345db75895106f2 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#ae5541017c0966b0af345db75895106f2">Subscriptor</a> ()</td></tr>
<tr class="separator:ae5541017c0966b0af345db75895106f2 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367fce3122075f05f168d14f114b4c65 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a367fce3122075f05f168d14f114b4c65">Subscriptor</a> (const <a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;)</td></tr>
<tr class="separator:a367fce3122075f05f168d14f114b4c65 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c6c557e06110d2127fa6459119e94af inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a6c6c557e06110d2127fa6459119e94af">~Subscriptor</a> ()</td></tr>
<tr class="separator:a6c6c557e06110d2127fa6459119e94af inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24ee69d4b3cf9690d1208b2443cbbb80 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a24ee69d4b3cf9690d1208b2443cbbb80">operator=</a> (const <a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;)</td></tr>
<tr class="separator:a24ee69d4b3cf9690d1208b2443cbbb80 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3422499827ecd52f1d12d65eb6cc3125 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a3422499827ecd52f1d12d65eb6cc3125">subscribe</a> (const char *identifier=0) const </td></tr>
<tr class="separator:a3422499827ecd52f1d12d65eb6cc3125 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b4839b1cffc18781144ede1744b35ea inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a2b4839b1cffc18781144ede1744b35ea">unsubscribe</a> (const char *identifier=0) const </td></tr>
<tr class="separator:a2b4839b1cffc18781144ede1744b35ea inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b45274c8e1936bff024df01d618e86f inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a7b45274c8e1936bff024df01d618e86f">n_subscriptions</a> () const </td></tr>
<tr class="separator:a7b45274c8e1936bff024df01d618e86f inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbbc5f845063b1f23223b7ac96e89e13 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#adbbc5f845063b1f23223b7ac96e89e13">list_subscribers</a> () const </td></tr>
<tr class="separator:adbbc5f845063b1f23223b7ac96e89e13 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2f0251d20c6a5295024de3b2e9b4359 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac2f0251d20c6a5295024de3b2e9b4359">DeclException3</a> (ExcInUse, <a class="el" href="classint.html">int</a>, char *, std::string &amp;,&lt;&lt; &quot;Object of class &quot;&lt;&lt; arg2&lt;&lt; &quot; is still used by &quot;&lt;&lt; arg1&lt;&lt; &quot; other objects.\n&quot;&lt;&lt; &quot;(Additional information: &quot;&lt;&lt; arg3&lt;&lt; &quot;)\n&quot;&lt;&lt; &quot;Note the entry in the Frequently Asked Questions of &quot;&lt;&lt; &quot;deal.II (linked to from http://www.dealii.org/) for &quot;&lt;&lt; &quot;more information on what this error means.&quot;)</td></tr>
<tr class="separator:gac2f0251d20c6a5295024de3b2e9b4359 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e000d9ce953da6afe4bbbaca4397344 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga9e000d9ce953da6afe4bbbaca4397344">DeclException2</a> (ExcNoSubscriber, char *, char *,&lt;&lt; &quot;No subscriber with identifier \&quot;&quot;&lt;&lt; arg2&lt;&lt; &quot;\&quot; did <a class="el" href="classSubscriptor.html#a3422499827ecd52f1d12d65eb6cc3125">subscribe</a> to this object of class &quot;&lt;&lt; arg1)</td></tr>
<tr class="separator:ga9e000d9ce953da6afe4bbbaca4397344 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38 inherit pub_methods_classSubscriptor"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38 inherit pub_methods_classSubscriptor"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:a68efd17a8330ab676d9cd711029b0f38 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int dim&gt;<br/>
class DataPostprocessor&lt; dim &gt;</h3>

<p>For the (graphical) output of a FE solution one frequently wants to include derived quantities, which are calculated from the values of the solution and possibly the first and second derivates of the solution. Examples are the calculation Mach numbers from velocity and density in supersonic flow computations, or the computation of the magnitude of a complex-valued solution as demonstrated in <a class="el" href="step_29.html">step-29</a>. Other uses are shown in <a class="el" href="step_32.html">step-32</a> and <a class="el" href="step_33.html">step-33</a>. This class offers the interface to perform such postprocessing. Given the values and derivatives of the solution at those points where we want to generated output, the functions of this class can be overloaded to compute new quantities.</p>
<p>A data vector and an object of a derived class can be given to the <a class="el" href="classDataOut__DoFData.html#a59a6b70a4b909e0229a20487dd68cc43">DataOut::add_data_vector()</a> function, which will write the derived quantities instead of the provided data to the output file. Note, that the <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a> has to live until <a class="el" href="classDataOut.html#ab3d44201acb97fba286a897452236b51">DataOut::build_patches</a> has been called. <a class="el" href="classDataOutFaces.html">DataOutFaces</a> and <a class="el" href="classDataOutRotation.html">DataOutRotation</a> can be used as well.</p>
<p>In order not to perform needless calculations, <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a> has to provide information which input data is needed for the calculation of the derived quantities, i.e. whether it needs the values, the first derivative and/or the second derivative of the provided data. <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a> objects which are used in combination with a <a class="el" href="classDataOutFaces.html">DataOutFaces</a> object can also ask for the normal vectors at each point. The information which data is needed has to be provided via the UpdateFlags returned by the virtual function <a class="el" href="classDataPostprocessor.html#aadecdd040447b395164397ea1196f721">get_needed_update_flags()</a>. It is your responsibility to use only those values which were updated in the calculation of derived quantities. The <a class="el" href="classDataOut.html">DataOut</a> object will provide references to the requested data in the call to <a class="el" href="classDataPostprocessor.html#a0e270c5c9b832a36b61f8a2ba7258f03">compute_derived_quantities_scalar()</a> or <a class="el" href="classDataPostprocessor.html#adc1d3c63c2f069689841782cfd68e1cc">compute_derived_quantities_vector()</a> (<a class="el" href="classDataOut.html">DataOut</a> decides which of the two functions to call depending on whether the finite element in use has only a single, or multiple vector components; note that this is only determined by the number of components in the finite element in use, and not by whether the data computed by a class derived from the current one is scalar or vector valued).</p>
<p>Furthermore, derived classes have to implement the <a class="el" href="classDataPostprocessor.html#a254f38bcdf4bdb5aa94231b695da7d55">get_names()</a> function, where the number of output variables returned by the latter function has to match the size of the vector returned by the former. Furthermore, this number has to match the number of computed quantities, of course.</p>
<h3>Use in simpler cases</h3>
<p>Deriving from the current class allows to implement very general postprocessors. For example, in the <a class="el" href="step_32.html">step-32</a> program, we implement a postprocessor that takes a solution that consists of velocity, pressure and temperature (dim+2 components) and computes a variety of output quantities, some of which are vector valued and some of which are scalar. On the other hand, in <a class="el" href="step_29.html">step-29</a> we implement a postprocessor that only computes the magnitude of a complex number given by a two-component finite element. It seems silly to have to implement four virtual functions for this (<a class="el" href="classDataPostprocessor.html#a0e270c5c9b832a36b61f8a2ba7258f03">compute_derived_quantities_scalar()</a> or <a class="el" href="classDataPostprocessor.html#adc1d3c63c2f069689841782cfd68e1cc">compute_derived_quantities_vector()</a>, <a class="el" href="classDataPostprocessor.html#a254f38bcdf4bdb5aa94231b695da7d55">get_names()</a>, get_update_flags() and <a class="el" href="classDataPostprocessor.html#abfe096c6db118311a1389c31d7e2d773">get_data_component_interpretation()</a>).</p>
<p>To this end there are two classes <a class="el" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a> and <a class="el" href="classDataPostprocessorVector.html">DataPostprocessorVector</a> that are meant to be used if the output quantity is either a single scalar or a single vector (here used meaning to have exactly dim components). When using these classes, one only has to write a constructor that passes the name of the output variable and the update flags to the constructor of the base class and overload the function that actually computes the results.</p>
<dl class="section author"><dt>Author</dt><dd>Tobias Leicht, 2007 </dd></dl>

<p>Definition at line <a class="el" href="data__postprocessor_8h_source.html#l00103">103</a> of file <a class="el" href="data__postprocessor_8h_source.html">data_postprocessor.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ad54b5476e500f6277d29b178075c3cb5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a>&lt; dim &gt;::~<a class="el" href="classDataPostprocessor.html">DataPostprocessor</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Virtual desctructor for safety. Does not do anything. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a0e270c5c9b832a36b61f8a2ba7258f03"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a>&lt; dim &gt;::compute_derived_quantities_scalar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>uh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>duh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>dduh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>normals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>computed_quantities</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000176">Deprecated:</a></b></dt><dd></dd></dl>
<p>This function only exists for backward compatibility as this is the interface provided by previous versions of the library. The default implementation of the other function of same name below calls this function by simply dropping the argument that denotes the evaluation points. Since this function might at one point go away, you should overload the other function instead. </p>

</div>
</div>
<a class="anchor" id="a39c063fc47740952dc29cfcb861fbb4f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a>&lt; dim &gt;::compute_derived_quantities_scalar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>uh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>duh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>dduh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>normals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>evaluation_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>computed_quantities</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the main function which actually performs the postprocessing. The last argument is a reference to the postprocessed data which has correct size already and must be filled by this function. <code>uh</code> is a reference to a vector of data values at all points, <code>duh</code> the same for gradients, <code>dduh</code> for second derivatives and <code>normals</code> is a reference to the normal vectors. Note, that the last four references will only contain valid data, if the respective flags are returned by <code>get_needed_update_flags</code>, otherwise those vectors will be in an unspecified state. <code>normals</code> will always be an empty vector when working on cells, not on faces.</p>
<p>This function is called when the original data vector represents scalar data, i.e. the finite element in use has only a single vector component. </p>

</div>
</div>
<a class="anchor" id="adc1d3c63c2f069689841782cfd68e1cc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a>&lt; dim &gt;::compute_derived_quantities_vector </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>uh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>duh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>dduh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>normals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>computed_quantities</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000177">Deprecated:</a></b></dt><dd></dd></dl>
<p>This function only exists for backward compatibility as this is the interface provided by previous versions of the library. The default implementation of the other function of same name below calls this function by simply dropping the argument that denotes the evaluation points. Since this function might at one point go away, you should overload the other function instead. </p>

</div>
</div>
<a class="anchor" id="aabfd7ef3eec0d636e0c69f8740af29f9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a>&lt; dim &gt;::compute_derived_quantities_vector </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>uh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>duh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>dduh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>normals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>evaluation_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>computed_quantities</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as the <a class="el" href="classDataPostprocessor.html#a0e270c5c9b832a36b61f8a2ba7258f03">compute_derived_quantities_scalar()</a> function, but this function is called when the original data vector represents vector data, i.e. the finite element in use has multiple vector components. </p>

</div>
</div>
<a class="anchor" id="a254f38bcdf4bdb5aa94231b695da7d55"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::string&gt; <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a>&lt; dim &gt;::get_names </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the vector of strings describing the names of the computed quantities. </p>

<p>Implemented in <a class="el" href="classDataPostprocessorVector.html#ae0fc154817fc081f45c781632ece68cd">DataPostprocessorVector&lt; dim &gt;</a>, and <a class="el" href="classDataPostprocessorScalar.html#a281c2778d770c33fed406513b99f90a5">DataPostprocessorScalar&lt; dim &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="abfe096c6db118311a1389c31d7e2d773"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;<a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a>&gt; <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a>&lt; dim &gt;::get_data_component_interpretation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This functions returns information about how the individual components of output files that consist of more than one data set are to be interpreted.</p>
<p>For example, if one has a finite element for the Stokes equations in 2d, representing components (u,v,p), one would like to indicate that the first two, u and v, represent a logical vector so that later on when we generate graphical output we can hand them off to a visualization program that will automatically know to render them as a vector field, rather than as two separate and independent scalar fields.</p>
<p>The default implementation of this function returns a vector of values <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>, indicating that all output components are independent scalar fields. However, if a derived class produces data that represents vectors, it may return a vector that contains values <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>. In the example above, one would return a vector with components (<a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>, <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>, <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>) for (u,v,p). </p>

<p>Reimplemented in <a class="el" href="classDataPostprocessorVector.html#a2312510559a9e518a5d3d98a05b4c2ff">DataPostprocessorVector&lt; dim &gt;</a>, and <a class="el" href="classDataPostprocessorScalar.html#a3345e2cb9d021a82c42beec3fe2aa14c">DataPostprocessorScalar&lt; dim &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="aadecdd040447b395164397ea1196f721"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a>&lt; dim &gt;::get_needed_update_flags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return, which data has to be provided to compute the derived quantities. This has to be a combination of <code>update_values</code>, <code>update_gradients</code> and <code>update_hessians</code>. If the <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a> is to be used in combination with <a class="el" href="classDataOutFaces.html">DataOutFaces</a>, you may also ask for a update of normals via the <code>update_normal_vectors</code> flag. </p>

<p>Implemented in <a class="el" href="classDataPostprocessorVector.html#a152502ba2dce1a17ed2afaa13c0a3d9d">DataPostprocessorVector&lt; dim &gt;</a>, and <a class="el" href="classDataPostprocessorScalar.html#afcc75e12168d848614a1b292c59a1f1d">DataPostprocessorScalar&lt; dim &gt;</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/deal.II/numerics/<a class="el" href="data__postprocessor_8h_source.html">data_postprocessor.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jan 27 2014 15:27:17 for The deal.II Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
