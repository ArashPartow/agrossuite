<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>The deal.II Library: IndexSet Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="http://www.dealii.org/deal.ico"></link>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2014 by the deal.II authors"></meta>
<meta name="deal.II-version" content="8.1.0"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 8.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classIndexSet-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">IndexSet Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="index__set_8h_source.html">index_set.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structIndexSet_1_1Range.html">Range</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a765acb4655708ac63f0b58fef14a617e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#a765acb4655708ac63f0b58fef14a617e">IndexSet</a> ()</td></tr>
<tr class="separator:a765acb4655708ac63f0b58fef14a617e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a292cb326b9f870d569ddf45e453b2676"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#a292cb326b9f870d569ddf45e453b2676">IndexSet</a> (const <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> <a class="el" href="classIndexSet.html#aa6019f5ebeb06c551a010050bc8e61fe">size</a>)</td></tr>
<tr class="separator:a292cb326b9f870d569ddf45e453b2676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a3d75a9cba3f1a50866691327aa7609"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#a8a3d75a9cba3f1a50866691327aa7609">clear</a> ()</td></tr>
<tr class="separator:a8a3d75a9cba3f1a50866691327aa7609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1859f61cfbeafaf715add21291d5c8d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#a1859f61cfbeafaf715add21291d5c8d1">set_size</a> (const <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> <a class="el" href="classIndexSet.html#aa6019f5ebeb06c551a010050bc8e61fe">size</a>)</td></tr>
<tr class="separator:a1859f61cfbeafaf715add21291d5c8d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6019f5ebeb06c551a010050bc8e61fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#aa6019f5ebeb06c551a010050bc8e61fe">size</a> () const </td></tr>
<tr class="separator:aa6019f5ebeb06c551a010050bc8e61fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15cb4a9a8f8cc58bed6c9daedea26489"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#a15cb4a9a8f8cc58bed6c9daedea26489">add_range</a> (const <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> begin, const <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> end)</td></tr>
<tr class="separator:a15cb4a9a8f8cc58bed6c9daedea26489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62b8e5ebeea4705fa26845fd7a56aaa9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#a62b8e5ebeea4705fa26845fd7a56aaa9">add_index</a> (const <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> index)</td></tr>
<tr class="separator:a62b8e5ebeea4705fa26845fd7a56aaa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd3cb227b79aee79b10da86b6841399d"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator &gt; </td></tr>
<tr class="memitem:afd3cb227b79aee79b10da86b6841399d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIndexSet.html#afd3cb227b79aee79b10da86b6841399d">add_indices</a> (const ForwardIterator &amp;begin, const ForwardIterator &amp;end)</td></tr>
<tr class="separator:afd3cb227b79aee79b10da86b6841399d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d7d0507018483fb625ecf1358187e26"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#a4d7d0507018483fb625ecf1358187e26">add_indices</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;other, const unsigned <a class="el" href="classint.html">int</a> offset=0)</td></tr>
<tr class="separator:a4d7d0507018483fb625ecf1358187e26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f6de2f2aa20f3a776d949f78f4490e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#a5f6de2f2aa20f3a776d949f78f4490e1">is_element</a> (const <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> index) const </td></tr>
<tr class="separator:a5f6de2f2aa20f3a776d949f78f4490e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02f9a8640d5a485b611a136201d13c0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#a02f9a8640d5a485b611a136201d13c0d">is_contiguous</a> () const </td></tr>
<tr class="separator:a02f9a8640d5a485b611a136201d13c0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a009610d130eba9a99a3cb6ad9bec457b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#a009610d130eba9a99a3cb6ad9bec457b">n_elements</a> () const </td></tr>
<tr class="separator:a009610d130eba9a99a3cb6ad9bec457b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fa629a1f9a3cfce2c1d8e05905cc6f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#a9fa629a1f9a3cfce2c1d8e05905cc6f2">nth_index_in_set</a> (const unsigned <a class="el" href="classint.html">int</a> local_index) const </td></tr>
<tr class="separator:a9fa629a1f9a3cfce2c1d8e05905cc6f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45462843cbe29ea393563aae6d0e9b1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#a45462843cbe29ea393563aae6d0e9b1a">index_within_set</a> (const <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> global_index) const </td></tr>
<tr class="separator:a45462843cbe29ea393563aae6d0e9b1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d18db39432524a4f7df121124ffaf70"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#a8d18db39432524a4f7df121124ffaf70">n_intervals</a> () const </td></tr>
<tr class="separator:a8d18db39432524a4f7df121124ffaf70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeb798101f61c7efc03bcadc86f5987a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#aeeb798101f61c7efc03bcadc86f5987a">compress</a> () const </td></tr>
<tr class="separator:aeeb798101f61c7efc03bcadc86f5987a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc3cb5e3927170f1745d3c183010d36a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#acc3cb5e3927170f1745d3c183010d36a">operator==</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;is) const </td></tr>
<tr class="separator:acc3cb5e3927170f1745d3c183010d36a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cfa6add639f49f69751151303ab7a0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#a3cfa6add639f49f69751151303ab7a0a">operator!=</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;is) const </td></tr>
<tr class="separator:a3cfa6add639f49f69751151303ab7a0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d4a7739a6b41d9ab6e3be7e09e1d1ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIndexSet.html">IndexSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#a1d4a7739a6b41d9ab6e3be7e09e1d1ca">operator&amp;</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;is) const </td></tr>
<tr class="separator:a1d4a7739a6b41d9ab6e3be7e09e1d1ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7af8c5450b63588594d21c02df3b854"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIndexSet.html">IndexSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#ab7af8c5450b63588594d21c02df3b854">get_view</a> (const <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> begin, const <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> end) const </td></tr>
<tr class="separator:ab7af8c5450b63588594d21c02df3b854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac15601b7c5742d386127b3ecabf61cf8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#ac15601b7c5742d386127b3ecabf61cf8">subtract_set</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;other)</td></tr>
<tr class="separator:ac15601b7c5742d386127b3ecabf61cf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8750378396309e3e90725292a8d3d168"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#a8750378396309e3e90725292a8d3d168">fill_index_vector</a> (std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;indices) const </td></tr>
<tr class="separator:a8750378396309e3e90725292a8d3d168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aa35d3794a20f50f73cd1faa641860c"><td class="memTemplParams" colspan="2">template&lt;typename Vector &gt; </td></tr>
<tr class="memitem:a4aa35d3794a20f50f73cd1faa641860c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIndexSet.html#a4aa35d3794a20f50f73cd1faa641860c">fill_binary_vector</a> (<a class="el" href="classVector.html">Vector</a> &amp;vector) const </td></tr>
<tr class="separator:a4aa35d3794a20f50f73cd1faa641860c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0856dd9662b4c08e1999a77d71539130"><td class="memTemplParams" colspan="2">template&lt;class STREAM &gt; </td></tr>
<tr class="memitem:a0856dd9662b4c08e1999a77d71539130"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIndexSet.html#a0856dd9662b4c08e1999a77d71539130">print</a> (STREAM &amp;out) const </td></tr>
<tr class="separator:a0856dd9662b4c08e1999a77d71539130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d378b33cf76208b7531375250fe3697"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#a9d378b33cf76208b7531375250fe3697">write</a> (std::ostream &amp;out) const </td></tr>
<tr class="separator:a9d378b33cf76208b7531375250fe3697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80613305bf8a26f68dfe841e084d5045"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#a80613305bf8a26f68dfe841e084d5045">read</a> (std::istream &amp;in)</td></tr>
<tr class="separator:a80613305bf8a26f68dfe841e084d5045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8093fd6dd293bc1598aa568f9c406e38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#a8093fd6dd293bc1598aa568f9c406e38">block_write</a> (std::ostream &amp;out) const </td></tr>
<tr class="separator:a8093fd6dd293bc1598aa568f9c406e38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9975dcc4ba3b7f5a5e22b52ff44db8bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#a9975dcc4ba3b7f5a5e22b52ff44db8bd">block_read</a> (std::istream &amp;in)</td></tr>
<tr class="separator:a9975dcc4ba3b7f5a5e22b52ff44db8bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1ca2471173d25742b2cebdc203c6c2f"><td class="memItemLeft" align="right" valign="top">Epetra_Map&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#ae1ca2471173d25742b2cebdc203c6c2f">make_trilinos_map</a> (const MPI_Comm &amp;communicator=MPI_COMM_WORLD, const <a class="el" href="classbool.html">bool</a> overlapping=false) const </td></tr>
<tr class="separator:ae1ca2471173d25742b2cebdc203c6c2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac14fbe3a5191f1d333c41db16fff59d5"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#ac14fbe3a5191f1d333c41db16fff59d5">memory_consumption</a> () const </td></tr>
<tr class="separator:ac14fbe3a5191f1d333c41db16fff59d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00311c3ac951f94ce2b9c5fc5f47ce30"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a00311c3ac951f94ce2b9c5fc5f47ce30"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DeclException1</b> (ExcIndexNotPresent, <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>,&lt;&lt; &quot;The global index &quot;&lt;&lt; arg1&lt;&lt; &quot; is not an element of this set.&quot;)</td></tr>
<tr class="separator:a00311c3ac951f94ce2b9c5fc5f47ce30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6996bfbeb7950e706a46a755b4600dcb"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a6996bfbeb7950e706a46a755b4600dcb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIndexSet.html#a6996bfbeb7950e706a46a755b4600dcb">serialize</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:a6996bfbeb7950e706a46a755b4600dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a8363bd9feae32b6a49ca5823586ae8ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#a8363bd9feae32b6a49ca5823586ae8ed">do_compress</a> () const </td></tr>
<tr class="separator:a8363bd9feae32b6a49ca5823586ae8ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ac1473031a61493d84806614ac902bb59"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structIndexSet_1_1Range.html">Range</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#ac1473031a61493d84806614ac902bb59">ranges</a></td></tr>
<tr class="separator:ac1473031a61493d84806614ac902bb59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa971e41b981640576254569d9a75530f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#aa971e41b981640576254569d9a75530f">is_compressed</a></td></tr>
<tr class="separator:aa971e41b981640576254569d9a75530f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a369c8fbcbe2450b72b0823b85e4bd8f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#a369c8fbcbe2450b72b0823b85e4bd8f1">index_space_size</a></td></tr>
<tr class="separator:a369c8fbcbe2450b72b0823b85e4bd8f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05edbc37d50b4dd4ace9a83275175e47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#a05edbc37d50b4dd4ace9a83275175e47">largest_range</a></td></tr>
<tr class="separator:a05edbc37d50b4dd4ace9a83275175e47"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a9ce660b8e47e336e4842066394d44a65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIndexSet.html">IndexSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#a9ce660b8e47e336e4842066394d44a65">complete_index_set</a> (const unsigned <a class="el" href="classint.html">int</a> N)</td></tr>
<tr class="separator:a9ce660b8e47e336e4842066394d44a65"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A class that represents a subset of indices among a larger set. For example, it can be used to denote the set of degrees of freedom within the range <img class="formulaInl" alt="$[0,\text{dof\_handler.n\_dofs})$" src="form_493.png"/> that belongs to a particular subdomain, or those among all degrees of freedom that are stored on a particular processor in a distributed parallel computation.</p>
<p>This class can represent a collection of half-open ranges of indices as well as individual elements. For practical purposes it also stores the overall range these indices can assume. In other words, you need to specify the size of the index space <img class="formulaInl" alt="$[0,\text{size})$" src="form_494.png"/> of which objects of this class are a subset.</p>
<p>The data structures used in this class along with a rationale can be found in the <a class="el" href="DEALGlossary.html#distributed_paper">Distributed Computing paper</a>.</p>
<dl class="section author"><dt>Author</dt><dd>Wolfgang Bangerth, 2009 </dd></dl>

<p>Definition at line <a class="el" href="index__set_8h_source.html#l00060">60</a> of file <a class="el" href="index__set_8h_source.html">index_set.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a765acb4655708ac63f0b58fef14a617e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IndexSet::IndexSet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Default constructor. </p>

<p>Definition at line <a class="el" href="index__set_8h_source.html#l00641">641</a> of file <a class="el" href="index__set_8h_source.html">index_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="a292cb326b9f870d569ddf45e453b2676"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IndexSet::IndexSet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor that also sets the overall size of the index range. </p>

<p>Definition at line <a class="el" href="index__set_8h_source.html#l00651">651</a> of file <a class="el" href="index__set_8h_source.html">index_set.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a8a3d75a9cba3f1a50866691327aa7609"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IndexSet::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Remove all indices from this index set. The index set retains its size, however. </p>

<p>Definition at line <a class="el" href="index__set_8h_source.html#l00662">662</a> of file <a class="el" href="index__set_8h_source.html">index_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1859f61cfbeafaf715add21291d5c8d1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IndexSet::set_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the maximal size of the indices upon which this object operates.</p>
<p>This function can only be called if the index set does not yet contain any elements. This can be achieved by calling <a class="el" href="classIndexSet.html#a8a3d75a9cba3f1a50866691327aa7609">clear()</a>, for example. </p>

<p>Definition at line <a class="el" href="index__set_8h_source.html#l00672">672</a> of file <a class="el" href="index__set_8h_source.html">index_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa6019f5ebeb06c551a010050bc8e61fe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> IndexSet::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the size of the index space of which this index set is a subset of.</p>
<p>Note that the result is not equal to the number of indices within this set. The latter information is returned by <a class="el" href="classIndexSet.html#a009610d130eba9a99a3cb6ad9bec457b">n_elements()</a>. </p>

<p>Definition at line <a class="el" href="index__set_8h_source.html#l00685">685</a> of file <a class="el" href="index__set_8h_source.html">index_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="a15cb4a9a8f8cc58bed6c9daedea26489"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IndexSet::add_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add the half-open range <img class="formulaInl" alt="$[\text{begin},\text{end})$" src="form_495.png"/> to the set of indices represented by this class. </p>

<p>Definition at line <a class="el" href="index__set_8h_source.html#l00706">706</a> of file <a class="el" href="index__set_8h_source.html">index_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="a62b8e5ebeea4705fa26845fd7a56aaa9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IndexSet::add_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add an individual index to the set of indices. </p>

<p>Definition at line <a class="el" href="index__set_8h_source.html#l00740">740</a> of file <a class="el" href="index__set_8h_source.html">index_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="afd3cb227b79aee79b10da86b6841399d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IndexSet::add_indices </td>
          <td>(</td>
          <td class="paramtype">const ForwardIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ForwardIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add a whole set of indices described by dereferencing every element of the the iterator range <code>[begin,end)</code>. </p>

<p>Definition at line <a class="el" href="index__set_8h_source.html#l00763">763</a> of file <a class="el" href="index__set_8h_source.html">index_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4d7d0507018483fb625ecf1358187e26"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IndexSet::add_indices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add the given <a class="el" href="classIndexSet.html">IndexSet</a> <code>other</code> to the current one, constructing the union of *this and <code>other</code>.</p>
<p>If the <code>offset</code> argument is nonzero, then every index in <code>other</code> is shifted by <code>offset</code> before being added to the current index set. This allows to construct, for example, one index set from several others that are supposed to represent index sets corresponding to different ranges (e.g., when constructing the set of nonzero entries of a block vector from the sets of nonzero elements of the individual blocks of a vector).</p>
<p>This function will generate an exception if any of the (possibly shifted) indices of the <code>other</code> index set lie outside the range <code>[0,<a class="el" href="classIndexSet.html#aa6019f5ebeb06c551a010050bc8e61fe">size()</a>)</code> represented by the current object. </p>

<p>Definition at line <a class="el" href="index__set_8h_source.html#l00791">791</a> of file <a class="el" href="index__set_8h_source.html">index_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5f6de2f2aa20f3a776d949f78f4490e1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> IndexSet::is_element </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return whether the specified index is an element of the index set. </p>

<p>Definition at line <a class="el" href="index__set_8h_source.html#l00811">811</a> of file <a class="el" href="index__set_8h_source.html">index_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="a02f9a8640d5a485b611a136201d13c0d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> IndexSet::is_contiguous </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return whether the index set stored by this object defines a contiguous range. This is true also if no indices are stored at all. </p>

<p>Definition at line <a class="el" href="index__set_8h_source.html#l00880">880</a> of file <a class="el" href="index__set_8h_source.html">index_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="a009610d130eba9a99a3cb6ad9bec457b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> IndexSet::n_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the number of elements stored in this index set. </p>

<p>Definition at line <a class="el" href="index__set_8h_source.html#l00890">890</a> of file <a class="el" href="index__set_8h_source.html">index_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9fa629a1f9a3cfce2c1d8e05905cc6f2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> IndexSet::nth_index_in_set </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>local_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the global index of the local index with number <code>local_index</code> stored in this index set. <code>local_index</code> obviously needs to be less than <a class="el" href="classIndexSet.html#a009610d130eba9a99a3cb6ad9bec457b">n_elements()</a>. </p>

<p>Definition at line <a class="el" href="index__set_8h_source.html#l00919">919</a> of file <a class="el" href="index__set_8h_source.html">index_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="a45462843cbe29ea393563aae6d0e9b1a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> IndexSet::index_within_set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>&#160;</td>
          <td class="paramname"><em>global_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the how-manyth element of this set (counted in ascending order) <code>global_index</code> is. <code>global_index</code> needs to be less than the <a class="el" href="classIndexSet.html#aa6019f5ebeb06c551a010050bc8e61fe">size()</a>. This function throws an exception if the index <code>global_index</code> is not actually a member of this index set, i.e. if is_element(global_index) is false. </p>

<p>Definition at line <a class="el" href="index__set_8h_source.html#l00970">970</a> of file <a class="el" href="index__set_8h_source.html">index_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8d18db39432524a4f7df121124ffaf70"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> IndexSet::n_intervals </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Each index set can be represented as the union of a number of contiguous intervals of indices, where if necessary intervals may only consist of individual elements to represent isolated members of the index set.</p>
<p>This function returns the minimal number of such intervals that are needed to represent the index set under consideration. </p>

</div>
</div>
<a class="anchor" id="aeeb798101f61c7efc03bcadc86f5987a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IndexSet::compress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compress the internal representation by merging individual elements with contiguous ranges, etc. This function does not have any external effect. </p>

<p>Definition at line <a class="el" href="index__set_8h_source.html#l00694">694</a> of file <a class="el" href="index__set_8h_source.html">index_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="acc3cb5e3927170f1745d3c183010d36a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> IndexSet::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>is</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Comparison for equality of index sets. This operation is only allowed if the size of the two sets is the same (though of course they do not have to have the same number of indices). </p>

<p>Definition at line <a class="el" href="index__set_8h_source.html#l01013">1013</a> of file <a class="el" href="index__set_8h_source.html">index_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3cfa6add639f49f69751151303ab7a0a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> IndexSet::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>is</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Comparison for inequality of index sets. This operation is only allowed if the size of the two sets is the same (though of course they do not have to have the same number of indices). </p>

<p>Definition at line <a class="el" href="index__set_8h_source.html#l01028">1028</a> of file <a class="el" href="index__set_8h_source.html">index_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1d4a7739a6b41d9ab6e3be7e09e1d1ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexSet.html">IndexSet</a> IndexSet::operator&amp; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>is</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the intersection of the current index set and the argument given, i.e. a set of indices that are elements of both index sets. The two index sets must have the same size (though of course they do not have to have the same number of indices). </p>

</div>
</div>
<a class="anchor" id="ab7af8c5450b63588594d21c02df3b854"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexSet.html">IndexSet</a> IndexSet::get_view </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This command takes an interval <code>[begin, end)</code> and returns the intersection of the current index set with the interval, shifted to the range <code>[0, end-begin)</code>.</p>
<p>In other words, the result of this operation is the intersection of the set represented by the current object and the interval <code>[begin, end)</code>, as seen <em>within the interval <code>[begin, end)</code></em> by shifting the result of the intersection operation to the left by <code>begin</code>. This corresponds to the notion of a <em>view</em>: The interval <code>[begin, end)</code> is a <em>window</em> through which we see the set represented by the current object. </p>

</div>
</div>
<a class="anchor" id="ac15601b7c5742d386127b3ecabf61cf8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IndexSet::subtract_set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes all elements contained in <code>other</code> from this set. In other words, if <img class="formulaInl" alt="$x$" src="form_9.png"/> is the current object and <img class="formulaInl" alt="$o$" src="form_496.png"/> the argument, then we compute <img class="formulaInl" alt="$x \leftarrow x \backslash o$" src="form_497.png"/>. </p>

</div>
</div>
<a class="anchor" id="a8750378396309e3e90725292a8d3d168"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IndexSet::fill_index_vector </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fills the given vector with all indices contained in this <a class="el" href="classIndexSet.html">IndexSet</a>. </p>

</div>
</div>
<a class="anchor" id="a4aa35d3794a20f50f73cd1faa641860c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void IndexSet::fill_binary_vector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fill the given vector with either zero or one elements, providing a binary representation of this index set. The given vector is assumed to already have the correct size.</p>
<p>The given argument is filled with integer values zero and one, using <code>vector.operator[]</code>. Thus, any object that has such an operator can be used as long as it allows conversion of integers zero and one to elements of the vector. Specifically, this is the case for classes <a class="el" href="classVector.html">Vector</a>, <a class="el" href="classBlockVector.html">BlockVector</a>, but also std::vector&lt;bool&gt;, std::vector&lt;int&gt;, and std::vector&lt;double&gt;. </p>

<p>Definition at line <a class="el" href="index__set_8h_source.html#l01043">1043</a> of file <a class="el" href="index__set_8h_source.html">index_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0856dd9662b4c08e1999a77d71539130"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAM &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IndexSet::print </td>
          <td>(</td>
          <td class="paramtype">STREAM &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Outputs a text representation of this <a class="el" href="classIndexSet.html">IndexSet</a> to the given stream. Used for testing. </p>

<p>Definition at line <a class="el" href="index__set_8h_source.html#l01067">1067</a> of file <a class="el" href="index__set_8h_source.html">index_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9d378b33cf76208b7531375250fe3697"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IndexSet::write </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes the <a class="el" href="classIndexSet.html">IndexSet</a> into a text based file format, that can be read in again using the <a class="el" href="classIndexSet.html#a80613305bf8a26f68dfe841e084d5045">read()</a> function. </p>

</div>
</div>
<a class="anchor" id="a80613305bf8a26f68dfe841e084d5045"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IndexSet::read </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs the <a class="el" href="classIndexSet.html">IndexSet</a> from a text based representation given by the stream </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>written by the <a class="el" href="classIndexSet.html#a9d378b33cf76208b7531375250fe3697">write()</a> function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8093fd6dd293bc1598aa568f9c406e38"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IndexSet::block_write </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes the <a class="el" href="classIndexSet.html">IndexSet</a> into a binary, compact representation, that can be read in again using the <a class="el" href="classIndexSet.html#a9975dcc4ba3b7f5a5e22b52ff44db8bd">block_read()</a> function. </p>

</div>
</div>
<a class="anchor" id="a9975dcc4ba3b7f5a5e22b52ff44db8bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IndexSet::block_read </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs the <a class="el" href="classIndexSet.html">IndexSet</a> from a binary representation given by the stream </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>written by the write_block() function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae1ca2471173d25742b2cebdc203c6c2f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Epetra_Map IndexSet::make_trilinos_map </td>
          <td>(</td>
          <td class="paramtype">const MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>communicator</em> = <code>MPI_COMM_WORLD</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>overlapping</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given an MPI communicator, create a Trilinos map object that represents a distribution of vector elements or matrix rows in which we will locally store those elements or rows for which we store the index in the current index set, and all the other elements/rows elsewhere on one of the other MPI processes.</p>
<p>The last argument only plays a role if the communicator is a parallel one, distributing computations across multiple processors. In that case, if the last argument is false, then it is assumed that the index sets this function is called on on all processors are mutually exclusive but together enumerate each index exactly once. In other words, if you call this function on two processors, then the index sets this function is called with must together have all possible indices from zero to <a class="el" href="classIndexSet.html#aa6019f5ebeb06c551a010050bc8e61fe">size()</a>-1, and no index must appear in both index sets. This corresponds, for example, to the case where we want to split the elements of vectors into unique subsets to be stored on different processors &ndash; no element should be owned by more than one processor, but each element must be owned by one.</p>
<p>On the other hand, if the second argument is true, then the index sets can be overlapping, though they still need to contain each index exactly once on all processors taken together. This is a useful operation if we want to create vectors that not only contain the locally owned indices, but for example also the elements that correspond to degrees of freedom located on ghost cells. </p>

</div>
</div>
<a class="anchor" id="ac14fbe3a5191f1d333c41db16fff59d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t IndexSet::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine an estimate for the memory consumption (in bytes) of this object. </p>

</div>
</div>
<a class="anchor" id="a6996bfbeb7950e706a46a755b4600dcb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IndexSet::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write or read the data of this object to or from a stream for the purpose of serialization </p>

<p>Definition at line <a class="el" href="index__set_8h_source.html#l01100">1100</a> of file <a class="el" href="index__set_8h_source.html">index_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8363bd9feae32b6a49ca5823586ae8ed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IndexSet::do_compress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Actually perform the <a class="el" href="classIndexSet.html#aeeb798101f61c7efc03bcadc86f5987a">compress()</a> operation. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="a9ce660b8e47e336e4842066394d44a65"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexSet.html">IndexSet</a> complete_index_set </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>N</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create and return an index set of size <img class="formulaInl" alt="$N$" src="form_139.png"/> that contains every single index within this range. In essence, this function returns an index set created by </p>
<div class="fragment"><div class="line"><a class="code" href="classIndexSet.html">IndexSet</a> is (N);</div>
<div class="line">is.add_range(0, N);</div>
</div><!-- fragment --><p> This function exists so that one can create and initialize index sets that are complete in one step, or so one can write code like </p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (my_index_set == <a class="code" href="classIndexSet.html#a9ce660b8e47e336e4842066394d44a65">complete_index_set</a>(my_index_set.size())</div>
<div class="line">  ...</div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="index__set_8h_source.html#l00614">614</a> of file <a class="el" href="index__set_8h_source.html">index_set.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="ac1473031a61493d84806614ac902bb59"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structIndexSet_1_1Range.html">Range</a>&gt; IndexSet::ranges</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A set of contiguous ranges of indices that make up (part of) this index set. This variable is always kept sorted.</p>
<p>The variable is marked "mutable" so that it can be changed by <a class="el" href="classIndexSet.html#aeeb798101f61c7efc03bcadc86f5987a">compress()</a>, though this of course doesn't change anything about the external representation of this index set. </p>

<p>Definition at line <a class="el" href="index__set_8h_source.html#l00545">545</a> of file <a class="el" href="index__set_8h_source.html">index_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa971e41b981640576254569d9a75530f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> IndexSet::is_compressed</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>True if <a class="el" href="classIndexSet.html#aeeb798101f61c7efc03bcadc86f5987a">compress()</a> has been called after the last change in the set of indices.</p>
<p>The variable is marked "mutable" so that it can be changed by <a class="el" href="classIndexSet.html#aeeb798101f61c7efc03bcadc86f5987a">compress()</a>, though this of course doesn't change anything about the external representation of this index set. </p>

<p>Definition at line <a class="el" href="index__set_8h_source.html#l00560">560</a> of file <a class="el" href="index__set_8h_source.html">index_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="a369c8fbcbe2450b72b0823b85e4bd8f1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> IndexSet::index_space_size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The overall size of the index range. Elements of this index set have to have a smaller number than this value. </p>

<p>Definition at line <a class="el" href="index__set_8h_source.html#l00568">568</a> of file <a class="el" href="index__set_8h_source.html">index_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="a05edbc37d50b4dd4ace9a83275175e47"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> IndexSet::largest_range</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This integer caches the index of the largest range in <code>ranges</code>. This gives <code>O(1)</code> access to the range with most elements, while general access costs <code>O(log(n_ranges))</code>. The largest range is needed for the methods <code><a class="el" href="classIndexSet.html#a5f6de2f2aa20f3a776d949f78f4490e1">is_element()</a></code>, <code><a class="el" href="classIndexSet.html#a45462843cbe29ea393563aae6d0e9b1a">index_within_set()</a></code>, <code>nth_index_in_set</code>. In many applications, the largest range contains most elements (the locally owned range), whereas there are only a few other elements (ghosts). </p>

<p>Definition at line <a class="el" href="index__set_8h_source.html#l00585">585</a> of file <a class="el" href="index__set_8h_source.html">index_set.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/deal.II/base/<a class="el" href="index__set_8h_source.html">index_set.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jan 27 2014 15:27:19 for The deal.II Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
