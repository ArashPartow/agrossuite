<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>The deal.II Library: GridTools Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="http://www.dealii.org/deal.ico"></link>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2014 by the deal.II authors"></meta>
<meta name="deal.II-version" content="8.1.0"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 8.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">GridTools Namespace Reference<div class="ingroups"><a class="el" href="group__grid.html">Grid classes</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGridTools_1_1PeriodicFacePair.html">PeriodicFacePair</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:acd5ccc543d561cfb086b571d1f7818cb"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:acd5ccc543d561cfb086b571d1f7818cb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#acd5ccc543d561cfb086b571d1f7818cb">diameter</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria)</td></tr>
<tr class="separator:acd5ccc543d561cfb086b571d1f7818cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ff265d387af7b430f5aec7005faace6"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a4ff265d387af7b430f5aec7005faace6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a4ff265d387af7b430f5aec7005faace6">volume</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping=(<a class="el" href="structStaticMappingQ1.html">StaticMappingQ1</a>&lt; dim, spacedim &gt;::mapping))</td></tr>
<tr class="separator:a4ff265d387af7b430f5aec7005faace6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51ca8be2ba8a96aa8c5c4dcb51b55a73"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a51ca8be2ba8a96aa8c5c4dcb51b55a73"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a51ca8be2ba8a96aa8c5c4dcb51b55a73">cell_measure</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;all_vertices, const unsigned <a class="el" href="classint.html">int</a>(&amp;vertex_indices)[<a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::vertices_per_cell])</td></tr>
<tr class="separator:a51ca8be2ba8a96aa8c5c4dcb51b55a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0606069313c01837a47c9fd4bc1e11f1"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a0606069313c01837a47c9fd4bc1e11f1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a0606069313c01837a47c9fd4bc1e11f1">delete_unused_vertices</a> (std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &gt; &amp;vertices, std::vector&lt; <a class="el" href="structCellData.html">CellData</a>&lt; dim &gt; &gt; &amp;cells, <a class="el" href="structSubCellData.html">SubCellData</a> &amp;subcelldata)</td></tr>
<tr class="separator:a0606069313c01837a47c9fd4bc1e11f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79820d66b08b06e94541817ba78d6213"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a79820d66b08b06e94541817ba78d6213"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a79820d66b08b06e94541817ba78d6213">delete_duplicated_vertices</a> (std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &gt; &amp;all_vertices, std::vector&lt; <a class="el" href="structCellData.html">CellData</a>&lt; dim &gt; &gt; &amp;cells, <a class="el" href="structSubCellData.html">SubCellData</a> &amp;subcelldata, std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;considered_vertices, const <a class="el" href="classdouble.html">double</a> tol=1e-12)</td></tr>
<tr class="separator:a79820d66b08b06e94541817ba78d6213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a212e99cf0d923cebfa04f1d23fa60b04"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Transformation , int spacedim&gt; </td></tr>
<tr class="memitem:a212e99cf0d923cebfa04f1d23fa60b04"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">transform</a> (const Transformation &amp;transformation, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;triangulation)</td></tr>
<tr class="separator:a212e99cf0d923cebfa04f1d23fa60b04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaba24ff634583cda857085e03e3458b"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:afaba24ff634583cda857085e03e3458b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#afaba24ff634583cda857085e03e3458b">shift</a> (const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;shift_vector, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;triangulation)</td></tr>
<tr class="separator:afaba24ff634583cda857085e03e3458b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7ea00f2009014a52520c05beadc78b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#aa7ea00f2009014a52520c05beadc78b6">rotate</a> (const <a class="el" href="classdouble.html">double</a> angle, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2 &gt; &amp;triangulation)</td></tr>
<tr class="separator:aa7ea00f2009014a52520c05beadc78b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6e5968b4507495a77d200e958c496c6"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:ad6e5968b4507495a77d200e958c496c6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#ad6e5968b4507495a77d200e958c496c6">laplace_transform</a> (const std::map&lt; unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;new_points, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria)</td></tr>
<tr class="separator:ad6e5968b4507495a77d200e958c496c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0967563badadd81f77f62622dd8bc2cd"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a0967563badadd81f77f62622dd8bc2cd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a0967563badadd81f77f62622dd8bc2cd">scale</a> (const <a class="el" href="classdouble.html">double</a> scaling_factor, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;triangulation)</td></tr>
<tr class="separator:a0967563badadd81f77f62622dd8bc2cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec039d544c93a6e810427ad45ba0c84f"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:aec039d544c93a6e810427ad45ba0c84f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#aec039d544c93a6e810427ad45ba0c84f">distort_random</a> (const <a class="el" href="classdouble.html">double</a> factor, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;triangulation, const <a class="el" href="classbool.html">bool</a> keep_boundary=true)</td></tr>
<tr class="separator:aec039d544c93a6e810427ad45ba0c84f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75af951bec4cbfab172db65a868c2475"><td class="memTemplParams" colspan="2">template&lt;int dim, template&lt; int, int &gt; class Container, int spacedim&gt; </td></tr>
<tr class="memitem:a75af951bec4cbfab172db65a868c2475"><td class="memTemplItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a75af951bec4cbfab172db65a868c2475">find_closest_vertex</a> (const Container&lt; dim, spacedim &gt; &amp;container, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p)</td></tr>
<tr class="separator:a75af951bec4cbfab172db65a868c2475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb92588f155ebcbd7a76ed36dc502cd9"><td class="memTemplParams" colspan="2">template&lt;int dim, template&lt; int, int &gt; class Container, int spacedim&gt; </td></tr>
<tr class="memitem:aeb92588f155ebcbd7a76ed36dc502cd9"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename <br class="typebreak"/>
Container&lt; dim, spacedim &gt;<br class="typebreak"/>
::active_cell_iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#aeb92588f155ebcbd7a76ed36dc502cd9">find_cells_adjacent_to_vertex</a> (const Container&lt; dim, spacedim &gt; &amp;container, const unsigned <a class="el" href="classint.html">int</a> vertex_index)</td></tr>
<tr class="separator:aeb92588f155ebcbd7a76ed36dc502cd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f56d59cca64a6e64d1efe05f80ee606"><td class="memTemplParams" colspan="2">template&lt;int dim, template&lt; int, int &gt; class Container, int spacedim&gt; </td></tr>
<tr class="memitem:a5f56d59cca64a6e64d1efe05f80ee606"><td class="memTemplItemLeft" align="right" valign="top">Container&lt; dim, spacedim &gt;<br class="typebreak"/>
::active_cell_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a5f56d59cca64a6e64d1efe05f80ee606">find_active_cell_around_point</a> (const Container&lt; dim, spacedim &gt; &amp;container, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p)</td></tr>
<tr class="separator:a5f56d59cca64a6e64d1efe05f80ee606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf00364f2e2bab8c2993f8bb6e2ac22e"><td class="memTemplParams" colspan="2">template&lt;int dim, template&lt; int, int &gt; class Container, int spacedim&gt; </td></tr>
<tr class="memitem:acf00364f2e2bab8c2993f8bb6e2ac22e"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; typename Container<br class="typebreak"/>
&lt; dim, spacedim &gt;<br class="typebreak"/>
::active_cell_iterator, <a class="el" href="classPoint.html">Point</a><br class="typebreak"/>
&lt; dim &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#acf00364f2e2bab8c2993f8bb6e2ac22e">find_active_cell_around_point</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const Container&lt; dim, spacedim &gt; &amp;container, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p)</td></tr>
<tr class="separator:acf00364f2e2bab8c2993f8bb6e2ac22e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae8a52aa3fbf44131bf02c08ba5a381a"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:aae8a52aa3fbf44131bf02c08ba5a381a"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; typename <br class="typebreak"/>
<a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt;<br class="typebreak"/>
::active_cell_iterator, <a class="el" href="classPoint.html">Point</a><br class="typebreak"/>
&lt; dim &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#aae8a52aa3fbf44131bf02c08ba5a381a">find_active_cell_around_point</a> (const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;container, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p)</td></tr>
<tr class="separator:aae8a52aa3fbf44131bf02c08ba5a381a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0454de678c2e9df3d8b40ab53856b09f"><td class="memTemplParams" colspan="2">template&lt;class Container &gt; </td></tr>
<tr class="memitem:a0454de678c2e9df3d8b40ab53856b09f"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename <br class="typebreak"/>
Container::active_cell_iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a0454de678c2e9df3d8b40ab53856b09f">get_active_child_cells</a> (const typename Container::cell_iterator &amp;cell)</td></tr>
<tr class="separator:a0454de678c2e9df3d8b40ab53856b09f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e37831eb03498d6890e31006a66398c"><td class="memTemplParams" colspan="2">template&lt;class Container &gt; </td></tr>
<tr class="memitem:a6e37831eb03498d6890e31006a66398c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a6e37831eb03498d6890e31006a66398c">get_active_neighbors</a> (const typename Container::active_cell_iterator &amp;cell, std::vector&lt; typename Container::active_cell_iterator &gt; &amp;active_neighbors)</td></tr>
<tr class="separator:a6e37831eb03498d6890e31006a66398c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47f7fc7c35ca682ec4e2743f629f0ef1"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a47f7fc7c35ca682ec4e2743f629f0ef1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a47f7fc7c35ca682ec4e2743f629f0ef1">get_face_connectivity_of_cells</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;triangulation, <a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;connectivity)</td></tr>
<tr class="separator:a47f7fc7c35ca682ec4e2743f629f0ef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b4706b77042db5437cf81fd13e62b20"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a5b4706b77042db5437cf81fd13e62b20"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a5b4706b77042db5437cf81fd13e62b20">partition_triangulation</a> (const unsigned <a class="el" href="classint.html">int</a> n_partitions, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;triangulation)</td></tr>
<tr class="separator:a5b4706b77042db5437cf81fd13e62b20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e6de68d2a7d5444fd3d2664974a2c5e"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a7e6de68d2a7d5444fd3d2664974a2c5e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a7e6de68d2a7d5444fd3d2664974a2c5e">partition_triangulation</a> (const unsigned <a class="el" href="classint.html">int</a> n_partitions, const <a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;cell_connection_graph, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;triangulation)</td></tr>
<tr class="separator:a7e6de68d2a7d5444fd3d2664974a2c5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0cb61bdd7e17c6b1589bdd16891e561"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ae0cb61bdd7e17c6b1589bdd16891e561"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#ae0cb61bdd7e17c6b1589bdd16891e561">get_subdomain_association</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;triangulation, std::vector&lt; <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a> &gt; &amp;subdomain)</td></tr>
<tr class="separator:ae0cb61bdd7e17c6b1589bdd16891e561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c212a30784bec20b1ae13fad3fd579c"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a8c212a30784bec20b1ae13fad3fd579c"><td class="memTemplItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a8c212a30784bec20b1ae13fad3fd579c">count_cells_with_subdomain_association</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;triangulation, const <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a> subdomain)</td></tr>
<tr class="separator:a8c212a30784bec20b1ae13fad3fd579c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59e7f52274335209b6c7f7fe5cd4ae04"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:a59e7f52274335209b6c7f7fe5cd4ae04"><td class="memTemplItemLeft" align="right" valign="top">std::list&lt; std::pair&lt; typename <br class="typebreak"/>
Container::cell_iterator, <br class="typebreak"/>
typename <br class="typebreak"/>
Container::cell_iterator &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a59e7f52274335209b6c7f7fe5cd4ae04">get_finest_common_cells</a> (const Container &amp;mesh_1, const Container &amp;mesh_2)</td></tr>
<tr class="separator:a59e7f52274335209b6c7f7fe5cd4ae04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae387b14cb19f14e3dbd3e0e1a3e3ba2"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:aae387b14cb19f14e3dbd3e0e1a3e3ba2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#aae387b14cb19f14e3dbd3e0e1a3e3ba2">have_same_coarse_mesh</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;mesh_1, const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;mesh_2)</td></tr>
<tr class="separator:aae387b14cb19f14e3dbd3e0e1a3e3ba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7b92330f27985f14bef57755be6b0f9"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:aa7b92330f27985f14bef57755be6b0f9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#aa7b92330f27985f14bef57755be6b0f9">have_same_coarse_mesh</a> (const Container &amp;mesh_1, const Container &amp;mesh_2)</td></tr>
<tr class="separator:aa7b92330f27985f14bef57755be6b0f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac89deda30a32b232dbe9c95e14896df5"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ac89deda30a32b232dbe9c95e14896df5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#ac89deda30a32b232dbe9c95e14896df5">minimal_cell_diameter</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;triangulation)</td></tr>
<tr class="separator:ac89deda30a32b232dbe9c95e14896df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbfcfbf4a51832d5994de2c185183101"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:acbfcfbf4a51832d5994de2c185183101"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#acbfcfbf4a51832d5994de2c185183101">maximal_cell_diameter</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;triangulation)</td></tr>
<tr class="separator:acbfcfbf4a51832d5994de2c185183101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a067c348e5c274041eb2bacb4184b2746"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a067c348e5c274041eb2bacb4184b2746"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a067c348e5c274041eb2bacb4184b2746">create_union_triangulation</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;triangulation_1, const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;triangulation_2, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;result)</td></tr>
<tr class="separator:a067c348e5c274041eb2bacb4184b2746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfe914816bd29721d7fedf2c3c18f830"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:acfe914816bd29721d7fedf2c3c18f830"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;<br class="typebreak"/>
::DistortedCellList&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#acfe914816bd29721d7fedf2c3c18f830">fix_up_distorted_child_cells</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::DistortedCellList &amp;distorted_cells, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;triangulation)</td></tr>
<tr class="separator:acfe914816bd29721d7fedf2c3c18f830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28b09deae93cc229c7bdb4641d0a61ac"><td class="memTemplParams" colspan="2">template&lt;template&lt; int, int &gt; class Container, int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a28b09deae93cc229c7bdb4641d0a61ac"><td class="memTemplItemLeft" align="right" valign="top">std::map&lt; typename Container<br class="typebreak"/>
&lt; dim-1, spacedim &gt;<br class="typebreak"/>
::cell_iterator, typename <br class="typebreak"/>
Container&lt; dim, spacedim &gt;<br class="typebreak"/>
::face_iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a28b09deae93cc229c7bdb4641d0a61ac">extract_boundary_mesh</a> (const Container&lt; dim, spacedim &gt; &amp;volume_mesh, Container&lt; dim-1, spacedim &gt; &amp;surface_mesh, const std::set&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> &gt; &amp;boundary_ids=std::set&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> &gt;())</td></tr>
<tr class="separator:a28b09deae93cc229c7bdb4641d0a61ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a137eccb690dbaaee166b6a35a011e1ce"><td class="memTemplParams" colspan="2">template&lt;typename FaceIterator &gt; </td></tr>
<tr class="memitem:a137eccb690dbaaee166b6a35a011e1ce"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a137eccb690dbaaee166b6a35a011e1ce">orthogonal_equality</a> (std::bitset&lt; 3 &gt; &amp;orientation, const FaceIterator &amp;face1, const FaceIterator &amp;face2, const <a class="el" href="classint.html">int</a> direction, const ::<a class="el" href="classTensor.html">Tensor</a>&lt; 1, FaceIterator::AccessorType::space_dimension &gt; &amp;offset)</td></tr>
<tr class="separator:a137eccb690dbaaee166b6a35a011e1ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5688e7fe1386a5ad57b3563e2bd776cc"><td class="memTemplParams" colspan="2">template&lt;typename FaceIterator &gt; </td></tr>
<tr class="memitem:a5688e7fe1386a5ad57b3563e2bd776cc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a5688e7fe1386a5ad57b3563e2bd776cc">orthogonal_equality</a> (const FaceIterator &amp;face1, const FaceIterator &amp;face2, const <a class="el" href="classint.html">int</a> direction, const ::<a class="el" href="classTensor.html">Tensor</a>&lt; 1, FaceIterator::AccessorType::space_dimension &gt; &amp;offset)</td></tr>
<tr class="separator:a5688e7fe1386a5ad57b3563e2bd776cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af53b71bf72e4473c48c7e8458d38f066"><td class="memTemplParams" colspan="2">template&lt;typename CONTAINER &gt; </td></tr>
<tr class="memitem:af53b71bf72e4473c48c7e8458d38f066"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#af53b71bf72e4473c48c7e8458d38f066">collect_periodic_faces</a> (const CONTAINER &amp;container, const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> b_id1, const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> b_id2, const <a class="el" href="classint.html">int</a> direction, std::vector&lt; <a class="el" href="structGridTools_1_1PeriodicFacePair.html">PeriodicFacePair</a>&lt; typename CONTAINER::cell_iterator &gt; &gt; &amp;matched_pairs, const ::<a class="el" href="classTensor.html">Tensor</a>&lt; 1, CONTAINER::space_dimension &gt; &amp;offset=::<a class="el" href="classTensor.html">Tensor</a>&lt; 1, CONTAINER::space_dimension &gt;())</td></tr>
<tr class="separator:af53b71bf72e4473c48c7e8458d38f066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67809862a794342a88982671099aad6d"><td class="memTemplParams" colspan="2">template&lt;typename CONTAINER &gt; </td></tr>
<tr class="memitem:a67809862a794342a88982671099aad6d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a67809862a794342a88982671099aad6d">collect_periodic_faces</a> (const CONTAINER &amp;container, const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> b_id, const <a class="el" href="classint.html">int</a> direction, std::vector&lt; <a class="el" href="structGridTools_1_1PeriodicFacePair.html">PeriodicFacePair</a>&lt; typename CONTAINER::cell_iterator &gt; &gt; &amp;matched_pairs, const ::<a class="el" href="classTensor.html">Tensor</a>&lt; 1, CONTAINER::space_dimension &gt; &amp;offset=::<a class="el" href="classTensor.html">Tensor</a>&lt; 1, CONTAINER::space_dimension &gt;())</td></tr>
<tr class="separator:a67809862a794342a88982671099aad6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b96d83a9f10a39048e1613fa8da8cea"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a9b96d83a9f10a39048e1613fa8da8cea">DeclException1</a> (ExcInvalidNumberOfPartitions, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;The number of partitions you gave is &quot;&lt;&lt; arg1&lt;&lt; &quot;, but must be greater than zero.&quot;)</td></tr>
<tr class="separator:a9b96d83a9f10a39048e1613fa8da8cea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27708777444134752f8cc8138857df28"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a27708777444134752f8cc8138857df28">DeclException1</a> (ExcNonExistentSubdomain, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;The subdomain id &quot;&lt;&lt; arg1&lt;&lt; &quot; has no cells associated with it.&quot;)</td></tr>
<tr class="separator:a27708777444134752f8cc8138857df28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a088ac82f79509dbe1dc9e8d25bc7e50a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a088ac82f79509dbe1dc9e8d25bc7e50a">DeclException0</a> (ExcTriangulationHasBeenRefined)</td></tr>
<tr class="separator:a088ac82f79509dbe1dc9e8d25bc7e50a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a763cd136b48a9c01482b439ff9947460"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a763cd136b48a9c01482b439ff9947460">DeclException1</a> (ExcScalingFactorNotPositive, <a class="el" href="classdouble.html">double</a>,&lt;&lt; &quot;The scaling factor must be positive, but is &quot;&lt;&lt; arg1)</td></tr>
<tr class="separator:a763cd136b48a9c01482b439ff9947460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a2778b0d67960808474a6e36878f697"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:a8a2778b0d67960808474a6e36878f697"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a8a2778b0d67960808474a6e36878f697">DeclException1</a> (ExcPointNotFoundInCoarseGrid, <a class="el" href="classPoint.html">Point</a>&lt; N &gt;,&lt;&lt; &quot;The point &lt;&quot;&lt;&lt; arg1&lt;&lt; &quot;&gt; could not be found inside any of the &quot;&lt;&lt; &quot;coarse grid cells.&quot;)</td></tr>
<tr class="separator:a8a2778b0d67960808474a6e36878f697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadd7cf2536cef9243c41f8deb787e025"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:aadd7cf2536cef9243c41f8deb787e025"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#aadd7cf2536cef9243c41f8deb787e025">DeclException1</a> (ExcPointNotFound, <a class="el" href="classPoint.html">Point</a>&lt; N &gt;,&lt;&lt; &quot;The point &lt;&quot;&lt;&lt; arg1&lt;&lt; &quot;&gt; could not be found inside any of the &quot;&lt;&lt; &quot;subcells of a coarse grid cell.&quot;)</td></tr>
<tr class="separator:aadd7cf2536cef9243c41f8deb787e025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0def280b3a8f856abafef89e59d52a4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae0def280b3a8f856abafef89e59d52a4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DeclException1</b> (ExcVertexNotUsed, unsigned <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;The given vertex &quot;&lt;&lt; arg1&lt;&lt; &quot; is not used in the given triangulation&quot;)</td></tr>
<tr class="separator:ae0def280b3a8f856abafef89e59d52a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a792c69f3c9ec075420421f220329c40b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a792c69f3c9ec075420421f220329c40b"></a>
template&lt;int dim, typename Predicate , int spacedim&gt; </td></tr>
<tr class="memitem:a792c69f3c9ec075420421f220329c40b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>transform</b> (const Predicate &amp;predicate, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;triangulation)</td></tr>
<tr class="separator:a792c69f3c9ec075420421f220329c40b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6af114a8aaece5fe0e5d74fb9dfc80a"><td class="memTemplParams" colspan="2"><a class="anchor" id="af6af114a8aaece5fe0e5d74fb9dfc80a"></a>
template&lt;class DH &gt; </td></tr>
<tr class="memitem:af6af114a8aaece5fe0e5d74fb9dfc80a"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename <br class="typebreak"/>
DH::active_cell_iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_active_child_cells</b> (const typename DH::cell_iterator &amp;cell)</td></tr>
<tr class="separator:af6af114a8aaece5fe0e5d74fb9dfc80a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1605921a5cb39015de4e8dfcd29eaf41"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1605921a5cb39015de4e8dfcd29eaf41"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a1605921a5cb39015de4e8dfcd29eaf41"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cell_measure&lt; 3 &gt;</b> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt; &gt; &amp;all_vertices, const unsigned <a class="el" href="classint.html">int</a>(&amp;vertex_indices)[<a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; 3 &gt;::vertices_per_cell])</td></tr>
<tr class="separator:a1605921a5cb39015de4e8dfcd29eaf41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9965940fa9bd66a564d80b1f610fc14"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa9965940fa9bd66a564d80b1f610fc14"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:aa9965940fa9bd66a564d80b1f610fc14"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cell_measure&lt; 2 &gt;</b> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; 2 &gt; &gt; &amp;all_vertices, const unsigned <a class="el" href="classint.html">int</a>(&amp;vertex_indices)[<a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; 2 &gt;::vertices_per_cell])</td></tr>
<tr class="separator:aa9965940fa9bd66a564d80b1f610fc14"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This namespace is a collection of algorithms working on triangulations, such as shifting or rotating triangulations, but also finding a cell that contains a given point. See the descriptions of the individual functions for more information. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="acd5ccc543d561cfb086b571d1f7818cb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> GridTools::diameter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the diameter of a triangulation. The diameter is computed using only the vertices, i.e. if the diameter should be larger than the maximal distance between boundary vertices due to a higher order mapping, then this function will not catch this. </p>

</div>
</div>
<a class="anchor" id="a4ff265d387af7b430f5aec7005faace6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> GridTools::volume </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em> = <code>(<a class="el" href="structStaticMappingQ1.html">StaticMappingQ1</a>&lt;&#160;dim,&#160;spacedim&#160;&gt;::mapping)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the volume (i.e. the dim-dimensional measure) of the triangulation. We compute the measure using the integral <img class="formulaInl" alt="$\int 1 \; dx$" src="form_680.png"/>. The integral approximated is approximated via quadrature for which we need the mapping argument.</p>
<p>This function also works for objects of type <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>, in which case the function is a collective operation. </p>

</div>
</div>
<a class="anchor" id="a51ca8be2ba8a96aa8c5c4dcb51b55a73"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> GridTools::cell_measure </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>all_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>(&amp;)&#160;</td>
          <td class="paramname"><em>vertex_indices</em>[GeometryInfo&lt; dim &gt;::vertices_per_cell]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a list of vertices (typically obtained using <a class="el" href="classTriangulation.html#a6fcee3caf27bb54c53ddb279cf6b8f5a">Triangulation::get_vertices</a>) as the first, and a list of vertex indices that characterize a single cell as the second argument, return the measure (area, volume) of this cell. If this is a real cell, then you can get the same result using <code>cell-&gt;measure()</code>, but this function also works for cells that do not exist except that you make it up by naming its vertices from the list. </p>

</div>
</div>
<a class="anchor" id="a0606069313c01837a47c9fd4bc1e11f1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::delete_unused_vertices </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structCellData.html">CellData</a>&lt; dim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSubCellData.html">SubCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>subcelldata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove vertices that are not referenced by any of the cells. This function is called by all <code>GridIn::read_*</code> functions to eliminate vertices that are listed in the input files but are not used by the cells in the input file. While these vertices should not be in the input from the beginning, they sometimes are, most often when some cells have been removed by hand without wanting to update the vertex lists, as they might be lengthy.</p>
<p>This function is called by all <code>GridIn::read_*</code> functions as the triangulation class requires them to be called with used vertices only. This is so, since the vertices are copied verbatim by that class, so we have to eliminate unused vertices beforehand.</p>
<p>Not implemented for the codimension one case. </p>

</div>
</div>
<a class="anchor" id="a79820d66b08b06e94541817ba78d6213"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::delete_duplicated_vertices </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>all_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structCellData.html">CellData</a>&lt; dim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSubCellData.html">SubCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>subcelldata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>considered_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tol</em> = <code>1e-12</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove vertices that are duplicated, due to the input of a structured grid, for example. If these vertices are not removed, the faces bounded by these vertices become part of the boundary, even if they are in the interior of the mesh.</p>
<p>This function is called by some <code>GridIn::read_*</code> functions. Only the vertices with indices in <code>considered_vertices</code> are tested for equality. This speeds up the algorithm, which is quadratic and thus quite slow to begin with. However, if you wish to consider all vertices, simply pass an empty vector.</p>
<p>Two vertices are considered equal if their difference in each coordinate direction is less than <code>tol</code>. </p>

</div>
</div>
<a class="anchor" id="a212e99cf0d923cebfa04f1d23fa60b04"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Transformation , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::transform </td>
          <td>(</td>
          <td class="paramtype">const Transformation &amp;&#160;</td>
          <td class="paramname"><em>transformation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transform the vertices of the given triangulation by applying the function object provided as first argument to all its vertices. Since the internal consistency of a triangulation can only be guaranteed if the transformation is applied to the vertices of only one level of hierarchically refined cells, this function may only be used if all cells of the triangulation are on the same refinement level.</p>
<p>The transformation given as argument is used to transform each vertex. Its respective type has to offer a function-like syntax, i.e. the predicate is either an object of a type that has an <code>operator()</code>, or it is a pointer to the function. In either case, argument and return value have to be of type <code><a class="el" href="classPoint.html">Point&lt;spacedim&gt;</a></code>.</p>
<p>This function is used in the "Possibilities for extensions" section of <a class="el" href="step_38.html">step-38</a>. It is also used in <a class="el" href="step_49.html">step-49</a>. </p>

</div>
</div>
<a class="anchor" id="afaba24ff634583cda857085e03e3458b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::shift </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>shift_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shift each vertex of the triangulation by the given shift vector. This function uses the <a class="el" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">transform()</a> function above, so the requirements on the triangulation stated there hold for this function as well. </p>

</div>
</div>
<a class="anchor" id="aa7ea00f2009014a52520c05beadc78b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::rotate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Rotate all vertices of the given two-dimensional triangulation in counter-clockwise sense around the origin of the coordinate system by the given angle (given in radians, rather than degrees). This function uses the <a class="el" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">transform()</a> function above, so the requirements on the triangulation stated there hold for this function as well. </p>

</div>
</div>
<a class="anchor" id="ad6e5968b4507495a77d200e958c496c6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::laplace_transform </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transform the given triangulation smoothly to a different domain where each of the vertices at the boundary of the triangulation is mapped to the corresponding points in the <code>new_points</code> map.</p>
<p>The way this function works is that it solves a Laplace equation for each of the dim components of a displacement field that maps the current domain into one described by <code>new_points</code> . The <code>new_points</code> array therefore represents the boundary values of this displacement field. The function then evaluates this displacement field at each vertex in the interior and uses it to place the mapped vertex where the displacement field locates it. Because the solution of the Laplace equation is smooth, this guarantees a smooth mapping from the old domain to the new one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">new_points</td><td>The locations where a subset of the existing vertices are to be placed. Typically, this would be a map from the vertex indices of all nodes on the boundary to their new locations, thus completely specifying the geometry of the mapped domain. However, it may also include interior points if necessary and it does not need to include all boundary vertices (although you then lose control over the exact shape of the mapped domain).</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">tria</td><td>The <a class="el" href="classTriangulation.html">Triangulation</a> object. This object is changed in-place, i.e., the previous locations of vertices are overwritten.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is not currently implemented for the 1d case. </dd></dl>

</div>
</div>
<a class="anchor" id="a0967563badadd81f77f62622dd8bc2cd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::scale </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>scaling_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scale the entire triangulation by the given factor. To preserve the orientation of the triangulation, the factor must be positive.</p>
<p>This function uses the <a class="el" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">transform()</a> function above, so the requirements on the triangulation stated there hold for this function as well. </p>

</div>
</div>
<a class="anchor" id="aec039d544c93a6e810427ad45ba0c84f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::distort_random </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>keep_boundary</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Distort the given triangulation by randomly moving around all the vertices of the grid. The direction of movement of each vertex is random, while the length of the shift vector has a value of <code>factor</code> times the minimal length of the active edges adjacent to this vertex. Note that <code>factor</code> should obviously be well below <code>0.5</code>.</p>
<p>If <code>keep_boundary</code> is set to <code>true</code> (which is the default), then boundary vertices are not moved. </p>

</div>
</div>
<a class="anchor" id="a75af951bec4cbfab172db65a868c2475"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, template&lt; int, int &gt; class Container, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> GridTools::find_closest_vertex </td>
          <td>(</td>
          <td class="paramtype">const Container&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find and return the number of the used vertex in a given Container that is located closest to a given point <code>p</code>. The type of the first parameter may be either <a class="el" href="classTriangulation.html">Triangulation</a>, <a class="el" href="classDoFHandler.html">DoFHandler</a>, <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>, or <a class="el" href="classMGDoFHandler.html">MGDoFHandler</a>.</p>
<dl class="section author"><dt>Author</dt><dd>Ralf B. Schulz, 2006 </dd></dl>

</div>
</div>
<a class="anchor" id="aeb92588f155ebcbd7a76ed36dc502cd9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, template&lt; int, int &gt; class Container, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;typename Container&lt;dim,spacedim&gt;::active_cell_iterator&gt; GridTools::find_cells_adjacent_to_vertex </td>
          <td>(</td>
          <td class="paramtype">const Container&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>vertex_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find and return a vector of iterators to active cells that surround a given vertex with index <code>vertex_index</code>. The type of the first parameter may be either <a class="el" href="classTriangulation.html">Triangulation</a>, <a class="el" href="classDoFHandler.html">DoFHandler</a>, <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>, or <a class="el" href="classMGDoFHandler.html">MGDoFHandler</a>.</p>
<p>For locally refined grids, the vertex itself might not be a vertex of all adjacent cells that are returned. However, it will always be either a vertex of a cell or be a hanging node located on a face or an edge of it.</p>
<dl class="section note"><dt>Note</dt><dd>If the point requested does not lie in any of the cells of the mesh given, then this function throws an exception of type GridTools::ExcPointNotFound. You can catch this exception and decide what to do in that case.</dd>
<dd>
It isn't entirely clear at this time whether the function does the right thing with anisotropically refined meshes. It needs to be checked for this case. </dd></dl>

</div>
</div>
<a class="anchor" id="a5f56d59cca64a6e64d1efe05f80ee606"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, template&lt; int, int &gt; class Container, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Container&lt;dim,spacedim&gt;::active_cell_iterator GridTools::find_active_cell_around_point </td>
          <td>(</td>
          <td class="paramtype">const Container&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find and return an iterator to the active cell that surrounds a given point <code>ref</code>. The type of the first parameter may be either <a class="el" href="classTriangulation.html">Triangulation</a>, or one of the DoF handler classes, i.e. we can find the cell around a point for iterators into each of these classes.</p>
<p>This is solely a wrapper function for the function of same name below. A Q1 mapping is used for the boundary, and the iterator to the cell in which the point resides is returned.</p>
<p>It is recommended to use the other version of this function, as it simultaneously delivers the local coordinate of the given point without additional computational cost.</p>
<dl class="section note"><dt>Note</dt><dd>If the point requested does not lie in any of the cells of the mesh given, then this function throws an exception of type GridTools::ExcPointNotFound. You can catch this exception and decide what to do in that case.</dd>
<dd>
When applied to a triangulation or DoF handler object based on a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object, the cell returned may in fact be a ghost or artificial cell (see <a class="el" href="DEALGlossary.html#GlossArtificialCell">GlossArtificialCell</a> and <a class="el" href="DEALGlossary.html#GlossGhostCell">GlossGhostCell</a>). If so, many of the operations one may want to do on this cell (e.g., evaluating the solution) may not be possible and you will have to decide what to do in that case. </dd></dl>

</div>
</div>
<a class="anchor" id="acf00364f2e2bab8c2993f8bb6e2ac22e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, template&lt; int, int &gt; class Container, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;typename Container&lt;dim,spacedim&gt;::active_cell_iterator, <a class="el" href="classPoint.html">Point</a>&lt;dim&gt; &gt; GridTools::find_active_cell_around_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find and return an iterator to the active cell that surrounds a given point <code>p</code>. The type of the first parameter may be either <a class="el" href="classTriangulation.html">Triangulation</a>, <a class="el" href="classDoFHandler.html">DoFHandler</a>, <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>, or <a class="el" href="classMGDoFHandler.html">MGDoFHandler</a>, i.e., we can find the cell around a point for iterators into each of these classes.</p>
<p>The algorithm used in this function proceeds by first looking for vertex located closest to the given point, see <a class="el" href="namespaceGridTools.html#a75af951bec4cbfab172db65a868c2475">find_closest_vertex()</a>. Secondly, all adjacent cells to this point are found in the mesh, see <a class="el" href="namespaceGridTools.html#aeb92588f155ebcbd7a76ed36dc502cd9">find_cells_adjacent_to_vertex()</a>. Lastly, for each of these cells, it is tested whether the point is inside. This check is performed using arbitrary boundary mappings. Still, it is possible that due to roundoff errors, the point cannot be located exactly inside the unit cell. In this case, even points at a very small distance outside the unit cell are allowed.</p>
<p>If a point lies on the boundary of two or more cells, then the algorithm tries to identify the cell that is of highest refinement level.</p>
<p>The function returns an iterator to the cell, as well as the local position of the point inside the unit cell. This local position might be located slightly outside an actual unit cell, due to numerical roundoff. Therefore, the point returned by this function should be projected onto the unit cell, using <a class="el" href="structGeometryInfo.html#afbf89d313a8b5adae21b018d8e476d37">GeometryInfo::project_to_unit_cell</a>. This is not automatically performed by the algorithm.</p>
<dl class="section note"><dt>Note</dt><dd>If the point requested does not lie in any of the cells of the mesh given, then this function throws an exception of type GridTools::ExcPointNotFound. You can catch this exception and decide what to do in that case.</dd>
<dd>
When applied to a triangulation or DoF handler object based on a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object, the cell returned may in fact be a ghost or artificial cell (see <a class="el" href="DEALGlossary.html#GlossArtificialCell">GlossArtificialCell</a> and <a class="el" href="DEALGlossary.html#GlossGhostCell">GlossGhostCell</a>). If so, many of the operations one may want to do on this cell (e.g., evaluating the solution) may not be possible and you will have to decide what to do in that case. </dd></dl>

</div>
</div>
<a class="anchor" id="aae8a52aa3fbf44131bf02c08ba5a381a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;typename <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt;dim,spacedim&gt;::active_cell_iterator, <a class="el" href="classPoint.html">Point</a>&lt;dim&gt; &gt; GridTools::find_active_cell_around_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A version of the previous function where we use that mapping on a given cell that corresponds to the active finite element index of that cell. This is obviously only useful for hp problems, since the active finite element index for all other DoF handlers is always zero.</p>
<dl class="section note"><dt>Note</dt><dd>If the point requested does not lie in any of the cells of the mesh given, then this function throws an exception of type GridTools::ExcPointNotFound. You can catch this exception and decide what to do in that case.</dd>
<dd>
When applied to a triangulation or DoF handler object based on a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object, the cell returned may in fact be a ghost or artificial cell (see <a class="el" href="DEALGlossary.html#GlossArtificialCell">GlossArtificialCell</a> and <a class="el" href="DEALGlossary.html#GlossGhostCell">GlossGhostCell</a>). If so, many of the operations one may want to do on this cell (e.g., evaluating the solution) may not be possible and you will have to decide what to do in that case. </dd></dl>

</div>
</div>
<a class="anchor" id="a0454de678c2e9df3d8b40ab53856b09f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;typename Container::active_cell_iterator&gt; GridTools::get_active_child_cells </td>
          <td>(</td>
          <td class="paramtype">const typename Container::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a list of all descendents of the given cell that are active. For example, if the current cell is once refined but none of its children are any further refined, then the returned list will contain all its children.</p>
<p>If the current cell is already active, then the returned list is empty (because the cell has no children that may be active).</p>
<p>Since in C++ the type of the Container template argument (which can be <a class="el" href="classTriangulation.html">Triangulation</a>, <a class="el" href="classDoFHandler.html">DoFHandler</a>, <a class="el" href="classMGDoFHandler.html">MGDoFHandler</a>, or <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>) can not be deduced from a function call, you will have to specify it after the function name, as for example in <code><a class="el" href="namespaceGridTools.html#a0454de678c2e9df3d8b40ab53856b09f">GridTools::get_active_child_cells</a>&lt;<a class="el" href="classDoFHandler.html">DoFHandler</a>&lt;dim&gt; &gt; (cell)</code>. </p>

</div>
</div>
<a class="anchor" id="a6e37831eb03498d6890e31006a66398c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::get_active_neighbors </td>
          <td>(</td>
          <td class="paramtype">const typename Container::active_cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; typename Container::active_cell_iterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>active_neighbors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract the active cells around a given cell <code>cell</code> and return them in the vector <code>active_neighbors</code>. </p>

<p>Definition at line <a class="el" href="grid__tools_8h_source.html#l01267">1267</a> of file <a class="el" href="grid__tools_8h_source.html">grid_tools.h</a>.</p>

</div>
</div>
<a class="anchor" id="a47f7fc7c35ca682ec4e2743f629f0ef1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::get_face_connectivity_of_cells </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>connectivity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Produce a sparsity pattern in which nonzero entries indicate that two cells are connected via a common face. The diagonal entries of the sparsity pattern are also set.</p>
<p>The rows and columns refer to the cells as they are traversed in their natural order using cell iterators. </p>

</div>
</div>
<a class="anchor" id="a5b4706b77042db5437cf81fd13e62b20"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::partition_triangulation </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_partitions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use the METIS partitioner to generate a partitioning of the active cells making up the entire domain. After calling this function, the subdomain ids of all active cells will have values between zero and <code>n_partitions-1</code>. You can access the subdomain id of a cell by using <code>cell-&gt;subdomain_id()</code>.</p>
<p>This function will generate an error if METIS is not installed unless <code>n_partitions</code> is one. I.e., you can write a program so that it runs in the single-processor single-partition case without METIS installed, and only requires METIS when multiple partitions are required. </p>

</div>
</div>
<a class="anchor" id="a7e6de68d2a7d5444fd3d2664974a2c5e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::partition_triangulation </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_partitions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>cell_connection_graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function does the same as the previous one, i.e. it partitions a triangulation using METIS into a number of subdomains identified by the <code>cell-&gt;subdomain_id()</code> flag.</p>
<p>The difference to the previous function is the second argument, a sparsity pattern that represents the connectivity pattern between cells.</p>
<p>While the function above builds it directly from the triangulation by considering which cells neighbor each other, this function can take a more refined connectivity graph. The sparsity pattern needs to be of size <img class="formulaInl" alt="$N\times N$" src="form_681.png"/>, where <img class="formulaInl" alt="$N$" src="form_139.png"/> is the number of active cells in the triangulation. If the sparsity pattern contains an entry at position <img class="formulaInl" alt="$(i,j)$" src="form_209.png"/>, then this means that cells <img class="formulaInl" alt="$i$" src="form_77.png"/> and <img class="formulaInl" alt="$j$" src="form_391.png"/> (in the order in which they are traversed by active cell iterators) are to be considered connected; METIS will then try to partition the domain in such a way that (i) the subdomains are of roughly equal size, and (ii) a minimal number of connections are broken.</p>
<p>This function is mainly useful in cases where connections between cells exist that are not present in the triangulation alone (otherwise the previous function would be the simpler one to use). Such connections may include that certain parts of the boundary of a domain are coupled through symmetric boundary conditions or integrals (e.g. friction contact between the two sides of a crack in the domain), or if a numerical scheme is used that not only connects immediate neighbors but a larger neighborhood of cells (e.g. when solving integral equations).</p>
<p>In addition, this function may be useful in cases where the default sparsity pattern is not entirely sufficient. This can happen because the default is to just consider face neighbors, not neighboring cells that are connected by edges or vertices. While the latter couple when using continuous finite elements, they are typically still closely connected in the neighborship graph, and METIS will not usually cut important connections in this case. However, if there are vertices in the mesh where many cells (many more than the common 4 or 6 in 2d and 3d, respectively) come together, then there will be a significant number of cells that are connected across a vertex, but several degrees removed in the connectivity graph built only using face neighbors. In a case like this, METIS may sometimes make bad decisions and you may want to build your own connectivity graph. </p>

</div>
</div>
<a class="anchor" id="ae0cb61bdd7e17c6b1589bdd16891e561"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::get_subdomain_association </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>subdomain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For each active cell, return in the output array to which subdomain (as given by the <code>cell-&gt;subdomain_id()</code> function) it belongs. The output array is supposed to have the right size already when calling this function.</p>
<p>This function returns the association of each cell with one subdomain. If you are looking for the association of each <em>DoF</em> with a subdomain, use the <code><a class="el" href="namespaceDoFTools.html#a21ed56f06e60447282b0948cfed2537c">DoFTools::get_subdomain_association</a></code> function. </p>

</div>
</div>
<a class="anchor" id="a8c212a30784bec20b1ae13fad3fd579c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> GridTools::count_cells_with_subdomain_association </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a>&#160;</td>
          <td class="paramname"><em>subdomain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Count how many cells are uniquely associated with the given <code>subdomain</code> index.</p>
<p>This function may return zero if there are no cells with the given <code>subdomain</code> index. This can happen, for example, if you try to partition a coarse mesh into more partitions (one for each processor) than there are cells in the mesh.</p>
<p>This function returns the number of cells associated with one subdomain. If you are looking for the association of <em>DoFs</em> with this subdomain, use the <code><a class="el" href="namespaceDoFTools.html#a95c92f74cc712dd820ed42d39ae45e10">DoFTools::count_dofs_with_subdomain_association</a></code> function. </p>

</div>
</div>
<a class="anchor" id="a59e7f52274335209b6c7f7fe5cd4ae04"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt;std::pair&lt;typename Container::cell_iterator, typename Container::cell_iterator&gt; &gt; GridTools::get_finest_common_cells </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>mesh_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>mesh_2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given two mesh containers (i.e. objects of type <a class="el" href="classTriangulation.html">Triangulation</a>, <a class="el" href="classDoFHandler.html">DoFHandler</a>, <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>, or <a class="el" href="classMGDoFHandler.html">MGDoFHandler</a>) that are based on the same coarse mesh, this function figures out a set of cells that are matched between the two meshes and where at most one of the meshes is more refined on this cell. In other words, it finds the smallest cells that are common to both meshes, and that together completely cover the domain.</p>
<p>This function is useful, for example, in time-dependent or nonlinear application, where one has to integrate a solution defined on one mesh (e.g., the one from the previous time step or nonlinear iteration) against the shape functions of another mesh (the next time step, the next nonlinear iteration). If, for example, the new mesh is finer, then one has to obtain the solution on the coarse mesh (mesh_1) and interpolate it to the children of the corresponding cell of mesh_2. Conversely, if the new mesh is coarser, one has to express the coarse cell shape function by a linear combination of fine cell shape functions. In either case, one needs to loop over the finest cells that are common to both triangulations. This function returns a list of pairs of matching iterators to cells in the two meshes that can be used to this end.</p>
<p>Note that the list of these iterators is not necessarily order, and does also not necessarily coincide with the order in which cells are traversed in one, or both, of the meshes given as arguments. </p>

</div>
</div>
<a class="anchor" id="aae387b14cb19f14e3dbd3e0e1a3e3ba2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> GridTools::have_same_coarse_mesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh_2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return true if the two triangulations are based on the same coarse mesh. This is determined by checking whether they have the same number of cells on the coarsest level, and then checking that they have the same vertices.</p>
<p>The two meshes may have different refinement histories beyond the coarse mesh. </p>

</div>
</div>
<a class="anchor" id="aa7b92330f27985f14bef57755be6b0f9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> GridTools::have_same_coarse_mesh </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>mesh_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>mesh_2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The same function as above, but working on arguments of type <a class="el" href="classDoFHandler.html">DoFHandler</a>, <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>, or <a class="el" href="classMGDoFHandler.html">MGDoFHandler</a>. This function is provided to allow calling have_same_coarse_mesh for all types of containers representing triangulations or the classes built on triangulations. </p>

</div>
</div>
<a class="anchor" id="ac89deda30a32b232dbe9c95e14896df5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> GridTools::minimal_cell_diameter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the diamater of the smallest active cell of a triangulation. See <a class="el" href="step_24.html">step-24</a> for an example of use of this function. </p>

</div>
</div>
<a class="anchor" id="acbfcfbf4a51832d5994de2c185183101"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> GridTools::maximal_cell_diameter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the diamater of the largest active cell of a triangulation. </p>

</div>
</div>
<a class="anchor" id="a067c348e5c274041eb2bacb4184b2746"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::create_union_triangulation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation_2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given the two triangulations specified as the first two arguments, create the triangulation that contains the finest cells of both triangulation and store it in the third parameter. Previous content of <code>result</code> will be deleted.</p>
<dl class="section note"><dt>Note</dt><dd>This function is intended to create an adaptively refined triangulation that contains the <em>most refined cells</em> from two input triangulations that were derived from the <em>same </em> coarse grid by adaptive refinement. This is an operation sometimes needed when one solves for two variables of a coupled problem on separately refined meshes on the same domain (for example because these variables have boundary layers in different places) but then needs to compute something that involves both variables or wants to output the result into a single file. In both cases, in order not to lose information, the two solutions can not be interpolated onto the respectively other mesh because that may be coarser than the ones on which the variable was computed. Rather, one needs to have a mesh for the domain that is at least as fine as each of the two initial meshes. This function computes such a mesh.</dd>
<dd>
If you want to create a mesh that is the merger of two other coarse meshes, for example in order to compose a mesh for a complicated geometry from meshes for simpler geometries, take a look at <a class="el" href="namespaceGridGenerator.html#a0dace8884c1510160d7b6cbb313523e9">GridGenerator::merge_triangulations</a> . </dd></dl>

</div>
</div>
<a class="anchor" id="acfe914816bd29721d7fedf2c3c18f830"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html">Triangulation</a>&lt;dim,spacedim&gt;::DistortedCellList GridTools::fix_up_distorted_child_cells </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::DistortedCellList &amp;&#160;</td>
          <td class="paramname"><em>distorted_cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a triangulation and a list of cells whose children have become distorted as a result of mesh refinement, try to fix these cells up by moving the center node around.</p>
<p>The function returns a list of cells with distorted children that couldn't be fixed up for whatever reason. The returned list is therefore a subset of the input argument.</p>
<p>For a definition of the concept of distorted cells, see the <a class="el" href="DEALGlossary.html#GlossDistorted">glossary entry</a>. The first argument passed to the current function is typically the exception thrown by the <a class="el" href="classTriangulation.html#aaedd900205c1879d8d9ef6ffe7d1a554">Triangulation::execute_coarsening_and_refinement</a> function. </p>

</div>
</div>
<a class="anchor" id="a28b09deae93cc229c7bdb4641d0a61ac"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; int, int &gt; class Container, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;typename Container&lt;dim-1,spacedim&gt;::cell_iterator, typename Container&lt;dim,spacedim&gt;::face_iterator&gt; GridTools::extract_boundary_mesh </td>
          <td>(</td>
          <td class="paramtype">const Container&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>volume_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Container&lt; dim-1, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>surface_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_ids</em> = <code>std::set&lt;&#160;<a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function implements a boundary subgrid extraction. Given a &lt;dim,spacedim&gt;-Triangulation (the "volume mesh") the function extracts a subset of its boundary (the "surface
mesh"). The boundary to be extracted is specified by a list of boundary_ids. If none is specified the whole boundary will be extracted. The function is used in <a class="el" href="step_38.html">step-38</a>.</p>
<p>It also builds a mapping linking the cells on the surface mesh to the corresponding faces on the volume one. This mapping is the return value of the function.</p>
<dl class="section note"><dt>Note</dt><dd>The function builds the surface mesh by creating a coarse mesh from the selected faces of the coarse cells of the volume mesh. It copies the boundary indicators of these faces to the cells of the coarse surface mesh. The surface mesh is then refined in the same way as the faces of the volume mesh are. In order to ensure that the surface mesh has the same vertices as the volume mesh, it is therefore important that you assign appropriate boundary objects through <a class="el" href="group__boundary.html#ga0509d862f0e07071dcff837bd58fd082">Triangulation::set_boundary</a> to the surface mesh object before calling this function. If you don't, the refinement will happen under the assumption that all faces are straight (i.e using the <a class="el" href="classStraightBoundary.html">StraightBoundary</a> class) rather than any curved boundary object you may want to use to determine the location of new vertices.</dd>
<dd>
Oftentimes, the <code>Container</code> template type will be of kind <a class="el" href="classTriangulation.html">Triangulation</a>; in that case, the map that is returned will be between <a class="el" href="classTriangulation.html">Triangulation</a> cell iterators of the surface mesh and <a class="el" href="classTriangulation.html">Triangulation</a> face iterators of the volume mesh. However, one often needs to have this mapping between <a class="el" href="classDoFHandler.html">DoFHandler</a> (or <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>) iterators. In that case, you can pass <a class="el" href="classDoFHandler.html">DoFHandler</a> arguments as first and second parameter; the function will in that case re-build the triangulation underlying the second argument and return a map between <a class="el" href="classDoFHandler.html">DoFHandler</a> iterators. However, the function will not actually distribute degrees of freedom on this newly created surface mesh.</dd>
<dd>
The algorithm outlined above assumes that all faces on higher refinement levels always have exactly the same boundary indicator as their parent face. Consequently, we can start with coarse level faces and build the surface mesh based on that. It would not be very difficult to extend the function to also copy boundary indicators from finer level faces to their corresponding surface mesh cells, for example to accommodate different geometry descriptions in the case of curved boundaries. </dd></dl>

</div>
</div>
<a class="anchor" id="a137eccb690dbaaee166b6a35a011e1ce"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FaceIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> GridTools::orthogonal_equality </td>
          <td>(</td>
          <td class="paramtype">std::bitset&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>orientation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FaceIterator &amp;&#160;</td>
          <td class="paramname"><em>face1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FaceIterator &amp;&#160;</td>
          <td class="paramname"><em>face2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classTensor.html">Tensor</a>&lt; 1, FaceIterator::AccessorType::space_dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An orthogonal equality test for faces.</p>
<p><code>face1</code> and <code>face2</code> are considered equal, if a one to one matching between its vertices can be achieved via an orthogonal equality relation: Two vertices <code>v_1</code> and <code>v_2</code> are considered equal, if <code> (v_1 + offset) - v_2</code> is parallel to the unit vector in <code>direction</code>.</p>
<p>If the matching was successful, the <em>relative</em> orientation of <code>face1</code> with respect to <code>face2</code> is returned in the bitset <code>orientation</code>, where </p>
<div class="fragment"><div class="line">orientation[0] -&gt; face_orientation</div>
<div class="line">orientation[1] -&gt; face_flip</div>
<div class="line">orientation[2] -&gt; face_rotation</div>
</div><!-- fragment --><p>In 2D <code>face_orientation</code> is always <code>true</code>, <code>face_rotation</code> is always <code>false</code>, and face_flip has the meaning of <code>line_flip</code>. More precisely in 3d:</p>
<p><code>face_orientation</code>: <code>true</code> if <code>face1</code> and <code>face2</code> have the same orientation. Otherwise, the vertex indices of <code>face1</code> match the vertex indices of <code>face2</code> in the following manner:</p>
<div class="fragment"><div class="line">face1:           face2:</div>
<div class="line"></div>
<div class="line">1 - 3            2 - 3</div>
<div class="line">|   |    &lt;--&gt;    |   |</div>
<div class="line">0 - 2            0 - 1</div>
</div><!-- fragment --><p><code>face_flip</code>: <code>true</code> if the matched vertices are rotated by 180 degrees:</p>
<div class="fragment"><div class="line">face1:           face2:</div>
<div class="line"></div>
<div class="line">1 - 0            2 - 3</div>
<div class="line">|   |    &lt;--&gt;    |   |</div>
<div class="line">3 - 2            0 - 1</div>
</div><!-- fragment --><p><code>face_rotation</code>: <code>true</code> if the matched vertices are rotated by 90 degrees counterclockwise:</p>
<div class="fragment"><div class="line">face1:           face2:</div>
<div class="line"></div>
<div class="line">0 - 2            2 - 3</div>
<div class="line">|   |    &lt;--&gt;    |   |</div>
<div class="line">1 - 3            0 - 1</div>
</div><!-- fragment --><p>and any combination of that... More information on the topic can be found in the <a class="el" href="DEALGlossary.html#GlossFaceOrientation">glossary</a> article.</p>
<dl class="section author"><dt>Author</dt><dd>Matthias Maier, 2012 </dd></dl>

</div>
</div>
<a class="anchor" id="a5688e7fe1386a5ad57b3563e2bd776cc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FaceIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> GridTools::orthogonal_equality </td>
          <td>(</td>
          <td class="paramtype">const FaceIterator &amp;&#160;</td>
          <td class="paramname"><em>face1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FaceIterator &amp;&#160;</td>
          <td class="paramname"><em>face2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classTensor.html">Tensor</a>&lt; 1, FaceIterator::AccessorType::space_dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same function as above, but doesn't return the actual orientation </p>

</div>
</div>
<a class="anchor" id="af53b71bf72e4473c48c7e8458d38f066"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CONTAINER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::collect_periodic_faces </td>
          <td>(</td>
          <td class="paramtype">const CONTAINER &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>b_id1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>b_id2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; PeriodicFacePair&lt; typename CONTAINER::cell_iterator &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>matched_pairs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classTensor.html">Tensor</a>&lt; 1, CONTAINER::space_dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>offset</em> = <code>::<a class="el" href="classTensor.html">Tensor</a>&lt;&#160;1,&#160;CONTAINER::space_dimension&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function will collect periodic face pairs on the coarsest mesh level of the given <code>container</code> (a <a class="el" href="classTriangulation.html">Triangulation</a> or <a class="el" href="classDoFHandler.html">DoFHandler</a>) and add them to the vector <code>matched_pairs</code> leaving the original contents intact.</p>
<p>Define a 'first' boundary as all boundary faces having boundary_id <code>b_id1</code> and a 'second' boundary consisting of all faces belonging to <code>b_id2</code>.</p>
<p>This function tries to match all faces belonging to the first boundary with faces belonging to the second boundary with the help of <a class="el" href="namespaceGridTools.html#a137eccb690dbaaee166b6a35a011e1ce">orthogonal_equality()</a>.</p>
<p>The bitset that is returned inside of <a class="el" href="structGridTools_1_1PeriodicFacePair.html">PeriodicFacePair</a> encodes the <em>relative</em> orientation of the first face with respect to the second face, see the documentation of orthogonal_equality for further details.</p>
<p>The <code>direction</code> refers to the space direction in which periodicity is enforced.</p>
<p>The <code>offset</code> is a vector tangential to the faces that is added to the location of vertices of the 'first' boundary when attempting to match them to the corresponding vertices of the 'second' boundary. This can be used to implement conditions such as <img class="formulaInl" alt="$u(0,y)=u(1,y+1)$" src="form_408.png"/>.</p>
<dl class="section note"><dt>Note</dt><dd>The created std::vector can be used in <a class="el" href="namespaceDoFTools.html#ae23173d20bc1b6c56c6d3a4aa2cbae73">DoFTools::make_periodicity_constraints</a> and in <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#ad7660c5fb6d0589d0b7a8ddc1d13a22b">parallel::distributed::Triangulation::add_periodicity</a> to enforce periodicity algebraically.</dd>
<dd>
Because elements will be added to <code>matched_pairs</code> (and existing entries will be preserved), it is possible to call this function several times with different boundary ids to generate a vector with all periodic pairs.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Daniel Arndt, Matthias Maier, 2013 </dd></dl>

</div>
</div>
<a class="anchor" id="a67809862a794342a88982671099aad6d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CONTAINER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::collect_periodic_faces </td>
          <td>(</td>
          <td class="paramtype">const CONTAINER &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>b_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; PeriodicFacePair&lt; typename CONTAINER::cell_iterator &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>matched_pairs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classTensor.html">Tensor</a>&lt; 1, CONTAINER::space_dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>offset</em> = <code>::<a class="el" href="classTensor.html">Tensor</a>&lt;&#160;1,&#160;CONTAINER::space_dimension&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This compatibility version of collect_periodic_face_pairs only works on grids with cells in <a class="el" href="DEALGlossary.html#GlossFaceOrientation">standard orientation</a>.</p>
<p>Instead of defining a 'first' and 'second' boundary with the help of two boundary_indicators this function defines a 'left' boundary as all faces with local face index <code>2*dimension</code> and boundary indicator <code>b_id</code> and, similarly, a 'right' boundary consisting of all face with local face index <code>2*dimension+1</code> and boundary indicator <code>b_id</code>.</p>
<p>This function will collect periodic face pairs on the coarsest mesh level and add them to <code>matched_pairs</code> leaving the original contents intact.</p>
<dl class="section note"><dt>Note</dt><dd>This version of collect_periodic_face_pairs will not work on meshes with cells not in <a class="el" href="DEALGlossary.html#GlossFaceOrientation">standard orientation</a>.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Daniel Arndt, Matthias Maier, 2013 </dd></dl>

</div>
</div>
<a class="anchor" id="a9b96d83a9f10a39048e1613fa8da8cea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GridTools::DeclException1 </td>
          <td>(</td>
          <td class="paramtype">ExcInvalidNumberOfPartitions&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;The number of partitions you gave is &quot;&lt;&lt; arg1&lt;&lt; &quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">but must be greater than zero.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exception </p>

</div>
</div>
<a class="anchor" id="a27708777444134752f8cc8138857df28"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GridTools::DeclException1 </td>
          <td>(</td>
          <td class="paramtype">ExcNonExistentSubdomain&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;The subdomain id &quot;&lt;&lt; arg1&lt;&lt; &quot; has no cells associated with it.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exception </p>

</div>
</div>
<a class="anchor" id="a088ac82f79509dbe1dc9e8d25bc7e50a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GridTools::DeclException0 </td>
          <td>(</td>
          <td class="paramtype">ExcTriangulationHasBeenRefined&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exception </p>

</div>
</div>
<a class="anchor" id="a763cd136b48a9c01482b439ff9947460"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GridTools::DeclException1 </td>
          <td>(</td>
          <td class="paramtype">ExcScalingFactorNotPositive&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;The scaling factor must be&#160;</td>
          <td class="paramname"><em>positive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">but is&quot;&lt;&lt;&#160;</td>
          <td class="paramname"><em>arg1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exception </p>

</div>
</div>
<a class="anchor" id="a8a2778b0d67960808474a6e36878f697"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GridTools::DeclException1 </td>
          <td>(</td>
          <td class="paramtype">ExcPointNotFoundInCoarseGrid&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPoint.html">Point</a>&lt; N &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exception </p>

</div>
</div>
<a class="anchor" id="aadd7cf2536cef9243c41f8deb787e025"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GridTools::DeclException1 </td>
          <td>(</td>
          <td class="paramtype">ExcPointNotFound&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPoint.html">Point</a>&lt; N &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exception </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jan 27 2014 15:27:23 for The deal.II Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
