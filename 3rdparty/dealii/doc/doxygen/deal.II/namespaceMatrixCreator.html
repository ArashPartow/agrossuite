<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>The deal.II Library: MatrixCreator Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="http://www.dealii.org/deal.ico"></link>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2014 by the deal.II authors"></meta>
<meta name="deal.II-version" content="8.1.0"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 8.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">MatrixCreator Namespace Reference<div class="ingroups"><a class="el" href="group__numerics.html">Numerical algorithms</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa95a194001f23f96327fb7a630c6b036"><td class="memTemplParams" colspan="2">template&lt;int dim, typename number , int spacedim&gt; </td></tr>
<tr class="memitem:aa95a194001f23f96327fb7a630c6b036"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMatrixCreator.html#aa95a194001f23f96327fb7a630c6b036">create_mass_matrix</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;q, <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;matrix, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *const a=0, const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints=<a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a>())</td></tr>
<tr class="separator:aa95a194001f23f96327fb7a630c6b036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0213cd07aa47e16778a927015bdf237"><td class="memTemplParams" colspan="2">template&lt;int dim, typename number , int spacedim&gt; </td></tr>
<tr class="memitem:aa0213cd07aa47e16778a927015bdf237"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMatrixCreator.html#aa0213cd07aa47e16778a927015bdf237">create_mass_matrix</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;q, <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;matrix, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *const a=0, const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints=<a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a>())</td></tr>
<tr class="separator:aa0213cd07aa47e16778a927015bdf237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac461f13bb0f657e1489b2220e93509b5"><td class="memTemplParams" colspan="2">template&lt;int dim, typename number , int spacedim&gt; </td></tr>
<tr class="memitem:ac461f13bb0f657e1489b2220e93509b5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMatrixCreator.html#ac461f13bb0f657e1489b2220e93509b5">create_mass_matrix</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;q, <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;matrix, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; &amp;rhs, <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;rhs_vector, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *const a=0, const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints=<a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a>())</td></tr>
<tr class="separator:ac461f13bb0f657e1489b2220e93509b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e9c1a22df3bf9d0a2f3526fd4da2cac"><td class="memTemplParams" colspan="2">template&lt;int dim, typename number , int spacedim&gt; </td></tr>
<tr class="memitem:a9e9c1a22df3bf9d0a2f3526fd4da2cac"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMatrixCreator.html#a9e9c1a22df3bf9d0a2f3526fd4da2cac">create_mass_matrix</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;q, <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;matrix, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; &amp;rhs, <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;rhs_vector, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *const a=0, const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints=<a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a>())</td></tr>
<tr class="separator:a9e9c1a22df3bf9d0a2f3526fd4da2cac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a752bf68b4668b441f77f4500e6779c5a"><td class="memTemplParams" colspan="2">template&lt;int dim, typename number , int spacedim&gt; </td></tr>
<tr class="memitem:a752bf68b4668b441f77f4500e6779c5a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMatrixCreator.html#a752bf68b4668b441f77f4500e6779c5a">create_mass_matrix</a> (const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;q, <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;matrix, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *const a=0, const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints=<a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a>())</td></tr>
<tr class="separator:a752bf68b4668b441f77f4500e6779c5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aa151a4de63c83b6e992c7eee34aefd"><td class="memTemplParams" colspan="2">template&lt;int dim, typename number , int spacedim&gt; </td></tr>
<tr class="memitem:a7aa151a4de63c83b6e992c7eee34aefd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMatrixCreator.html#a7aa151a4de63c83b6e992c7eee34aefd">create_mass_matrix</a> (const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;q, <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;matrix, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *const a=0, const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints=<a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a>())</td></tr>
<tr class="separator:a7aa151a4de63c83b6e992c7eee34aefd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad370cdb9febed26090bdb7608cace3a3"><td class="memTemplParams" colspan="2">template&lt;int dim, typename number , int spacedim&gt; </td></tr>
<tr class="memitem:ad370cdb9febed26090bdb7608cace3a3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMatrixCreator.html#ad370cdb9febed26090bdb7608cace3a3">create_mass_matrix</a> (const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;q, <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;matrix, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; &amp;rhs, <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;rhs_vector, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *const a=0, const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints=<a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a>())</td></tr>
<tr class="separator:ad370cdb9febed26090bdb7608cace3a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e67ac7f633e08c31d9dfeb174ab9352"><td class="memTemplParams" colspan="2">template&lt;int dim, typename number , int spacedim&gt; </td></tr>
<tr class="memitem:a1e67ac7f633e08c31d9dfeb174ab9352"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMatrixCreator.html#a1e67ac7f633e08c31d9dfeb174ab9352">create_mass_matrix</a> (const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;q, <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;matrix, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; &amp;rhs, <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;rhs_vector, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *const a=0, const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints=<a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a>())</td></tr>
<tr class="separator:a1e67ac7f633e08c31d9dfeb174ab9352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6288b0b2abba624a094281fcd5e2df27"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a6288b0b2abba624a094281fcd5e2df27"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMatrixCreator.html#a6288b0b2abba624a094281fcd5e2df27">create_boundary_mass_matrix</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt; &amp;q, <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;matrix, const typename <a class="el" href="structFunctionMap.html">FunctionMap</a>&lt; spacedim &gt;::type &amp;boundary_functions, <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;rhs_vector, std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;dof_to_boundary_mapping, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *const weight=0, std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; component_mapping=std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;())</td></tr>
<tr class="separator:a6288b0b2abba624a094281fcd5e2df27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a877098aaa5bd6b62b904a80a162476f3"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a877098aaa5bd6b62b904a80a162476f3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMatrixCreator.html#a877098aaa5bd6b62b904a80a162476f3">create_boundary_mass_matrix</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt; &amp;q, <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;matrix, const typename <a class="el" href="structFunctionMap.html">FunctionMap</a>&lt; spacedim &gt;::type &amp;boundary_functions, <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;rhs_vector, std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;dof_to_boundary_mapping, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *const a=0, std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; component_mapping=std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;())</td></tr>
<tr class="separator:a877098aaa5bd6b62b904a80a162476f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3fdb8bf2c8cc8c7415e7cf5fa7bc5eb"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:aa3fdb8bf2c8cc8c7415e7cf5fa7bc5eb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMatrixCreator.html#aa3fdb8bf2c8cc8c7415e7cf5fa7bc5eb">create_boundary_mass_matrix</a> (const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim-1 &gt; &amp;q, <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;matrix, const typename <a class="el" href="structFunctionMap.html">FunctionMap</a>&lt; spacedim &gt;::type &amp;boundary_functions, <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;rhs_vector, std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;dof_to_boundary_mapping, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *const a=0, std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; component_mapping=std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;())</td></tr>
<tr class="separator:aa3fdb8bf2c8cc8c7415e7cf5fa7bc5eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a980fbfb235b6b5ac113a22cbf7af68ff"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a980fbfb235b6b5ac113a22cbf7af68ff"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMatrixCreator.html#a980fbfb235b6b5ac113a22cbf7af68ff">create_boundary_mass_matrix</a> (const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim-1 &gt; &amp;q, <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;matrix, const typename <a class="el" href="structFunctionMap.html">FunctionMap</a>&lt; spacedim &gt;::type &amp;boundary_functions, <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;rhs_vector, std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;dof_to_boundary_mapping, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *const a=0, std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; component_mapping=std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;())</td></tr>
<tr class="separator:a980fbfb235b6b5ac113a22cbf7af68ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d877bf4661ca5f1433bb0460345b35c"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a0d877bf4661ca5f1433bb0460345b35c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMatrixCreator.html#a0d877bf4661ca5f1433bb0460345b35c">create_laplace_matrix</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;q, <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;matrix, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *const a=0, const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints=<a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a>())</td></tr>
<tr class="separator:a0d877bf4661ca5f1433bb0460345b35c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6d23df721d903cb202be46ac458d47e"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ac6d23df721d903cb202be46ac458d47e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMatrixCreator.html#ac6d23df721d903cb202be46ac458d47e">create_laplace_matrix</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;q, <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;matrix, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *const a=0, const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints=<a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a>())</td></tr>
<tr class="separator:ac6d23df721d903cb202be46ac458d47e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa28e425b2060195360c843d1f9c571d8"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:aa28e425b2060195360c843d1f9c571d8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMatrixCreator.html#aa28e425b2060195360c843d1f9c571d8">create_laplace_matrix</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;q, <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;matrix, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; &amp;rhs, <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;rhs_vector, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *const a=0, const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints=<a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a>())</td></tr>
<tr class="separator:aa28e425b2060195360c843d1f9c571d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17d786adfdc85b402107b2691a36a8b3"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a17d786adfdc85b402107b2691a36a8b3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMatrixCreator.html#a17d786adfdc85b402107b2691a36a8b3">create_laplace_matrix</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;q, <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;matrix, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; &amp;rhs, <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;rhs_vector, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *const a=0, const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints=<a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a>())</td></tr>
<tr class="separator:a17d786adfdc85b402107b2691a36a8b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b1781218e0512ee3533a5a9fb336774"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a4b1781218e0512ee3533a5a9fb336774"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMatrixCreator.html#a4b1781218e0512ee3533a5a9fb336774">create_laplace_matrix</a> (const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;q, <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;matrix, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *const a=0, const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints=<a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a>())</td></tr>
<tr class="separator:a4b1781218e0512ee3533a5a9fb336774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77bb9304edf475b713c465203d738f49"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a77bb9304edf475b713c465203d738f49"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMatrixCreator.html#a77bb9304edf475b713c465203d738f49">create_laplace_matrix</a> (const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;q, <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;matrix, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *const a=0, const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints=<a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a>())</td></tr>
<tr class="separator:a77bb9304edf475b713c465203d738f49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00769fb1cf1f10156a0cd0a5ef719bb5"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a00769fb1cf1f10156a0cd0a5ef719bb5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMatrixCreator.html#a00769fb1cf1f10156a0cd0a5ef719bb5">create_laplace_matrix</a> (const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;q, <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;matrix, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; &amp;rhs, <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;rhs_vector, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *const a=0, const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints=<a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a>())</td></tr>
<tr class="separator:a00769fb1cf1f10156a0cd0a5ef719bb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad31bd3ae91094cf893388ed0561a42d0"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ad31bd3ae91094cf893388ed0561a42d0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMatrixCreator.html#ad31bd3ae91094cf893388ed0561a42d0">create_laplace_matrix</a> (const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;q, <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;matrix, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; &amp;rhs, <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;rhs_vector, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *const a=0, const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints=<a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a>())</td></tr>
<tr class="separator:ad31bd3ae91094cf893388ed0561a42d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38be568c08baf1cb3b75985ffd13ac58"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMatrixCreator.html#a38be568c08baf1cb3b75985ffd13ac58">DeclException0</a> (ExcComponentMismatch)</td></tr>
<tr class="separator:a38be568c08baf1cb3b75985ffd13ac58"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This namespace provides functions that assemble certain standard matrices for a given triangulation, using a given finite element, a given mapping and a quadrature formula.</p>
<h3>Conventions for all functions</h3>
<p>There exist two versions of each function. One with a <a class="el" href="classMapping.html">Mapping</a> argument and one without. If a code uses a mapping different from <a class="el" href="classMappingQ1.html">MappingQ1</a> the functions <em>with</em> mapping argument should be used. Code that uses only <a class="el" href="classMappingQ1.html">MappingQ1</a> may also use the functions <em>without</em> <a class="el" href="classMapping.html">Mapping</a> argument. Each of these latter functions create a <a class="el" href="classMappingQ1.html">MappingQ1</a> object and just call the respective functions with that object as mapping argument.</p>
<p>All functions take a sparse matrix object to hold the matrix to be created. The functions assume that the matrix is initialized with a sparsity pattern (<a class="el" href="classSparsityPattern.html">SparsityPattern</a>) corresponding to the given degree of freedom handler, i.e. the sparsity structure is already as needed. You can do this by calling the <a class="el" href="group__constraints.html#gab627b1d4845c9526521dbd1be83469dc">DoFTools::make_sparsity_pattern()</a> function.</p>
<p>Furthermore it is assumed that no relevant data is in the matrix. Some entries will be overwritten and some others will contain invalid data if the matrix wasn't empty before. Therefore you may want to clear the matrix before assemblage.</p>
<p>By default, all created matrices are `raw': they are not condensed, i.e. hanging nodes are not eliminated. The reason is that you may want to add several matrices and could then condense afterwards only once, instead of for every matrix. To actually do computations with these matrices, you have to condense the matrix using the <a class="el" href="classConstraintMatrix.html#a66337316e8fbbc786c9f0383d085ab01">ConstraintMatrix::condense</a> function; you also have to condense the right hand side accordingly and distribute the solution afterwards. Alternatively, you can give an optional argument <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> that writes cell matrix (and vector) entries with distribute_local_to_global into the global matrix and vector. This way, adding several matrices from different sources is more complicated and you should make sure that you do not mix different ways of applying constraints. Particular caution is necessary when the given constraint matrix contains inhomogeneous constraints: In that case, the matrix assembled this way must be the only matrix (or you need to assemble the <b>same</b> right hand side for <b>every</b> matrix you generate and add together).</p>
<p>If you want to use boundary conditions with the matrices generated by the functions of this class in addition to the ones in a possible constraint matrix, you have to use a function like <code>ProblemBase&lt;&gt;::apply_dirichlet_bc</code> to matrix and right hand side.</p>
<h3>Supported matrices</h3>
<p>At present there are functions to create the following matrices: </p>
<ul>
<li>
<p class="startli"><code>create_mass_matrix:</code> create the matrix with entries <img class="formulaInl" alt="$m_{ij} = \int_\Omega \phi_i(x) \phi_j(x) dx$" src="form_606.png"/> by numerical quadrature. Here, the <img class="formulaInl" alt="$\phi_i$" src="form_204.png"/> are the basis functions of the finite element space given.</p>
<p>A coefficient may be given to evaluate <img class="formulaInl" alt="$m_{ij} = \int_\Omega a(x) \phi_i(x) \phi_j(x) dx$" src="form_643.png"/> instead.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><code>create_laplace_matrix:</code> create the matrix with entries <img class="formulaInl" alt="$a_{ij} = \int_\Omega \nabla\phi_i(x) \nabla\phi_j(x) dx$" src="form_644.png"/> by numerical quadrature.</p>
<p class="endli">Again, a coefficient may be given to evaluate <img class="formulaInl" alt="$a_{ij} = \int_\Omega a(x) \nabla\phi_i(x) \nabla\phi_j(x) dx$" src="form_645.png"/> instead. </p>
</li>
</ul>
<p>Make sure that the order of the <a class="el" href="classQuadrature.html">Quadrature</a> formula given to these functions is sufficiently high to compute the matrices with the required accuracy. For the choice of this quadrature rule you need to take into account the polynomial degree of the <a class="el" href="classFiniteElement.html">FiniteElement</a> basis functions, the roughness of the coefficient <code>a</code>, as well as the degree of the given <code><a class="el" href="classMapping.html">Mapping</a></code> (if any).</p>
<p>Note, that for system elements the mass matrix and the laplace matrix is implemented such that each components couple only with itself, i.e. there is no coupling of shape functions belonging to different components. If the degrees of freedom have been sorted according to their vector component (e.g., using <a class="el" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise()</a>), then the resulting matrices will be block diagonal.</p>
<p>If the finite element for which the mass matrix or the laplace matrix is to be built has more than one component, this function accepts a single coefficient as well as a vector valued coefficient function. For the latter case make sure that the number of components coincides with the number of components of the system finite element.</p>
<h3>Matrices on the boundary</h3>
<p>The <a class="el" href="namespaceMatrixCreator.html#a6288b0b2abba624a094281fcd5e2df27">create_boundary_mass_matrix()</a> creates the matrix with entries <img class="formulaInl" alt="$m_{ij} = \int_{\Gamma} \phi_i \phi_j dx$" src="form_646.png"/>, where <img class="formulaInl" alt="$\Gamma$" src="form_647.png"/> is the union of boundary parts with indicators contained in a <a class="el" href="structFunctionMap.html">FunctionMap</a> passed to the function (i.e. if you want to set up the mass matrix for the parts of the boundary with indicators zero and 2, you pass the function a map of <code>unsigned char</code>s as parameter <code>boundary_functions</code> containing the keys zero and 2). The size of the matrix is equal to the number of degrees of freedom that have support on the boundary, i.e. it is <em>not</em> a matrix on all degrees of freedom, but only a subset. (The <img class="formulaInl" alt="$\phi_i$" src="form_204.png"/> in the formula are this subsect of basis functions which have at least part of their support on <img class="formulaInl" alt="$\Gamma$" src="form_647.png"/>.) In order to determine which shape functions are to be considered, and in order to determine in which order, the function takes a <code>dof_to_boundary_mapping</code>; this object maps global DoF numbers to a numbering of the degrees of freedom located on the boundary, and can be obtained using the function <a class="el" href="namespaceDoFTools.html#aea9fa329f0c4a00ee55782a9e0810db4">DoFTools::map_dof_to_boundary_indices()</a>.</p>
<p>In order to work, the function needs a matrix of the correct size, built on top of a corresponding sparsity pattern. Since we only work on a subset of the degrees of freedom, we can't use the matrices and sparsity patterns that are created for the entire set of degrees of freedom. Rather, you should use the <a class="el" href="group__constraints.html#ga60b493fa4c36d86a15c8599eef8c0e32">DoFHandler::make_boundary_sparsity_pattern()</a> function to create the correct sparsity pattern, and build a matrix on top of it.</p>
<p>Note that at present there is no function that computes the mass matrix for <em>all</em> shape functions, though such a function would be trivial to implement.</p>
<h3>Right hand sides</h3>
<p>In many cases, you will not only want to build the matrix, but also a right hand side, which will give a vector with <img class="formulaInl" alt="$f_i = \int_\Omega f(x) \phi_i(x) dx$" src="form_607.png"/>. For this purpose, each function exists in two versions, one only building the matrix and one also building the right hand side vector. If you want to create a right hand side vector without creating a matrix, you can use the <a class="el" href="namespaceVectorTools.html#a920c5f556c9a56b891b0fbdb279cb58b">VectorTools::create_right_hand_side()</a> function. The use of the latter may be useful if you want to create many right hand side vectors.</p>
<dl class="section author"><dt>Author</dt><dd>Wolfgang Bangerth, 1998, Ralf Hartmann, 2001 </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="aa95a194001f23f96327fb7a630c6b036"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename number , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void MatrixCreator::create_mass_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *const&#160;</td>
          <td class="paramname"><em>a</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints</em> = <code><a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assemble the mass matrix. If no coefficient is given, it is assumed to be unity.</p>
<p>If the library is configured to use multithreading, this function works in parallel.</p>
<p>The optional argument <code>constraints</code> allows to apply constraints on the resulting matrix directly. Be careful when combining several matrices and using inhomogeneous constraints.</p>
<p>See the general doc of this class for more information. </p>

</div>
</div>
<a class="anchor" id="aa0213cd07aa47e16778a927015bdf237"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename number , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void MatrixCreator::create_mass_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *const&#160;</td>
          <td class="paramname"><em>a</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints</em> = <code><a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calls the <a class="el" href="namespaceMatrixCreator.html#aa95a194001f23f96327fb7a630c6b036">create_mass_matrix()</a> function, see above, with <code>mapping=<a class="el" href="classMappingQ1.html">MappingQ1</a>&lt;dim&gt;()</code>. </p>

</div>
</div>
<a class="anchor" id="ac461f13bb0f657e1489b2220e93509b5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename number , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void MatrixCreator::create_mass_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *const&#160;</td>
          <td class="paramname"><em>a</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints</em> = <code><a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assemble the mass matrix and a right hand side vector. If no coefficient is given, it is assumed to be unity.</p>
<p>If the library is configured to use multithreading, this function works in parallel.</p>
<p>The optional argument <code>constraints</code> allows to apply constraints on the resulting matrix directly. Be careful when combining several matrices and using inhomogeneous constraints.</p>
<p>See the general doc of this class for more information. </p>

</div>
</div>
<a class="anchor" id="a9e9c1a22df3bf9d0a2f3526fd4da2cac"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename number , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void MatrixCreator::create_mass_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *const&#160;</td>
          <td class="paramname"><em>a</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints</em> = <code><a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calls the <a class="el" href="namespaceMatrixCreator.html#aa95a194001f23f96327fb7a630c6b036">create_mass_matrix()</a> function, see above, with <code>mapping=<a class="el" href="classMappingQ1.html">MappingQ1</a>&lt;dim&gt;()</code>. </p>

</div>
</div>
<a class="anchor" id="a752bf68b4668b441f77f4500e6779c5a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename number , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void MatrixCreator::create_mass_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *const&#160;</td>
          <td class="paramname"><em>a</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints</em> = <code><a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same function as above, but for hp objects. </p>

</div>
</div>
<a class="anchor" id="a7aa151a4de63c83b6e992c7eee34aefd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename number , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void MatrixCreator::create_mass_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *const&#160;</td>
          <td class="paramname"><em>a</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints</em> = <code><a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same function as above, but for hp objects. </p>

</div>
</div>
<a class="anchor" id="ad370cdb9febed26090bdb7608cace3a3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename number , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void MatrixCreator::create_mass_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *const&#160;</td>
          <td class="paramname"><em>a</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints</em> = <code><a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same function as above, but for hp objects. </p>

</div>
</div>
<a class="anchor" id="a1e67ac7f633e08c31d9dfeb174ab9352"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename number , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void MatrixCreator::create_mass_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *const&#160;</td>
          <td class="paramname"><em>a</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints</em> = <code><a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same function as above, but for hp objects. </p>

</div>
</div>
<a class="anchor" id="a6288b0b2abba624a094281fcd5e2df27"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void MatrixCreator::create_boundary_mass_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="structFunctionMap.html">FunctionMap</a>&lt; spacedim &gt;::type &amp;&#160;</td>
          <td class="paramname"><em>boundary_functions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_to_boundary_mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *const&#160;</td>
          <td class="paramname"><em>weight</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td>
          <td class="paramname"><em>component_mapping</em> = <code>std::vector&lt;&#160;unsigned&#160;<a class="el" href="classint.html">int</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assemble the mass matrix and a right hand side vector along the boundary.</p>
<p>The matrix is assumed to already be initialized with a suiting sparsity pattern (the <a class="el" href="classDoFHandler.html">DoFHandler</a> provides an appropriate function).</p>
<p>If the library is configured to use multithreading, this function works in parallel.</p>
<ul>
<li><code>weight:</code> an optional weight for the computation of the mass matrix. If no weight is given, it is set to one.</li>
</ul>
<ul>
<li><code>component_mapping:</code> if the components in <code>boundary_functions</code> and <code>dof</code> do not coincide, this vector allows them to be remapped. If the vector is not empty, it has to have one entry for each component in <code>dof</code>. This entry is the component number in <code>boundary_functions</code> that should be used for this component in <code>dof</code>. By default, no remapping is applied.</li>
</ul>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000049">Todo:</a></b></dt><dd>This function does not work for finite elements with cell-dependent shape functions. </dd></dl>

</div>
</div>
<a class="anchor" id="a877098aaa5bd6b62b904a80a162476f3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void MatrixCreator::create_boundary_mass_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="structFunctionMap.html">FunctionMap</a>&lt; spacedim &gt;::type &amp;&#160;</td>
          <td class="paramname"><em>boundary_functions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_to_boundary_mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *const&#160;</td>
          <td class="paramname"><em>a</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td>
          <td class="paramname"><em>component_mapping</em> = <code>std::vector&lt;&#160;unsigned&#160;<a class="el" href="classint.html">int</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calls the <a class="el" href="namespaceMatrixCreator.html#a6288b0b2abba624a094281fcd5e2df27">create_boundary_mass_matrix()</a> function, see above, with <code>mapping=<a class="el" href="classMappingQ1.html">MappingQ1</a>&lt;dim&gt;()</code>. </p>

</div>
</div>
<a class="anchor" id="aa3fdb8bf2c8cc8c7415e7cf5fa7bc5eb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void MatrixCreator::create_boundary_mass_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim-1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="structFunctionMap.html">FunctionMap</a>&lt; spacedim &gt;::type &amp;&#160;</td>
          <td class="paramname"><em>boundary_functions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_to_boundary_mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *const&#160;</td>
          <td class="paramname"><em>a</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td>
          <td class="paramname"><em>component_mapping</em> = <code>std::vector&lt;&#160;unsigned&#160;<a class="el" href="classint.html">int</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same function as above, but for hp objects. </p>

</div>
</div>
<a class="anchor" id="a980fbfb235b6b5ac113a22cbf7af68ff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void MatrixCreator::create_boundary_mass_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim-1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="structFunctionMap.html">FunctionMap</a>&lt; spacedim &gt;::type &amp;&#160;</td>
          <td class="paramname"><em>boundary_functions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_to_boundary_mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *const&#160;</td>
          <td class="paramname"><em>a</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td>
          <td class="paramname"><em>component_mapping</em> = <code>std::vector&lt;&#160;unsigned&#160;<a class="el" href="classint.html">int</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same function as above, but for hp objects. Same function as above, but for hp objects. </p>

</div>
</div>
<a class="anchor" id="a0d877bf4661ca5f1433bb0460345b35c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void MatrixCreator::create_laplace_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *const&#160;</td>
          <td class="paramname"><em>a</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints</em> = <code><a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assemble the Laplace matrix. If no coefficient is given, it is assumed to be constant one.</p>
<p>If the library is configured to use multithreading, this function works in parallel.</p>
<p>The optional argument <code>constraints</code> allows to apply constraints on the resulting matrix directly. Be careful when combining several matrices and using inhomogeneous constraints.</p>
<p>See the general doc of this class for more information. </p>

</div>
</div>
<a class="anchor" id="ac6d23df721d903cb202be46ac458d47e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void MatrixCreator::create_laplace_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *const&#160;</td>
          <td class="paramname"><em>a</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints</em> = <code><a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calls the <a class="el" href="namespaceMatrixCreator.html#a0d877bf4661ca5f1433bb0460345b35c">create_laplace_matrix()</a> function, see above, with <code>mapping=<a class="el" href="classMappingQ1.html">MappingQ1</a>&lt;dim&gt;()</code>. </p>

</div>
</div>
<a class="anchor" id="aa28e425b2060195360c843d1f9c571d8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void MatrixCreator::create_laplace_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *const&#160;</td>
          <td class="paramname"><em>a</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints</em> = <code><a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assemble the Laplace matrix and a right hand side vector. If no coefficient is given, it is assumed to be constant one.</p>
<p>If the library is configured to use multithreading, this function works in parallel.</p>
<p>The optional argument <code>constraints</code> allows to apply constraints on the resulting matrix directly. Be careful when combining several matrices and using inhomogeneous constraints.</p>
<p>See the general doc of this class for more information. </p>

</div>
</div>
<a class="anchor" id="a17d786adfdc85b402107b2691a36a8b3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void MatrixCreator::create_laplace_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *const&#160;</td>
          <td class="paramname"><em>a</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints</em> = <code><a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calls the <a class="el" href="namespaceMatrixCreator.html#a0d877bf4661ca5f1433bb0460345b35c">create_laplace_matrix()</a> function, see above, with <code>mapping=<a class="el" href="classMappingQ1.html">MappingQ1</a>&lt;dim&gt;()</code>. </p>

</div>
</div>
<a class="anchor" id="a4b1781218e0512ee3533a5a9fb336774"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void MatrixCreator::create_laplace_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *const&#160;</td>
          <td class="paramname"><em>a</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints</em> = <code><a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like the functions above, but for hp dof handlers, mappings, and quadrature collections. </p>

</div>
</div>
<a class="anchor" id="a77bb9304edf475b713c465203d738f49"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void MatrixCreator::create_laplace_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *const&#160;</td>
          <td class="paramname"><em>a</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints</em> = <code><a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like the functions above, but for hp dof handlers, mappings, and quadrature collections. </p>

</div>
</div>
<a class="anchor" id="a00769fb1cf1f10156a0cd0a5ef719bb5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void MatrixCreator::create_laplace_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *const&#160;</td>
          <td class="paramname"><em>a</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints</em> = <code><a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like the functions above, but for hp dof handlers, mappings, and quadrature collections. </p>

</div>
</div>
<a class="anchor" id="ad31bd3ae91094cf893388ed0561a42d0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void MatrixCreator::create_laplace_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *const&#160;</td>
          <td class="paramname"><em>a</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints</em> = <code><a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like the functions above, but for hp dof handlers, mappings, and quadrature collections. </p>

</div>
</div>
<a class="anchor" id="a38be568c08baf1cb3b75985ffd13ac58"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MatrixCreator::DeclException0 </td>
          <td>(</td>
          <td class="paramtype">ExcComponentMismatch&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exception </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jan 27 2014 15:27:24 for The deal.II Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
