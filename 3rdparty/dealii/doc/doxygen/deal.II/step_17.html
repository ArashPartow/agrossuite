<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>The deal.II Library: The step-17 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="http://www.dealii.org/deal.ico"></link>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2014 by the deal.II authors"></meta>
<meta name="deal.II-version" content="8.1.0"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 8.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The step-17 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Possibilitiesforextensions">Possibilities for extensions</a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <a class="anchor" id="Intro"></a> <a class="anchor" id="Introduction"></a></p>
<h1>Introduction</h1>
<p>This program does not introduce any new mathematical ideas; in fact, all it does is to do the exact same computations that <a class="el" href="step_8.html">step-8</a> already does, but it does so in a different manner: instead of using deal.II's own linear algebra classes, we build everything on top of classes deal.II provides that wrap around the linear algebra implementation of the <a href="http://www.mcs.anl.gov/petsc/" target="_top">PETSc</a> library. And since PETSc allows to distribute matrices and vectors across several computers within an MPI network, the resulting code will even be able to solve the problem in parallel. If you don't know what PETSc is, then this would be a good time to take a quick glimpse at their homepage.</p>
<p>As a prerequisite of this program, you need to have PETSc installed, and if you want to run in parallel on a cluster, you also need <a href="http://www-users.cs.umn.edu/~karypis/metis/index.html" target="_top">METIS</a> to partition meshes. The installation of deal.II together with these two additional libraries is described in the <a href="../../readme.html" target="body">README</a> file.</p>
<p>There is an additional caveat: PETSc appears not to co-operate well when using threads and the program crashes when deal.II is compiled in its usual mode supporting multithreading. The program can therefore only be compiled and run if multithreading is disabled upon configuration of deal.II using the <code>&ndash;disable-threads</code> switch to <code>./configure</code>.</p>
<p>Now, for the details: as mentioned, the program does not compute anything new, so the use of finite element classes etc. is exactly the same as before. The difference to previous programs is that we have replaced almost all uses of classes <code><a class="el" href="classVector.html">Vector</a></code> and <code><a class="el" href="classSparseMatrix.html">SparseMatrix</a></code> by their near-equivalents <code><a class="el" href="classPETScWrappers_1_1Vector.html">PETScWrappers::Vector</a></code> and <code><a class="el" href="classPETScWrappers_1_1SparseMatrix.html">PETScWrappers::SparseMatrix</a></code> (for sequential vectors and matrices, i.e. objects for which all elements are stored locally on one machine), and <code><a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a></code> and <code><a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">PETScWrappers::MPI::SparseMatrix</a></code> for versions of these classes where only a part of the matrix or vector is stored on each machine within an MPI network. These classes provide an interface that is very similar to that of the deal.II linear algebra classes, but instead of implementing this functionality themselves, they simply pass on to their corresponding PETSc functions. The wrappers are therefore only used to give PETSc a more modern, object oriented interface, and to make the use of PETSc and deal.II objects as interchangeable as possible.</p>
<p>While the sequential PETSc wrappers classes do not have any advantage over their deal.II counterparts, the main point of using PETSc is that it can run in parallel. We will make use of this by partitioning the domain into as many blocks (``subdomains'') as there are processes in the MPI network. At the same time, PETSc provides dummy MPI stubs that allow to run the same program on a single machine if so desired, without any changes.</p>
<p>Note, however, that the only data structures we parallelize are matrices and vectors. We do, in particular, not split up the <code><a class="el" href="classTriangulation.html">Triangulation</a></code> and <code><a class="el" href="classDoFHandler.html">DoFHandler</a></code> classes: each process still has a complete copy of these objects, and all processes have exact copies of what the other processes have. Doing so is slightly, though not much more complicated (from a user perspective, it is <em>much</em> more complicated under the hood) to achieve and we will show how to do this in <a class="el" href="step_40.html">step-40</a>.</p>
<p>The techniques this program demonstrates are: how to use the PETSc wrapper classes; how to parallelize operations for jobs running on an MPI network; and how to partition the domain into subdomains to parallelize up the work. Since all this can only be demonstrated using actual code, let us go straight to the code without much further ado.</p>
<p><a class="anchor" id="CommProg"></a> </p>
<h1>The commented program</h1>
<p>First the usual assortment of header files we have already used in previous example programs:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/base/quadrature_lib.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/base/function.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/base/logstream.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/lac/vector.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/lac/full_matrix.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/lac/constraint_matrix.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_generator.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_refinement.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_accessor.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_iterator.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_boundary_lib.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_handler.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_accessor.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_tools.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_values.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_system.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_q.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/vector_tools.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/matrix_tools.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/data_out.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/error_estimator.h&gt;</span></div>
</div><!-- fragment --><p>And here come the things that we need particularly for this example program and that weren't in <a class="el" href="step_8.html">step-8</a>. First, we replace the standard output <code>std::cout</code> by a new stream <code>pcout</code> which is used in parallel computations for generating output only on one of the MPI processes.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/base/conditional_ostream.h&gt;</span></div>
</div><!-- fragment --><p>We are going to query the number of processes and the number of the present process by calling the respective functions in the <a class="el" href="namespaceUtilities_1_1MPI.html">Utilities::MPI</a> namespace.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/base/utilities.h&gt;</span></div>
</div><!-- fragment --><p>Then, we are going to replace all linear algebra components that involve the (global) linear system by classes that wrap interfaces similar to our own linear algebra classes around what PETSc offers (PETSc is a library written in C, and deal.II comes with wrapper classes that provide the PETSc functionality with an interface that is similar to the interface we already had for our own linear algebra classes). In particular, we need vectors and matrices that are distributed across several processes in MPI programs (and simply map to sequential, local vectors and matrices if there is only a single process, i.e. if you are running on only one machine, and without MPI support):</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/petsc_vector.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/lac/petsc_parallel_vector.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/lac/petsc_parallel_sparse_matrix.h&gt;</span></div>
</div><!-- fragment --><p>Then we also need interfaces for solvers and preconditioners that PETSc provides:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/petsc_solver.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/lac/petsc_precondition.h&gt;</span></div>
</div><!-- fragment --><p>And in addition, we need some algorithms for partitioning our meshes so that they can be efficiently distributed across an MPI network. The partitioning algorithm is implemented in the <code><a class="el" href="namespaceGridTools.html">GridTools</a></code> class, and we need an additional include file for a function in <code><a class="el" href="namespaceDoFRenumbering.html">DoFRenumbering</a></code> that allows to sort the indices associated with degrees of freedom so that they are numbered according to the subdomain they are associated with:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_tools.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_renumbering.h&gt;</span></div>
</div><!-- fragment --><p>And this is simply C++ again:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div>
</div><!-- fragment --><p>The last step is as in all previous programs:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Step17</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">using namespace </span>dealii;</div>
</div><!-- fragment --><p>Now, here comes the declaration of the main class and of various other things below it. As mentioned in the introduction, almost all of this has been copied verbatim from <a class="el" href="step_8.html">step-8</a>, so we only comment on the few things that are different. There is one (cosmetic) change in that we let <code>solve</code> return a value, namely the number of iterations it took to converge, so that we can output this to the screen at the appropriate place. In addition, we introduce a stream-like variable <code>pcout</code>, explained below:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keyword">class </span>ElasticProblem</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  ElasticProblem ();</div>
<div class="line">  ~ElasticProblem ();</div>
<div class="line">  <span class="keywordtype">void</span> run ();</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keywordtype">void</span> setup_system ();</div>
<div class="line">  <span class="keywordtype">void</span> assemble_system ();</div>
<div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> solve ();</div>
<div class="line">  <span class="keywordtype">void</span> refine_grid ();</div>
<div class="line">  <span class="keywordtype">void</span> output_results (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle) <span class="keyword">const</span>;</div>
</div><!-- fragment --><p>The first variable is basically only for convenience: in parallel program, if each process outputs status information, then there quickly is a lot of clutter. Rather, we would want to only have one process output everything once, for example the one with process number zero. <code><a class="el" href="classConditionalOStream.html">ConditionalOStream</a></code> does exactly this: it acts as if it were a stream, but only forwards to a real, underlying stream if a flag is set. By setting this condition to <code>this_mpi_process==0</code>, we make sure that output is only generated from the first process and that we don't get the same lines of output over and over again, once per process.</p>
<p>With this simple trick, we make sure that we don't have to guard each and every write to <code>std::cout</code> by a prefixed <code>if(this_mpi_process==0)</code>.</p>
<div class="fragment"><div class="line"><a class="code" href="classConditionalOStream.html">ConditionalOStream</a> pcout;</div>
</div><!-- fragment --><p>The next few variables are taken verbatim from <a class="el" href="step_8.html">step-8</a>:</p>
<div class="fragment"><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a>   triangulation;</div>
<div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>      dof_handler;</div>
<div class="line"></div>
<div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>        fe;</div>
<div class="line"></div>
<div class="line"><a class="code" href="classConstraintMatrix.html">ConstraintMatrix</a>     hanging_node_constraints;</div>
</div><!-- fragment --><p>In <a class="el" href="step_8.html">step-8</a>, this would have been the place where we would have declared the member variables for the sparsity pattern, the system matrix, right hand, and solution vector. We change these declarations to use parallel PETSc objects instead (note that the fact that we use the parallel versions is denoted the fact that we use the classes from the <code><a class="el" href="namespacePETScWrappers_1_1MPI.html">PETScWrappers::MPI</a></code> namespace; sequential versions of these classes are in the <code><a class="el" href="namespacePETScWrappers.html">PETScWrappers</a></code> namespace, i.e. without the <code>MPI</code> part). Note also that we do not use a separate sparsity pattern, since PETSc manages that as part of its matrix data structures.</p>
<div class="fragment"><div class="line"><a class="code" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">PETScWrappers::MPI::SparseMatrix</a> system_matrix;</div>
<div class="line"></div>
<div class="line"><a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a>       solution;</div>
<div class="line"><a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a>       system_rhs;</div>
</div><!-- fragment --><p>The next change is that we have to declare a variable that indicates the MPI communicator over which we are supposed to distribute our computations. Note that if this is a sequential job without support by MPI, then PETSc provides some dummy type for <code>MPI_Comm</code>, so we do not have to care here whether the job is really a parallel one:</p>
<div class="fragment"><div class="line">MPI_Comm mpi_communicator;</div>
</div><!-- fragment --><p>Then we have two variables that tell us where in the parallel world we are. The first of the following variables, <code>n_mpi_processes</code> tells us how many MPI processes there exist in total, while the second one, <code>this_mpi_process</code>, indicates which is the number of the present process within this space of processes. The latter variable will have a unique value for each process between zero and (less than) <code>n_mpi_processes</code>. If this program is run on a single machine without MPI support, then their values are <code>1</code> and <code>0</code>, respectively.</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_mpi_processes;</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">this_mpi_process</a>;</div>
<div class="line">};</div>
</div><!-- fragment --><p>The following is again taken from <a class="el" href="step_8.html">step-8</a> without change:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keyword">class </span>RightHandSide :  <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  RightHandSide ();</div>
<div class="line"></div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classFunction.html#a1fa27ec3204c0929a0b33ae34a97ef8f">vector_value</a> (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div>
<div class="line">                             <a class="code" href="classVector.html">Vector&lt;double&gt;</a>   &amp;values) <span class="keyword">const</span>;</div>
<div class="line"></div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classFunction.html#a97867379f17a1eacb7e274a2b626ade3">vector_value_list</a> (<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &gt; &amp;points,</div>
<div class="line">                                  std::vector&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &gt;   &amp;value_list) <span class="keyword">const</span>;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">RightHandSide&lt;dim&gt;::RightHandSide () :</div>
<div class="line">  <a class="code" href="classFunction.html">Function</a>&lt;dim&gt; (dim)</div>
<div class="line">{}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keyword">inline</span></div>
<div class="line"><span class="keywordtype">void</span> RightHandSide&lt;dim&gt;::vector_value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div>
<div class="line">                                       <a class="code" href="classVector.html">Vector&lt;double&gt;</a>   &amp;values)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (values.<a class="code" href="classVector.html#ad900ae86530d76f5fbff32c21c582b71">size</a>() == dim,</div>
<div class="line">          <a class="code" href="group__Exceptions.html#ga325fd73751a9373f1b901962daeb2ea7">ExcDimensionMismatch</a> (values.<a class="code" href="classVector.html#ad900ae86530d76f5fbff32c21c582b71">size</a>(), dim));</div>
<div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (dim &gt;= 2, <a class="code" href="group__Exceptions.html#gae372f2b2b6a64585eb80ca01d0b0e236">ExcInternalError</a>());</div>
<div class="line"></div>
<div class="line">  <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> point_1, point_2;</div>
<div class="line">  point_1(0) = 0.5;</div>
<div class="line">  point_2(0) = -0.5;</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span> (((p-point_1).square() &lt; 0.2*0.2) ||</div>
<div class="line">      ((p-point_2).square() &lt; 0.2*0.2))</div>
<div class="line">    values(0) = 1;</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">    values(0) = 0;</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span> (p.<a class="code" href="classPoint.html#ad46f55479010282e242b1d8e427285e8">square</a>() &lt; 0.2*0.2)</div>
<div class="line">    values(1) = 1;</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">    values(1) = 0;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> RightHandSide&lt;dim&gt;::vector_value_list (<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &gt; &amp;points,</div>
<div class="line">                                            std::vector&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &gt;   &amp;value_list)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_points = points.<a class="code" href="classVector.html#ad900ae86530d76f5fbff32c21c582b71">size</a>();</div>
<div class="line"></div>
<div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (value_list.size() == n_points,</div>
<div class="line">          <a class="code" href="group__Exceptions.html#ga325fd73751a9373f1b901962daeb2ea7">ExcDimensionMismatch</a> (value_list.size(), n_points));</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p=0; p&lt;n_points; ++p)</div>
<div class="line">    RightHandSide&lt;dim&gt;::vector_value (points[p],</div>
<div class="line">                                      value_list[p]);</div>
<div class="line">}</div>
</div><!-- fragment --><p>The first step in the actual implementation of things is the constructor of the main class. Apart from initializing the same member variables that we already had in <a class="el" href="step_8.html">step-8</a>, we here initialize the MPI communicator variable we shall use with the global MPI communicator linking all processes together (in more complex applications, one could here use a communicator object that only links a subset of all processes), and call the <a class="el" href="namespaceUtilities.html">Utilities</a> helper functions to determine the number of processes and where the present one fits into this picture. In addition, we make sure that output is only generated by the (globally) first process. As <code>this_mpi_process</code> is determined after creation of pcout, we cannot set the condition through the constructor, i.e. by <code>pcout(std::cout, this_mpi_process==0)</code>, but set the condition separately.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">ElasticProblem&lt;dim&gt;::ElasticProblem ()</div>
<div class="line">  :</div>
<div class="line">  pcout (std::cout),</div>
<div class="line">  dof_handler (triangulation),</div>
<div class="line">  fe (<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(1), dim),</div>
<div class="line">  mpi_communicator (MPI_COMM_WORLD),</div>
<div class="line">  n_mpi_processes (Utilities::MPI::n_mpi_processes(mpi_communicator)),</div>
<div class="line">  <a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">this_mpi_process</a> (Utilities::MPI::<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">this_mpi_process</a>(mpi_communicator))</div>
<div class="line">{</div>
<div class="line">  pcout.set_condition(this_mpi_process == 0);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">ElasticProblem&lt;dim&gt;::~ElasticProblem ()</div>
<div class="line">{</div>
<div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a78fda065d6f58e554a3335ea9b5b482e">clear</a> ();</div>
<div class="line">}</div>
</div><!-- fragment --><p>The second step is the function in which we set up the various variables for the global linear system to be solved.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> ElasticProblem&lt;dim&gt;::setup_system ()</div>
<div class="line">{</div>
</div><!-- fragment --><p>Before we even start out setting up the system, there is one thing to do for a parallel program: we need to assign cells to each of the processes. We do this by splitting (<code>partitioning</code>) the mesh cells into as many chunks (<code>subdomains</code>) as there are processes in this MPI job (if this is a sequential job, then there is only one job and all cells will get a zero as subdomain indicator). This is done using an interface to the METIS library that does this in a very efficient way, trying to minimize the number of nodes on the interfaces between subdomains. All this is hidden behind the following call to a deal.II library function:</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceGridTools.html#a5b4706b77042db5437cf81fd13e62b20">GridTools::partition_triangulation</a> (n_mpi_processes, triangulation);</div>
</div><!-- fragment --><p>As for the linear system: First, we need to generate an enumeration for the degrees of freedom in our problem. Further below, we will show how we assign each cell to one of the MPI processes before we even get here. What we then need to do is to enumerate the degrees of freedom in a way so that all degrees of freedom associated with cells in subdomain zero (which resides on process zero) come before all DoFs associated with cells on subdomain one, before those on cells on process two, and so on. We need this since we have to split the global vectors for right hand side and solution, as well as the matrix into contiguous chunks of rows that live on each of the processors, and we will want to do this in a way that requires minimal communication. This is done using the following two functions, which first generates an initial ordering of all degrees of freedom, and then re-sort them according to above criterion:</p>
<div class="fragment"><div class="line">dof_handler.<a class="code" href="classDoFHandler.html#afcfcc3b473f444f50d206ae62dfe3694">distribute_dofs</a> (fe);</div>
<div class="line"><a class="code" href="namespaceDoFRenumbering.html#af21ead37a274586c21c61bbce6dedd56">DoFRenumbering::subdomain_wise</a> (dof_handler);</div>
</div><!-- fragment --><p>While we're at it, let us also count how many degrees of freedom there exist on the present process:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> n_local_dofs</div>
<div class="line">  = <a class="code" href="namespaceDoFTools.html#a95c92f74cc712dd820ed42d39ae45e10">DoFTools::count_dofs_with_subdomain_association</a> (dof_handler,</div>
<div class="line">                                                     this_mpi_process);</div>
</div><!-- fragment --><p>Then we initialize the system matrix, solution, and right hand side vectors. Since they all need to work in parallel, we have to pass them an MPI communication object, as well as their global sizes (both dimensions are equal to the number of degrees of freedom), and also how many rows out of this global size are to be stored locally (<code>n_local_dofs</code>). In addition, PETSc needs to know how to partition the columns in the chunk of the matrix that is stored locally; for square matrices, the columns should be partitioned in the same way as the rows (indicated by the second <code>n_local_dofs</code> in the call) but in the case of rectangular matrices one has to partition the columns in the same way as vectors are partitioned with which the matrix is multiplied, while rows have to partitioned in the same way as destination vectors of matrix-vector multiplications:</p>
<div class="fragment"><div class="line">system_matrix.reinit (mpi_communicator,</div>
<div class="line">                      dof_handler.<a class="code" href="classDoFHandler.html#a54e7270f2ba6206604f794114b39a2aa">n_dofs</a>(),</div>
<div class="line">                      dof_handler.<a class="code" href="classDoFHandler.html#a54e7270f2ba6206604f794114b39a2aa">n_dofs</a>(),</div>
<div class="line">                      n_local_dofs,</div>
<div class="line">                      n_local_dofs,</div>
<div class="line">                      dof_handler.<a class="code" href="classDoFHandler.html#a59f7c83998cc66a6ac527e01aa4ff5a7">max_couplings_between_dofs</a>());</div>
<div class="line"></div>
<div class="line">solution.<a class="code" href="classVector.html#ac3adfcf8cf35943558fc27ef989b7263">reinit</a> (mpi_communicator, dof_handler.<a class="code" href="classDoFHandler.html#a54e7270f2ba6206604f794114b39a2aa">n_dofs</a>(), n_local_dofs);</div>
<div class="line">system_rhs.<a class="code" href="classBlockVector.html#a4caa9be7a7053fd6ae9fac1da74e564b">reinit</a> (mpi_communicator, dof_handler.<a class="code" href="classDoFHandler.html#a54e7270f2ba6206604f794114b39a2aa">n_dofs</a>(), n_local_dofs);</div>
</div><!-- fragment --><p>Finally, we need to initialize the objects denoting hanging node constraints for the present grid. Note that since PETSc handles the sparsity pattern internally to the matrix, there is no need to set up an independent sparsity pattern here, and to condense it for constraints, as we have done in all other example programs.</p>
<div class="fragment"><div class="line">  hanging_node_constraints.clear ();</div>
<div class="line">  <a class="code" href="group__constraints.html#gabe9d21d4bb33ce556a6e6e80c2bf4b41">DoFTools::make_hanging_node_constraints</a> (dof_handler,</div>
<div class="line">                                           hanging_node_constraints);</div>
<div class="line">  hanging_node_constraints.close ();</div>
<div class="line">}</div>
</div><!-- fragment --><p>The third step is to actually assemble the matrix and right hand side of the problem. There are some things worth mentioning before we go into detail. First, we will be assembling the system in parallel, i.e. each process will be responsible for assembling on cells that belong to this particular processor. Note that the degrees of freedom are split in a way such that all DoFs in the interior of cells and between cells belonging to the same subdomain belong to the process that <code>owns</code> the cell. However, even then we sometimes need to assemble on a cell with a neighbor that belongs to a different process, and in these cases when we write the local contributions into the global matrix or right hand side vector, we actually have to transfer these entries to the other process. Fortunately, we don't have to do this by hand, PETSc does all this for us by caching these elements locally, and sending them to the other processes as necessary when we call the <code>compress()</code> functions on the matrix and vector at the end of this function.</p>
<p>The second point is that once we have handed over matrix and vector contributions to PETSc, it is a) hard, and b) very inefficient to get them back for modifications. This is not only the fault of PETSc, it is also a consequence of the distributed nature of this program: if an entry resides on another processor, then it is necessarily expensive to get it. The consequence of this is that where we previously first assembled the matrix and right hand side as if there were no hanging node constraints and boundary values, and then eliminated these in a second step, we should now try to do that while still assembling the local systems, and before handing these entries over to PETSc. At least as far as eliminating hanging nodes is concerned, this is actually possible, though removing boundary nodes isn't that simple. deal.II provides functions to do this first part: instead of copying elements by hand into the global matrix, we use the <code>distribute_local_to_global</code> functions below to take care of hanging nodes at the same time. The second step, elimination of boundary nodes, is then done in exactly the same way as in all previous example programs.</p>
<p>So, here is the actual implementation:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> ElasticProblem&lt;dim&gt;::assemble_system ()</div>
<div class="line">{</div>
</div><!-- fragment --><p>The infrastructure to assemble linear systems is the same as in all the other programs, and in particular unchanged from <a class="el" href="step_8.html">step-8</a>. Note that we still use the deal.II full matrix and vector types for the local systems.</p>
<div class="fragment"><div class="line"><a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>  quadrature_formula(2);</div>
<div class="line"><a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values (fe, quadrature_formula,</div>
<div class="line">                         <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>   | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div>
<div class="line">                         <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div>
<div class="line"></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   dofs_per_cell = fe.dofs_per_cell;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   n_q_points    = quadrature_formula.size();</div>
<div class="line"></div>
<div class="line"><a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>   cell_matrix (dofs_per_cell, dofs_per_cell);</div>
<div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a>       cell_rhs (dofs_per_cell);</div>
<div class="line"></div>
<div class="line">std::vector&lt;types::global_dof_index&gt; local_dof_indices (dofs_per_cell);</div>
<div class="line"></div>
<div class="line">std::vector&lt;double&gt;     lambda_values (n_q_points);</div>
<div class="line">std::vector&lt;double&gt;     mu_values (n_q_points);</div>
<div class="line"></div>
<div class="line"><a class="code" href="classConstantFunction.html">ConstantFunction&lt;dim&gt;</a> lambda(1.), mu(1.);</div>
<div class="line"></div>
<div class="line">RightHandSide&lt;dim&gt;      right_hand_side;</div>
<div class="line">std::vector&lt;Vector&lt;double&gt; &gt; rhs_values (n_q_points,</div>
<div class="line">                                         <a class="code" href="classVector.html">Vector&lt;double&gt;</a>(dim));</div>
</div><!-- fragment --><p>The next thing is the loop over all elements. Note that we do not have to do all the work: our job here is only to assemble the system on cells that actually belong to this MPI process, all other cells will be taken care of by other processes. This is what the if-clause immediately after the for-loop takes care of: it queries the subdomain identifier of each cell, which is a number associated with each cell that tells which process handles it. In more generality, the subdomain id is used to split a domain into several parts (we do this above, at the beginning of <code>setup_system</code>), and which allows to identify which subdomain a cell is living on. In this application, we have each process handle exactly one subdomain, so we identify the terms <code>subdomain</code> and <code>MPI process</code> with each other.</p>
<p>Apart from this, assembling the local system is relatively uneventful if you have understood how this is done in <a class="el" href="step_8.html">step-8</a>, and only becomes interesting again once we start distributing it into the global matrix and right hand sides.</p>
<div class="fragment"><div class="line"><span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div>
<div class="line">cell = dof_handler.<a class="code" href="classDoFHandler.html#a6f2aa9c61385cbb749ed3d2e7bfe3de1">begin_active</a>(),</div>
<div class="line">endc = dof_handler.<a class="code" href="classDoFHandler.html#abf64c3734383b6fb1bed4888935f2edf">end</a>();</div>
<div class="line"><span class="keywordflow">for</span> (; cell!=endc; ++cell)</div>
<div class="line">  <span class="keywordflow">if</span> (cell-&gt;subdomain_id() == <a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">this_mpi_process</a>)</div>
<div class="line">    {</div>
<div class="line">      cell_matrix = 0;</div>
<div class="line">      cell_rhs = 0;</div>
<div class="line"></div>
<div class="line">      fe_values.<a class="code" href="classFEValues.html#afde502903642c57ade24dfcebf5c1650">reinit</a> (cell);</div>
<div class="line"></div>
<div class="line">      lambda.value_list (fe_values.<a class="code" href="classFEValuesBase.html#a5f8732ebe2d3c6746f6de26a79cb1e45">get_quadrature_points</a>(), lambda_values);</div>
<div class="line">      mu.value_list     (fe_values.<a class="code" href="classFEValuesBase.html#a5f8732ebe2d3c6746f6de26a79cb1e45">get_quadrature_points</a>(), mu_values);</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div>
<div class="line">        {</div>
<div class="line">          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span></div>
<div class="line">          component_i = fe.system_to_component_index(i).first;</div>
<div class="line"></div>
<div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div>
<div class="line">            {</div>
<div class="line">              <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span></div>
<div class="line">              component_j = fe.system_to_component_index(j).first;</div>
<div class="line"></div>
<div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point=0; q_point&lt;n_q_points;</div>
<div class="line">                   ++q_point)</div>
<div class="line">                {</div>
</div><!-- fragment --><p>TODO investigate really small values here</p>
<div class="fragment"><div class="line">            cell_matrix(i,j)</div>
<div class="line">            +=</div>
<div class="line">              (</div>
<div class="line">                (fe_values.<a class="code" href="classFEValuesBase.html#ac4cee7628c2903a89c5c399fddeb00a5">shape_grad</a>(i,q_point)[component_i] *</div>
<div class="line">                 fe_values.<a class="code" href="classFEValuesBase.html#ac4cee7628c2903a89c5c399fddeb00a5">shape_grad</a>(j,q_point)[component_j] *</div>
<div class="line">                 lambda_values[q_point])</div>
<div class="line">                +</div>
<div class="line">                (fe_values.<a class="code" href="classFEValuesBase.html#ac4cee7628c2903a89c5c399fddeb00a5">shape_grad</a>(i,q_point)[component_j] *</div>
<div class="line">                 fe_values.<a class="code" href="classFEValuesBase.html#ac4cee7628c2903a89c5c399fddeb00a5">shape_grad</a>(j,q_point)[component_i] *</div>
<div class="line">                 mu_values[q_point])</div>
<div class="line">                +</div>
<div class="line">                ((component_i == component_j) ?</div>
<div class="line">                 (fe_values.<a class="code" href="classFEValuesBase.html#ac4cee7628c2903a89c5c399fddeb00a5">shape_grad</a>(i,q_point) *</div>
<div class="line">                  fe_values.<a class="code" href="classFEValuesBase.html#ac4cee7628c2903a89c5c399fddeb00a5">shape_grad</a>(j,q_point) *</div>
<div class="line">                  mu_values[q_point])  :</div>
<div class="line">                 0)</div>
<div class="line">              )</div>
<div class="line">              *</div>
<div class="line">              fe_values.<a class="code" href="classFEValuesBase.html#ad097580a2f71878695096cc73b271b9d">JxW</a>(q_point);</div>
<div class="line">          }</div>
<div class="line">      }</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">right_hand_side.vector_value_list (fe_values.<a class="code" href="classFEValuesBase.html#a5f8732ebe2d3c6746f6de26a79cb1e45">get_quadrature_points</a>(),</div>
<div class="line">                                   rhs_values);</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div>
<div class="line">  {</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span></div>
<div class="line">    component_i = fe.system_to_component_index(i).first;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point=0; q_point&lt;n_q_points; ++q_point)</div>
<div class="line">      cell_rhs(i) += fe_values.<a class="code" href="classFEValuesBase.html#abe4de48ff59778bb82a0ec13037804aa">shape_value</a>(i,q_point) *</div>
<div class="line">                     rhs_values[q_point](component_i) *</div>
<div class="line">                     fe_values.<a class="code" href="classFEValuesBase.html#ad097580a2f71878695096cc73b271b9d">JxW</a>(q_point);</div>
<div class="line">  }</div>
</div><!-- fragment --><p>Now we have the local system, and need to transfer it into the global objects. However, as described in the introduction to this function, we want to avoid any operations to matrix and vector entries after handing them off to PETSc (i.e. after distributing to the global objects). Therefore, we will take care of hanging node constraints already here. This is not quite trivial since the rows and columns of constrained nodes have to be distributed to the rows and columns of those nodes to which they are constrained. This can't be done on a purely local basis (because the degrees of freedom to which hanging nodes are constrained may not be associated with the cell we are presently treating, and are therefore not represented in the local matrix and vector), but it can be done while distributing the local system to the global one. This is what the following call does, i.e. we distribute to the global objects and at the same time make sure that hanging node constraints are taken care of:</p>
<div class="fragment"><div class="line">  cell-&gt;get_dof_indices (local_dof_indices);</div>
<div class="line">  hanging_node_constraints</div>
<div class="line">  .distribute_local_to_global(cell_matrix, cell_rhs,</div>
<div class="line">                              local_dof_indices,</div>
<div class="line">                              system_matrix, system_rhs);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Now compress the vector and the system matrix:</p>
<div class="fragment"><div class="line">system_matrix.compress(VectorOperation::add);</div>
<div class="line">system_rhs.<a class="code" href="classBlockVector.html#ad581edc4d3b86a88c4277117c4fae57a">compress</a>(VectorOperation::add);</div>
</div><!-- fragment --><p>The global matrix and right hand side vectors have now been formed. Note that since we took care of this already above, we do not have to condense away hanging node constraints any more.</p>
<p>However, we still have to apply boundary values, in the same way as we always do:</p>
<div class="fragment"><div class="line">std::map&lt;types::global_dof_index,double&gt; boundary_values;</div>
<div class="line"><a class="code" href="namespaceVectorTools.html#a199f38e07822b47e5b5957c21ce35d1b">VectorTools::interpolate_boundary_values</a> (dof_handler,</div>
<div class="line">                                          0,</div>
<div class="line">                                          <a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a>(dim),</div>
<div class="line">                                          boundary_values);</div>
<div class="line"><a class="code" href="namespaceMatrixTools.html#a41a069894610445f84840d712d4f891e">MatrixTools::apply_boundary_values</a> (boundary_values,</div>
<div class="line">                                    system_matrix, solution,</div>
<div class="line">                                    system_rhs, <span class="keyword">false</span>);</div>
</div><!-- fragment --><p>The last argument to the call just performed allows for some optimizations. It controls whether we should also delete the column corresponding to a boundary node, or keep it (and passing <code>true</code> means: yes, do eliminate the column). If we do, then the resulting matrix will be symmetric again if it was before; if we don't, then it won't. The solution of the resulting system should be the same, though. The only reason why we may want to make the system symmetric again is that we would like to use the CG method, which only works with symmetric matrices. Experience tells that CG also works (and works almost as well) if we don't remove the columns associated with boundary nodes, which can be easily explained by the special structure of the non-symmetry. Since eliminating columns from dense matrices is not expensive, though, we let the function do it; not doing so is more important if the linear system is either non-symmetric anyway, or we are using the non-local version of this function (as in all the other example programs before) and want to save a few cycles during this operation.</p>
<div class="fragment"><div class="line">}</div>
</div><!-- fragment --><p>The fourth step is to solve the linear system, with its distributed matrix and vector objects. Fortunately, PETSc offers a variety of sequential and parallel solvers, for which we have written wrappers that have almost the same interface as is used for the deal.II solvers used in all previous example programs.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ElasticProblem&lt;dim&gt;::solve ()</div>
<div class="line">{</div>
</div><!-- fragment --><p>First, we have to set up a convergence monitor, and assign it the accuracy to which we would like to solve the linear system. Next, an actual solver object using PETSc's CG solver which also works with parallel (distributed) vectors and matrices. And finally a preconditioner; we choose to use a block Jacobi preconditioner which works by computing an incomplete LU decomposition on each block (i.e. the chunk of matrix that is stored on each MPI process). That means that if you run the program with only one process, then you will use an ILU(0) as a preconditioner, while if it is run on many processes, then we will have a number of blocks on the diagonal and the preconditioner is the ILU(0) of each of these blocks.</p>
<div class="fragment"><div class="line"><a class="code" href="classSolverControl.html">SolverControl</a>           solver_control (solution.<a class="code" href="classVector.html#ad900ae86530d76f5fbff32c21c582b71">size</a>(),</div>
<div class="line">                                        1e-8*system_rhs.<a class="code" href="classBlockVectorBase.html#a39191b8a99e917a95c8523f94c807a95">l2_norm</a>());</div>
<div class="line"><a class="code" href="classPETScWrappers_1_1SolverCG.html">PETScWrappers::SolverCG</a> cg (solver_control,</div>
<div class="line">                            mpi_communicator);</div>
<div class="line"></div>
<div class="line"><a class="code" href="classPETScWrappers_1_1PreconditionBlockJacobi.html">PETScWrappers::PreconditionBlockJacobi</a> preconditioner(system_matrix);</div>
</div><!-- fragment --><p>Then solve the system:</p>
<div class="fragment"><div class="line">cg.solve (system_matrix, solution, system_rhs,</div>
<div class="line">          preconditioner);</div>
</div><!-- fragment --><p>The next step is to distribute hanging node constraints. This is a little tricky, since to fill in the value of a constrained node you need access to the values of the nodes to which it is constrained (for example, for a Q1 element in 2d, we need access to the two nodes on the big side of a hanging node face, to compute the value of the constrained node in the middle). Since PETSc (and, for that matter, the MPI model on which it is built) does not allow to query the value of another node in a simple way if we should need it, what we do here is to get a copy of the distributed vector where we keep all elements locally. This is simple, since the deal.II wrappers have a conversion constructor for the non-MPI vector class:</p>
<div class="fragment"><div class="line"><a class="code" href="classPETScWrappers_1_1Vector.html">PETScWrappers::Vector</a> localized_solution (solution);</div>
</div><!-- fragment --><p>Then we distribute hanging node constraints on this local copy, i.e. we compute the values of all constrained nodes:</p>
<div class="fragment"><div class="line">hanging_node_constraints.distribute (localized_solution);</div>
</div><!-- fragment --><p>Then transfer everything back into the global vector. The following operation copies those elements of the localized solution that we store locally in the distributed solution, and does not touch the other ones. Since we do the same operation on all processors, we end up with a distributed vector that has all the constrained nodes fixed.</p>
<div class="fragment"><div class="line">solution = localized_solution;</div>
</div><!-- fragment --><p>Finally return the number of iterations it took to converge, to allow for some output:</p>
<div class="fragment"><div class="line">  <span class="keywordflow">return</span> solver_control.last_step();</div>
<div class="line">}</div>
</div><!-- fragment --><p>Step five is to output the results we computed in this iteration. This is actually the same as done in <a class="el" href="step_8.html">step-8</a> before, with two small differences. First, all processes call this function, but not all of them need to do the work associated with generating output. In fact, they shouldn't, since we would try to write to the same file multiple times at once. So we let only the first job do this, and all the other ones idle around during this time (or start their work for the next iteration, or simply yield their CPUs to other jobs that happen to run at the same time). The second thing is that we not only output the solution vector, but also a vector that indicates which subdomain each cell belongs to. This will make for some nice pictures of partitioned domains.</p>
<p>In practice, the present implementation of the output function is a major bottleneck of this program, since generating graphical output is expensive and doing so only on one process does, of course, not scale if we significantly increase the number of processes. In effect, this function will consume most of the run-time if you go to very large numbers of unknowns and processes, and real applications should limit the number of times they generate output through this function.</p>
<p>The solution to this is to have each process generate output data only for it's own local cells, and write them to separate files, one file per process. This would distribute the work of generating the output to all processes equally. In a second step, separate from running this program, we would then take all the output files for a given cycle and merge these parts into one single output file. This has to be done sequentially, but can be done on a different machine, and should be relatively cheap. However, the necessary functionality for this is not yet implemented in the library, and since we are too close to the next release, we do not want to do such major destabilizing changes any more. This has been fixed in the meantime, though, and a better way to do things is explained in the <a class="el" href="step_18.html">step-18</a> example program.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> ElasticProblem&lt;dim&gt;::output_results (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
</div><!-- fragment --><p>One point to realize is that when we want to generate output on process zero only, we need to have access to all elements of the solution vector. So we need to get a local copy of the distributed vector, which is in fact simple:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classPETScWrappers_1_1Vector.html">PETScWrappers::Vector</a> localized_solution (solution);</div>
</div><!-- fragment --><p>The thing to notice, however, is that we do this localization operation on all processes, not only the one that actually needs the data. This can't be avoided, however, with the communication model of MPI: MPI does not have a way to query data on another process, both sides have to initiate a communication at the same time. So even though most of the processes do not need the localized solution, we have to place the call here so that all processes execute it.</p>
<p>(In reality, part of this work can in fact be avoided. What we do is send the local parts of all processes to all other processes. What we would really need to do is to initiate an operation on all processes where each process simply sends its local chunk of data to process zero, since this is the only one that actually needs it, i.e. we need something like a gather operation. PETSc can do this, but for simplicity's sake we don't attempt to make use of this here. We don't, since what we do is not very expensive in the grand scheme of things: it is one vector communication among all processes , which has to be compared to the number of communications we have to do when solving the linear system, setting up the block-ILU for the preconditioner, and other operations.)</p>
<p>This being done, process zero goes ahead with setting up the output file as in <a class="el" href="step_8.html">step-8</a>, and attaching the (localized) solution vector to the output object:. (The code to generate the output file name is stolen and slightly modified from <a class="el" href="step_5.html">step-5</a>, since we expect that we can do a number of cycles greater than 10, which is the maximum of what the code in <a class="el" href="step_8.html">step-8</a> could handle.)</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (this_mpi_process == 0)</div>
<div class="line">  {</div>
<div class="line">    std::ostringstream filename;</div>
<div class="line">    filename &lt;&lt; <span class="stringliteral">&quot;solution-&quot;</span> &lt;&lt; cycle &lt;&lt; <span class="stringliteral">&quot;.gmv&quot;</span>;</div>
<div class="line"></div>
<div class="line">    std::ofstream output (filename.str().c_str());</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div>
<div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a5e63bad650805ce93cd74c6dc3b29b11">attach_dof_handler</a> (dof_handler);</div>
<div class="line"></div>
<div class="line">    std::vector&lt;std::string&gt; solution_names;</div>
<div class="line">    <span class="keywordflow">switch</span> (dim)</div>
<div class="line">      {</div>
<div class="line">      <span class="keywordflow">case</span> 1:</div>
<div class="line">        solution_names.push_back (<span class="stringliteral">&quot;displacement&quot;</span>);</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">      <span class="keywordflow">case</span> 2:</div>
<div class="line">        solution_names.push_back (<span class="stringliteral">&quot;x_displacement&quot;</span>);</div>
<div class="line">        solution_names.push_back (<span class="stringliteral">&quot;y_displacement&quot;</span>);</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">      <span class="keywordflow">case</span> 3:</div>
<div class="line">        solution_names.push_back (<span class="stringliteral">&quot;x_displacement&quot;</span>);</div>
<div class="line">        solution_names.push_back (<span class="stringliteral">&quot;y_displacement&quot;</span>);</div>
<div class="line">        solution_names.push_back (<span class="stringliteral">&quot;z_displacement&quot;</span>);</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">      <span class="keywordflow">default</span>:</div>
<div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#gae372f2b2b6a64585eb80ca01d0b0e236">ExcInternalError</a>());</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">    data_out.add_data_vector (localized_solution, solution_names);</div>
</div><!-- fragment --><p>The only thing we do here additionally is that we also output one value per cell indicating which subdomain (i.e. MPI process) it belongs to. This requires some conversion work, since the data the library provides us with is not the one the output class expects, but this is not difficult. First, set up a vector of integers, one per cell, that is then filled by the number of subdomain each cell is in:</p>
<div class="fragment"><div class="line">std::vector&lt;unsigned int&gt; partition_int (triangulation.<a class="code" href="classTriangulation.html#aa21f25016ce1b9d70d2003a128985870">n_active_cells</a>());</div>
<div class="line"><a class="code" href="namespaceGridTools.html#ae0cb61bdd7e17c6b1589bdd16891e561">GridTools::get_subdomain_association</a> (triangulation, partition_int);</div>
</div><!-- fragment --><p>Then convert this integer vector into a floating point vector just as the output functions want to see:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> partitioning(partition_int.begin(),</div>
<div class="line">                                  partition_int.end());</div>
</div><!-- fragment --><p>And finally add this vector as well:</p>
<div class="fragment"><div class="line">data_out.add_data_vector (partitioning, <span class="stringliteral">&quot;partitioning&quot;</span>);</div>
</div><!-- fragment --><p>This all being done, generate the intermediate format and write it out in GMV output format:</p>
<div class="fragment"><div class="line">      data_out.build_patches ();</div>
<div class="line">      data_out.write_gmv (output);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>The sixth step is to take the solution just computed, and evaluate some kind of refinement indicator to refine the mesh. The problem is basically the same as with distributing hanging node constraints: in order to compute the error indicator, we need access to all elements of the solution vector. We then compute the indicators for the cells that belong to the present process, but then we need to distribute the refinement indicators into a distributed vector so that all processes have the values of the refinement indicator for all cells. But then, in order for each process to refine its copy of the mesh, they need to have access to all refinement indicators locally, so they have to copy the global vector back into a local one. That's a little convoluted, but thinking about it quite straightforward nevertheless. So here's how we do it:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> ElasticProblem&lt;dim&gt;::refine_grid ()</div>
<div class="line">{</div>
</div><!-- fragment --><p>So, first part: get a local copy of the distributed solution vector. This is necessary since the error estimator needs to get at the value of neighboring cells even if they do not belong to the subdomain associated with the present MPI process:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classPETScWrappers_1_1Vector.html">PETScWrappers::Vector</a> localized_solution (solution);</div>
</div><!-- fragment --><p>Second part: set up a vector of error indicators for all cells and let the Kelly class compute refinement indicators for all cells belonging to the present subdomain/process. Note that the last argument of the call indicates which subdomain we are interested in. The three arguments before it are various other default arguments that one usually doesn't need (and doesn't state values for, but rather uses the defaults), but which we have to state here explicitly since we want to modify the value of a following argument (i.e. the one indicating the subdomain):</p>
<div class="fragment"><div class="line"><a class="code" href="classVector.html">Vector&lt;float&gt;</a> local_error_per_cell (triangulation.<a class="code" href="classTriangulation.html#aa21f25016ce1b9d70d2003a128985870">n_active_cells</a>());</div>
<div class="line"><a class="code" href="classKellyErrorEstimator.html#ae1f3149bcc7653baa5ef0a2ac88070b9">KellyErrorEstimator&lt;dim&gt;::estimate</a> (dof_handler,</div>
<div class="line">                                    <a class="code" href="classQGauss.html">QGauss&lt;dim-1&gt;</a>(2),</div>
<div class="line">                                    <span class="keyword">typename</span> <a class="code" href="structFunctionMap.html#aa286a6c5e13045f84faabfd7170b1c48">FunctionMap&lt;dim&gt;::type</a>(),</div>
<div class="line">                                    localized_solution,</div>
<div class="line">                                    local_error_per_cell,</div>
<div class="line">                                    <a class="code" href="classComponentMask.html">ComponentMask</a>(),</div>
<div class="line">                                    0,</div>
<div class="line">                                    <a class="code" href="group__threads.html#ga63ae5e375c4a785919b8a2ea7ca5653d">multithread_info</a>.n_threads(),</div>
<div class="line">                                    <a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">this_mpi_process</a>);</div>
</div><!-- fragment --><p>Now all processes have computed error indicators for their own cells and stored them in the respective elements of the <code>local_error_per_cell</code> vector. The elements of this vector for cells not on the present process are zero. However, since all processes have a copy of a copy of the entire triangulation and need to keep these copies in sync, they need the values of refinement indicators for all cells of the triangulation. Thus, we need to distribute our results. We do this by creating a distributed vector where each process has its share, and sets the elements it has computed. We will then later generate a local sequential copy of this distributed vector to allow each process to access all elements of this vector.</p>
<p>So in the first step, we need to set up a parallel vector. For simplicity, every process will own a chunk with as many elements as this process owns cells, so that the first chunk of elements is stored with process zero, the next chunk with process one, and so on. It is important to remark, however, that these elements are not necessarily the ones we will write to. This is so, since the order in which cells are arranged, i.e. the order in which the elements of the vector correspond to cells, is not ordered according to the subdomain these cells belong to. In other words, if on this process we compute indicators for cells of a certain subdomain, we may write the results to more or less random elements if the distributed vector, that do not necessarily lie within the chunk of vector we own on the present process. They will subsequently have to be copied into another process's memory space then, an operation that PETSc does for us when we call the <code>compress</code> function. This inefficiency could be avoided with some more code, but we refrain from it since it is not a major factor in the program's total runtime.</p>
<p>So here's how we do it: count how many cells belong to this process, set up a distributed vector with that many elements to be stored locally, and copy over the elements we computed locally, then compress the result. In fact, we really only copy the elements that are nonzero, so we may miss a few that we computed to zero, but this won't hurt since the original values of the vector is zero anyway.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_local_cells</div>
<div class="line">  = <a class="code" href="namespaceGridTools.html#a8c212a30784bec20b1ae13fad3fd579c">GridTools::count_cells_with_subdomain_association</a> (triangulation,</div>
<div class="line">                                                       this_mpi_process);</div>
<div class="line"><a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a></div>
<div class="line">distributed_all_errors (mpi_communicator,</div>
<div class="line">                        triangulation.<a class="code" href="classTriangulation.html#aa21f25016ce1b9d70d2003a128985870">n_active_cells</a>(),</div>
<div class="line">                        n_local_cells);</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;local_error_per_cell.size(); ++i)</div>
<div class="line">  <span class="keywordflow">if</span> (local_error_per_cell(i) != 0)</div>
<div class="line">    distributed_all_errors(i) = local_error_per_cell(i);</div>
<div class="line">distributed_all_errors.compress (VectorOperation::insert);</div>
</div><!-- fragment --><p>So now we have this distributed vector out there that contains the refinement indicators for all cells. To use it, we need to obtain a local copy...</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;float&gt;</a> localized_all_errors (distributed_all_errors);</div>
</div><!-- fragment --><p>...which we can the subsequently use to finally refine the grid:</p>
<div class="fragment"><div class="line">  <a class="code" href="namespaceGridRefinement.html#a722dd0fd72533bf87367b0ec14e893e0">GridRefinement::refine_and_coarsen_fixed_number</a> (triangulation,</div>
<div class="line">                                                   localized_all_errors,</div>
<div class="line">                                                   0.3, 0.03);</div>
<div class="line">  triangulation.<a class="code" href="classTriangulation.html#aaedd900205c1879d8d9ef6ffe7d1a554">execute_coarsening_and_refinement</a> ();</div>
<div class="line">}</div>
</div><!-- fragment --><p>Lastly, here is the driver function. It is almost unchanged from <a class="el" href="step_8.html">step-8</a>, with the exception that we replace <code>std::cout</code> by the <code>pcout</code> stream. Apart from this, the only other cosmetic change is that we output how many degrees of freedom there are per process, and how many iterations it took for the linear solver to converge:</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> ElasticProblem&lt;dim&gt;::run ()</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle=0; cycle&lt;10; ++cycle)</div>
<div class="line">      {</div>
<div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; <span class="charliteral">&#39;:&#39;</span> &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (cycle == 0)</div>
<div class="line">          {</div>
<div class="line">            <a class="code" href="namespaceGridGenerator.html#a7149c59cefa805a132177cfa6cb953bd">GridGenerator::hyper_cube</a> (triangulation, -1, 1);</div>
<div class="line">            triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a> (3);</div>
<div class="line">          }</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">          refine_grid ();</div>
<div class="line"></div>
<div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells:       &quot;</span></div>
<div class="line">              &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#aa21f25016ce1b9d70d2003a128985870">n_active_cells</a>()</div>
<div class="line">              &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line">        setup_system ();</div>
<div class="line"></div>
<div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span></div>
<div class="line">              &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#a54e7270f2ba6206604f794114b39a2aa">n_dofs</a>()</div>
<div class="line">              &lt;&lt; <span class="stringliteral">&quot; (by partition:&quot;</span>;</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p=0; p&lt;n_mpi_processes; ++p)</div>
<div class="line">          pcout &lt;&lt; (p==0 ? <span class="charliteral">&#39; &#39;</span> : <span class="charliteral">&#39;+&#39;</span>)</div>
<div class="line">                &lt;&lt; (<a class="code" href="namespaceDoFTools.html#a95c92f74cc712dd820ed42d39ae45e10">DoFTools::</a></div>
<div class="line"><a class="code" href="namespaceDoFTools.html#a95c92f74cc712dd820ed42d39ae45e10">                    count_dofs_with_subdomain_association</a> (dof_handler,</div>
<div class="line">                                                           p));</div>
<div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line">        assemble_system ();</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_iterations = solve ();</div>
<div class="line"></div>
<div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;   Solver converged in &quot;</span> &lt;&lt; n_iterations</div>
<div class="line">              &lt;&lt; <span class="stringliteral">&quot; iterations.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line">        output_results (cycle);</div>
<div class="line">      }</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>So that's it, almost. <code><a class="el" href="group__ParameterGui.html#ga0ddf1224851353fc92bfbff6f499fa97">main()</a></code> works the same way as most of the main functions in the other example programs, i.e. it delegates work to the <code>run</code> function of a master object, and only wraps everything into some code to catch exceptions:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code" href="group__ParameterGui.html#ga0ddf1224851353fc92bfbff6f499fa97">main</a> (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">try</span></div>
<div class="line">    {</div>
<div class="line">      <span class="keyword">using namespace </span>dealii;</div>
<div class="line">      <span class="keyword">using namespace </span>Step17;</div>
</div><!-- fragment --><p>Here is the only real difference: PETSc requires that we initialize it at the beginning of the program, and un-initialize it at the end. The class MPI_InitFinalize takes care of that. The original code sits in between, enclosed in braces to make sure that the <code>elastic_problem</code> variable goes out of scope (and is destroyed) before PETSc is closed with <code>PetscFinalize</code>. (If we wouldn't use braces, the destructor of <code>elastic_problem</code> would run after <code>PetscFinalize</code>; since the destructor involves calls to PETSc functions, we would get strange error messages from PETSc.)</p>
<div class="fragment"><div class="line">      <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_initialization(argc, argv, 1);</div>
<div class="line">      {</div>
<div class="line">        deallog.<a class="code" href="classLogStream.html#a8028e970ad8388596d625ed463894e98">depth_console</a> (0);</div>
<div class="line"></div>
<div class="line">        ElasticProblem&lt;2&gt; elastic_problem;</div>
<div class="line">        elastic_problem.run ();</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div>
<div class="line">    {</div>
<div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">catch</span> (...)</div>
<div class="line">    {</div>
<div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p> <a class="anchor" id="Results"></a></p>
<h1>Results</h1>
<p>If the program above is compiled and run on a single processor machine, it should generate results that are very similar to those that we already got with <a class="el" href="step_8.html">step-8</a>. However, it becomes more interesting if we run it on a cluster of computers. Most clusters have some kind of scheduling system, all of which have different calling syntaxes - on my system, I have to use the command <code>bsub</code> with a whole host of options to run a job in parallel - so that the exact command line syntax varies. If you have found out how to run a job on your system, you should get output like this for a job on 8 processors, and with a few more refinement cycles than in the code above (these results were generated in 2004 with older versions of deal.II and a version of METIS that generated different partitionings; consequently, the numbers you get today are slightly different): </p>
<div class="fragment"><div class="line">Cycle 0:</div>
<div class="line">   Number of active cells:       64</div>
<div class="line">   Number of degrees of freedom: 162 (by partition: 22+22+20+20+18+16+20+24)</div>
<div class="line">   <a class="code" href="classSolver.html">Solver</a> converged in 23 iterations.</div>
<div class="line">Cycle 1:</div>
<div class="line">   Number of active cells:       124</div>
<div class="line">   Number of degrees of freedom: 302 (by partition: 38+42+36+34+44+44+36+28)</div>
<div class="line">   <a class="code" href="classSolver.html">Solver</a> converged in 35 iterations.</div>
<div class="line">Cycle 2:</div>
<div class="line">   Number of active cells:       238</div>
<div class="line">   Number of degrees of freedom: 570 (by partition: 68+80+66+74+58+68+78+78)</div>
<div class="line">   <a class="code" href="classSolver.html">Solver</a> converged in 46 iterations.</div>
<div class="line">Cycle 3:</div>
<div class="line">   Number of active cells:       454</div>
<div class="line">   Number of degrees of freedom: 1046 (by partition: 120+134+124+130+154+138+122+124)</div>
<div class="line">   <a class="code" href="classSolver.html">Solver</a> converged in 55 iterations.</div>
<div class="line">Cycle 4:</div>
<div class="line">   Number of active cells:       868</div>
<div class="line">   Number of degrees of freedom: 1926 (by partition: 232+276+214+248+230+224+234+268)</div>
<div class="line">   <a class="code" href="classSolver.html">Solver</a> converged in 77 iterations.</div>
<div class="line">Cycle 5:</div>
<div class="line">   Number of active cells:       1654</div>
<div class="line">   Number of degrees of freedom: 3550 (by partition: 418+466+432+470+442+474+424+424)</div>
<div class="line">   <a class="code" href="classSolver.html">Solver</a> converged in 93 iterations.</div>
<div class="line">Cycle 6:</div>
<div class="line">   Number of active cells:       3136</div>
<div class="line">   Number of degrees of freedom: 6702 (by partition: 838+796+828+892+866+798+878+806)</div>
<div class="line">   <a class="code" href="classSolver.html">Solver</a> converged in 127 iterations.</div>
<div class="line">Cycle 7:</div>
<div class="line">   Number of active cells:       5962</div>
<div class="line">   Number of degrees of freedom: 12446 (by partition: 1586+1484+1652+1552+1556+1576+1560+1480)</div>
<div class="line">   <a class="code" href="classSolver.html">Solver</a> converged in 158 iterations.</div>
<div class="line">Cycle 8:</div>
<div class="line">   Number of active cells:       11320</div>
<div class="line">   Number of degrees of freedom: 23586 (by partition: 2988+2924+2890+2868+2864+3042+2932+3078)</div>
<div class="line">   <a class="code" href="classSolver.html">Solver</a> converged in 225 iterations.</div>
<div class="line">Cycle 9:</div>
<div class="line">   Number of active cells:       21424</div>
<div class="line">   Number of degrees of freedom: 43986 (by partition: 5470+5376+5642+5450+5630+5470+5416+5532)</div>
<div class="line">   <a class="code" href="classSolver.html">Solver</a> converged in 282 iterations.</div>
<div class="line">Cycle 10:</div>
<div class="line">   Number of active cells:       40696</div>
<div class="line">   Number of degrees of freedom: 83754 (by partition: 10660+10606+10364+10258+10354+10322+10586+10604)</div>
<div class="line">   <a class="code" href="classSolver.html">Solver</a> converged in 392 iterations.</div>
<div class="line">Cycle 11:</div>
<div class="line">   Number of active cells:       76978</div>
<div class="line">   Number of degrees of freedom: 156490 (by partition: 19516+20148+19390+19390+19336+19450+19730+19530)</div>
<div class="line">   <a class="code" href="classSolver.html">Solver</a> converged in 509 iterations.</div>
<div class="line">Cycle 12:</div>
<div class="line">   Number of active cells:       146206</div>
<div class="line">   Number of degrees of freedom: 297994 (by partition: 37462+37780+37000+37060+37232+37328+36860+37272)</div>
<div class="line">   <a class="code" href="classSolver.html">Solver</a> converged in 705 iterations.</div>
<div class="line">Cycle 13:</div>
<div class="line">   Number of active cells:       276184</div>
<div class="line">   Number of degrees of freedom: 558766 (by partition: 69206+69404+69882+71266+70348+69616+69796+69248)</div>
<div class="line">   <a class="code" href="classSolver.html">Solver</a> converged in 945 iterations.</div>
<div class="line">Cycle 14:</div>
<div class="line">   Number of active cells:       523000</div>
<div class="line">   Number of degrees of freedom: 1060258 (by partition: 132928+132296+131626+132172+132170+133588+132252+133226)</div>
<div class="line">   <a class="code" href="classSolver.html">Solver</a> converged in 1282 iterations.</div>
<div class="line">Cycle 15:</div>
<div class="line">   Number of active cells:       987394</div>
<div class="line">   Number of degrees of freedom: 1994226 (by partition: 253276+249068+247430+248402+248496+251380+248272+247902)</div>
<div class="line">   <a class="code" href="classSolver.html">Solver</a> converged in 1760 iterations.</div>
<div class="line">Cycle 16:</div>
<div class="line">   Number of active cells:       1867477</div>
<div class="line">   Number of degrees of freedom: 3771884 (by partition: 468452+474204+470818+470884+469960+</div>
<div class="line">471186+470686+475694)</div>
<div class="line">   <a class="code" href="classSolver.html">Solver</a> converged in 2251 iterations.</div>
</div><!-- fragment --><p>As can be seen, we can easily get to almost four million unknowns. In fact, the code's runtime with 8 processes was less than 7 minutes up to (and including) cycle 14, and 14 minutes including the second to last step. I lost the timing information for the last step, though, but you get the idea. All this is if the debug flag in the Makefile was changed to "off", i.e. "optimized", and with the generation of graphical output switched off for the reasons stated in the program comments above. The biggest 2d computations we did had roughly 7.1 million unknowns, and were done on 32 processes. It took about 40 minutes. Not surprisingly, the limiting factor for how far one can go is how much memory one has, since every process has to hold the entire mesh and <a class="el" href="classDoFHandler.html">DoFHandler</a> objects, although matrices and vectors are split up. For the 7.1M computation, the memory consumption was about 600 bytes per unknown, which is not bad, but one has to consider that this is for every unknown, whether we store the matrix and vector entries locally or not.</p>
<p>Here is some output generated in the 12th cycle of the program, i.e. with roughly 300,000 unknowns:</p>
<div class="image">
<img src="images/step-17.12-ux.png" />
</div>
 <div class="image">
<img src="images/step-17.12-uy.png" />
</div>
<p>As one would hope for, the x- (left) and y-displacements (right) shown here closely match what we already saw in <a class="el" href="step_8.html">step-8</a>. As shown there and in <a class="el" href="step_22.html">step-22</a>, we could as well have produced a vector plot of the displacement field, rather than plotting it as two separate scalar fields. What may be more interesting, though, is to look at the mesh and partition at this step:</p>
<div class="image">
<img src="images/step-17.12-grid.png" />
</div>
 <div class="image">
<img src="images/step-17.12-partition.png" />
</div>
<p>Again, the mesh (left) shows the same refinement pattern as seen previously. The right panel shows the partitioning of the domain across the 8 processes, each indicated by a different color. The picture shows that the subdomains are smaller where mesh cells are small, a fact that needs to be expected given that the partitioning algorithm tries to equilibrate the number of cells in each subdomain; this equilibration is also easily identified in the output shown above, where the number of degrees per subdomain is roughly the same.</p>
<p>It is worth noting that if we ran the same program with a different number of processes, that we would likely get slightly different output: a different mesh, different number of unknowns and iterations to convergence. The reason for this is that while the matrix and right hand side are the same independent of the number of processes used, the preconditioner is not: it performs an ILU(0) on the chunk of the matrix of <em>each processor separately</em>. Thus, it's effectiveness as a preconditioner diminishes as the number of processes increases, which makes the number of iterations increase. Since a different preconditioner leads to slight changes in the computed solution, this will then lead to slightly different mesh cells tagged for refinement, and larger differences in subsequent steps. The solution will always look very similar, though.</p>
<p>Finally, here are some results for a 3d simulation. You can repeat these by first changing </p>
<div class="fragment"><div class="line">ElasticProblem&lt;2&gt; elastic_problem;</div>
</div><!-- fragment --><p> to </p>
<div class="fragment"><div class="line">ElasticProblem&lt;3&gt; elastic_problem;</div>
</div><!-- fragment --><p> in the main function, and then in the Makefile, change the reference to the 2d libraries to their 3d counterparts. If you then run the program in parallel, you get something similar to this (this is for a job with 16 processes): </p>
<div class="fragment"><div class="line">Cycle 0:</div>
<div class="line">   Number of active cells:       512</div>
<div class="line">   Number of degrees of freedom: 2187 (by partition: 114+156+150+114+114+210+105+102+120+120+96+123+141+183+156+183)</div>
<div class="line">   <a class="code" href="classSolver.html">Solver</a> converged in 27 iterations.</div>
<div class="line">Cycle 1:</div>
<div class="line">   Number of active cells:       1604</div>
<div class="line">   Number of degrees of freedom: 6549 (by partition: 393+291+342+354+414+417+570+366+444+288+543+525+345+387+489+381)</div>
<div class="line">   <a class="code" href="classSolver.html">Solver</a> converged in 42 iterations.</div>
<div class="line">Cycle 2:</div>
<div class="line">   Number of active cells:       4992</div>
<div class="line">   Number of degrees of freedom: 19167 (by partition: 1428+1266+1095+1005+1455+1257+1410+1041+1320+1380+1080+1050+963+1005+1188+1224)</div>
<div class="line">   <a class="code" href="classSolver.html">Solver</a> converged in 65 iterations.</div>
<div class="line">Cycle 3:</div>
<div class="line">   Number of active cells:       15485</div>
<div class="line">   Number of degrees of freedom: 56760 (by partition: 3099+3714+3384+3147+4332+3858+3615+3117+3027+3888+3942+3276+4149+3519+3030+3663)</div>
<div class="line">   <a class="code" href="classSolver.html">Solver</a> converged in 96 iterations.</div>
<div class="line">Cycle 4:</div>
<div class="line">   Number of active cells:       48014</div>
<div class="line">   Number of degrees of freedom: 168762 (by partition: 11043+10752+9846+10752+9918+10584+10545+11433+12393+11289+10488+9885+10056+9771+11031+8976)</div>
<div class="line">   <a class="code" href="classSolver.html">Solver</a> converged in 132 iterations.</div>
<div class="line">Cycle 5:</div>
<div class="line">   Number of active cells:       148828</div>
<div class="line">   Number of degrees of freedom: 492303 (by partition: 31359+30588+34638+32244+30984+28902+33297+31569+29778+29694+28482+28032+32283+30702+31491+28260)</div>
<div class="line">   <a class="code" href="classSolver.html">Solver</a> converged in 179 iterations.</div>
<div class="line">Cycle 6:</div>
<div class="line">   Number of active cells:       461392</div>
<div class="line">   Number of degrees of freedom: 1497951 (by partition: 103587+100827+97611+93726+93429+88074+95892+88296+96882+93000+87864+90915+92232+86931+98091+90594)</div>
<div class="line">   <a class="code" href="classSolver.html">Solver</a> converged in 261 iterations.</div>
</div><!-- fragment --><p>The last step, going up to 1.5 million unknowns, takes about 55 minutes with 16 processes on 8 dual-processor machines (of the kind available in 2003). The graphical output generated by this job is rather large (cycle 5 already prints around 82 MB of GMV data), so we contend ourselves with showing output from cycle 4:</p>
<div class="image">
<img src="images/step-17.4-3d-partition.png" />
</div>
 <div class="image">
<img src="images/step-17.4-3d-ux.png" />
</div>
<p>The left picture shows the partitioning of the cube into 16 processes, whereas the right one shows the x-displacement along two cutplanes through the cube.</p>
<p><a class="anchor" id="extensions"></a> <a class="anchor" id="Possibilitiesforextensions"></a></p>
<h3>Possibilities for extensions</h3>
<p>The program keeps a complete copy of the <a class="el" href="classTriangulation.html">Triangulation</a> and <a class="el" href="classDoFHandler.html">DoFHandler</a> objects on every processor. That's obviously the bottleneck for as far as parallelization goes. Internally, within deal.II, parallelizing the data structures used in hierarchic and unstructured triangulations is a very hard problem, and it took us a few more years to make this happen. The <a class="el" href="step_40.html">step-40</a> tutorial program and the <a class="el" href="group__distributed.html">Parallel computing with multiple processors using distributed memory</a> documentation module talk about how to do these steps and what it takes from an application perspective. An obvious extension of the current program would be to use this functionality to completely distribute computations to many more processors than used here. <a class="anchor" id="PlainProg"></a> </p>
<h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div>
<div class="line"><span class="comment"> * @f$Id: @ref step_17 &quot;step-17&quot;.cc 31077 2013-10-02 17:59:44Z heister @f$</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * Copyright (C) 2000 - 2013 by the deal.II authors</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div>
<div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div>
<div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div>
<div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div>
<div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE at</span></div>
<div class="line"><span class="comment"> * the top level of the deal.II distribution.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * Author: Wolfgang Bangerth, University of Texas at Austin, 2000, 2004</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/base/quadrature_lib.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/base/function.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/base/logstream.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/lac/vector.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/lac/full_matrix.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/lac/constraint_matrix.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_generator.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_refinement.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_accessor.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_iterator.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_boundary_lib.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_handler.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_accessor.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_tools.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_values.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_system.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_q.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/vector_tools.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/matrix_tools.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/data_out.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/error_estimator.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/base/conditional_ostream.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/base/utilities.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/lac/petsc_vector.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/lac/petsc_parallel_vector.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/lac/petsc_parallel_sparse_matrix.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/lac/petsc_solver.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/lac/petsc_precondition.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_tools.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_renumbering.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span>Step17</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">using namespace </span>dealii;</div>
<div class="line"></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keyword">class </span>ElasticProblem</div>
<div class="line">  {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    ElasticProblem ();</div>
<div class="line">    ~ElasticProblem ();</div>
<div class="line">    <span class="keywordtype">void</span> run ();</div>
<div class="line"></div>
<div class="line">  <span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">void</span> setup_system ();</div>
<div class="line">    <span class="keywordtype">void</span> assemble_system ();</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> solve ();</div>
<div class="line">    <span class="keywordtype">void</span> refine_grid ();</div>
<div class="line">    <span class="keywordtype">void</span> output_results (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle) <span class="keyword">const</span>;</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classConditionalOStream.html">ConditionalOStream</a> pcout;</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a>   triangulation;</div>
<div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>      dof_handler;</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>        fe;</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classConstraintMatrix.html">ConstraintMatrix</a>     hanging_node_constraints;</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">PETScWrappers::MPI::SparseMatrix</a> system_matrix;</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a>       solution;</div>
<div class="line">    <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a>       system_rhs;</div>
<div class="line"></div>
<div class="line">    MPI_Comm mpi_communicator;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_mpi_processes;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">this_mpi_process</a>;</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keyword">class </span>RightHandSide :  <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div>
<div class="line">  {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    RightHandSide ();</div>
<div class="line"></div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> vector_value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div>
<div class="line">                               <a class="code" href="classVector.html">Vector&lt;double&gt;</a>   &amp;values) <span class="keyword">const</span>;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> vector_value_list (<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &gt; &amp;points,</div>
<div class="line">                                    std::vector&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &gt;   &amp;value_list) <span class="keyword">const</span>;</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  RightHandSide&lt;dim&gt;::RightHandSide () :</div>
<div class="line">    <a class="code" href="classFunction.html">Function</a>&lt;dim&gt; (dim)</div>
<div class="line">  {}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keyword">inline</span></div>
<div class="line">  <span class="keywordtype">void</span> RightHandSide&lt;dim&gt;::vector_value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div>
<div class="line">                                         <a class="code" href="classVector.html">Vector&lt;double&gt;</a>   &amp;values)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (values.<a class="code" href="classVector.html#ad900ae86530d76f5fbff32c21c582b71">size</a>() == dim,</div>
<div class="line">            <a class="code" href="group__Exceptions.html#ga325fd73751a9373f1b901962daeb2ea7">ExcDimensionMismatch</a> (values.<a class="code" href="classVector.html#ad900ae86530d76f5fbff32c21c582b71">size</a>(), dim));</div>
<div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (dim &gt;= 2, <a class="code" href="group__Exceptions.html#gae372f2b2b6a64585eb80ca01d0b0e236">ExcInternalError</a>());</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> point_1, point_2;</div>
<div class="line">    point_1(0) = 0.5;</div>
<div class="line">    point_2(0) = -0.5;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (((p-point_1).square() &lt; 0.2*0.2) ||</div>
<div class="line">        ((p-point_2).square() &lt; 0.2*0.2))</div>
<div class="line">      values(0) = 1;</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">      values(0) = 0;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (p.<a class="code" href="classPoint.html#ad46f55479010282e242b1d8e427285e8">square</a>() &lt; 0.2*0.2)</div>
<div class="line">      values(1) = 1;</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">      values(1) = 0;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> RightHandSide&lt;dim&gt;::vector_value_list (<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &gt; &amp;points,</div>
<div class="line">                                              std::vector&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &gt;   &amp;value_list)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_points = points.<a class="code" href="classVector.html#ad900ae86530d76f5fbff32c21c582b71">size</a>();</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (value_list.size() == n_points,</div>
<div class="line">            <a class="code" href="group__Exceptions.html#ga325fd73751a9373f1b901962daeb2ea7">ExcDimensionMismatch</a> (value_list.size(), n_points));</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p=0; p&lt;n_points; ++p)</div>
<div class="line">      RightHandSide&lt;dim&gt;::vector_value (points[p],</div>
<div class="line">                                        value_list[p]);</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  ElasticProblem&lt;dim&gt;::ElasticProblem ()</div>
<div class="line">    :</div>
<div class="line">    pcout (std::cout),</div>
<div class="line">    dof_handler (triangulation),</div>
<div class="line">    fe (<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(1), dim),</div>
<div class="line">    mpi_communicator (MPI_COMM_WORLD),</div>
<div class="line">    n_mpi_processes (Utilities::MPI::n_mpi_processes(mpi_communicator)),</div>
<div class="line">    <a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">this_mpi_process</a> (Utilities::MPI::<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">this_mpi_process</a>(mpi_communicator))</div>
<div class="line">  {</div>
<div class="line">    pcout.set_condition(this_mpi_process == 0);</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  ElasticProblem&lt;dim&gt;::~ElasticProblem ()</div>
<div class="line">  {</div>
<div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a78fda065d6f58e554a3335ea9b5b482e">clear</a> ();</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> ElasticProblem&lt;dim&gt;::setup_system ()</div>
<div class="line">  {</div>
<div class="line">    <a class="code" href="namespaceGridTools.html#a5b4706b77042db5437cf81fd13e62b20">GridTools::partition_triangulation</a> (n_mpi_processes, triangulation);</div>
<div class="line"></div>
<div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#afcfcc3b473f444f50d206ae62dfe3694">distribute_dofs</a> (fe);</div>
<div class="line">    <a class="code" href="namespaceDoFRenumbering.html#af21ead37a274586c21c61bbce6dedd56">DoFRenumbering::subdomain_wise</a> (dof_handler);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> n_local_dofs</div>
<div class="line">      = <a class="code" href="namespaceDoFTools.html#a95c92f74cc712dd820ed42d39ae45e10">DoFTools::count_dofs_with_subdomain_association</a> (dof_handler,</div>
<div class="line">                                                         this_mpi_process);</div>
<div class="line"></div>
<div class="line">    system_matrix.reinit (mpi_communicator,</div>
<div class="line">                          dof_handler.<a class="code" href="classDoFHandler.html#a54e7270f2ba6206604f794114b39a2aa">n_dofs</a>(),</div>
<div class="line">                          dof_handler.<a class="code" href="classDoFHandler.html#a54e7270f2ba6206604f794114b39a2aa">n_dofs</a>(),</div>
<div class="line">                          n_local_dofs,</div>
<div class="line">                          n_local_dofs,</div>
<div class="line">                          dof_handler.<a class="code" href="classDoFHandler.html#a59f7c83998cc66a6ac527e01aa4ff5a7">max_couplings_between_dofs</a>());</div>
<div class="line"></div>
<div class="line">    solution.<a class="code" href="classVector.html#ac3adfcf8cf35943558fc27ef989b7263">reinit</a> (mpi_communicator, dof_handler.<a class="code" href="classDoFHandler.html#a54e7270f2ba6206604f794114b39a2aa">n_dofs</a>(), n_local_dofs);</div>
<div class="line">    system_rhs.<a class="code" href="classBlockVector.html#a4caa9be7a7053fd6ae9fac1da74e564b">reinit</a> (mpi_communicator, dof_handler.<a class="code" href="classDoFHandler.html#a54e7270f2ba6206604f794114b39a2aa">n_dofs</a>(), n_local_dofs);</div>
<div class="line"></div>
<div class="line">    hanging_node_constraints.clear ();</div>
<div class="line">    <a class="code" href="group__constraints.html#gabe9d21d4bb33ce556a6e6e80c2bf4b41">DoFTools::make_hanging_node_constraints</a> (dof_handler,</div>
<div class="line">                                             hanging_node_constraints);</div>
<div class="line">    hanging_node_constraints.close ();</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> ElasticProblem&lt;dim&gt;::assemble_system ()</div>
<div class="line">  {</div>
<div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>  quadrature_formula(2);</div>
<div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values (fe, quadrature_formula,</div>
<div class="line">                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>   | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div>
<div class="line">                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   dofs_per_cell = fe.dofs_per_cell;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   n_q_points    = quadrature_formula.size();</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>   cell_matrix (dofs_per_cell, dofs_per_cell);</div>
<div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       cell_rhs (dofs_per_cell);</div>
<div class="line"></div>
<div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices (dofs_per_cell);</div>
<div class="line"></div>
<div class="line">    std::vector&lt;double&gt;     lambda_values (n_q_points);</div>
<div class="line">    std::vector&lt;double&gt;     mu_values (n_q_points);</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classConstantFunction.html">ConstantFunction&lt;dim&gt;</a> lambda(1.), mu(1.);</div>
<div class="line"></div>
<div class="line">    RightHandSide&lt;dim&gt;      right_hand_side;</div>
<div class="line">    std::vector&lt;Vector&lt;double&gt; &gt; rhs_values (n_q_points,</div>
<div class="line">                                             <a class="code" href="classVector.html">Vector&lt;double&gt;</a>(dim));</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div>
<div class="line">    cell = dof_handler.<a class="code" href="classDoFHandler.html#a6f2aa9c61385cbb749ed3d2e7bfe3de1">begin_active</a>(),</div>
<div class="line">    endc = dof_handler.<a class="code" href="classDoFHandler.html#abf64c3734383b6fb1bed4888935f2edf">end</a>();</div>
<div class="line">    <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div>
<div class="line">      <span class="keywordflow">if</span> (cell-&gt;subdomain_id() == <a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">this_mpi_process</a>)</div>
<div class="line">        {</div>
<div class="line">          cell_matrix = 0;</div>
<div class="line">          cell_rhs = 0;</div>
<div class="line"></div>
<div class="line">          fe_values.<a class="code" href="classFEValues.html#afde502903642c57ade24dfcebf5c1650">reinit</a> (cell);</div>
<div class="line"></div>
<div class="line">          lambda.value_list (fe_values.<a class="code" href="classFEValuesBase.html#a5f8732ebe2d3c6746f6de26a79cb1e45">get_quadrature_points</a>(), lambda_values);</div>
<div class="line">          mu.value_list     (fe_values.<a class="code" href="classFEValuesBase.html#a5f8732ebe2d3c6746f6de26a79cb1e45">get_quadrature_points</a>(), mu_values);</div>
<div class="line"></div>
<div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div>
<div class="line">            {</div>
<div class="line">              <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span></div>
<div class="line">              component_i = fe.system_to_component_index(i).first;</div>
<div class="line"></div>
<div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div>
<div class="line">                {</div>
<div class="line">                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span></div>
<div class="line">                  component_j = fe.system_to_component_index(j).first;</div>
<div class="line"></div>
<div class="line">                  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point=0; q_point&lt;n_q_points;</div>
<div class="line">                       ++q_point)</div>
<div class="line">                    {</div>
<div class="line">                      cell_matrix(i,j)</div>
<div class="line">                      +=</div>
<div class="line">                        (</div>
<div class="line">                          (fe_values.<a class="code" href="classFEValuesBase.html#ac4cee7628c2903a89c5c399fddeb00a5">shape_grad</a>(i,q_point)[component_i] *</div>
<div class="line">                           fe_values.<a class="code" href="classFEValuesBase.html#ac4cee7628c2903a89c5c399fddeb00a5">shape_grad</a>(j,q_point)[component_j] *</div>
<div class="line">                           lambda_values[q_point])</div>
<div class="line">                          +</div>
<div class="line">                          (fe_values.<a class="code" href="classFEValuesBase.html#ac4cee7628c2903a89c5c399fddeb00a5">shape_grad</a>(i,q_point)[component_j] *</div>
<div class="line">                           fe_values.<a class="code" href="classFEValuesBase.html#ac4cee7628c2903a89c5c399fddeb00a5">shape_grad</a>(j,q_point)[component_i] *</div>
<div class="line">                           mu_values[q_point])</div>
<div class="line">                          +</div>
<div class="line">                          ((component_i == component_j) ?</div>
<div class="line">                           (fe_values.<a class="code" href="classFEValuesBase.html#ac4cee7628c2903a89c5c399fddeb00a5">shape_grad</a>(i,q_point) *</div>
<div class="line">                            fe_values.<a class="code" href="classFEValuesBase.html#ac4cee7628c2903a89c5c399fddeb00a5">shape_grad</a>(j,q_point) *</div>
<div class="line">                            mu_values[q_point])  :</div>
<div class="line">                           0)</div>
<div class="line">                        )</div>
<div class="line">                        *</div>
<div class="line">                        fe_values.<a class="code" href="classFEValuesBase.html#ad097580a2f71878695096cc73b271b9d">JxW</a>(q_point);</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">          right_hand_side.vector_value_list (fe_values.<a class="code" href="classFEValuesBase.html#a5f8732ebe2d3c6746f6de26a79cb1e45">get_quadrature_points</a>(),</div>
<div class="line">                                             rhs_values);</div>
<div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div>
<div class="line">            {</div>
<div class="line">              <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span></div>
<div class="line">              component_i = fe.system_to_component_index(i).first;</div>
<div class="line"></div>
<div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point=0; q_point&lt;n_q_points; ++q_point)</div>
<div class="line">                cell_rhs(i) += fe_values.<a class="code" href="classFEValuesBase.html#abe4de48ff59778bb82a0ec13037804aa">shape_value</a>(i,q_point) *</div>
<div class="line">                               rhs_values[q_point](component_i) *</div>
<div class="line">                               fe_values.<a class="code" href="classFEValuesBase.html#ad097580a2f71878695096cc73b271b9d">JxW</a>(q_point);</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">          cell-&gt;get_dof_indices (local_dof_indices);</div>
<div class="line">          hanging_node_constraints</div>
<div class="line">          .distribute_local_to_global(cell_matrix, cell_rhs,</div>
<div class="line">                                      local_dof_indices,</div>
<div class="line">                                      system_matrix, system_rhs);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">    system_matrix.compress(VectorOperation::add);</div>
<div class="line">    system_rhs.<a class="code" href="classBlockVector.html#ad581edc4d3b86a88c4277117c4fae57a">compress</a>(VectorOperation::add);</div>
<div class="line"></div>
<div class="line">    std::map&lt;types::global_dof_index,double&gt; boundary_values;</div>
<div class="line">    <a class="code" href="namespaceVectorTools.html#a199f38e07822b47e5b5957c21ce35d1b">VectorTools::interpolate_boundary_values</a> (dof_handler,</div>
<div class="line">                                              0,</div>
<div class="line">                                              <a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a>(dim),</div>
<div class="line">                                              boundary_values);</div>
<div class="line">    <a class="code" href="namespaceMatrixTools.html#a41a069894610445f84840d712d4f891e">MatrixTools::apply_boundary_values</a> (boundary_values,</div>
<div class="line">                                        system_matrix, solution,</div>
<div class="line">                                        system_rhs, <span class="keyword">false</span>);</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ElasticProblem&lt;dim&gt;::solve ()</div>
<div class="line">  {</div>
<div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a>           solver_control (solution.<a class="code" href="classVector.html#ad900ae86530d76f5fbff32c21c582b71">size</a>(),</div>
<div class="line">                                            1e-8*system_rhs.<a class="code" href="classBlockVectorBase.html#a39191b8a99e917a95c8523f94c807a95">l2_norm</a>());</div>
<div class="line">    <a class="code" href="classPETScWrappers_1_1SolverCG.html">PETScWrappers::SolverCG</a> cg (solver_control,</div>
<div class="line">                                mpi_communicator);</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classPETScWrappers_1_1PreconditionBlockJacobi.html">PETScWrappers::PreconditionBlockJacobi</a> preconditioner(system_matrix);</div>
<div class="line"></div>
<div class="line">    cg.solve (system_matrix, solution, system_rhs,</div>
<div class="line">              preconditioner);</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classPETScWrappers_1_1Vector.html">PETScWrappers::Vector</a> localized_solution (solution);</div>
<div class="line"></div>
<div class="line">    hanging_node_constraints.distribute (localized_solution);</div>
<div class="line"></div>
<div class="line">    solution = localized_solution;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> solver_control.last_step();</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> ElasticProblem&lt;dim&gt;::output_results (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="classPETScWrappers_1_1Vector.html">PETScWrappers::Vector</a> localized_solution (solution);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (this_mpi_process == 0)</div>
<div class="line">      {</div>
<div class="line">        std::ostringstream filename;</div>
<div class="line">        filename &lt;&lt; <span class="stringliteral">&quot;solution-&quot;</span> &lt;&lt; cycle &lt;&lt; <span class="stringliteral">&quot;.gmv&quot;</span>;</div>
<div class="line"></div>
<div class="line">        std::ofstream output (filename.str().c_str());</div>
<div class="line"></div>
<div class="line">        <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div>
<div class="line">        data_out.<a class="code" href="classDataOut__DoFData.html#a5e63bad650805ce93cd74c6dc3b29b11">attach_dof_handler</a> (dof_handler);</div>
<div class="line"></div>
<div class="line">        std::vector&lt;std::string&gt; solution_names;</div>
<div class="line">        <span class="keywordflow">switch</span> (dim)</div>
<div class="line">          {</div>
<div class="line">          <span class="keywordflow">case</span> 1:</div>
<div class="line">            solution_names.push_back (<span class="stringliteral">&quot;displacement&quot;</span>);</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">          <span class="keywordflow">case</span> 2:</div>
<div class="line">            solution_names.push_back (<span class="stringliteral">&quot;x_displacement&quot;</span>);</div>
<div class="line">            solution_names.push_back (<span class="stringliteral">&quot;y_displacement&quot;</span>);</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">          <span class="keywordflow">case</span> 3:</div>
<div class="line">            solution_names.push_back (<span class="stringliteral">&quot;x_displacement&quot;</span>);</div>
<div class="line">            solution_names.push_back (<span class="stringliteral">&quot;y_displacement&quot;</span>);</div>
<div class="line">            solution_names.push_back (<span class="stringliteral">&quot;z_displacement&quot;</span>);</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">          <span class="keywordflow">default</span>:</div>
<div class="line">            <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#gae372f2b2b6a64585eb80ca01d0b0e236">ExcInternalError</a>());</div>
<div class="line">          }</div>
<div class="line"></div>
<div class="line">        data_out.add_data_vector (localized_solution, solution_names);</div>
<div class="line"></div>
<div class="line">        std::vector&lt;unsigned int&gt; partition_int (triangulation.<a class="code" href="classTriangulation.html#aa21f25016ce1b9d70d2003a128985870">n_active_cells</a>());</div>
<div class="line">        <a class="code" href="namespaceGridTools.html#ae0cb61bdd7e17c6b1589bdd16891e561">GridTools::get_subdomain_association</a> (triangulation, partition_int);</div>
<div class="line"></div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> partitioning(partition_int.begin(),</div>
<div class="line">                                          partition_int.end());</div>
<div class="line"></div>
<div class="line">        data_out.add_data_vector (partitioning, <span class="stringliteral">&quot;partitioning&quot;</span>);</div>
<div class="line"></div>
<div class="line">        data_out.build_patches ();</div>
<div class="line">        data_out.write_gmv (output);</div>
<div class="line">      }</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> ElasticProblem&lt;dim&gt;::refine_grid ()</div>
<div class="line">  {</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="classPETScWrappers_1_1Vector.html">PETScWrappers::Vector</a> localized_solution (solution);</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classVector.html">Vector&lt;float&gt;</a> local_error_per_cell (triangulation.<a class="code" href="classTriangulation.html#aa21f25016ce1b9d70d2003a128985870">n_active_cells</a>());</div>
<div class="line">    <a class="code" href="classKellyErrorEstimator.html#ae1f3149bcc7653baa5ef0a2ac88070b9">KellyErrorEstimator&lt;dim&gt;::estimate</a> (dof_handler,</div>
<div class="line">                                        <a class="code" href="classQGauss.html">QGauss&lt;dim-1&gt;</a>(2),</div>
<div class="line">                                        <span class="keyword">typename</span> <a class="code" href="structFunctionMap.html#aa286a6c5e13045f84faabfd7170b1c48">FunctionMap&lt;dim&gt;::type</a>(),</div>
<div class="line">                                        localized_solution,</div>
<div class="line">                                        local_error_per_cell,</div>
<div class="line">                                        <a class="code" href="classComponentMask.html">ComponentMask</a>(),</div>
<div class="line">                                        0,</div>
<div class="line">                                        <a class="code" href="group__threads.html#ga63ae5e375c4a785919b8a2ea7ca5653d">multithread_info</a>.n_threads(),</div>
<div class="line">                                        <a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">this_mpi_process</a>);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_local_cells</div>
<div class="line">      = <a class="code" href="namespaceGridTools.html#a8c212a30784bec20b1ae13fad3fd579c">GridTools::count_cells_with_subdomain_association</a> (triangulation,</div>
<div class="line">                                                           this_mpi_process);</div>
<div class="line">    <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a></div>
<div class="line">    distributed_all_errors (mpi_communicator,</div>
<div class="line">                            triangulation.<a class="code" href="classTriangulation.html#aa21f25016ce1b9d70d2003a128985870">n_active_cells</a>(),</div>
<div class="line">                            n_local_cells);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;local_error_per_cell.size(); ++i)</div>
<div class="line">      <span class="keywordflow">if</span> (local_error_per_cell(i) != 0)</div>
<div class="line">        distributed_all_errors(i) = local_error_per_cell(i);</div>
<div class="line">    distributed_all_errors.compress (VectorOperation::insert);</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;float&gt;</a> localized_all_errors (distributed_all_errors);</div>
<div class="line"></div>
<div class="line">    <a class="code" href="namespaceGridRefinement.html#a722dd0fd72533bf87367b0ec14e893e0">GridRefinement::refine_and_coarsen_fixed_number</a> (triangulation,</div>
<div class="line">                                                     localized_all_errors,</div>
<div class="line">                                                     0.3, 0.03);</div>
<div class="line">    triangulation.<a class="code" href="classTriangulation.html#aaedd900205c1879d8d9ef6ffe7d1a554">execute_coarsening_and_refinement</a> ();</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> ElasticProblem&lt;dim&gt;::run ()</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle=0; cycle&lt;10; ++cycle)</div>
<div class="line">      {</div>
<div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; <span class="charliteral">&#39;:&#39;</span> &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (cycle == 0)</div>
<div class="line">          {</div>
<div class="line">            <a class="code" href="namespaceGridGenerator.html#a7149c59cefa805a132177cfa6cb953bd">GridGenerator::hyper_cube</a> (triangulation, -1, 1);</div>
<div class="line">            triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a> (3);</div>
<div class="line">          }</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">          refine_grid ();</div>
<div class="line"></div>
<div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells:       &quot;</span></div>
<div class="line">              &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#aa21f25016ce1b9d70d2003a128985870">n_active_cells</a>()</div>
<div class="line">              &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line">        setup_system ();</div>
<div class="line"></div>
<div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span></div>
<div class="line">              &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#a54e7270f2ba6206604f794114b39a2aa">n_dofs</a>()</div>
<div class="line">              &lt;&lt; <span class="stringliteral">&quot; (by partition:&quot;</span>;</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p=0; p&lt;n_mpi_processes; ++p)</div>
<div class="line">          pcout &lt;&lt; (p==0 ? <span class="charliteral">&#39; &#39;</span> : <span class="charliteral">&#39;+&#39;</span>)</div>
<div class="line">                &lt;&lt; (<a class="code" href="namespaceDoFTools.html#a95c92f74cc712dd820ed42d39ae45e10">DoFTools::</a></div>
<div class="line"><a class="code" href="namespaceDoFTools.html#a95c92f74cc712dd820ed42d39ae45e10">                    count_dofs_with_subdomain_association</a> (dof_handler,</div>
<div class="line">                                                           p));</div>
<div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line">        assemble_system ();</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_iterations = solve ();</div>
<div class="line"></div>
<div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;   Solver converged in &quot;</span> &lt;&lt; n_iterations</div>
<div class="line">              &lt;&lt; <span class="stringliteral">&quot; iterations.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line">        output_results (cycle);</div>
<div class="line">      }</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> <a class="code" href="group__ParameterGui.html#ga0ddf1224851353fc92bfbff6f499fa97">main</a> (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">try</span></div>
<div class="line">    {</div>
<div class="line">      <span class="keyword">using namespace </span>dealii;</div>
<div class="line">      <span class="keyword">using namespace </span>Step17;</div>
<div class="line"></div>
<div class="line">      <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_initialization(argc, argv, 1);</div>
<div class="line">      {</div>
<div class="line">        deallog.<a class="code" href="classLogStream.html#a8028e970ad8388596d625ed463894e98">depth_console</a> (0);</div>
<div class="line"></div>
<div class="line">        ElasticProblem&lt;2&gt; elastic_problem;</div>
<div class="line">        elastic_problem.run ();</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div>
<div class="line">    {</div>
<div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">catch</span> (...)</div>
<div class="line">    {</div>
<div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jan 27 2014 15:26:50 for The deal.II Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
