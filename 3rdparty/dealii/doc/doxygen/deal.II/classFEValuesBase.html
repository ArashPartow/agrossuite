<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>The deal.II Library: FEValuesBase&lt; dim, spacedim &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="http://www.dealii.org/deal.ico"></link>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2014 by the deal.II authors"></meta>
<meta name="deal.II-version" content="8.1.0"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 8.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classFEValuesBase-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">FEValuesBase&lt; dim, spacedim &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__feaccess.html">Finite element access/FEValues classes</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="fe_2fe__values_8h_source.html">fe_values.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for FEValuesBase&lt; dim, spacedim &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classFEValuesBase__inherit__graph.svg" width="468" height="347"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase_1_1CellIterator.html">CellIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3adde03753e99c526bb323533faa25d2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a3adde03753e99c526bb323533faa25d2">FEValuesBase</a> (const unsigned <a class="el" href="classint.html">int</a> n_q_points, const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>, const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> <a class="el" href="classFEValuesData.html#a8f61e745cc3938c8a2534fa857d15fca">update_flags</a>, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;<a class="el" href="classFEValuesBase.html#a8fb1d5f367902df6b2b598d9da1b0398">mapping</a>, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;<a class="el" href="classFEValuesBase.html#aeb05cc9511ff887438f3e6cf036a3134">fe</a>)</td></tr>
<tr class="separator:a3adde03753e99c526bb323533faa25d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d56296cbd8389414d14d7d42219b7e7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a5d56296cbd8389414d14d7d42219b7e7">~FEValuesBase</a> ()</td></tr>
<tr class="separator:a5d56296cbd8389414d14d7d42219b7e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1580f9a00ed2601c5d9169b85f46df2b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga1580f9a00ed2601c5d9169b85f46df2b">DeclException1</a> (ExcAccessToUninitializedField, char *,&lt;&lt; (&quot;You are requesting information from an <a class="el" href="classFEValues.html">FEValues</a>/<a class="el" href="classFEFaceValues.html">FEFaceValues</a>/<a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> &quot;&quot;object for which this kind of information has not been computed. What &quot;&quot;information these objects compute is determined by the update_* flags you &quot;&quot;pass to the constructor. Here, the operation you are attempting requires &quot;&quot;the &lt;&quot;)&lt;&lt; arg1&lt;&lt; &quot;&gt; flag to be set, but it was apparently not specified upon construction.&quot;)</td></tr>
<tr class="separator:ga1580f9a00ed2601c5d9169b85f46df2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga140b747584c951725b54bd57754320fb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga140b747584c951725b54bd57754320fb">DeclException0</a> (ExcCannotInitializeField)</td></tr>
<tr class="separator:ga140b747584c951725b54bd57754320fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa63a78552bf8f787f878e9984b4c5b4f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaa63a78552bf8f787f878e9984b4c5b4f">DeclException0</a> (ExcInvalidUpdateFlag)</td></tr>
<tr class="separator:gaa63a78552bf8f787f878e9984b4c5b4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97d0542f73b6741291022467e8bcf350"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga97d0542f73b6741291022467e8bcf350">DeclException0</a> (ExcFEDontMatch)</td></tr>
<tr class="separator:ga97d0542f73b6741291022467e8bcf350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c4ee91a4333e56c9c3251aa676663ca"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga3c4ee91a4333e56c9c3251aa676663ca">DeclException1</a> (ExcShapeFunctionNotPrimitive, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;The shape function with index &quot;&lt;&lt; arg1&lt;&lt; &quot; is not primitive, i.e. it is vector-valued and &quot;&lt;&lt; &quot;has more than one non-zero vector component. This &quot;&lt;&lt; &quot;function cannot be called for these shape functions. &quot;&lt;&lt; &quot;Maybe you want to use the same function with the &quot;&lt;&lt; &quot;_component suffix?&quot;)</td></tr>
<tr class="separator:ga3c4ee91a4333e56c9c3251aa676663ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4130d601e610483bd016a97e9735e1e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaa4130d601e610483bd016a97e9735e1e">DeclException0</a> (ExcFENotPrimitive)</td></tr>
<tr class="separator:gaa4130d601e610483bd016a97e9735e1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">ShapeAccess Access to shape function values</div></td></tr>
<tr class="memitem:abe4de48ff59778bb82a0ec13037804aa"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdouble.html">double</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#abe4de48ff59778bb82a0ec13037804aa">shape_value</a> (const unsigned <a class="el" href="classint.html">int</a> function_no, const unsigned <a class="el" href="classint.html">int</a> point_no) const </td></tr>
<tr class="separator:abe4de48ff59778bb82a0ec13037804aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55a507d64ae810232dc0e8bdbf7ee4c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a55a507d64ae810232dc0e8bdbf7ee4c1">shape_value_component</a> (const unsigned <a class="el" href="classint.html">int</a> function_no, const unsigned <a class="el" href="classint.html">int</a> point_no, const unsigned <a class="el" href="classint.html">int</a> component) const </td></tr>
<tr class="separator:a55a507d64ae810232dc0e8bdbf7ee4c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4cee7628c2903a89c5c399fddeb00a5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#ac4cee7628c2903a89c5c399fddeb00a5">shape_grad</a> (const unsigned <a class="el" href="classint.html">int</a> function_no, const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEValuesBase.html#a75b6f2cb7c735b51b20093d90b1930b0">quadrature_point</a>) const </td></tr>
<tr class="separator:ac4cee7628c2903a89c5c399fddeb00a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a836dd15035c0493714a284ee3d0e0a16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a836dd15035c0493714a284ee3d0e0a16">shape_grad_component</a> (const unsigned <a class="el" href="classint.html">int</a> function_no, const unsigned <a class="el" href="classint.html">int</a> point_no, const unsigned <a class="el" href="classint.html">int</a> component) const </td></tr>
<tr class="separator:a836dd15035c0493714a284ee3d0e0a16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a294fe8cefce05f98a6135582cacf91c5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a294fe8cefce05f98a6135582cacf91c5">shape_hessian</a> (const unsigned <a class="el" href="classint.html">int</a> function_no, const unsigned <a class="el" href="classint.html">int</a> point_no) const </td></tr>
<tr class="separator:a294fe8cefce05f98a6135582cacf91c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad61ba7df056187a6fd8975cc02184a1f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#ad61ba7df056187a6fd8975cc02184a1f">shape_2nd_derivative</a> (const unsigned <a class="el" href="classint.html">int</a> function_no, const unsigned <a class="el" href="classint.html">int</a> point_no) const <a class="el" href="group__Sparsity.html#ga0849dabf81f46d4d964e251c286784dd">DEAL_II_DEPRECATED</a></td></tr>
<tr class="separator:ad61ba7df056187a6fd8975cc02184a1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa36d3dcb8e642db56dcb38757c2ab2dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTensor.html">Tensor</a>&lt; 2, spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#aa36d3dcb8e642db56dcb38757c2ab2dc">shape_hessian_component</a> (const unsigned <a class="el" href="classint.html">int</a> function_no, const unsigned <a class="el" href="classint.html">int</a> point_no, const unsigned <a class="el" href="classint.html">int</a> component) const </td></tr>
<tr class="separator:aa36d3dcb8e642db56dcb38757c2ab2dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a462a6f32cbb8bf21a6ec223b4ec72f48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTensor.html">Tensor</a>&lt; 2, spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a462a6f32cbb8bf21a6ec223b4ec72f48">shape_2nd_derivative_component</a> (const unsigned <a class="el" href="classint.html">int</a> function_no, const unsigned <a class="el" href="classint.html">int</a> point_no, const unsigned <a class="el" href="classint.html">int</a> component) const <a class="el" href="group__Sparsity.html#ga0849dabf81f46d4d964e251c286784dd">DEAL_II_DEPRECATED</a></td></tr>
<tr class="separator:a462a6f32cbb8bf21a6ec223b4ec72f48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Access to values of global finite element fields</div></td></tr>
<tr class="memitem:a884144525a19d80f4e20b4e509c9132b"><td class="memTemplParams" colspan="2">template&lt;class InputVector , typename number &gt; </td></tr>
<tr class="memitem:a884144525a19d80f4e20b4e509c9132b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a884144525a19d80f4e20b4e509c9132b">get_function_values</a> (const InputVector &amp;fe_function, std::vector&lt; number &gt; &amp;values) const </td></tr>
<tr class="separator:a884144525a19d80f4e20b4e509c9132b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3dee2a75a4a4d24769ca10f39b7e0a0"><td class="memTemplParams" colspan="2">template&lt;class InputVector , typename number &gt; </td></tr>
<tr class="memitem:af3dee2a75a4a4d24769ca10f39b7e0a0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#af3dee2a75a4a4d24769ca10f39b7e0a0">get_function_values</a> (const InputVector &amp;fe_function, std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &gt; &amp;values) const </td></tr>
<tr class="separator:af3dee2a75a4a4d24769ca10f39b7e0a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae414ae839a23947040f51aa2845d1ad3"><td class="memTemplParams" colspan="2">template&lt;class InputVector , typename number &gt; </td></tr>
<tr class="memitem:ae414ae839a23947040f51aa2845d1ad3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#ae414ae839a23947040f51aa2845d1ad3">get_function_values</a> (const InputVector &amp;fe_function, const <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; const std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &gt; &amp;indices, std::vector&lt; number &gt; &amp;values) const </td></tr>
<tr class="separator:ae414ae839a23947040f51aa2845d1ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6878c6fdd77abd30e71979a78721806e"><td class="memTemplParams" colspan="2">template&lt;class InputVector , typename number &gt; </td></tr>
<tr class="memitem:a6878c6fdd77abd30e71979a78721806e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a6878c6fdd77abd30e71979a78721806e">get_function_values</a> (const InputVector &amp;fe_function, const <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; const std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &gt; &amp;indices, std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &gt; &amp;values) const </td></tr>
<tr class="separator:a6878c6fdd77abd30e71979a78721806e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eeca2159bc8ed995482c6c5ca6bd0c7"><td class="memTemplParams" colspan="2">template&lt;class InputVector &gt; </td></tr>
<tr class="memitem:a6eeca2159bc8ed995482c6c5ca6bd0c7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a6eeca2159bc8ed995482c6c5ca6bd0c7">get_function_values</a> (const InputVector &amp;fe_function, const <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; const std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &gt; &amp;indices, <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; std::vector&lt; std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt; &gt; values, const <a class="el" href="classbool.html">bool</a> quadrature_points_fastest) const </td></tr>
<tr class="separator:a6eeca2159bc8ed995482c6c5ca6bd0c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Access to derivatives of global finite element fields</div></td></tr>
<tr class="memitem:aa2a27be24e74293d1041ac0d8086809d"><td class="memTemplParams" colspan="2">template&lt;class InputVector &gt; </td></tr>
<tr class="memitem:aa2a27be24e74293d1041ac0d8086809d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#aa2a27be24e74293d1041ac0d8086809d">get_function_gradients</a> (const InputVector &amp;fe_function, std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt; &gt; &amp;gradients) const </td></tr>
<tr class="separator:aa2a27be24e74293d1041ac0d8086809d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26eeb4e2c09834fb0d8c1d24eaff1b55"><td class="memTemplParams" colspan="2">template&lt;class InputVector &gt; </td></tr>
<tr class="memitem:a26eeb4e2c09834fb0d8c1d24eaff1b55"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a26eeb4e2c09834fb0d8c1d24eaff1b55">get_function_gradients</a> (const InputVector &amp;fe_function, std::vector&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt; &gt; &gt; &amp;gradients) const </td></tr>
<tr class="separator:a26eeb4e2c09834fb0d8c1d24eaff1b55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8681e16644b2af4d27b1b75fbca332e3"><td class="memTemplParams" colspan="2">template&lt;class InputVector &gt; </td></tr>
<tr class="memitem:a8681e16644b2af4d27b1b75fbca332e3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a8681e16644b2af4d27b1b75fbca332e3">get_function_gradients</a> (const InputVector &amp;fe_function, const <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; const std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &gt; &amp;indices, std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt; &gt; &amp;gradients) const </td></tr>
<tr class="separator:a8681e16644b2af4d27b1b75fbca332e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24dc2c9e61950749db68f3437f318b45"><td class="memTemplParams" colspan="2">template&lt;class InputVector &gt; </td></tr>
<tr class="memitem:a24dc2c9e61950749db68f3437f318b45"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a24dc2c9e61950749db68f3437f318b45">get_function_gradients</a> (const InputVector &amp;fe_function, const <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; const std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &gt; &amp;indices, <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; std::vector&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt; &gt; &gt; &gt; gradients, <a class="el" href="classbool.html">bool</a> quadrature_points_fastest=false) const </td></tr>
<tr class="separator:a24dc2c9e61950749db68f3437f318b45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a393b58da5e9a60d09e1df40a71c96757"><td class="memTemplParams" colspan="2">template&lt;class InputVector &gt; </td></tr>
<tr class="memitem:a393b58da5e9a60d09e1df40a71c96757"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a393b58da5e9a60d09e1df40a71c96757">get_function_grads</a> (const InputVector &amp;fe_function, std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt; &gt; &amp;gradients) const <a class="el" href="group__Sparsity.html#ga0849dabf81f46d4d964e251c286784dd">DEAL_II_DEPRECATED</a></td></tr>
<tr class="separator:a393b58da5e9a60d09e1df40a71c96757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aa3142c0350749f1060d3de1b4eef28"><td class="memTemplParams" colspan="2">template&lt;class InputVector &gt; </td></tr>
<tr class="memitem:a9aa3142c0350749f1060d3de1b4eef28"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a9aa3142c0350749f1060d3de1b4eef28">get_function_grads</a> (const InputVector &amp;fe_function, std::vector&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt; &gt; &gt; &amp;gradients) const <a class="el" href="group__Sparsity.html#ga0849dabf81f46d4d964e251c286784dd">DEAL_II_DEPRECATED</a></td></tr>
<tr class="separator:a9aa3142c0350749f1060d3de1b4eef28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b51ec707d74bf4c005f805495582524"><td class="memTemplParams" colspan="2">template&lt;class InputVector &gt; </td></tr>
<tr class="memitem:a6b51ec707d74bf4c005f805495582524"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a6b51ec707d74bf4c005f805495582524">get_function_grads</a> (const InputVector &amp;fe_function, const <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; const std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &gt; &amp;indices, std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt; &gt; &amp;gradients) const <a class="el" href="group__Sparsity.html#ga0849dabf81f46d4d964e251c286784dd">DEAL_II_DEPRECATED</a></td></tr>
<tr class="separator:a6b51ec707d74bf4c005f805495582524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50532aed1ef919b1dc9261de5ebd7f25"><td class="memTemplParams" colspan="2">template&lt;class InputVector &gt; </td></tr>
<tr class="memitem:a50532aed1ef919b1dc9261de5ebd7f25"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a50532aed1ef919b1dc9261de5ebd7f25">get_function_grads</a> (const InputVector &amp;fe_function, const <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; const std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &gt; &amp;indices, std::vector&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt; &gt; &gt; &amp;gradients, <a class="el" href="classbool.html">bool</a> quadrature_points_fastest=false) const <a class="el" href="group__Sparsity.html#ga0849dabf81f46d4d964e251c286784dd">DEAL_II_DEPRECATED</a></td></tr>
<tr class="separator:a50532aed1ef919b1dc9261de5ebd7f25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Access to second derivatives (Hessian matrices and Laplacians) of global finite element fields</div></td></tr>
<tr class="memitem:a74d154434bef75478e4cb3f358c13c41"><td class="memTemplParams" colspan="2">template&lt;class InputVector &gt; </td></tr>
<tr class="memitem:a74d154434bef75478e4cb3f358c13c41"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a74d154434bef75478e4cb3f358c13c41">get_function_hessians</a> (const InputVector &amp;fe_function, std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 2, spacedim &gt; &gt; &amp;hessians) const </td></tr>
<tr class="separator:a74d154434bef75478e4cb3f358c13c41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accdef80677dde0542251c302261fc34a"><td class="memTemplParams" colspan="2">template&lt;class InputVector &gt; </td></tr>
<tr class="memitem:accdef80677dde0542251c302261fc34a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#accdef80677dde0542251c302261fc34a">get_function_hessians</a> (const InputVector &amp;fe_function, std::vector&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 2, spacedim &gt; &gt; &gt; &amp;hessians, <a class="el" href="classbool.html">bool</a> quadrature_points_fastest=false) const </td></tr>
<tr class="separator:accdef80677dde0542251c302261fc34a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af471b3cb0cb617093525284003c0be9f"><td class="memTemplParams" colspan="2">template&lt;class InputVector &gt; </td></tr>
<tr class="memitem:af471b3cb0cb617093525284003c0be9f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#af471b3cb0cb617093525284003c0be9f">get_function_hessians</a> (const InputVector &amp;fe_function, const <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; const std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &gt; &amp;indices, std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 2, spacedim &gt; &gt; &amp;hessians) const </td></tr>
<tr class="separator:af471b3cb0cb617093525284003c0be9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a259282cb3676418ca2590b98463ba8d4"><td class="memTemplParams" colspan="2">template&lt;class InputVector &gt; </td></tr>
<tr class="memitem:a259282cb3676418ca2590b98463ba8d4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a259282cb3676418ca2590b98463ba8d4">get_function_hessians</a> (const InputVector &amp;fe_function, const <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; const std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &gt; &amp;indices, <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; std::vector&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 2, spacedim &gt; &gt; &gt; &gt; hessians, <a class="el" href="classbool.html">bool</a> quadrature_points_fastest=false) const </td></tr>
<tr class="separator:a259282cb3676418ca2590b98463ba8d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77b4ee9cf5f5423b353da7e64896b17d"><td class="memTemplParams" colspan="2">template&lt;class InputVector &gt; </td></tr>
<tr class="memitem:a77b4ee9cf5f5423b353da7e64896b17d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a77b4ee9cf5f5423b353da7e64896b17d">get_function_2nd_derivatives</a> (const InputVector &amp;, std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 2, spacedim &gt; &gt; &amp;) const <a class="el" href="group__Sparsity.html#ga0849dabf81f46d4d964e251c286784dd">DEAL_II_DEPRECATED</a></td></tr>
<tr class="separator:a77b4ee9cf5f5423b353da7e64896b17d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b5700c4cd52a7108a8ae5f6c0567d0b"><td class="memTemplParams" colspan="2">template&lt;class InputVector &gt; </td></tr>
<tr class="memitem:a8b5700c4cd52a7108a8ae5f6c0567d0b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a8b5700c4cd52a7108a8ae5f6c0567d0b">get_function_2nd_derivatives</a> (const InputVector &amp;, std::vector&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 2, spacedim &gt; &gt; &gt; &amp;, <a class="el" href="classbool.html">bool</a>=false) const <a class="el" href="group__Sparsity.html#ga0849dabf81f46d4d964e251c286784dd">DEAL_II_DEPRECATED</a></td></tr>
<tr class="separator:a8b5700c4cd52a7108a8ae5f6c0567d0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2aafd8203cb76d573ba8e78245c4ed9"><td class="memTemplParams" colspan="2">template&lt;class InputVector , typename number &gt; </td></tr>
<tr class="memitem:af2aafd8203cb76d573ba8e78245c4ed9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#af2aafd8203cb76d573ba8e78245c4ed9">get_function_laplacians</a> (const InputVector &amp;fe_function, std::vector&lt; number &gt; &amp;laplacians) const </td></tr>
<tr class="separator:af2aafd8203cb76d573ba8e78245c4ed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa24fb3acb975500bdfa066396f67393b"><td class="memTemplParams" colspan="2">template&lt;class InputVector , typename number &gt; </td></tr>
<tr class="memitem:aa24fb3acb975500bdfa066396f67393b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#aa24fb3acb975500bdfa066396f67393b">get_function_laplacians</a> (const InputVector &amp;fe_function, std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &gt; &amp;laplacians) const </td></tr>
<tr class="separator:aa24fb3acb975500bdfa066396f67393b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e6d8bd6f7c7a3118d6932b84bc39f21"><td class="memTemplParams" colspan="2">template&lt;class InputVector , typename number &gt; </td></tr>
<tr class="memitem:a3e6d8bd6f7c7a3118d6932b84bc39f21"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a3e6d8bd6f7c7a3118d6932b84bc39f21">get_function_laplacians</a> (const InputVector &amp;fe_function, const <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; const std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &gt; &amp;indices, std::vector&lt; number &gt; &amp;laplacians) const </td></tr>
<tr class="separator:a3e6d8bd6f7c7a3118d6932b84bc39f21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a448e1d8a8c8b2dc79e7301a2124c760c"><td class="memTemplParams" colspan="2">template&lt;class InputVector , typename number &gt; </td></tr>
<tr class="memitem:a448e1d8a8c8b2dc79e7301a2124c760c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a448e1d8a8c8b2dc79e7301a2124c760c">get_function_laplacians</a> (const InputVector &amp;fe_function, const <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; const std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &gt; &amp;indices, std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &gt; &amp;laplacians) const </td></tr>
<tr class="separator:a448e1d8a8c8b2dc79e7301a2124c760c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b2c1a6c6b421d79d08667a859b7a019"><td class="memTemplParams" colspan="2">template&lt;class InputVector , typename number &gt; </td></tr>
<tr class="memitem:a4b2c1a6c6b421d79d08667a859b7a019"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a4b2c1a6c6b421d79d08667a859b7a019">get_function_laplacians</a> (const InputVector &amp;fe_function, const <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; const std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &gt; &amp;indices, std::vector&lt; std::vector&lt; number &gt; &gt; &amp;laplacians, <a class="el" href="classbool.html">bool</a> quadrature_points_fastest=false) const </td></tr>
<tr class="separator:a4b2c1a6c6b421d79d08667a859b7a019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Geometry of the cell</div></td></tr>
<tr class="memitem:a75b6f2cb7c735b51b20093d90b1930b0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a75b6f2cb7c735b51b20093d90b1930b0">quadrature_point</a> (const unsigned <a class="el" href="classint.html">int</a> i) const </td></tr>
<tr class="separator:a75b6f2cb7c735b51b20093d90b1930b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f8732ebe2d3c6746f6de26a79cb1e45"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classPoint.html">Point</a><br class="typebreak"/>
&lt; spacedim &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a5f8732ebe2d3c6746f6de26a79cb1e45">get_quadrature_points</a> () const </td></tr>
<tr class="separator:a5f8732ebe2d3c6746f6de26a79cb1e45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad097580a2f71878695096cc73b271b9d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#ad097580a2f71878695096cc73b271b9d">JxW</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEValuesBase.html#a75b6f2cb7c735b51b20093d90b1930b0">quadrature_point</a>) const </td></tr>
<tr class="separator:ad097580a2f71878695096cc73b271b9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f58a19d26312fba0a2e20f45e4c988a"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a9f58a19d26312fba0a2e20f45e4c988a">get_JxW_values</a> () const </td></tr>
<tr class="separator:a9f58a19d26312fba0a2e20f45e4c988a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2eb28f851a91705e8e06beca9e5dcad"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt; 1, dim, <br class="typebreak"/>
spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#ae2eb28f851a91705e8e06beca9e5dcad">jacobian</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEValuesBase.html#a75b6f2cb7c735b51b20093d90b1930b0">quadrature_point</a>) const </td></tr>
<tr class="separator:ae2eb28f851a91705e8e06beca9e5dcad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61dc18abdc242d282a7c40da6f6fc1e8"><td class="memItemLeft" align="right" valign="top">const std::vector<br class="typebreak"/>
&lt; <a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt; 1, dim, <br class="typebreak"/>
spacedim &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a61dc18abdc242d282a7c40da6f6fc1e8">get_jacobians</a> () const </td></tr>
<tr class="separator:a61dc18abdc242d282a7c40da6f6fc1e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82014c734026b855555cbab8504f48d0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt; 2, dim, <br class="typebreak"/>
spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a82014c734026b855555cbab8504f48d0">jacobian_grad</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEValuesBase.html#a75b6f2cb7c735b51b20093d90b1930b0">quadrature_point</a>) const </td></tr>
<tr class="separator:a82014c734026b855555cbab8504f48d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5292360b569c24feb15ca9d3a2f53d3c"><td class="memItemLeft" align="right" valign="top">const std::vector<br class="typebreak"/>
&lt; <a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt; 2, dim, <br class="typebreak"/>
spacedim &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a5292360b569c24feb15ca9d3a2f53d3c">get_jacobian_grads</a> () const </td></tr>
<tr class="separator:a5292360b569c24feb15ca9d3a2f53d3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a665ab681011424cb1b0ba11c4155a121"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classDerivativeForm.html">DerivativeForm</a><br class="typebreak"/>
&lt; 1, spacedim, dim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a665ab681011424cb1b0ba11c4155a121">inverse_jacobian</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEValuesBase.html#a75b6f2cb7c735b51b20093d90b1930b0">quadrature_point</a>) const </td></tr>
<tr class="separator:a665ab681011424cb1b0ba11c4155a121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5abadee1bbf314037cef0e006c46b4d"><td class="memItemLeft" align="right" valign="top">const std::vector<br class="typebreak"/>
&lt; <a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt; 1, spacedim, <br class="typebreak"/>
dim &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#ad5abadee1bbf314037cef0e006c46b4d">get_inverse_jacobians</a> () const </td></tr>
<tr class="separator:ad5abadee1bbf314037cef0e006c46b4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65b6761eafde9e485da59d599b90760b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a65b6761eafde9e485da59d599b90760b">normal_vector</a> (const unsigned <a class="el" href="classint.html">int</a> i) const </td></tr>
<tr class="separator:a65b6761eafde9e485da59d599b90760b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcddbeb5aac98c1bbde8b229ea3f0799"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classPoint.html">Point</a><br class="typebreak"/>
&lt; spacedim &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#afcddbeb5aac98c1bbde8b229ea3f0799">get_normal_vectors</a> () const </td></tr>
<tr class="separator:afcddbeb5aac98c1bbde8b229ea3f0799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f7e5af23da360ff063670b0511a41a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a0f7e5af23da360ff063670b0511a41a2">transform</a> (std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt; &gt; &amp;transformed, const std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt; &gt; &amp;original, <a class="el" href="group__mapping.html#gaf0a4d6be70322c742c12da1edccbb74d">MappingType</a> <a class="el" href="classFEValuesBase.html#a8fb1d5f367902df6b2b598d9da1b0398">mapping</a>) const </td></tr>
<tr class="separator:a0f7e5af23da360ff063670b0511a41a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2359a176a1d348ef6c2f6c9a087e27e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#ac2359a176a1d348ef6c2f6c9a087e27e">cell_normal_vector</a> (const unsigned <a class="el" href="classint.html">int</a> i) const <a class="el" href="group__Sparsity.html#ga0849dabf81f46d4d964e251c286784dd">DEAL_II_DEPRECATED</a></td></tr>
<tr class="separator:ac2359a176a1d348ef6c2f6c9a087e27e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4ff1049b98f6edb95ae9d5bb7e4b555"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classPoint.html">Point</a><br class="typebreak"/>
&lt; spacedim &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#aa4ff1049b98f6edb95ae9d5bb7e4b555">get_cell_normal_vectors</a> () const <a class="el" href="group__Sparsity.html#ga0849dabf81f46d4d964e251c286784dd">DEAL_II_DEPRECATED</a></td></tr>
<tr class="separator:aa4ff1049b98f6edb95ae9d5bb7e4b555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Extractors Methods to extract individual components</div></td></tr>
<tr class="memitem:a045b5cc028f0e4372d86ab647c7e938c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classFEValuesViews_1_1Scalar.html">FEValuesViews::Scalar</a><br class="typebreak"/>
&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a045b5cc028f0e4372d86ab647c7e938c">operator[]</a> (const <a class="el" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> &amp;scalar) const </td></tr>
<tr class="separator:a045b5cc028f0e4372d86ab647c7e938c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af29b6c5ffc0dca6eb1ea458d727752dc"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classFEValuesViews_1_1Vector.html">FEValuesViews::Vector</a><br class="typebreak"/>
&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#af29b6c5ffc0dca6eb1ea458d727752dc">operator[]</a> (const <a class="el" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> &amp;vector) const </td></tr>
<tr class="separator:af29b6c5ffc0dca6eb1ea458d727752dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5680b7a98e158df316b600e5d3a498fb"><td class="memItemLeft" align="right" valign="top">const <br class="typebreak"/>
<a class="el" href="classFEValuesViews_1_1SymmetricTensor.html">FEValuesViews::SymmetricTensor</a><br class="typebreak"/>
&lt; 2, dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a5680b7a98e158df316b600e5d3a498fb">operator[]</a> (const <a class="el" href="structFEValuesExtractors_1_1SymmetricTensor.html">FEValuesExtractors::SymmetricTensor</a>&lt; 2 &gt; &amp;tensor) const </td></tr>
<tr class="separator:a5680b7a98e158df316b600e5d3a498fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a978e33f9e08b20d6e472bf845fe126eb"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classFEValuesViews_1_1Tensor.html">FEValuesViews::Tensor</a><br class="typebreak"/>
&lt; 2, dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a978e33f9e08b20d6e472bf845fe126eb">operator[]</a> (const <a class="el" href="structFEValuesExtractors_1_1Tensor.html">FEValuesExtractors::Tensor</a>&lt; 2 &gt; &amp;tensor) const </td></tr>
<tr class="separator:a978e33f9e08b20d6e472bf845fe126eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Access to the raw data</div></td></tr>
<tr class="memitem:a7e077b1569f189d69afa242014b7c2da"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a7e077b1569f189d69afa242014b7c2da">get_mapping</a> () const </td></tr>
<tr class="separator:a7e077b1569f189d69afa242014b7c2da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa67eb1714ca9dc018182be86103091de"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, <br class="typebreak"/>
spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#aa67eb1714ca9dc018182be86103091de">get_fe</a> () const </td></tr>
<tr class="separator:aa67eb1714ca9dc018182be86103091de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae13d0676167b7e05b1d70737a901dd04"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#ae13d0676167b7e05b1d70737a901dd04">get_update_flags</a> () const </td></tr>
<tr class="separator:ae13d0676167b7e05b1d70737a901dd04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6959f20afbf234418f64968230a13ba3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, <br class="typebreak"/>
spacedim &gt;::cell_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a6959f20afbf234418f64968230a13ba3">get_cell</a> () const </td></tr>
<tr class="separator:a6959f20afbf234418f64968230a13ba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69a2e58ada338b185cf448d287294ee4"><td class="memItemLeft" align="right" valign="top">CellSimilarity::Similarity&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a69a2e58ada338b185cf448d287294ee4">get_cell_similarity</a> () const </td></tr>
<tr class="separator:a69a2e58ada338b185cf448d287294ee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a626f38270a935445272c2ba23db3a080"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a626f38270a935445272c2ba23db3a080">memory_consumption</a> () const </td></tr>
<tr class="separator:a626f38270a935445272c2ba23db3a080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSubscriptor"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSubscriptor')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSubscriptor.html">Subscriptor</a></td></tr>
<tr class="memitem:ae5541017c0966b0af345db75895106f2 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#ae5541017c0966b0af345db75895106f2">Subscriptor</a> ()</td></tr>
<tr class="separator:ae5541017c0966b0af345db75895106f2 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367fce3122075f05f168d14f114b4c65 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a367fce3122075f05f168d14f114b4c65">Subscriptor</a> (const <a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;)</td></tr>
<tr class="separator:a367fce3122075f05f168d14f114b4c65 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c6c557e06110d2127fa6459119e94af inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a6c6c557e06110d2127fa6459119e94af">~Subscriptor</a> ()</td></tr>
<tr class="separator:a6c6c557e06110d2127fa6459119e94af inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24ee69d4b3cf9690d1208b2443cbbb80 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a24ee69d4b3cf9690d1208b2443cbbb80">operator=</a> (const <a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;)</td></tr>
<tr class="separator:a24ee69d4b3cf9690d1208b2443cbbb80 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3422499827ecd52f1d12d65eb6cc3125 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a3422499827ecd52f1d12d65eb6cc3125">subscribe</a> (const char *identifier=0) const </td></tr>
<tr class="separator:a3422499827ecd52f1d12d65eb6cc3125 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b4839b1cffc18781144ede1744b35ea inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a2b4839b1cffc18781144ede1744b35ea">unsubscribe</a> (const char *identifier=0) const </td></tr>
<tr class="separator:a2b4839b1cffc18781144ede1744b35ea inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b45274c8e1936bff024df01d618e86f inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a7b45274c8e1936bff024df01d618e86f">n_subscriptions</a> () const </td></tr>
<tr class="separator:a7b45274c8e1936bff024df01d618e86f inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbbc5f845063b1f23223b7ac96e89e13 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#adbbc5f845063b1f23223b7ac96e89e13">list_subscribers</a> () const </td></tr>
<tr class="separator:adbbc5f845063b1f23223b7ac96e89e13 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2f0251d20c6a5295024de3b2e9b4359 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac2f0251d20c6a5295024de3b2e9b4359">DeclException3</a> (ExcInUse, <a class="el" href="classint.html">int</a>, char *, std::string &amp;,&lt;&lt; &quot;Object of class &quot;&lt;&lt; arg2&lt;&lt; &quot; is still used by &quot;&lt;&lt; arg1&lt;&lt; &quot; other objects.\n&quot;&lt;&lt; &quot;(Additional information: &quot;&lt;&lt; arg3&lt;&lt; &quot;)\n&quot;&lt;&lt; &quot;Note the entry in the Frequently Asked Questions of &quot;&lt;&lt; &quot;deal.II (linked to from http://www.dealii.org/) for &quot;&lt;&lt; &quot;more information on what this error means.&quot;)</td></tr>
<tr class="separator:gac2f0251d20c6a5295024de3b2e9b4359 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e000d9ce953da6afe4bbbaca4397344 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga9e000d9ce953da6afe4bbbaca4397344">DeclException2</a> (ExcNoSubscriber, char *, char *,&lt;&lt; &quot;No subscriber with identifier \&quot;&quot;&lt;&lt; arg2&lt;&lt; &quot;\&quot; did <a class="el" href="classSubscriptor.html#a3422499827ecd52f1d12d65eb6cc3125">subscribe</a> to this object of class &quot;&lt;&lt; arg1)</td></tr>
<tr class="separator:ga9e000d9ce953da6afe4bbbaca4397344 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38 inherit pub_methods_classSubscriptor"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38 inherit pub_methods_classSubscriptor"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:a68efd17a8330ab676d9cd711029b0f38 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a807c3049bfe81743fc0f237dfc2fbdea"><td class="memItemLeft" align="right" valign="top">const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a></td></tr>
<tr class="separator:a807c3049bfe81743fc0f237dfc2fbdea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b264d5b2fb6615f5dea7a21135ed1a5"><td class="memItemLeft" align="right" valign="top">const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a></td></tr>
<tr class="separator:a5b264d5b2fb6615f5dea7a21135ed1a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:afd889a38bbce8ea33d46d152f14abdd3"><td class="memItemLeft" align="right" valign="top">static const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#afd889a38bbce8ea33d46d152f14abdd3">dimension</a> = dim</td></tr>
<tr class="separator:afd889a38bbce8ea33d46d152f14abdd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6541820cb52f78a4d43de18be0352002"><td class="memItemLeft" align="right" valign="top">static const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a6541820cb52f78a4d43de18be0352002">space_dimension</a> = spacedim</td></tr>
<tr class="separator:a6541820cb52f78a4d43de18be0352002"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aaf01126d2e3b926fecbaf122357add53"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#aaf01126d2e3b926fecbaf122357add53">invalidate_present_cell</a> ()</td></tr>
<tr class="separator:aaf01126d2e3b926fecbaf122357add53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed652da6ec16e368e27da4085b4281bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#aed652da6ec16e368e27da4085b4281bb">maybe_invalidate_previous_present_cell</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell)</td></tr>
<tr class="separator:aed652da6ec16e368e27da4085b4281bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af928285aed02ded5d02cf4edb1086fe5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#af928285aed02ded5d02cf4edb1086fe5">compute_update_flags</a> (const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> <a class="el" href="classFEValuesData.html#a8f61e745cc3938c8a2534fa857d15fca">update_flags</a>) const </td></tr>
<tr class="separator:af928285aed02ded5d02cf4edb1086fe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c38a7d7c3a6b384ad5b46f38248524d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a5c38a7d7c3a6b384ad5b46f38248524d">check_cell_similarity</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell)</td></tr>
<tr class="separator:a5c38a7d7c3a6b384ad5b46f38248524d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classFEValuesData"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classFEValuesData')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classFEValuesData.html">FEValuesData&lt; dim, spacedim &gt;</a></td></tr>
<tr class="memitem:ad81ccec8ef1f58b39b9909cc5e20f7ec inherit pro_methods_classFEValuesData"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesData.html#ad81ccec8ef1f58b39b9909cc5e20f7ec">initialize</a> (const unsigned <a class="el" href="classint.html">int</a> n_quadrature_points, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe, const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> flags)</td></tr>
<tr class="separator:ad81ccec8ef1f58b39b9909cc5e20f7ec inherit pro_methods_classFEValuesData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classSubscriptor"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classSubscriptor')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classSubscriptor.html">Subscriptor</a></td></tr>
<tr class="memitem:ae5541017c0966b0af345db75895106f2 inherit pro_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#ae5541017c0966b0af345db75895106f2">Subscriptor</a> ()</td></tr>
<tr class="separator:ae5541017c0966b0af345db75895106f2 inherit pro_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367fce3122075f05f168d14f114b4c65 inherit pro_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a367fce3122075f05f168d14f114b4c65">Subscriptor</a> (const <a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;)</td></tr>
<tr class="separator:a367fce3122075f05f168d14f114b4c65 inherit pro_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c6c557e06110d2127fa6459119e94af inherit pro_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a6c6c557e06110d2127fa6459119e94af">~Subscriptor</a> ()</td></tr>
<tr class="separator:a6c6c557e06110d2127fa6459119e94af inherit pro_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24ee69d4b3cf9690d1208b2443cbbb80 inherit pro_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a24ee69d4b3cf9690d1208b2443cbbb80">operator=</a> (const <a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;)</td></tr>
<tr class="separator:a24ee69d4b3cf9690d1208b2443cbbb80 inherit pro_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3422499827ecd52f1d12d65eb6cc3125 inherit pro_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a3422499827ecd52f1d12d65eb6cc3125">subscribe</a> (const char *identifier=0) const </td></tr>
<tr class="separator:a3422499827ecd52f1d12d65eb6cc3125 inherit pro_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b4839b1cffc18781144ede1744b35ea inherit pro_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a2b4839b1cffc18781144ede1744b35ea">unsubscribe</a> (const char *identifier=0) const </td></tr>
<tr class="separator:a2b4839b1cffc18781144ede1744b35ea inherit pro_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b45274c8e1936bff024df01d618e86f inherit pro_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a7b45274c8e1936bff024df01d618e86f">n_subscriptions</a> () const </td></tr>
<tr class="separator:a7b45274c8e1936bff024df01d618e86f inherit pro_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbbc5f845063b1f23223b7ac96e89e13 inherit pro_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#adbbc5f845063b1f23223b7ac96e89e13">list_subscribers</a> () const </td></tr>
<tr class="separator:adbbc5f845063b1f23223b7ac96e89e13 inherit pro_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2f0251d20c6a5295024de3b2e9b4359 inherit pro_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac2f0251d20c6a5295024de3b2e9b4359">DeclException3</a> (ExcInUse, <a class="el" href="classint.html">int</a>, char *, std::string &amp;,&lt;&lt; &quot;Object of class &quot;&lt;&lt; arg2&lt;&lt; &quot; is still used by &quot;&lt;&lt; arg1&lt;&lt; &quot; other objects.\n&quot;&lt;&lt; &quot;(Additional information: &quot;&lt;&lt; arg3&lt;&lt; &quot;)\n&quot;&lt;&lt; &quot;Note the entry in the Frequently Asked Questions of &quot;&lt;&lt; &quot;deal.II (linked to from http://www.dealii.org/) for &quot;&lt;&lt; &quot;more information on what this error means.&quot;)</td></tr>
<tr class="separator:gac2f0251d20c6a5295024de3b2e9b4359 inherit pro_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e000d9ce953da6afe4bbbaca4397344 inherit pro_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga9e000d9ce953da6afe4bbbaca4397344">DeclException2</a> (ExcNoSubscriber, char *, char *,&lt;&lt; &quot;No subscriber with identifier \&quot;&quot;&lt;&lt; arg2&lt;&lt; &quot;\&quot; did <a class="el" href="classSubscriptor.html#a3422499827ecd52f1d12d65eb6cc3125">subscribe</a> to this object of class &quot;&lt;&lt; arg1)</td></tr>
<tr class="separator:ga9e000d9ce953da6afe4bbbaca4397344 inherit pro_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38 inherit pro_methods_classSubscriptor"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38 inherit pro_methods_classSubscriptor"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:a68efd17a8330ab676d9cd711029b0f38 inherit pro_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:afeddfe00fc718ed1ed1c83826408afe1"><td class="memItemLeft" align="right" valign="top">std::auto_ptr&lt; const <br class="typebreak"/>
CellIteratorBase &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#afeddfe00fc718ed1ed1c83826408afe1">present_cell</a></td></tr>
<tr class="separator:afeddfe00fc718ed1ed1c83826408afe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab688f51aad683baef55ce7e164fcdda7"><td class="memItemLeft" align="right" valign="top">boost::signals2::connection&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#ab688f51aad683baef55ce7e164fcdda7">tria_listener</a></td></tr>
<tr class="separator:ab688f51aad683baef55ce7e164fcdda7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fb1d5f367902df6b2b598d9da1b0398"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSmartPointer.html">SmartPointer</a>&lt; const <br class="typebreak"/>
<a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;<br class="typebreak"/>
, <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a8fb1d5f367902df6b2b598d9da1b0398">mapping</a></td></tr>
<tr class="separator:a8fb1d5f367902df6b2b598d9da1b0398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb05cc9511ff887438f3e6cf036a3134"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSmartPointer.html">SmartPointer</a>&lt; const <br class="typebreak"/>
<a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;<br class="typebreak"/>
, <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#aeb05cc9511ff887438f3e6cf036a3134">fe</a></td></tr>
<tr class="separator:aeb05cc9511ff887438f3e6cf036a3134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bcd3568305e3a943b7c7cefd29bbf77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSmartPointer.html">SmartPointer</a>&lt; typename <a class="el" href="classMapping.html">Mapping</a><br class="typebreak"/>
&lt; dim, spacedim &gt;<br class="typebreak"/>
::InternalDataBase, <br class="typebreak"/>
<a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a3bcd3568305e3a943b7c7cefd29bbf77">mapping_data</a></td></tr>
<tr class="separator:a3bcd3568305e3a943b7c7cefd29bbf77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adab61905282bc3237f01e7d9aec3c694"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSmartPointer.html">SmartPointer</a>&lt; typename <a class="el" href="classMapping.html">Mapping</a><br class="typebreak"/>
&lt; dim, spacedim &gt;<br class="typebreak"/>
::InternalDataBase, <br class="typebreak"/>
<a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#adab61905282bc3237f01e7d9aec3c694">fe_data</a></td></tr>
<tr class="separator:adab61905282bc3237f01e7d9aec3c694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a096d4ea9edea6618e23f5f13ab40784c"><td class="memItemLeft" align="right" valign="top">CellSimilarity::Similarity&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a096d4ea9edea6618e23f5f13ab40784c">cell_similarity</a></td></tr>
<tr class="separator:a096d4ea9edea6618e23f5f13ab40784c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classFEValuesData"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classFEValuesData')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classFEValuesData.html">FEValuesData&lt; dim, spacedim &gt;</a></td></tr>
<tr class="memitem:a17c599610feb50be56cffffc907e263e inherit pro_attribs_classFEValuesData"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFEValuesData.html#a555df5bf6d68703121f714f3089a1d5f">ShapeVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesData.html#a17c599610feb50be56cffffc907e263e">shape_values</a></td></tr>
<tr class="separator:a17c599610feb50be56cffffc907e263e inherit pro_attribs_classFEValuesData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab42c9df2a111e074b9555d8c7710d79b inherit pro_attribs_classFEValuesData"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFEValuesData.html#ada08662737636cc7cde8a3c6795403ef">GradientVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesData.html#ab42c9df2a111e074b9555d8c7710d79b">shape_gradients</a></td></tr>
<tr class="separator:ab42c9df2a111e074b9555d8c7710d79b inherit pro_attribs_classFEValuesData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b74752fc7b1037de2b5013e1d6de980 inherit pro_attribs_classFEValuesData"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFEValuesData.html#a1b11fa78dc99a1de485f16015eaf0df3">HessianVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesData.html#a2b74752fc7b1037de2b5013e1d6de980">shape_hessians</a></td></tr>
<tr class="separator:a2b74752fc7b1037de2b5013e1d6de980 inherit pro_attribs_classFEValuesData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad532f39c78e5d10cf15abdf14331d533 inherit pro_attribs_classFEValuesData"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesData.html#ad532f39c78e5d10cf15abdf14331d533">JxW_values</a></td></tr>
<tr class="separator:ad532f39c78e5d10cf15abdf14331d533 inherit pro_attribs_classFEValuesData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bb92a6a44514abf414d3d05b37ca204 inherit pro_attribs_classFEValuesData"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classDerivativeForm.html">DerivativeForm</a><br class="typebreak"/>
&lt; 1, dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesData.html#a5bb92a6a44514abf414d3d05b37ca204">jacobians</a></td></tr>
<tr class="separator:a5bb92a6a44514abf414d3d05b37ca204 inherit pro_attribs_classFEValuesData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff337b9f1d1fc1bbccdb4c3cc3ea739f inherit pro_attribs_classFEValuesData"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classDerivativeForm.html">DerivativeForm</a><br class="typebreak"/>
&lt; 2, dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesData.html#aff337b9f1d1fc1bbccdb4c3cc3ea739f">jacobian_grads</a></td></tr>
<tr class="separator:aff337b9f1d1fc1bbccdb4c3cc3ea739f inherit pro_attribs_classFEValuesData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61b14af6f65e43243441419a3215e897 inherit pro_attribs_classFEValuesData"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classDerivativeForm.html">DerivativeForm</a><br class="typebreak"/>
&lt; 1, spacedim, dim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesData.html#a61b14af6f65e43243441419a3215e897">inverse_jacobians</a></td></tr>
<tr class="separator:a61b14af6f65e43243441419a3215e897 inherit pro_attribs_classFEValuesData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb13b8d981bcb54b82005230df5b160b inherit pro_attribs_classFEValuesData"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesData.html#aeb13b8d981bcb54b82005230df5b160b">quadrature_points</a></td></tr>
<tr class="separator:aeb13b8d981bcb54b82005230df5b160b inherit pro_attribs_classFEValuesData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa288ce3f95f9cf1a6b4d9434ce0eb755 inherit pro_attribs_classFEValuesData"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesData.html#aa288ce3f95f9cf1a6b4d9434ce0eb755">normal_vectors</a></td></tr>
<tr class="separator:aa288ce3f95f9cf1a6b4d9434ce0eb755 inherit pro_attribs_classFEValuesData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac523dc195a05dff511ad6c0b63cadecc inherit pro_attribs_classFEValuesData"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classTensor.html">Tensor</a><br class="typebreak"/>
&lt; 1, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesData.html#ac523dc195a05dff511ad6c0b63cadecc">boundary_forms</a></td></tr>
<tr class="separator:ac523dc195a05dff511ad6c0b63cadecc inherit pro_attribs_classFEValuesData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f440ca2fd6274d81b0b126eb3fd2d65 inherit pro_attribs_classFEValuesData"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesData.html#a9f440ca2fd6274d81b0b126eb3fd2d65">shape_function_to_row_table</a></td></tr>
<tr class="separator:a9f440ca2fd6274d81b0b126eb3fd2d65 inherit pro_attribs_classFEValuesData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f61e745cc3938c8a2534fa857d15fca inherit pro_attribs_classFEValuesData"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesData.html#a8f61e745cc3938c8a2534fa857d15fca">update_flags</a></td></tr>
<tr class="separator:a8f61e745cc3938c8a2534fa857d15fca inherit pro_attribs_classFEValuesData"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ac52b829e28b9d9d38c69f6662783f92c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#ac52b829e28b9d9d38c69f6662783f92c">FEValuesBase</a> (const <a class="el" href="classFEValuesBase.html">FEValuesBase</a> &amp;)</td></tr>
<tr class="separator:ac52b829e28b9d9d38c69f6662783f92c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48091346190d2c2c562bca0b5d6e73b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFEValuesBase.html">FEValuesBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a48091346190d2c2c562bca0b5d6e73b7">operator=</a> (const <a class="el" href="classFEValuesBase.html">FEValuesBase</a> &amp;)</td></tr>
<tr class="separator:a48091346190d2c2c562bca0b5d6e73b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a7cf406ac2334ec378cdbaed4b836cc45"><td class="memItemLeft" align="right" valign="top">::<a class="el" href="structinternal_1_1FEValuesViews_1_1Cache.html">internal::FEValuesViews::Cache</a><br class="typebreak"/>
&lt; dim, spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a7cf406ac2334ec378cdbaed4b836cc45">fe_values_views_cache</a></td></tr>
<tr class="separator:a7cf406ac2334ec378cdbaed4b836cc45"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:abd66d1380ef2e58a1e433bc1626c324e"><td class="memTemplParams" colspan="2">template&lt;int , int &gt; </td></tr>
<tr class="memitem:abd66d1380ef2e58a1e433bc1626c324e"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#abd66d1380ef2e58a1e433bc1626c324e">FEValuesViews::Scalar</a></td></tr>
<tr class="separator:abd66d1380ef2e58a1e433bc1626c324e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7a6d19c4bc8339d65379e8f358cf5c5"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab7a6d19c4bc8339d65379e8f358cf5c5"></a>
template&lt;int , int &gt; </td></tr>
<tr class="memitem:ab7a6d19c4bc8339d65379e8f358cf5c5"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>FEValuesViews::Vector</b></td></tr>
<tr class="separator:ab7a6d19c4bc8339d65379e8f358cf5c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1076f685e37ef85af297ce99125d8a1a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1076f685e37ef85af297ce99125d8a1a"></a>
template&lt;int , int , int &gt; </td></tr>
<tr class="memitem:a1076f685e37ef85af297ce99125d8a1a"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>FEValuesViews::SymmetricTensor</b></td></tr>
<tr class="separator:a1076f685e37ef85af297ce99125d8a1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a741750605cc03e4b3ec0b456cf0f7631"><td class="memTemplParams" colspan="2"><a class="anchor" id="a741750605cc03e4b3ec0b456cf0f7631"></a>
template&lt;int , int , int &gt; </td></tr>
<tr class="memitem:a741750605cc03e4b3ec0b456cf0f7631"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>FEValuesViews::Tensor</b></td></tr>
<tr class="separator:a741750605cc03e4b3ec0b456cf0f7631"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_types_classFEValuesData"><td colspan="2" onclick="javascript:toggleInherit('pro_types_classFEValuesData')"><img src="closed.png" alt="-"/>&#160;Protected Types inherited from <a class="el" href="classFEValuesData.html">FEValuesData&lt; dim, spacedim &gt;</a></td></tr>
<tr class="memitem:a555df5bf6d68703121f714f3089a1d5f inherit pro_types_classFEValuesData"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesData.html#a555df5bf6d68703121f714f3089a1d5f">ShapeVector</a></td></tr>
<tr class="separator:a555df5bf6d68703121f714f3089a1d5f inherit pro_types_classFEValuesData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada08662737636cc7cde8a3c6795403ef inherit pro_types_classFEValuesData"><td class="memItemLeft" align="right" valign="top">typedef std::vector<br class="typebreak"/>
&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a><br class="typebreak"/>
&lt; 1, spacedim &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesData.html#ada08662737636cc7cde8a3c6795403ef">GradientVector</a></td></tr>
<tr class="separator:ada08662737636cc7cde8a3c6795403ef inherit pro_types_classFEValuesData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b11fa78dc99a1de485f16015eaf0df3 inherit pro_types_classFEValuesData"><td class="memItemLeft" align="right" valign="top">typedef std::vector<br class="typebreak"/>
&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a><br class="typebreak"/>
&lt; 2, spacedim &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesData.html#a1b11fa78dc99a1de485f16015eaf0df3">HessianVector</a></td></tr>
<tr class="separator:a1b11fa78dc99a1de485f16015eaf0df3 inherit pro_types_classFEValuesData"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int dim, int spacedim = dim&gt;<br/>
class FEValuesBase&lt; dim, spacedim &gt;</h3>

<p><a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a> and <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> objects are interfaces to finite element and mapping classes on the one hand side, to cells and quadrature rules on the other side. They allow to evaluate values or derivatives of shape functions at the quadrature points of a quadrature formula when projected by a mapping from the unit cell onto a cell in real space. The reason for this abstraction is possible optimization: Depending on the type of finite element and mapping, some values can be computed once on the unit cell. Others must be computed on each cell, but maybe computation of several values at the same time offers ways for optimization. Since this interlay may be complex and depends on the actual finite element, it cannot be left to the applications programmer.</p>
<p><a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a> and <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> provide only data handling: computations are left to objects of type <a class="el" href="classMapping.html">Mapping</a> and <a class="el" href="classFiniteElement.html">FiniteElement</a>. These provide functions <code>get_*_data</code> and <code>fill_*_values</code> which are called by the constructor and <code>reinit</code> functions of <code>FEValues*</code>, respectively.</p>
<h3>General usage</h3>
<p>Usually, an object of <code>FEValues*</code> is used in integration loops over all cells of a triangulation (or faces of cells). To take full advantage of the optimization features, it should be constructed before the loop so that information that does not depend on the location and shape of cells can be computed once and for all (this includes, for example, the values of shape functions at quadrature points for the most common elements: we can evaluate them on the unit cell and they will be the same when mapped to the real cell). Then, in the loop over all cells, it must be re-initialized for each grid cell to compute that part of the information that changes depending on the actual cell (for example, the gradient of shape functions equals the gradient on the unit cell &ndash; which can be computed once and for all &ndash; times the Jacobian matrix of the mapping between unit and real cell, which needs to be recomputed for each cell).</p>
<p>A typical piece of code, adding up local contributions to the Laplace matrix looks like this:</p>
<div class="fragment"><div class="line"><a class="code" href="classFEValues.html">FEValues</a> values (<a class="code" href="classFEValuesBase.html#a8fb1d5f367902df6b2b598d9da1b0398">mapping</a>, finite_element, quadrature, flags);</div>
<div class="line"><span class="keywordflow">for</span> (cell = dof_handler.<a class="code" href="classDoFHandler.html#a6f2aa9c61385cbb749ed3d2e7bfe3de1">begin_active</a>();</div>
<div class="line">     cell != dof_handler.<a class="code" href="classDoFHandler.html#abf64c3734383b6fb1bed4888935f2edf">end</a>();</div>
<div class="line">     ++cell)</div>
<div class="line">  {</div>
<div class="line">    values.reinit(cell);</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;quadrature.size(); ++q)</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;finite_element.dofs_per_cell; ++i)</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;finite_element.dofs_per_cell; ++j)</div>
<div class="line">        A(i,j) += fe_values.shape_value(i,q) *</div>
<div class="line">                  fe_values.shape_value(j,q) *</div>
<div class="line">                  fe_values.JxW(q);</div>
<div class="line">    ...</div>
<div class="line">  }</div>
</div><!-- fragment --><p>The individual functions used here are described below. Note that by design, the order of quadrature points used inside the <a class="el" href="classFEValues.html">FEValues</a> object is the same as defined by the quadrature formula passed to the constructor of the <a class="el" href="classFEValues.html">FEValues</a> object above.</p>
<h3>Member functions</h3>
<p>The functions of this class fall into different cathegories: </p>
<ul>
<li>
<p class="startli"><a class="el" href="classFEValuesBase.html#abe4de48ff59778bb82a0ec13037804aa">shape_value()</a>, <a class="el" href="classFEValuesBase.html#ac4cee7628c2903a89c5c399fddeb00a5">shape_grad()</a>, etc: return one of the values of this object at a time. These functions are inlined, so this is the suggested access to all finite element values. There should be no loss in performance with an optimizing compiler. If the finite element is vector valued, then these functions return the only non-zero component of the requested shape function. However, some finite elements have shape functions that have more than one non-zero component (we call them non-"primitive"), and in this case this set of functions will throw an exception since they cannot generate a useful result. Rather, use the next set of functions.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><a class="el" href="classFEValuesBase.html#a55a507d64ae810232dc0e8bdbf7ee4c1">shape_value_component()</a>, <a class="el" href="classFEValuesBase.html#a836dd15035c0493714a284ee3d0e0a16">shape_grad_component()</a>, etc: This is the same set of functions as above, except that for vector valued finite elements they return only one vector component. This is useful for elements of which shape functions have more than one non-zero component, since then the above functions cannot be used, and you have to walk over all (or only the non-zero) components of the shape function using this set of functions.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><a class="el" href="classFEValuesBase.html#a884144525a19d80f4e20b4e509c9132b">get_function_values()</a>, <a class="el" href="classFEValuesBase.html#aa2a27be24e74293d1041ac0d8086809d">get_function_gradients()</a>, etc.: Compute a finite element function or its derivative in quadrature points.</p>
<p class="endli"></p>
</li>
<li>
reinit: initialize the <a class="el" href="classFEValues.html">FEValues</a> object for a certain cell. This function is not in the present class but only in the derived classes and has a variable call syntax. See the docs for the derived classes for more information. </li>
</ul>
<h3>UpdateFlags</h3>
<p>The UpdateFlags object handed to the constructor is used to determine which of the data fields to compute. This way, it is possible to avoid expensive computations of useless derivatives. In the beginning, these flags are processed through the functions <a class="el" href="classMapping.html#ad763fd4b4286d869c5f89f6cd4fa142f">Mapping::update_once()</a>, <a class="el" href="classMapping.html#a3d5b93361958038a33586a23be3c532d">Mapping::update_each()</a>, <a class="el" href="classFiniteElement.html#a53ec2e9b0b29a6c0df0b941528be0306">FiniteElement::update_once()</a> <a class="el" href="classFiniteElement.html#a876f0be1b38ad6ed2ccad297876e1287">FiniteElement::update_each()</a>. All the results are bit-wise or'd and determine the fields actually computed. This enables <a class="el" href="classMapping.html">Mapping</a> and <a class="el" href="classFiniteElement.html">FiniteElement</a> to schedule auxiliary data fields for updating. Still, it is recommended to give <b>all</b> needed update flags to <a class="el" href="classFEValues.html">FEValues</a>.</p>
<p>The mechanisms by which this class works is also discussed on the page on <a class="el" href="UpdateFlagsEssay.html">The interplay of UpdateFlags, Mapping and FiniteElement in FEValues</a>.</p>
<dl class="section author"><dt>Author</dt><dd>Wolfgang Bangerth, 1998, 2003, Guido Kanschat, 2001 </dd></dl>

<p>Definition at line <a class="el" href="fe_2fe__values_8h_source.html#l00054">54</a> of file <a class="el" href="fe_2fe__values_8h_source.html">fe_values.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a3adde03753e99c526bb323533faa25d2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::<a class="el" href="classFEValuesBase.html">FEValuesBase</a> </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_q_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>dofs_per_cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td>
          <td class="paramname"><em>update_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. Set up the array sizes with <code>n_q_points</code> quadrature points, <code>dofs_per_cell</code> trial functions per cell and with the given pattern to update the fields when the <code>reinit</code> function of the derived classes is called. The fields themselves are not set up, this must happen in the constructor of the derived class. </p>

</div>
</div>
<a class="anchor" id="a5d56296cbd8389414d14d7d42219b7e7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::~<a class="el" href="classFEValuesBase.html">FEValuesBase</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destructor. </p>

</div>
</div>
<a class="anchor" id="ac52b829e28b9d9d38c69f6662783f92c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::<a class="el" href="classFEValuesBase.html">FEValuesBase</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy constructor. Since objects of this class are not copyable, we make it private, and also do not implement it. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="abe4de48ff59778bb82a0ec13037804aa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdouble.html">double</a>&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::shape_value </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>function_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>point_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Value of a shape function at a quadrature point on the cell, face or subface selected the last time the <code>reinit</code> function of the derived class was called.</p>
<p>If the shape function is vector-valued, then this returns the only non-zero component. If the shape function has more than one non-zero component (i.e. it is not primitive), then throw an exception of type ExcShapeFunctionNotPrimitive. In that case, use the <a class="el" href="classFEValuesBase.html#a55a507d64ae810232dc0e8bdbf7ee4c1">shape_value_component()</a> function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function_no</td><td>Number of the shape function to be evaluated. Note that this number runs from zero to dofs_per_cell, even in the case of an <a class="el" href="classFEFaceValues.html">FEFaceValues</a> or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object.</td></tr>
    <tr><td class="paramname">point_no</td><td>Number of the quadrature point at which function is to be evaluated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a55a507d64ae810232dc0e8bdbf7ee4c1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::shape_value_component </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>function_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>point_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute one vector component of the value of a shape function at a quadrature point. If the finite element is scalar, then only component zero is allowed and the return value equals that of the <a class="el" href="classFEValuesBase.html#abe4de48ff59778bb82a0ec13037804aa">shape_value()</a> function. If the finite element is vector valued but all shape functions are primitive (i.e. they are non-zero in only one component), then the value returned by <a class="el" href="classFEValuesBase.html#abe4de48ff59778bb82a0ec13037804aa">shape_value()</a> equals that of this function for exactly one component. This function is therefore only of greater interest if the shape function is not primitive, but then it is necessary since the other function cannot be used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function_no</td><td>Number of the shape function to be evaluated</td></tr>
    <tr><td class="paramname">point_no</td><td>Number of the quadrature point at which function is to be evaluated</td></tr>
    <tr><td class="paramname">component</td><td>vector component to be evaluated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac4cee7628c2903a89c5c399fddeb00a5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTensor.html">Tensor</a>&lt;1,spacedim&gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::shape_grad </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>function_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>quadrature_point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the gradient of the <code>function_no</code>th shape function at the <code>quadrature_point</code>th quadrature point with respect to real cell coordinates. If you want to get the derivative in one of the coordinate directions, use the appropriate function of the <a class="el" href="classTensor.html">Tensor</a> class to extract one component of the <a class="el" href="classTensor.html">Tensor</a> returned by this function. Since only a reference to the gradient's value is returned, there should be no major performance drawback.</p>
<p>If the shape function is vector-valued, then this returns the only non-zero component. If the shape function has more than one non-zero component (i.e. it is not primitive), then it will throw an exception of type ExcShapeFunctionNotPrimitive. In that case, use the <a class="el" href="classFEValuesBase.html#a836dd15035c0493714a284ee3d0e0a16">shape_grad_component()</a> function.</p>
<p>The same holds for the arguments of this function as for the <a class="el" href="classFEValuesBase.html#abe4de48ff59778bb82a0ec13037804aa">shape_value()</a> function. </p>

</div>
</div>
<a class="anchor" id="a836dd15035c0493714a284ee3d0e0a16"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt;1,spacedim&gt; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::shape_grad_component </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>function_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>point_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return one vector component of the gradient of a shape function at a quadrature point. If the finite element is scalar, then only component zero is allowed and the return value equals that of the <a class="el" href="classFEValuesBase.html#ac4cee7628c2903a89c5c399fddeb00a5">shape_grad()</a> function. If the finite element is vector valued but all shape functions are primitive (i.e. they are non-zero in only one component), then the value returned by <a class="el" href="classFEValuesBase.html#ac4cee7628c2903a89c5c399fddeb00a5">shape_grad()</a> equals that of this function for exactly one component. This function is therefore only of greater interest if the shape function is not primitive, but then it is necessary since the other function cannot be used.</p>
<p>The same holds for the arguments of this function as for the <a class="el" href="classFEValuesBase.html#a55a507d64ae810232dc0e8bdbf7ee4c1">shape_value_component()</a> function. </p>

</div>
</div>
<a class="anchor" id="a294fe8cefce05f98a6135582cacf91c5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTensor.html">Tensor</a>&lt;2,spacedim&gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::shape_hessian </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>function_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>point_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Second derivatives of the <code>function_no</code>th shape function at the <code>point_no</code>th quadrature point with respect to real cell coordinates. If you want to get the derivatives in one of the coordinate directions, use the appropriate function of the <a class="el" href="classTensor.html">Tensor</a> class to extract one component. Since only a reference to the derivative values is returned, there should be no major performance drawback.</p>
<p>If the shape function is vector-valued, then this returns the only non-zero component. If the shape function has more than one non-zero component (i.e. it is not primitive), then throw an exception of type ExcShapeFunctionNotPrimitive. In that case, use the shape_grad_grad_component() function.</p>
<p>The same holds for the arguments of this function as for the <a class="el" href="classFEValuesBase.html#abe4de48ff59778bb82a0ec13037804aa">shape_value()</a> function. </p>

</div>
</div>
<a class="anchor" id="ad61ba7df056187a6fd8975cc02184a1f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTensor.html">Tensor</a>&lt;2,spacedim&gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::shape_2nd_derivative </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>function_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>point_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd>Wrapper for <a class="el" href="classFEValuesBase.html#a294fe8cefce05f98a6135582cacf91c5">shape_hessian()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa36d3dcb8e642db56dcb38757c2ab2dc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt;2,spacedim&gt; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::shape_hessian_component </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>function_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>point_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return one vector component of the gradient of a shape function at a quadrature point. If the finite element is scalar, then only component zero is allowed and the return value equals that of the <a class="el" href="classFEValuesBase.html#a294fe8cefce05f98a6135582cacf91c5">shape_hessian()</a> function. If the finite element is vector valued but all shape functions are primitive (i.e. they are non-zero in only one component), then the value returned by <a class="el" href="classFEValuesBase.html#a294fe8cefce05f98a6135582cacf91c5">shape_hessian()</a> equals that of this function for exactly one component. This function is therefore only of greater interest if the shape function is not primitive, but then it is necessary since the other function cannot be used.</p>
<p>The same holds for the arguments of this function as for the <a class="el" href="classFEValuesBase.html#a55a507d64ae810232dc0e8bdbf7ee4c1">shape_value_component()</a> function. </p>

</div>
</div>
<a class="anchor" id="a462a6f32cbb8bf21a6ec223b4ec72f48"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt;2,spacedim&gt; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::shape_2nd_derivative_component </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>function_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>point_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd>Wrapper for <a class="el" href="classFEValuesBase.html#aa36d3dcb8e642db56dcb38757c2ab2dc">shape_hessian_component()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a884144525a19d80f4e20b4e509c9132b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector , typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_values </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the values of a finite element function restricted to the current cell, face or subface selected the last time the <code>reinit</code> function of the derived class was called, at the quadrature points.</p>
<p>If the present cell is not active then values are interpolated to the current cell and point values are computed from that.</p>
<p>This function may only be used if the finite element in use is a scalar one, i.e. has only one vector component. To get values of multi-component elements, there is another <a class="el" href="classFEValuesBase.html#a884144525a19d80f4e20b4e509c9132b">get_function_values()</a> below, returning a vector of vectors of results.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fe_function</td><td>A vector of values that describes (globally) the finite element function that this function should evaluate at the quadrature points of the current cell.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">values</td><td>The values of the function specified by fe_function at the quadrature points of the current cell. The object is assume to already have the correct size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>values[q]</code> will contain the value of the field described by fe_function at the <img class="formulaInl" alt="$q$" src="form_79.png"/>th quadrature point.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The actual data type of the input vector may be either a <a class="el" href="classVector.html">Vector</a>&lt;T&gt;, <a class="el" href="classBlockVector.html">BlockVector</a>&lt;T&gt;, or one of the sequential PETSc or Trilinos vector wrapper classes. It represents a global vector of DoF values associated with the DofHandler object with which this <a class="el" href="classFEValues.html">FEValues</a> object was last initialized. Alternatively, if the vector argument is of type <a class="el" href="classIndexSet.html">IndexSet</a>, then the function is represented as one that is either zero or one, depending on whether a DoF index is in the set or not. </dd></dl>

</div>
</div>
<a class="anchor" id="af3dee2a75a4a4d24769ca10f39b7e0a0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector , typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_values </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function does the same as the other <a class="el" href="classFEValuesBase.html#a884144525a19d80f4e20b4e509c9132b">get_function_values()</a>, but applied to multi-component (vector-valued) elements. The meaning of the arguments is as explained there.</p>
<dl class="section post"><dt>Postcondition</dt><dd><code>values[q]</code> is a vector of values of the field described by fe_function at the <img class="formulaInl" alt="$q$" src="form_79.png"/>th quadrature point. The size of the vector accessed by <code>values[q]</code> equals the number of components of the finite element, i.e. <code>values[q](c)</code> returns the value of the <img class="formulaInl" alt="$c$" src="form_208.png"/>th vector component at the <img class="formulaInl" alt="$q$" src="form_79.png"/>th quadrature point. </dd></dl>

</div>
</div>
<a class="anchor" id="ae414ae839a23947040f51aa2845d1ad3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector , typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_values </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; const std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate function values from an arbitrary vector.</p>
<p>This function offers the possibility to extract function values in quadrature points from vectors not corresponding to a whole discretization.</p>
<p>The vector <code>indices</code> corresponds to the degrees of freedom on a single cell. Its length may even be a multiple of the number of dofs per cell. Then, the vectors in <code>value</code> should allow for the same multiple of the components of the finite element.</p>
<p>You may want to use this function, if you want to access just a single block from a <a class="el" href="classBlockVector.html">BlockVector</a>, if you have a multi-level vector or if you already have a local representation of your finite element data. </p>

</div>
</div>
<a class="anchor" id="a6878c6fdd77abd30e71979a78721806e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector , typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_values </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; const std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate vector function values from an arbitrary vector.</p>
<p>This function offers the possibility to extract function values in quadrature points from vectors not corresponding to a whole discretization.</p>
<p>The vector <code>indices</code> corresponds to the degrees of freedom on a single cell. Its length may even be a multiple of the number of dofs per cell. Then, the vectors in <code>value</code> should allow for the same multiple of the components of the finite element.</p>
<p>You may want to use this function, if you want to access just a single block from a <a class="el" href="classBlockVector.html">BlockVector</a>, if you have a multi-level vector or if you already have a local representation of your finite element data.</p>
<p>Since this function allows for fairly general combinations of argument sizes, be aware that the checks on the arguments may not detect errors. </p>

</div>
</div>
<a class="anchor" id="a6eeca2159bc8ed995482c6c5ca6bd0c7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_values </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; const std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; std::vector&lt; std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt; &gt;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>quadrature_points_fastest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate vector function values from an arbitrary vector.</p>
<p>This function offers the possibility to extract function values in quadrature points from vectors not corresponding to a whole discretization.</p>
<p>The vector <code>indices</code> corresponds to the degrees of freedom on a single cell. Its length may even be a multiple of the number of dofs per cell. Then, the vectors in <code>value</code> should allow for the same multiple of the components of the finite element.</p>
<p>Depending on the value of the last argument, the outer vector of <code>values</code> has either the length of the quadrature rule (<code>quadrature_points_fastest == false</code>) or the length of components to be filled <code>quadrature_points_fastest == true</code>. If <code>p</code> is the current quadrature point number and <code>i</code> is the vector component of the solution desired, the access to <code>values</code> is <code>values[p][i]</code> if <code>quadrature_points_fastest == false</code>, and <code>values[i][p]</code> otherwise.</p>
<p>You may want to use this function, if you want to access just a single block from a <a class="el" href="classBlockVector.html">BlockVector</a>, if you have a multi-level vector or if you already have a local representation of your finite element data.</p>
<p>Since this function allows for fairly general combinations of argument sizes, be aware that the checks on the arguments may not detect errors. </p>

</div>
</div>
<a class="anchor" id="aa2a27be24e74293d1041ac0d8086809d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_gradients </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>gradients</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the gradients of a finite element at the quadrature points of a cell. This function is the equivalent of the corresponding <a class="el" href="classFEValuesBase.html#a884144525a19d80f4e20b4e509c9132b">get_function_values()</a> function (see there for more information) but evaluates the finite element field's gradient instead of its value.</p>
<p>This function may only be used if the finite element in use is a scalar one, i.e. has only one vector component. There is a corresponding function of the same name for vector-valued finite elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fe_function</td><td>A vector of values that describes (globally) the finite element function that this function should evaluate at the quadrature points of the current cell.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">gradients</td><td>The gradients of the function specified by fe_function at the quadrature points of the current cell. The gradients are computed in real space (as opposed to on the unit cell). The object is assume to already have the correct size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>gradients[q]</code> will contain the gradient of the field described by fe_function at the <img class="formulaInl" alt="$q$" src="form_79.png"/>th quadrature point. <code>gradients[q][d]</code> represents the derivative in coordinate direction <img class="formulaInl" alt="$d$" src="form_172.png"/> at quadrature point <img class="formulaInl" alt="$q$" src="form_79.png"/>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The actual data type of the input vector may be either a <a class="el" href="classVector.html">Vector</a>&lt;T&gt;, <a class="el" href="classBlockVector.html">BlockVector</a>&lt;T&gt;, or one of the sequential PETSc or Trilinos vector wrapper classes. It represents a global vector of DoF values associated with the DofHandler object with which this <a class="el" href="classFEValues.html">FEValues</a> object was last initialized. Alternatively, if the vector argument is of type <a class="el" href="classIndexSet.html">IndexSet</a>, then the function is represented as one that is either zero or one, depending on whether a DoF index is in the set or not. </dd></dl>

</div>
</div>
<a class="anchor" id="a26eeb4e2c09834fb0d8c1d24eaff1b55"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_gradients </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>gradients</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function does the same as the other <a class="el" href="classFEValuesBase.html#aa2a27be24e74293d1041ac0d8086809d">get_function_gradients()</a>, but applied to multi-component (vector-valued) elements. The meaning of the arguments is as explained there.</p>
<dl class="section post"><dt>Postcondition</dt><dd><code>gradients[q]</code> is a vector of gradients of the field described by fe_function at the <img class="formulaInl" alt="$q$" src="form_79.png"/>th quadrature point. The size of the vector accessed by <code>gradients[q]</code> equals the number of components of the finite element, i.e. <code>gradients[q][c]</code> returns the gradient of the <img class="formulaInl" alt="$c$" src="form_208.png"/>th vector component at the <img class="formulaInl" alt="$q$" src="form_79.png"/>th quadrature point. Consequently, <code>gradients[q][c][d]</code> is the derivative in coordinate direction <img class="formulaInl" alt="$d$" src="form_172.png"/> of the <img class="formulaInl" alt="$c$" src="form_208.png"/>th vector component of the vector field at quadrature point <img class="formulaInl" alt="$q$" src="form_79.png"/> of the current cell. </dd></dl>

</div>
</div>
<a class="anchor" id="a8681e16644b2af4d27b1b75fbca332e3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_gradients </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; const std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>gradients</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classFunction.html">Function</a> gradient access with more flexibility. see <a class="el" href="classFEValuesBase.html#a884144525a19d80f4e20b4e509c9132b">get_function_values()</a> with corresponding arguments. </p>

</div>
</div>
<a class="anchor" id="a24dc2c9e61950749db68f3437f318b45"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_gradients </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; const std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; std::vector&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt; &gt; &gt; &gt;&#160;</td>
          <td class="paramname"><em>gradients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>quadrature_points_fastest</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classFunction.html">Function</a> gradient access with more flexibility. see <a class="el" href="classFEValuesBase.html#a884144525a19d80f4e20b4e509c9132b">get_function_values()</a> with corresponding arguments. </p>

</div>
</div>
<a class="anchor" id="a393b58da5e9a60d09e1df40a71c96757"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_grads </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>gradients</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd>Use <a class="el" href="classFEValuesBase.html#aa2a27be24e74293d1041ac0d8086809d">get_function_gradients()</a> instead. </dd></dl>

</div>
</div>
<a class="anchor" id="a9aa3142c0350749f1060d3de1b4eef28"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_grads </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>gradients</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000004">Deprecated:</a></b></dt><dd>Use <a class="el" href="classFEValuesBase.html#aa2a27be24e74293d1041ac0d8086809d">get_function_gradients()</a> instead. </dd></dl>

</div>
</div>
<a class="anchor" id="a6b51ec707d74bf4c005f805495582524"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_grads </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; const std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>gradients</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000005">Deprecated:</a></b></dt><dd>Use <a class="el" href="classFEValuesBase.html#aa2a27be24e74293d1041ac0d8086809d">get_function_gradients()</a> instead. </dd></dl>

</div>
</div>
<a class="anchor" id="a50532aed1ef919b1dc9261de5ebd7f25"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_grads </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; const std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>gradients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>quadrature_points_fastest</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000006">Deprecated:</a></b></dt><dd>Use <a class="el" href="classFEValuesBase.html#aa2a27be24e74293d1041ac0d8086809d">get_function_gradients()</a> instead. </dd></dl>

</div>
</div>
<a class="anchor" id="a74d154434bef75478e4cb3f358c13c41"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_hessians </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 2, spacedim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>hessians</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the tensor of second derivatives of a finite element at the quadrature points of a cell. This function is the equivalent of the corresponding <a class="el" href="classFEValuesBase.html#a884144525a19d80f4e20b4e509c9132b">get_function_values()</a> function (see there for more information) but evaluates the finite element field's second derivatives instead of its value.</p>
<p>This function may only be used if the finite element in use is a scalar one, i.e. has only one vector component. There is a corresponding function of the same name for vector-valued finite elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fe_function</td><td>A vector of values that describes (globally) the finite element function that this function should evaluate at the quadrature points of the current cell.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">hessians</td><td>The Hessians of the function specified by fe_function at the quadrature points of the current cell. The Hessians are computed in real space (as opposed to on the unit cell). The object is assume to already have the correct size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>hessians[q]</code> will contain the Hessian of the field described by fe_function at the <img class="formulaInl" alt="$q$" src="form_79.png"/>th quadrature point. <code>gradients[q][i][j]</code> represents the <img class="formulaInl" alt="$(i,j)$" src="form_209.png"/>th component of the matrix of second derivatives at quadrature point <img class="formulaInl" alt="$q$" src="form_79.png"/>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The actual data type of the input vector may be either a <a class="el" href="classVector.html">Vector</a>&lt;T&gt;, <a class="el" href="classBlockVector.html">BlockVector</a>&lt;T&gt;, or one of the sequential PETSc or Trilinos vector wrapper classes. It represents a global vector of DoF values associated with the DofHandler object with which this <a class="el" href="classFEValues.html">FEValues</a> object was last initialized. Alternatively, if the vector argument is of type <a class="el" href="classIndexSet.html">IndexSet</a>, then the function is represented as one that is either zero or one, depending on whether a DoF index is in the set or not. </dd></dl>

</div>
</div>
<a class="anchor" id="accdef80677dde0542251c302261fc34a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_hessians </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 2, spacedim &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>hessians</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>quadrature_points_fastest</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function does the same as the other <a class="el" href="classFEValuesBase.html#a74d154434bef75478e4cb3f358c13c41">get_function_hessians()</a>, but applied to multi-component (vector-valued) elements. The meaning of the arguments is as explained there.</p>
<dl class="section post"><dt>Postcondition</dt><dd><code>hessians[q]</code> is a vector of Hessians of the field described by fe_function at the <img class="formulaInl" alt="$q$" src="form_79.png"/>th quadrature point. The size of the vector accessed by <code>hessians[q]</code> equals the number of components of the finite element, i.e. <code>hessians[q][c]</code> returns the Hessian of the <img class="formulaInl" alt="$c$" src="form_208.png"/>th vector component at the <img class="formulaInl" alt="$q$" src="form_79.png"/>th quadrature point. Consequently, <code>values[q][c][i][j]</code> is the <img class="formulaInl" alt="$(i,j)$" src="form_209.png"/>th component of the matrix of second derivatives of the <img class="formulaInl" alt="$c$" src="form_208.png"/>th vector component of the vector field at quadrature point <img class="formulaInl" alt="$q$" src="form_79.png"/> of the current cell. </dd></dl>

</div>
</div>
<a class="anchor" id="af471b3cb0cb617093525284003c0be9f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_hessians </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; const std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 2, spacedim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>hessians</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access to the second derivatives of a function with more flexibility. see <a class="el" href="classFEValuesBase.html#a884144525a19d80f4e20b4e509c9132b">get_function_values()</a> with corresponding arguments. </p>

</div>
</div>
<a class="anchor" id="a259282cb3676418ca2590b98463ba8d4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_hessians </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; const std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; std::vector&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 2, spacedim &gt; &gt; &gt; &gt;&#160;</td>
          <td class="paramname"><em>hessians</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>quadrature_points_fastest</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access to the second derivatives of a function with more flexibility. see <a class="el" href="classFEValuesBase.html#a884144525a19d80f4e20b4e509c9132b">get_function_values()</a> with corresponding arguments. </p>

</div>
</div>
<a class="anchor" id="a77b4ee9cf5f5423b353da7e64896b17d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_2nd_derivatives </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 2, spacedim &gt; &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000007">Deprecated:</a></b></dt><dd>Wrapper for <a class="el" href="classFEValuesBase.html#a74d154434bef75478e4cb3f358c13c41">get_function_hessians()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8b5700c4cd52a7108a8ae5f6c0567d0b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_2nd_derivatives </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 2, spacedim &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000008">Deprecated:</a></b></dt><dd>Wrapper for <a class="el" href="classFEValuesBase.html#a74d154434bef75478e4cb3f358c13c41">get_function_hessians()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af2aafd8203cb76d573ba8e78245c4ed9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector , typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_laplacians </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>laplacians</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the (scalar) Laplacian (i.e. the trace of the tensor of second derivatives) of a finite element at the quadrature points of a cell. This function is the equivalent of the corresponding <a class="el" href="classFEValuesBase.html#a884144525a19d80f4e20b4e509c9132b">get_function_values()</a> function (see there for more information) but evaluates the finite element field's second derivatives instead of its value.</p>
<p>This function may only be used if the finite element in use is a scalar one, i.e. has only one vector component. There is a corresponding function of the same name for vector-valued finite elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fe_function</td><td>A vector of values that describes (globally) the finite element function that this function should evaluate at the quadrature points of the current cell.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">laplacians</td><td>The Laplacians of the function specified by fe_function at the quadrature points of the current cell. The Laplacians are computed in real space (as opposed to on the unit cell). The object is assume to already have the correct size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>laplacians[q]</code> will contain the Laplacian of the field described by fe_function at the <img class="formulaInl" alt="$q$" src="form_79.png"/>th quadrature point. <code>gradients[q][i][j]</code> represents the <img class="formulaInl" alt="$(i,j)$" src="form_209.png"/>th component of the matrix of second derivatives at quadrature point <img class="formulaInl" alt="$q$" src="form_79.png"/>.</dd>
<dd>
For each component of the output vector, there holds <code>laplacians[q]=trace(hessians[q])</code>, where <code>hessians</code> would be the output of the <a class="el" href="classFEValuesBase.html#a74d154434bef75478e4cb3f358c13c41">get_function_hessians()</a> function.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The actual data type of the input vector may be either a <a class="el" href="classVector.html">Vector</a>&lt;T&gt;, <a class="el" href="classBlockVector.html">BlockVector</a>&lt;T&gt;, or one of the sequential PETSc or Trilinos vector wrapper classes. It represents a global vector of DoF values associated with the DofHandler object with which this <a class="el" href="classFEValues.html">FEValues</a> object was last initialized. Alternatively, if the vector argument is of type <a class="el" href="classIndexSet.html">IndexSet</a>, then the function is represented as one that is either zero or one, depending on whether a DoF index is in the set or not. </dd></dl>

</div>
</div>
<a class="anchor" id="aa24fb3acb975500bdfa066396f67393b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector , typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_laplacians </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>laplacians</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function does the same as the other <a class="el" href="classFEValuesBase.html#af2aafd8203cb76d573ba8e78245c4ed9">get_function_laplacians()</a>, but applied to multi-component (vector-valued) elements. The meaning of the arguments is as explained there.</p>
<dl class="section post"><dt>Postcondition</dt><dd><code>laplacians[q]</code> is a vector of Laplacians of the field described by fe_function at the <img class="formulaInl" alt="$q$" src="form_79.png"/>th quadrature point. The size of the vector accessed by <code>laplacians[q]</code> equals the number of components of the finite element, i.e. <code>laplacians[q][c]</code> returns the Laplacian of the <img class="formulaInl" alt="$c$" src="form_208.png"/>th vector component at the <img class="formulaInl" alt="$q$" src="form_79.png"/>th quadrature point.</dd>
<dd>
For each component of the output vector, there holds <code>laplacians[q][c]=trace(hessians[q][c])</code>, where <code>hessians</code> would be the output of the <a class="el" href="classFEValuesBase.html#a74d154434bef75478e4cb3f358c13c41">get_function_hessians()</a> function. </dd></dl>

</div>
</div>
<a class="anchor" id="a3e6d8bd6f7c7a3118d6932b84bc39f21"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector , typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_laplacians </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; const std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>laplacians</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access to the second derivatives of a function with more flexibility. see <a class="el" href="classFEValuesBase.html#a884144525a19d80f4e20b4e509c9132b">get_function_values()</a> with corresponding arguments. </p>

</div>
</div>
<a class="anchor" id="a448e1d8a8c8b2dc79e7301a2124c760c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector , typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_laplacians </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; const std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>laplacians</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access to the second derivatives of a function with more flexibility. see <a class="el" href="classFEValuesBase.html#a884144525a19d80f4e20b4e509c9132b">get_function_values()</a> with corresponding arguments. </p>

</div>
</div>
<a class="anchor" id="a4b2c1a6c6b421d79d08667a859b7a019"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector , typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_laplacians </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; const std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; number &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>laplacians</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>quadrature_points_fastest</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access to the second derivatives of a function with more flexibility. see <a class="el" href="classFEValuesBase.html#a884144525a19d80f4e20b4e509c9132b">get_function_values()</a> with corresponding arguments. </p>

</div>
</div>
<a class="anchor" id="a75b6f2cb7c735b51b20093d90b1930b0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::quadrature_point </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Position of the <code>i</code>th quadrature point in real space. </p>

</div>
</div>
<a class="anchor" id="a5f8732ebe2d3c6746f6de26a79cb1e45"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt; &gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_quadrature_points </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a pointer to the vector of quadrature points in real space. </p>

</div>
</div>
<a class="anchor" id="ad097580a2f71878695096cc73b271b9d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::JxW </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>quadrature_point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mapped quadrature weight. If this object refers to a volume evaluation (i.e. the derived class is of type <a class="el" href="classFEValues.html">FEValues</a>), then this is the Jacobi determinant times the weight of the *<code>i</code>th unit quadrature point.</p>
<p>For surface evaluations (i.e. classes <a class="el" href="classFEFaceValues.html">FEFaceValues</a> or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a>), it is the mapped surface element times the weight of the quadrature point.</p>
<p>You can think of the quantity returned by this function as the volume or surface element <img class="formulaInl" alt="$dx, ds$" src="form_210.png"/> in the integral that we implement here by quadrature. </p>

</div>
</div>
<a class="anchor" id="a9f58a19d26312fba0a2e20f45e4c988a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classdouble.html">double</a>&gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_JxW_values </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pointer to the array holding the values returned by <a class="el" href="classFEValuesBase.html#ad097580a2f71878695096cc73b271b9d">JxW()</a>. </p>

</div>
</div>
<a class="anchor" id="ae2eb28f851a91705e8e06beca9e5dcad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt;1,dim,spacedim&gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::jacobian </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>quadrature_point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the Jacobian of the transformation at the specified quadrature point, i.e. <img class="formulaInl" alt="$J_{ij}=dx_i/d\hat x_j$" src="form_211.png"/> </p>

</div>
</div>
<a class="anchor" id="a61dc18abdc242d282a7c40da6f6fc1e8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt;1,dim,spacedim&gt; &gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_jacobians </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pointer to the array holding the values returned by <a class="el" href="classFEValuesBase.html#ae2eb28f851a91705e8e06beca9e5dcad">jacobian()</a>. </p>

</div>
</div>
<a class="anchor" id="a82014c734026b855555cbab8504f48d0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt;2,dim,spacedim&gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::jacobian_grad </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>quadrature_point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the second derivative of the transformation from unit to real cell, i.e. the first derivative of the Jacobian, at the specified quadrature point, i.e. <img class="formulaInl" alt="$G_{ijk}=dJ_{jk}/d\hat x_i$" src="form_212.png"/>. </p>

</div>
</div>
<a class="anchor" id="a5292360b569c24feb15ca9d3a2f53d3c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt;2,dim,spacedim&gt; &gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_jacobian_grads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pointer to the array holding the values returned by <a class="el" href="classFEValuesData.html#aff337b9f1d1fc1bbccdb4c3cc3ea739f">jacobian_grads()</a>. </p>

</div>
</div>
<a class="anchor" id="a665ab681011424cb1b0ba11c4155a121"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt;1,spacedim,dim&gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::inverse_jacobian </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>quadrature_point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the inverse Jacobian of the transformation at the specified quadrature point, i.e. <img class="formulaInl" alt="$J_{ij}=d\hat x_i/dx_j$" src="form_213.png"/> </p>

</div>
</div>
<a class="anchor" id="ad5abadee1bbf314037cef0e006c46b4d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt;1,spacedim,dim&gt; &gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_inverse_jacobians </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pointer to the array holding the values returned by <a class="el" href="classFEValuesBase.html#a665ab681011424cb1b0ba11c4155a121">inverse_jacobian()</a>. </p>

</div>
</div>
<a class="anchor" id="a65b6761eafde9e485da59d599b90760b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::normal_vector </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For a face, return the outward normal vector to the cell at the <code>i</code>th quadrature point.</p>
<p>For a cell of codimension one, return the normal vector, as it is specified by the numbering of the vertices.</p>
<p>The length of the vector is normalized to one. </p>

</div>
</div>
<a class="anchor" id="afcddbeb5aac98c1bbde8b229ea3f0799"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt; &gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_normal_vectors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the normal vectors at the quadrature points. For a face, these are the outward normal vectors to the cell. For a cell of codimension one, the orientation is given by the numbering of vertices. </p>

</div>
</div>
<a class="anchor" id="a0f7e5af23da360ff063670b0511a41a2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::transform </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>transformed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>original</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mapping.html#gaf0a4d6be70322c742c12da1edccbb74d">MappingType</a>&#160;</td>
          <td class="paramname"><em>mapping</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transform a set of vectors, one for each quadrature point. The <code>mapping</code> can be any of the ones defined in MappingType. </p>

</div>
</div>
<a class="anchor" id="ac2359a176a1d348ef6c2f6c9a087e27e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::cell_normal_vector </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000009">Deprecated:</a></b></dt><dd>Use <a class="el" href="classFEValuesBase.html#a65b6761eafde9e485da59d599b90760b">normal_vector()</a> instead.</dd></dl>
<p>Return the outward normal vector to the cell at the <code>i</code>th quadrature point. The length of the vector is normalized to one. </p>

</div>
</div>
<a class="anchor" id="aa4ff1049b98f6edb95ae9d5bb7e4b555"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt; &gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_cell_normal_vectors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000010">Deprecated:</a></b></dt><dd>Use <a class="el" href="classFEValuesBase.html#afcddbeb5aac98c1bbde8b229ea3f0799">get_normal_vectors()</a> instead.</dd></dl>
<p>Returns the vectors normal to the cell in each of the quadrature points. </p>

</div>
</div>
<a class="anchor" id="a045b5cc028f0e4372d86ab647c7e938c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classFEValuesViews_1_1Scalar.html">FEValuesViews::Scalar</a>&lt;dim,spacedim&gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a view of the current <a class="el" href="classFEValues.html">FEValues</a> object that represents a particular scalar component of the possibly vector-valued finite element. The concept of views is explained in the documentation of the namespace <a class="el" href="namespaceFEValuesViews.html">FEValuesViews</a> and in particular in the <a class="el" href="group__vector__valued.html">Handling vector valued problems</a> module. </p>

</div>
</div>
<a class="anchor" id="af29b6c5ffc0dca6eb1ea458d727752dc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classFEValuesViews_1_1Vector.html">FEValuesViews::Vector</a>&lt;dim,spacedim&gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a view of the current <a class="el" href="classFEValues.html">FEValues</a> object that represents a set of <code>dim</code> scalar components (i.e. a vector) of the vector-valued finite element. The concept of views is explained in the documentation of the namespace <a class="el" href="namespaceFEValuesViews.html">FEValuesViews</a> and in particular in the <a class="el" href="group__vector__valued.html">Handling vector valued problems</a> module. </p>

</div>
</div>
<a class="anchor" id="a5680b7a98e158df316b600e5d3a498fb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classFEValuesViews_1_1SymmetricTensor.html">FEValuesViews::SymmetricTensor</a>&lt;2,dim,spacedim&gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structFEValuesExtractors_1_1SymmetricTensor.html">FEValuesExtractors::SymmetricTensor</a>&lt; 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>tensor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a view of the current <a class="el" href="classFEValues.html">FEValues</a> object that represents a set of <code>(dim*dim + dim)/2</code> scalar components (i.e. a symmetric 2nd order tensor) of the vector-valued finite element. The concept of views is explained in the documentation of the namespace <a class="el" href="namespaceFEValuesViews.html">FEValuesViews</a> and in particular in the <a class="el" href="group__vector__valued.html">Handling vector valued problems</a> module. </p>

</div>
</div>
<a class="anchor" id="a978e33f9e08b20d6e472bf845fe126eb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classFEValuesViews_1_1Tensor.html">FEValuesViews::Tensor</a>&lt;2,dim,spacedim&gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structFEValuesExtractors_1_1Tensor.html">FEValuesExtractors::Tensor</a>&lt; 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>tensor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a view of the current <a class="el" href="classFEValues.html">FEValues</a> object that represents a set of <code>(dim*dim)</code> scalar components (i.e. a 2nd order tensor) of the vector-valued finite element. The concept of views is explained in the documentation of the namespace <a class="el" href="namespaceFEValuesViews.html">FEValuesViews</a> and in particular in the <a class="el" href="group__vector__valued.html">Handling vector valued problems</a> module. </p>

</div>
</div>
<a class="anchor" id="a7e077b1569f189d69afa242014b7c2da"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classMapping.html">Mapping</a>&lt;dim,spacedim&gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_mapping </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constant reference to the selected mapping object. </p>

</div>
</div>
<a class="anchor" id="aa67eb1714ca9dc018182be86103091de"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt;dim,spacedim&gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_fe </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constant reference to the selected finite element object. </p>

</div>
</div>
<a class="anchor" id="ae13d0676167b7e05b1d70737a901dd04"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_update_flags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the update flags set for this object. </p>

</div>
</div>
<a class="anchor" id="a6959f20afbf234418f64968230a13ba3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt;dim,spacedim&gt;::cell_iterator <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_cell </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a triangulation iterator to the current cell. </p>

</div>
</div>
<a class="anchor" id="a69a2e58ada338b185cf448d287294ee4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CellSimilarity::Similarity <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_cell_similarity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the relation of the current cell to the previous cell. This allows re-use of some cell data (like local matrices for equations with constant coefficients) if the result is <code>CellSimilarity::translation</code>. </p>

</div>
</div>
<a class="anchor" id="a626f38270a935445272c2ba23db3a080"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine an estimate for the memory consumption (in bytes) of this object. </p>

</div>
</div>
<a class="anchor" id="aaf01126d2e3b926fecbaf122357add53"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::invalidate_present_cell </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A function that is connected to the triangulation in order to reset the stored 'present_cell' iterator to an invalid one whenever the triangulation is changed and the iterator consequently becomes invalid. </p>

</div>
</div>
<a class="anchor" id="aed652da6ec16e368e27da4085b4281bb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::maybe_invalidate_previous_present_cell </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is called by the various reinit() functions in derived classes. Given the cell indicated by the argument, test whether we have to throw away the previously stored present_cell argument because it would require us to compare cells from different triangulations. In checking all this, also make sure that we have tria_listener connected to the triangulation to which we will set present_cell right after calling this function. </p>

</div>
</div>
<a class="anchor" id="af928285aed02ded5d02cf4edb1086fe5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::compute_update_flags </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td>
          <td class="paramname"><em>update_flags</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initialize some update flags. Called from the <code>initialize</code> functions of derived classes, which are in turn called from their constructors.</p>
<p>Basically, this function finds out using the finite element and mapping object already stored which flags need to be set to compute everything the user wants, as expressed through the flags passed as argument. </p>

</div>
</div>
<a class="anchor" id="a5c38a7d7c3a6b384ad5b46f38248524d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::check_cell_similarity </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A function that checks whether the new cell is similar to the one previously used. Then, a significant amount of the data can be reused, e.g. the derivatives of the basis functions in real space, shape_grad. </p>

</div>
</div>
<a class="anchor" id="a48091346190d2c2c562bca0b5d6e73b7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFEValuesBase.html">FEValuesBase</a>&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy operator. Since objects of this class are not copyable, we make it private, and also do not implement it. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="abd66d1380ef2e58a1e433bc1626c324e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<div class="memtemplate">
template&lt;int , int &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classFEValuesViews_1_1Scalar.html">FEValuesViews::Scalar</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Make the view classes friends of this class, since they access internal data. </p>

<p>Definition at line <a class="el" href="fe_2fe__values_8h_source.html#l02409">2409</a> of file <a class="el" href="fe_2fe__values_8h_source.html">fe_values.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="afd889a38bbce8ea33d46d152f14abdd3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::dimension = dim</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Dimension in which this object operates. </p>

<p>Definition at line <a class="el" href="fe_2fe__values_8h_source.html#l01401">1401</a> of file <a class="el" href="fe_2fe__values_8h_source.html">fe_values.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6541820cb52f78a4d43de18be0352002"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::space_dimension = spacedim</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Dimension of the space in which this object operates. </p>

<p>Definition at line <a class="el" href="fe_2fe__values_8h_source.html#l01406">1406</a> of file <a class="el" href="fe_2fe__values_8h_source.html">fe_values.h</a>.</p>

</div>
</div>
<a class="anchor" id="a807c3049bfe81743fc0f237dfc2fbdea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::n_quadrature_points</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of quadrature points. </p>

<p>Definition at line <a class="el" href="fe_2fe__values_8h_source.html#l01411">1411</a> of file <a class="el" href="fe_2fe__values_8h_source.html">fe_values.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5b264d5b2fb6615f5dea7a21135ed1a5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::dofs_per_cell</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of shape functions per cell. If we use this base class to evaluate a finite element on faces of cells, this is still the number of degrees of freedom per cell, not per face. </p>

<p>Definition at line <a class="el" href="fe_2fe__values_8h_source.html#l01418">1418</a> of file <a class="el" href="fe_2fe__values_8h_source.html">fe_values.h</a>.</p>

</div>
</div>
<a class="anchor" id="afeddfe00fc718ed1ed1c83826408afe1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::auto_ptr&lt;const CellIteratorBase&gt; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::present_cell</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Store the cell selected last time the reinit() function was called. This is necessary for the <code>get_function_*</code> functions as well as the functions of same name in the extractor classes. </p>

<p>Definition at line <a class="el" href="fe_2fe__values_8h_source.html#l02304">2304</a> of file <a class="el" href="fe_2fe__values_8h_source.html">fe_values.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab688f51aad683baef55ce7e164fcdda7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::signals2::connection <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::tria_listener</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A signal connection we use to ensure we get informed whenever the triangulation changes. We need to know about that because it invalidates all cell iterators and, as part of that, the 'present_cell' iterator we keep around between subsequent calls to reinit() in order to compute the cell similarity. </p>

<p>Definition at line <a class="el" href="fe_2fe__values_8h_source.html#l02320">2320</a> of file <a class="el" href="fe_2fe__values_8h_source.html">fe_values.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8fb1d5f367902df6b2b598d9da1b0398"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSmartPointer.html">SmartPointer</a>&lt;const <a class="el" href="classMapping.html">Mapping</a>&lt;dim,spacedim&gt;,<a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt;dim,spacedim&gt; &gt; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::mapping</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Storage for the mapping object. </p>

<p>Definition at line <a class="el" href="fe_2fe__values_8h_source.html#l02344">2344</a> of file <a class="el" href="fe_2fe__values_8h_source.html">fe_values.h</a>.</p>

</div>
</div>
<a class="anchor" id="aeb05cc9511ff887438f3e6cf036a3134"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSmartPointer.html">SmartPointer</a>&lt;const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt;dim,spacedim&gt;,<a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt;dim,spacedim&gt; &gt; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::fe</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Store the finite element for later use. </p>

<p>Definition at line <a class="el" href="fe_2fe__values_8h_source.html#l02349">2349</a> of file <a class="el" href="fe_2fe__values_8h_source.html">fe_values.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3bcd3568305e3a943b7c7cefd29bbf77"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSmartPointer.html">SmartPointer</a>&lt;typename <a class="el" href="classMapping.html">Mapping</a>&lt;dim,spacedim&gt;::InternalDataBase,<a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt;dim,spacedim&gt; &gt; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::mapping_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Internal data of mapping. </p>

<p>Definition at line <a class="el" href="fe_2fe__values_8h_source.html#l02355">2355</a> of file <a class="el" href="fe_2fe__values_8h_source.html">fe_values.h</a>.</p>

</div>
</div>
<a class="anchor" id="adab61905282bc3237f01e7d9aec3c694"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSmartPointer.html">SmartPointer</a>&lt;typename <a class="el" href="classMapping.html">Mapping</a>&lt;dim,spacedim&gt;::InternalDataBase,<a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt;dim,spacedim&gt; &gt; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::fe_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Internal data of finite element. </p>

<p>Definition at line <a class="el" href="fe_2fe__values_8h_source.html#l02360">2360</a> of file <a class="el" href="fe_2fe__values_8h_source.html">fe_values.h</a>.</p>

</div>
</div>
<a class="anchor" id="a096d4ea9edea6618e23f5f13ab40784c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CellSimilarity::Similarity <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::cell_similarity</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>An enum variable that can store different states of the current cell in comparison to the previously visited cell. If wanted, additional states can be checked here and used in one of the methods used during reinit. </p>

<p>Definition at line <a class="el" href="fe_2fe__values_8h_source.html#l02377">2377</a> of file <a class="el" href="fe_2fe__values_8h_source.html">fe_values.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7cf406ac2334ec378cdbaed4b836cc45"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">::<a class="el" href="structinternal_1_1FEValuesViews_1_1Cache.html">internal::FEValuesViews::Cache</a>&lt;dim,spacedim&gt; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::fe_values_views_cache</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A cache for all possible <a class="el" href="namespaceFEValuesViews.html">FEValuesViews</a> objects. </p>

<p>Definition at line <a class="el" href="fe_2fe__values_8h_source.html#l02403">2403</a> of file <a class="el" href="fe_2fe__values_8h_source.html">fe_values.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/deal.II/fe/<a class="el" href="fe_2fe__values_8h_source.html">fe_values.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jan 27 2014 15:27:18 for The deal.II Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
