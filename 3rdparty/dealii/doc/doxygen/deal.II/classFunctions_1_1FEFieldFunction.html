<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>The deal.II Library: Functions::FEFieldFunction&lt; dim, DH, VECTOR &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="http://www.dealii.org/deal.ico"></link>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2014 by the deal.II authors"></meta>
<meta name="deal.II-version" content="8.1.0"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 8.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceFunctions.html">Functions</a></li><li class="navelem"><a class="el" href="classFunctions_1_1FEFieldFunction.html">FEFieldFunction</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classFunctions_1_1FEFieldFunction-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Functions::FEFieldFunction&lt; dim, DH, VECTOR &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__functions.html">Functions</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="fe__field__function_8h_source.html">fe_field_function.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Functions::FEFieldFunction&lt; dim, DH, VECTOR &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classFunctions_1_1FEFieldFunction__inherit__graph.svg" width="263" height="315"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac7f1d91d9b5d816bb5221faf2458e33b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#ac7f1d91d9b5d816bb5221faf2458e33b">FEFieldFunction</a> (const DH &amp;<a class="el" href="classFunctions_1_1FEFieldFunction.html#a5b72e6ff1462fbfd15ce22b1f111ca6b">dh</a>, const VECTOR &amp;<a class="el" href="classFunctions_1_1FEFieldFunction.html#ab2f2f7b1ab6421d4c63ded3468d2b36e">data_vector</a>, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim &gt; &amp;<a class="el" href="classFunctions_1_1FEFieldFunction.html#a1d702d2e6ecac6e645921beaf3540723">mapping</a>=<a class="el" href="structStaticMappingQ1.html">StaticMappingQ1</a>&lt; dim &gt;::<a class="el" href="classFunctions_1_1FEFieldFunction.html#a1d702d2e6ecac6e645921beaf3540723">mapping</a>)</td></tr>
<tr class="separator:ac7f1d91d9b5d816bb5221faf2458e33b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7170e1661d3295432cf6abd0eac7a825"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#a7170e1661d3295432cf6abd0eac7a825">set_active_cell</a> (const typename DH::active_cell_iterator &amp;newcell)</td></tr>
<tr class="separator:a7170e1661d3295432cf6abd0eac7a825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae80e2860fb6eb268524d7ca135e111a7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#ae80e2860fb6eb268524d7ca135e111a7">vector_value</a> (const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;values) const </td></tr>
<tr class="separator:ae80e2860fb6eb268524d7ca135e111a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ecdc273606ab64d0a17d00118cf46e9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#a2ecdc273606ab64d0a17d00118cf46e9">value</a> (const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, const unsigned <a class="el" href="classint.html">int</a> component=0) const </td></tr>
<tr class="separator:a2ecdc273606ab64d0a17d00118cf46e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4acaac93f6a797a25b67e16d5de15a82"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#a4acaac93f6a797a25b67e16d5de15a82">value_list</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;points, std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;values, const unsigned <a class="el" href="classint.html">int</a> component=0) const </td></tr>
<tr class="separator:a4acaac93f6a797a25b67e16d5de15a82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adec1f9209ba366c375fcc5f67406f49d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#adec1f9209ba366c375fcc5f67406f49d">vector_value_list</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;points, std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt; &amp;values) const </td></tr>
<tr class="separator:adec1f9209ba366c375fcc5f67406f49d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5bbeb2f0e6c107dea851aa433df88bc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#ac5bbeb2f0e6c107dea851aa433df88bc">vector_gradient</a> (const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt; &gt; &amp;gradients) const </td></tr>
<tr class="separator:ac5bbeb2f0e6c107dea851aa433df88bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae86b30c1f2d8902528f9c87eedfeddd1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#ae86b30c1f2d8902528f9c87eedfeddd1">gradient</a> (const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, const unsigned <a class="el" href="classint.html">int</a> component=0) const </td></tr>
<tr class="separator:ae86b30c1f2d8902528f9c87eedfeddd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53c5306bad5cde6cfc4228873f3fcf14"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#a53c5306bad5cde6cfc4228873f3fcf14">vector_gradient_list</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;p, std::vector&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt; &gt; &gt; &amp;gradients) const </td></tr>
<tr class="separator:a53c5306bad5cde6cfc4228873f3fcf14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27b1085bc29af0918324363b4e712a79"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#a27b1085bc29af0918324363b4e712a79">gradient_list</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;p, std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt; &gt; &amp;gradients, const unsigned <a class="el" href="classint.html">int</a> component=0) const </td></tr>
<tr class="separator:a27b1085bc29af0918324363b4e712a79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fdc0af70dcf85529549736b277b254d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#a9fdc0af70dcf85529549736b277b254d">laplacian</a> (const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, const unsigned <a class="el" href="classint.html">int</a> component=0) const </td></tr>
<tr class="separator:a9fdc0af70dcf85529549736b277b254d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab241cd8065b0294b3a94ad829214ed1a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#ab241cd8065b0294b3a94ad829214ed1a">vector_laplacian</a> (const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;values) const </td></tr>
<tr class="separator:ab241cd8065b0294b3a94ad829214ed1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d6954141e889217367710753ab0c6c9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#a5d6954141e889217367710753ab0c6c9">laplacian_list</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;points, std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;values, const unsigned <a class="el" href="classint.html">int</a> component=0) const </td></tr>
<tr class="separator:a5d6954141e889217367710753ab0c6c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b975c809df59abf50e06fbc4f6b49ed"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#a6b975c809df59abf50e06fbc4f6b49ed">vector_laplacian_list</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;points, std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt; &amp;values) const </td></tr>
<tr class="separator:a6b975c809df59abf50e06fbc4f6b49ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3147cf31104135184553d8338820cdca"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#a3147cf31104135184553d8338820cdca">compute_point_locations</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;points, std::vector&lt; typename DH::active_cell_iterator &gt; &amp;cells, std::vector&lt; std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &gt; &amp;qpoints, std::vector&lt; std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &gt; &amp;maps) const </td></tr>
<tr class="separator:a3147cf31104135184553d8338820cdca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab53e18f14c938c9ff45d68381313e7d3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#ab53e18f14c938c9ff45d68381313e7d3">DeclException0</a> (ExcPointNotAvailableHere)</td></tr>
<tr class="separator:ab53e18f14c938c9ff45d68381313e7d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classFunction"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classFunction')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classFunction.html">Function&lt; dim &gt;</a></td></tr>
<tr class="memitem:a90d8466fe8b3879fdd2caf73b08261e7 inherit pub_methods_classFunction"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a90d8466fe8b3879fdd2caf73b08261e7">Function</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFunction.html#a22de55d2cbd6696fd0274a626614e31a">n_components</a>=1, const <a class="el" href="classdouble.html">double</a> initial_time=0.0)</td></tr>
<tr class="separator:a90d8466fe8b3879fdd2caf73b08261e7 inherit pub_methods_classFunction"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4f43afb9ac9f00ba4392cebd88606d4 inherit pub_methods_classFunction"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#ac4f43afb9ac9f00ba4392cebd88606d4">~Function</a> ()=0</td></tr>
<tr class="separator:ac4f43afb9ac9f00ba4392cebd88606d4 inherit pub_methods_classFunction"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46ef8267edba3f6719cb37cc855e7dc5 inherit pub_methods_classFunction"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFunction.html">Function</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a46ef8267edba3f6719cb37cc855e7dc5">operator=</a> (const <a class="el" href="classFunction.html">Function</a> &amp;f)</td></tr>
<tr class="separator:a46ef8267edba3f6719cb37cc855e7dc5 inherit pub_methods_classFunction"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad19c5b7fabf50615fce03a61a63efaf7 inherit pub_methods_classFunction"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#ad19c5b7fabf50615fce03a61a63efaf7">vector_values</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;points, std::vector&lt; std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt; &amp;values) const</td></tr>
<tr class="separator:ad19c5b7fabf50615fce03a61a63efaf7 inherit pub_methods_classFunction"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6655835d08360d3f45c06f88fba4c929 inherit pub_methods_classFunction"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a6655835d08360d3f45c06f88fba4c929">vector_gradients</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;points, std::vector&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt; &gt; &gt; &amp;gradients) const</td></tr>
<tr class="separator:a6655835d08360d3f45c06f88fba4c929 inherit pub_methods_classFunction"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f8f15b255e6d36a46dc8e48cf837015 inherit pub_methods_classFunction"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a5f8f15b255e6d36a46dc8e48cf837015">memory_consumption</a> () const</td></tr>
<tr class="separator:a5f8f15b255e6d36a46dc8e48cf837015 inherit pub_methods_classFunction"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classFunctionTime"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classFunctionTime')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classFunctionTime.html">FunctionTime</a></td></tr>
<tr class="memitem:a3f2f7f422c9c12cdf796c2f19b561b88 inherit pub_methods_classFunctionTime"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionTime.html#a3f2f7f422c9c12cdf796c2f19b561b88">FunctionTime</a> (const <a class="el" href="classdouble.html">double</a> initial_time=0.0)</td></tr>
<tr class="separator:a3f2f7f422c9c12cdf796c2f19b561b88 inherit pub_methods_classFunctionTime"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a340b97bb3f66db10515a97fcc87b01ea inherit pub_methods_classFunctionTime"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionTime.html#a340b97bb3f66db10515a97fcc87b01ea">~FunctionTime</a> ()</td></tr>
<tr class="separator:a340b97bb3f66db10515a97fcc87b01ea inherit pub_methods_classFunctionTime"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a47376558f29dbcd7841300429a5071 inherit pub_methods_classFunctionTime"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionTime.html#a8a47376558f29dbcd7841300429a5071">get_time</a> () const </td></tr>
<tr class="separator:a8a47376558f29dbcd7841300429a5071 inherit pub_methods_classFunctionTime"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07df154db543f0e641491763cc2fdcf4 inherit pub_methods_classFunctionTime"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionTime.html#a07df154db543f0e641491763cc2fdcf4">set_time</a> (const <a class="el" href="classdouble.html">double</a> new_time)</td></tr>
<tr class="separator:a07df154db543f0e641491763cc2fdcf4 inherit pub_methods_classFunctionTime"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71d5c299a154a6ab65e8006fea2424c6 inherit pub_methods_classFunctionTime"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionTime.html#a71d5c299a154a6ab65e8006fea2424c6">advance_time</a> (const <a class="el" href="classdouble.html">double</a> delta_t)</td></tr>
<tr class="separator:a71d5c299a154a6ab65e8006fea2424c6 inherit pub_methods_classFunctionTime"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSubscriptor"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSubscriptor')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSubscriptor.html">Subscriptor</a></td></tr>
<tr class="memitem:ae5541017c0966b0af345db75895106f2 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#ae5541017c0966b0af345db75895106f2">Subscriptor</a> ()</td></tr>
<tr class="separator:ae5541017c0966b0af345db75895106f2 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367fce3122075f05f168d14f114b4c65 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a367fce3122075f05f168d14f114b4c65">Subscriptor</a> (const <a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;)</td></tr>
<tr class="separator:a367fce3122075f05f168d14f114b4c65 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c6c557e06110d2127fa6459119e94af inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a6c6c557e06110d2127fa6459119e94af">~Subscriptor</a> ()</td></tr>
<tr class="separator:a6c6c557e06110d2127fa6459119e94af inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24ee69d4b3cf9690d1208b2443cbbb80 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a24ee69d4b3cf9690d1208b2443cbbb80">operator=</a> (const <a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;)</td></tr>
<tr class="separator:a24ee69d4b3cf9690d1208b2443cbbb80 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3422499827ecd52f1d12d65eb6cc3125 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a3422499827ecd52f1d12d65eb6cc3125">subscribe</a> (const char *identifier=0) const </td></tr>
<tr class="separator:a3422499827ecd52f1d12d65eb6cc3125 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b4839b1cffc18781144ede1744b35ea inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a2b4839b1cffc18781144ede1744b35ea">unsubscribe</a> (const char *identifier=0) const </td></tr>
<tr class="separator:a2b4839b1cffc18781144ede1744b35ea inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b45274c8e1936bff024df01d618e86f inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a7b45274c8e1936bff024df01d618e86f">n_subscriptions</a> () const </td></tr>
<tr class="separator:a7b45274c8e1936bff024df01d618e86f inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbbc5f845063b1f23223b7ac96e89e13 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#adbbc5f845063b1f23223b7ac96e89e13">list_subscribers</a> () const </td></tr>
<tr class="separator:adbbc5f845063b1f23223b7ac96e89e13 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2f0251d20c6a5295024de3b2e9b4359 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac2f0251d20c6a5295024de3b2e9b4359">DeclException3</a> (ExcInUse, <a class="el" href="classint.html">int</a>, char *, std::string &amp;,&lt;&lt; &quot;Object of class &quot;&lt;&lt; arg2&lt;&lt; &quot; is still used by &quot;&lt;&lt; arg1&lt;&lt; &quot; other objects.\n&quot;&lt;&lt; &quot;(Additional information: &quot;&lt;&lt; arg3&lt;&lt; &quot;)\n&quot;&lt;&lt; &quot;Note the entry in the Frequently Asked Questions of &quot;&lt;&lt; &quot;deal.II (linked to from http://www.dealii.org/) for &quot;&lt;&lt; &quot;more information on what this error means.&quot;)</td></tr>
<tr class="separator:gac2f0251d20c6a5295024de3b2e9b4359 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e000d9ce953da6afe4bbbaca4397344 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga9e000d9ce953da6afe4bbbaca4397344">DeclException2</a> (ExcNoSubscriber, char *, char *,&lt;&lt; &quot;No subscriber with identifier \&quot;&quot;&lt;&lt; arg2&lt;&lt; &quot;\&quot; did <a class="el" href="classSubscriptor.html#a3422499827ecd52f1d12d65eb6cc3125">subscribe</a> to this object of class &quot;&lt;&lt; arg1)</td></tr>
<tr class="separator:ga9e000d9ce953da6afe4bbbaca4397344 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38 inherit pub_methods_classSubscriptor"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38 inherit pub_methods_classSubscriptor"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:a68efd17a8330ab676d9cd711029b0f38 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:a72b8943b6f75f87636031f3efbfea1a9"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="classThreads_1_1ThreadLocalStorage.html">Threads::ThreadLocalStorage</a><br class="typebreak"/>
&lt; typename <br class="typebreak"/>
DH::active_cell_iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#a72b8943b6f75f87636031f3efbfea1a9">cell_hint_t</a></td></tr>
<tr class="separator:a72b8943b6f75f87636031f3efbfea1a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a7ce30ab1d1c46b3010cb24bc674ce3c7"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#a7ce30ab1d1c46b3010cb24bc674ce3c7">get_reference_coordinates</a> (const typename DH::active_cell_iterator &amp;cell, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;point) const </td></tr>
<tr class="separator:a7ce30ab1d1c46b3010cb24bc674ce3c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a5b72e6ff1462fbfd15ce22b1f111ca6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSmartPointer.html">SmartPointer</a>&lt; const DH, <br class="typebreak"/>
<a class="el" href="classFunctions_1_1FEFieldFunction.html">FEFieldFunction</a>&lt; dim, DH, <br class="typebreak"/>
VECTOR &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#a5b72e6ff1462fbfd15ce22b1f111ca6b">dh</a></td></tr>
<tr class="separator:a5b72e6ff1462fbfd15ce22b1f111ca6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2f2f7b1ab6421d4c63ded3468d2b36e"><td class="memItemLeft" align="right" valign="top">const VECTOR &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#ab2f2f7b1ab6421d4c63ded3468d2b36e">data_vector</a></td></tr>
<tr class="separator:ab2f2f7b1ab6421d4c63ded3468d2b36e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d702d2e6ecac6e645921beaf3540723"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#a1d702d2e6ecac6e645921beaf3540723">mapping</a></td></tr>
<tr class="separator:a1d702d2e6ecac6e645921beaf3540723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26456407ff664bf8fff7a1be0ef2b9ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFunctions_1_1FEFieldFunction.html#a72b8943b6f75f87636031f3efbfea1a9">cell_hint_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#a26456407ff664bf8fff7a1be0ef2b9ad">cell_hint</a></td></tr>
<tr class="separator:a26456407ff664bf8fff7a1be0ef2b9ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a014430d1362fc7c872eb16b5d8b19067"><td class="memItemLeft" align="right" valign="top">const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#a014430d1362fc7c872eb16b5d8b19067">n_components</a></td></tr>
<tr class="separator:a014430d1362fc7c872eb16b5d8b19067"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_attribs_classFunction"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classFunction')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classFunction.html">Function&lt; dim &gt;</a></td></tr>
<tr class="memitem:a22de55d2cbd6696fd0274a626614e31a inherit pub_attribs_classFunction"><td class="memItemLeft" align="right" valign="top">const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a22de55d2cbd6696fd0274a626614e31a">n_components</a></td></tr>
<tr class="separator:a22de55d2cbd6696fd0274a626614e31a inherit pub_attribs_classFunction"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_attribs_classFunction"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classFunction')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="classFunction.html">Function&lt; dim &gt;</a></td></tr>
<tr class="memitem:a92dba1a812f73bc2126c4a1711e171f2 inherit pub_static_attribs_classFunction"><td class="memItemLeft" align="right" valign="top">static const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a92dba1a812f73bc2126c4a1711e171f2">dimension</a></td></tr>
<tr class="separator:a92dba1a812f73bc2126c4a1711e171f2 inherit pub_static_attribs_classFunction"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int dim, typename DH = DoFHandler&lt;dim&gt;, typename VECTOR = Vector&lt;double&gt;&gt;<br/>
class Functions::FEFieldFunction&lt; dim, DH, VECTOR &gt;</h3>

<p>This is an interpolation function for the given dof handler and the given solution vector. The points at which this function can be evaluated MUST be inside the domain of the dof handler, but except from this, no other requirement is given. This function is rather slow, as it needs to construct a quadrature object for the point (or set of points) where you want to evaluate your finite element function. In order to do so, it needs to find out where the points lie.</p>
<p>If you know in advance in which cell your points lie, you can accelerate things a bit, by calling set_active_cell before asking for values or gradients of the function. If you don't do this, and your points don't lie in the cell that is currently stored, the function GridTools::find_cell_around_point is called to find out where the point is. You can specify an optional mapping to use when looking for points in the grid. If you don't do so, this function uses a Q1 mapping.</p>
<p>Once the <a class="el" href="classFunctions_1_1FEFieldFunction.html">FEFieldFunction</a> knows where the points lie, it creates a quadrature formula for those points, and calls <a class="el" href="classFEValuesBase.html#a884144525a19d80f4e20b4e509c9132b">FEValues::get_function_values</a> or <a class="el" href="classFEValuesBase.html#a393b58da5e9a60d09e1df40a71c96757">FEValues::get_function_grads</a> with the given quadrature points.</p>
<p>If you only need the quadrature points but not the values of the finite element function (you might want this for the adjoint interpolation), you can also use the function <code>compute_point_locations</code> alone.</p>
<p>An example of how to use this function is the following:</p>
<div class="fragment"><div class="line"><span class="comment">// Generate two triangulations</span></div>
<div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> tria_1;</div>
<div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> tria_2;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Read the triangulations from files, or build them up, or get</span></div>
<div class="line"><span class="comment">// them from some place...  Assume that tria_2 is *entirely*</span></div>
<div class="line"><span class="comment">// included in tria_1</span></div>
<div class="line">...</div>
<div class="line"></div>
<div class="line"><span class="comment">// Associate a dofhandler and a solution to the first</span></div>
<div class="line"><span class="comment">// triangulation</span></div>
<div class="line">DoFHandler&lt;dim&gt; dh1(tria_1);</div>
<div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a> solution_1;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Do the same with the second</span></div>
<div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dh2;</div>
<div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a> solution_2;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Setup the system, assemble matrices, solve problems and get the</span></div>
<div class="line"><span class="comment">// nobel prize on the first domain...</span></div>
<div class="line">...</div>
<div class="line"></div>
<div class="line"><span class="comment">// Now project it to the second domain</span></div>
<div class="line">FEFieldFunction&lt;dim&gt; fe_function_1 (dh_1, solution_1);</div>
<div class="line"><a class="code" href="namespaceVectorTools.html#aef011bd8868e6f8ce1309cf76d34c68b">VectorTools::project</a>(dh_2, constraints_2, quad, fe_function_1, solution_2);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Or interpolate it...</span></div>
<div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a> solution_3;</div>
<div class="line"><a class="code" href="namespaceVectorTools.html#a87efdd37923f76e54015909cb373c8e1">VectorTools::interpolate</a>(dh_2, fe_function_1, solution_3);</div>
</div><!-- fragment --><p>The snippet of code above will work assuming that the second triangulation is entirely included in the first one.</p>
<p><a class="el" href="classFunctions_1_1FEFieldFunction.html">FEFieldFunction</a> is designed to be an easy way to get the results of your computations across different, possibly non matching, grids. No knowledge of the location of the points is assumed in this class, which makes it rely entirely on the <a class="el" href="namespaceGridTools.html#a5f56d59cca64a6e64d1efe05f80ee606">GridTools::find_active_cell_around_point</a> utility for its job. However the class can be fed an "educated guess" of where the points that will be computed actually are by using the <a class="el" href="classFunctions_1_1FEFieldFunction.html#a7170e1661d3295432cf6abd0eac7a825">FEFieldFunction::set_active_cell</a> method, so if you have a smart way to tell where your points are, you will save a lot of computational time by letting this class know.</p>
<h3>Using <a class="el" href="classFunctions_1_1FEFieldFunction.html">FEFieldFunction</a> with <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a></h3>
<p>When using this class with a parallel distributed triangulation object and evaluating the solution at a particular point, not every processor will own the cell at which the solution is evaluated. Rather, it may be that the cell in which this point is found is in fact a ghost or artificial cell (see <a class="el" href="DEALGlossary.html#GlossArtificialCell">GlossArtificialCell</a> and <a class="el" href="DEALGlossary.html#GlossGhostCell">GlossGhostCell</a>). If the cell is artificial, we have no access to the solution there and functions that evaluate the solution at such a point will trigger an exception of type FEFieldFunction::ExcPointNotAvailableHere. The same kind of exception will also be produced if the cell is a ghost cell: On such cells, one could in principle evaluate the solution, but it becomes easier if we do not allow to do so because then there is exactly one processor in a parallel distributed computation that can indeed evaluate the solution. Consequently, it is clear which processor is responsible for producing output if the point evaluation is done as a postprocessing step.</p>
<p>To deal with this situation, you will want to use code as follows when, for example, evaluating the solution at the origin (here using a parallel <a class="el" href="namespaceTrilinosWrappers.html">TrilinosWrappers</a> vector to hold the solution): </p>
<div class="fragment"><div class="line"><a class="code" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction&lt;dim,DoFHandler&lt;dim&gt;</a>,<a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a>&gt;</div>
<div class="line">  solution_function (dof_handler, solution);</div>
<div class="line"><a class="code" href="classPoint.html">Point&lt;dim&gt;</a> origin = <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>();</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">double</span> solution_at_origin;</div>
<div class="line"><span class="keywordtype">bool</span>   point_found = <span class="keyword">true</span>;</div>
<div class="line"><span class="keywordflow">try</span></div>
<div class="line">  {</div>
<div class="line">    solution_at_origin = solution_function.value (origin);</div>
<div class="line">  }</div>
<div class="line"><span class="keywordflow">catch</span> (<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt;dim,<a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>,<a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a>&gt;::ExcPointNotAvailableHere &amp;)</div>
<div class="line">  {</div>
<div class="line">    point_found = <span class="keyword">false</span>;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">if</span> (point_found == <span class="keyword">true</span>)</div>
<div class="line">  ...do something...;</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>To C++, <code>Functions::FEFieldFunction&lt;dim&gt;::ExcPointNotAvailableHere</code> and <code><a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt;dim,<a class="el" href="classhp_1_1DoFHandler.html">DoFHandler&lt;dim&gt;</a>,<a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a>&gt;::ExcPointNotAvailableHere</code> are distinct types. You need to make sure that the type of the exception you catch matches the type of the object that throws it, as shown in the example above.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Luca Heltai, 2006, Markus Buerg, 2012, Wolfgang Bangerth, 2013 </dd></dl>

<p>Definition at line <a class="el" href="fe__field__function_8h_source.html#l00173">173</a> of file <a class="el" href="fe__field__function_8h_source.html">fe_field_function.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a72b8943b6f75f87636031f3efbfea1a9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DH  = DoFHandler&lt;dim&gt;, typename VECTOR  = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classThreads_1_1ThreadLocalStorage.html">Threads::ThreadLocalStorage</a>&lt;typename DH::active_cell_iterator &gt; <a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, DH, VECTOR &gt;::<a class="el" href="classFunctions_1_1FEFieldFunction.html#a72b8943b6f75f87636031f3efbfea1a9">cell_hint_t</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Typedef holding the local cell_hint. </p>

<p>Definition at line <a class="el" href="fe__field__function_8h_source.html#l00500">500</a> of file <a class="el" href="fe__field__function_8h_source.html">fe_field_function.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ac7f1d91d9b5d816bb5221faf2458e33b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DH , typename VECTOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, DH, VECTOR &gt;::<a class="el" href="classFunctions_1_1FEFieldFunction.html">FEFieldFunction</a> </td>
          <td>(</td>
          <td class="paramtype">const DH &amp;&#160;</td>
          <td class="paramname"><em>dh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VECTOR &amp;&#160;</td>
          <td class="paramname"><em>data_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em> = <code><a class="el" href="structStaticMappingQ1.html">StaticMappingQ1</a>&lt;dim&gt;::<a class="el" href="classFunctions_1_1FEFieldFunction.html#a1d702d2e6ecac6e645921beaf3540723">mapping</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct a vector function. A smart pointers is stored to the dof handler, so you have to make sure that it make sense for the entire lifetime of this object. The number of components of this functions is equal to the number of components of the finite element object. If a mapping is specified, that is what is used to find out where the points lay. Otherwise the standard Q1 mapping is used. </p>

<p>Definition at line <a class="el" href="fe__field__function_8templates_8h_source.html#l00035">35</a> of file <a class="el" href="fe__field__function_8templates_8h_source.html">fe_field_function.templates.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a7170e1661d3295432cf6abd0eac7a825"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DH , typename VECTOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, DH, VECTOR &gt;::set_active_cell </td>
          <td>(</td>
          <td class="paramtype">const typename DH::active_cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>newcell</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the current cell. If you know in advance where your points lie, you can tell this object by calling this function. This will speed things up a little. </p>

<p>Definition at line <a class="el" href="fe__field__function_8templates_8h_source.html#l00053">53</a> of file <a class="el" href="fe__field__function_8templates_8h_source.html">fe_field_function.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae80e2860fb6eb268524d7ca135e111a7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DH , typename VECTOR &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, DH, VECTOR &gt;::vector_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get one vector value at the given point. It is inefficient to use single points. If you need more than one at a time, use the <a class="el" href="classFunctions_1_1FEFieldFunction.html#adec1f9209ba366c375fcc5f67406f49d">vector_value_list()</a> function. For efficiency reasons, it is better if all the points lie on the same cell. This is not mandatory, however it does speed things up.</p>
<dl class="section note"><dt>Note</dt><dd>When using this function on a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> you may get an exception when trying to evaluate the solution at a point that does not lie in a locally owned cell (see <a class="el" href="DEALGlossary.html#GlossLocallyOwnedCell">GlossLocallyOwnedCell</a>). See the section in the general documentation of this class for more information. </dd></dl>

<p>Reimplemented from <a class="el" href="classFunction.html#a1fa27ec3204c0929a0b33ae34a97ef8f">Function&lt; dim &gt;</a>.</p>

<p>Definition at line <a class="el" href="fe__field__function_8templates_8h_source.html#l00061">61</a> of file <a class="el" href="fe__field__function_8templates_8h_source.html">fe_field_function.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2ecdc273606ab64d0a17d00118cf46e9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DH , typename VECTOR &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> <a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, DH, VECTOR &gt;::value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the value of the function at the given point. Unless there is only one component (i.e. the function is scalar), you should state the component you want to have evaluated; it defaults to zero, i.e. the first component. It is inefficient to use single points. If you need more than one at a time, use the vector_value_list function. For efficiency reasons, it is better if all the points lie on the same cell. This is not mandatory, however it does speed things up.</p>
<dl class="section note"><dt>Note</dt><dd>When using this function on a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> you may get an exception when trying to evaluate the solution at a point that does not lie in a locally owned cell (see <a class="el" href="DEALGlossary.html#GlossLocallyOwnedCell">GlossLocallyOwnedCell</a>). See the section in the general documentation of this class for more information. </dd></dl>

<p>Reimplemented from <a class="el" href="classFunction.html#a9783cc12b6b205d4019379b0cc6f3956">Function&lt; dim &gt;</a>.</p>

<p>Definition at line <a class="el" href="fe__field__function_8templates_8h_source.html#l00099">99</a> of file <a class="el" href="fe__field__function_8templates_8h_source.html">fe_field_function.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4acaac93f6a797a25b67e16d5de15a82"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DH , typename VECTOR &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, DH, VECTOR &gt;::value_list </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set <code>values</code> to the point values of the specified component of the function at the <code>points</code>. It is assumed that <code>values</code> already has the right size, i.e. the same size as the points array. This is rather efficient if all the points lie on the same cell. If this is not the case, things may slow down a bit.</p>
<dl class="section note"><dt>Note</dt><dd>When using this function on a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> you may get an exception when trying to evaluate the solution at a point that does not lie in a locally owned cell (see <a class="el" href="DEALGlossary.html#GlossLocallyOwnedCell">GlossLocallyOwnedCell</a>). See the section in the general documentation of this class for more information. </dd></dl>

<p>Reimplemented from <a class="el" href="classFunction.html#af6f1aceeeb499ff07d828df250f4f3b2">Function&lt; dim &gt;</a>.</p>

<p>Definition at line <a class="el" href="fe__field__function_8templates_8h_source.html#l00261">261</a> of file <a class="el" href="fe__field__function_8templates_8h_source.html">fe_field_function.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="adec1f9209ba366c375fcc5f67406f49d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DH , typename VECTOR &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, DH, VECTOR &gt;::vector_value_list </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set <code>values</code> to the point values of the function at the <code>points</code>. It is assumed that <code>values</code> already has the right size, i.e. the same size as the points array. This is rather efficient if all the points lie on the same cell. If this is not the case, things may slow down a bit.</p>
<dl class="section note"><dt>Note</dt><dd>When using this function on a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> you may get an exception when trying to evaluate the solution at a point that does not lie in a locally owned cell (see <a class="el" href="DEALGlossary.html#GlossLocallyOwnedCell">GlossLocallyOwnedCell</a>). See the section in the general documentation of this class for more information. </dd></dl>

<p>Reimplemented from <a class="el" href="classFunction.html#a97867379f17a1eacb7e274a2b626ade3">Function&lt; dim &gt;</a>.</p>

<p>Definition at line <a class="el" href="fe__field__function_8templates_8h_source.html#l00217">217</a> of file <a class="el" href="fe__field__function_8templates_8h_source.html">fe_field_function.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac5bbeb2f0e6c107dea851aa433df88bc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DH , typename VECTOR &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, DH, VECTOR &gt;::vector_gradient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>gradients</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the gradient of all components of the function at the given point. It is inefficient to use single points. If you need more than one at a time, use the vector_value_list function. For efficiency reasons, it is better if all the points lie on the same cell. This is not mandatory, however it does speed things up.</p>
<dl class="section note"><dt>Note</dt><dd>When using this function on a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> you may get an exception when trying to evaluate the solution at a point that does not lie in a locally owned cell (see <a class="el" href="DEALGlossary.html#GlossLocallyOwnedCell">GlossLocallyOwnedCell</a>). See the section in the general documentation of this class for more information. </dd></dl>

<p>Reimplemented from <a class="el" href="classFunction.html#ab083c97c4b8e03ef1cc81fcf2b1cce45">Function&lt; dim &gt;</a>.</p>

<p>Definition at line <a class="el" href="fe__field__function_8templates_8h_source.html#l00112">112</a> of file <a class="el" href="fe__field__function_8templates_8h_source.html">fe_field_function.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae86b30c1f2d8902528f9c87eedfeddd1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DH , typename VECTOR &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt; <a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, DH, VECTOR &gt;::gradient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the gradient of the specified component of the function at the given point. It is inefficient to use single points. If you need more than one at a time, use the vector_value_list function. For efficiency reasons, it is better if all the points lie on the same cell. This is not mandatory, however it does speed things up.</p>
<dl class="section note"><dt>Note</dt><dd>When using this function on a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> you may get an exception when trying to evaluate the solution at a point that does not lie in a locally owned cell (see <a class="el" href="DEALGlossary.html#GlossLocallyOwnedCell">GlossLocallyOwnedCell</a>). See the section in the general documentation of this class for more information. </dd></dl>

<p>Reimplemented from <a class="el" href="classFunction.html#a3d3c4a52286afb38ccfd677cfaf12bf4">Function&lt; dim &gt;</a>.</p>

<p>Definition at line <a class="el" href="fe__field__function_8templates_8h_source.html#l00152">152</a> of file <a class="el" href="fe__field__function_8templates_8h_source.html">fe_field_function.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a53c5306bad5cde6cfc4228873f3fcf14"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DH , typename VECTOR &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, DH, VECTOR &gt;::vector_gradient_list </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>gradients</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the gradient of all components of the function at all the given points. This is rather efficient if all the points lie on the same cell. If this is not the case, things may slow down a bit.</p>
<dl class="section note"><dt>Note</dt><dd>When using this function on a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> you may get an exception when trying to evaluate the solution at a point that does not lie in a locally owned cell (see <a class="el" href="DEALGlossary.html#GlossLocallyOwnedCell">GlossLocallyOwnedCell</a>). See the section in the general documentation of this class for more information. </dd></dl>

<p>Reimplemented from <a class="el" href="classFunction.html#aadf4d74a5366445dfc1330ca8007a262">Function&lt; dim &gt;</a>.</p>

<p>Definition at line <a class="el" href="fe__field__function_8templates_8h_source.html#l00278">278</a> of file <a class="el" href="fe__field__function_8templates_8h_source.html">fe_field_function.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a27b1085bc29af0918324363b4e712a79"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DH , typename VECTOR &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, DH, VECTOR &gt;::gradient_list </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>gradients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the gradient of the specified component of the function at all the given points. This is rather efficient if all the points lie on the same cell. If this is not the case, things may slow down a bit.</p>
<dl class="section note"><dt>Note</dt><dd>When using this function on a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> you may get an exception when trying to evaluate the solution at a point that does not lie in a locally owned cell (see <a class="el" href="DEALGlossary.html#GlossLocallyOwnedCell">GlossLocallyOwnedCell</a>). See the section in the general documentation of this class for more information. </dd></dl>

<p>Reimplemented from <a class="el" href="classFunction.html#a1320c32407e552ddd0c778f78a502439">Function&lt; dim &gt;</a>.</p>

<p>Definition at line <a class="el" href="fe__field__function_8templates_8h_source.html#l00322">322</a> of file <a class="el" href="fe__field__function_8templates_8h_source.html">fe_field_function.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9fdc0af70dcf85529549736b277b254d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DH , typename VECTOR &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> <a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, DH, VECTOR &gt;::laplacian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the Laplacian of a given component at point <code>p</code>.</p>
<dl class="section note"><dt>Note</dt><dd>When using this function on a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> you may get an exception when trying to evaluate the solution at a point that does not lie in a locally owned cell (see <a class="el" href="DEALGlossary.html#GlossLocallyOwnedCell">GlossLocallyOwnedCell</a>). See the section in the general documentation of this class for more information. </dd></dl>

<p>Reimplemented from <a class="el" href="classFunction.html#af199eab1f93f2bdded9f68811230dd00">Function&lt; dim &gt;</a>.</p>

<p>Definition at line <a class="el" href="fe__field__function_8templates_8h_source.html#l00203">203</a> of file <a class="el" href="fe__field__function_8templates_8h_source.html">fe_field_function.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab241cd8065b0294b3a94ad829214ed1a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DH , typename VECTOR &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, DH, VECTOR &gt;::vector_laplacian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the Laplacian of all components at point <code>p</code> and store them in <code>values</code>.</p>
<dl class="section note"><dt>Note</dt><dd>When using this function on a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> you may get an exception when trying to evaluate the solution at a point that does not lie in a locally owned cell (see <a class="el" href="DEALGlossary.html#GlossLocallyOwnedCell">GlossLocallyOwnedCell</a>). See the section in the general documentation of this class for more information. </dd></dl>

<p>Reimplemented from <a class="el" href="classFunction.html#ae9128f1c3133751d215513c0c37b9e24">Function&lt; dim &gt;</a>.</p>

<p>Definition at line <a class="el" href="fe__field__function_8templates_8h_source.html#l00165">165</a> of file <a class="el" href="fe__field__function_8templates_8h_source.html">fe_field_function.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5d6954141e889217367710753ab0c6c9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DH , typename VECTOR &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, DH, VECTOR &gt;::laplacian_list </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the Laplacian of one component at a set of points.</p>
<dl class="section note"><dt>Note</dt><dd>When using this function on a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> you may get an exception when trying to evaluate the solution at a point that does not lie in a locally owned cell (see <a class="el" href="DEALGlossary.html#GlossLocallyOwnedCell">GlossLocallyOwnedCell</a>). See the section in the general documentation of this class for more information. </dd></dl>

<p>Reimplemented from <a class="el" href="classFunction.html#a192e6c816980878d387a582487e6cd55">Function&lt; dim &gt;</a>.</p>

<p>Definition at line <a class="el" href="fe__field__function_8templates_8h_source.html#l00381">381</a> of file <a class="el" href="fe__field__function_8templates_8h_source.html">fe_field_function.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6b975c809df59abf50e06fbc4f6b49ed"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DH , typename VECTOR &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, DH, VECTOR &gt;::vector_laplacian_list </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the Laplacians of all components at a set of points.</p>
<dl class="section note"><dt>Note</dt><dd>When using this function on a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> you may get an exception when trying to evaluate the solution at a point that does not lie in a locally owned cell (see <a class="el" href="DEALGlossary.html#GlossLocallyOwnedCell">GlossLocallyOwnedCell</a>). See the section in the general documentation of this class for more information. </dd></dl>

<p>Reimplemented from <a class="el" href="classFunction.html#a606b05b313caec6ae0f99f80666ecdfe">Function&lt; dim &gt;</a>.</p>

<p>Definition at line <a class="el" href="fe__field__function_8templates_8h_source.html#l00339">339</a> of file <a class="el" href="fe__field__function_8templates_8h_source.html">fe_field_function.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3147cf31104135184553d8338820cdca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DH , typename VECTOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, DH, VECTOR &gt;::compute_point_locations </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; typename DH::active_cell_iterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>qpoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>maps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create quadrature rules. This function groups the points into blocks that live in the same cell, and fills up three vectors: <code>cells</code>, <code>qpoints</code> and <code>maps</code>. The first is a list of the cells that contain the points, the second is a list of quadrature points matching each cell of the first list, and the third contains the index of the given quadrature points, i.e., <code>points</code>[maps[3][4]] ends up as the 5th quadrature point in the 4th cell. This is where optimization would help. This function returns the number of cells that contain the given set of points. </p>

<p>Definition at line <a class="el" href="fe__field__function_8templates_8h_source.html#l00397">397</a> of file <a class="el" href="fe__field__function_8templates_8h_source.html">fe_field_function.templates.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab53e18f14c938c9ff45d68381313e7d3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DH  = DoFHandler&lt;dim&gt;, typename VECTOR  = Vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, DH, VECTOR &gt;::DeclException0 </td>
          <td>(</td>
          <td class="paramtype">ExcPointNotAvailableHere&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exception </p>

</div>
</div>
<a class="anchor" id="a7ce30ab1d1c46b3010cb24bc674ce3c7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DH , typename VECTOR &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; <a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, DH, VECTOR &gt;::get_reference_coordinates </td>
          <td>(</td>
          <td class="paramtype">const typename DH::active_cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a cell, return the reference coordinates of the given point within this cell if it indeed lies within the cell. Otherwise return an uninitialized boost::optional object. </p>

<p>Definition at line <a class="el" href="fe__field__function_8templates_8h_source.html#l00560">560</a> of file <a class="el" href="fe__field__function_8templates_8h_source.html">fe_field_function.templates.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a5b72e6ff1462fbfd15ce22b1f111ca6b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DH  = DoFHandler&lt;dim&gt;, typename VECTOR  = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSmartPointer.html">SmartPointer</a>&lt;const DH,<a class="el" href="classFunctions_1_1FEFieldFunction.html">FEFieldFunction</a>&lt;dim, DH, VECTOR&gt; &gt; <a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, DH, VECTOR &gt;::dh</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pointer to the dof handler. </p>

<p>Definition at line <a class="el" href="fe__field__function_8h_source.html#l00505">505</a> of file <a class="el" href="fe__field__function_8h_source.html">fe_field_function.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab2f2f7b1ab6421d4c63ded3468d2b36e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DH  = DoFHandler&lt;dim&gt;, typename VECTOR  = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const VECTOR&amp; <a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, DH, VECTOR &gt;::data_vector</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A reference to the actual data vector. </p>

<p>Definition at line <a class="el" href="fe__field__function_8h_source.html#l00511">511</a> of file <a class="el" href="fe__field__function_8h_source.html">fe_field_function.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1d702d2e6ecac6e645921beaf3540723"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DH  = DoFHandler&lt;dim&gt;, typename VECTOR  = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classMapping.html">Mapping</a>&lt;dim&gt;&amp; <a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, DH, VECTOR &gt;::mapping</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A reference to the mapping being used. </p>

<p>Definition at line <a class="el" href="fe__field__function_8h_source.html#l00517">517</a> of file <a class="el" href="fe__field__function_8h_source.html">fe_field_function.h</a>.</p>

</div>
</div>
<a class="anchor" id="a26456407ff664bf8fff7a1be0ef2b9ad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DH  = DoFHandler&lt;dim&gt;, typename VECTOR  = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFunctions_1_1FEFieldFunction.html#a72b8943b6f75f87636031f3efbfea1a9">cell_hint_t</a> <a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, DH, VECTOR &gt;::cell_hint</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The latest cell hint. </p>

<p>Definition at line <a class="el" href="fe__field__function_8h_source.html#l00522">522</a> of file <a class="el" href="fe__field__function_8h_source.html">fe_field_function.h</a>.</p>

</div>
</div>
<a class="anchor" id="a014430d1362fc7c872eb16b5d8b19067"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DH  = DoFHandler&lt;dim&gt;, typename VECTOR  = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, DH, VECTOR &gt;::n_components</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Store the number of components of this function. </p>

<p>Definition at line <a class="el" href="fe__field__function_8h_source.html#l00528">528</a> of file <a class="el" href="fe__field__function_8h_source.html">fe_field_function.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/deal.II/numerics/<a class="el" href="fe__field__function_8h_source.html">fe_field_function.h</a></li>
<li>include/deal.II/numerics/<a class="el" href="fe__field__function_8templates_8h_source.html">fe_field_function.templates.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jan 27 2014 15:27:23 for The deal.II Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
