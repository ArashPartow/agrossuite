<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>The deal.II Library: SymmetricTensor&lt; rank, dim, Number &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="http://www.dealii.org/deal.ico"></link>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2014 by the deal.II authors"></meta>
<meta name="deal.II-version" content="8.1.0"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 8.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classSymmetricTensor-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SymmetricTensor&lt; rank, dim, Number &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__geomprimitives.html">Geometric and other primitives</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac99c806b0335dedcf84555c6036cbe23"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#ac99c806b0335dedcf84555c6036cbe23">SymmetricTensor</a> ()</td></tr>
<tr class="separator:ac99c806b0335dedcf84555c6036cbe23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac247404bad39c53d36784c9a7ba0bea9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#ac247404bad39c53d36784c9a7ba0bea9">SymmetricTensor</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim, Number &gt; &amp;t)</td></tr>
<tr class="separator:ac247404bad39c53d36784c9a7ba0bea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e7430a4b6db7f4a693c5746989bc9e1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a2e7430a4b6db7f4a693c5746989bc9e1">SymmetricTensor</a> (const Number(&amp;array)[<a class="el" href="classSymmetricTensor.html#adf501ef6f23cafa2ff79081afbd8478d">n_independent_components</a>])</td></tr>
<tr class="separator:a2e7430a4b6db7f4a693c5746989bc9e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0894b81f393a60b5527154775876bdb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#af0894b81f393a60b5527154775876bdb">operator=</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a> &amp;)</td></tr>
<tr class="separator:af0894b81f393a60b5527154775876bdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b43fde5bed166fa6b874f17b9c0bcd7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a0b43fde5bed166fa6b874f17b9c0bcd7">operator=</a> (const Number d)</td></tr>
<tr class="separator:a0b43fde5bed166fa6b874f17b9c0bcd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89011fbde45c93fa529532401978ae86"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a89011fbde45c93fa529532401978ae86">operator Tensor&lt; rank, dim, Number &gt;</a> () const </td></tr>
<tr class="separator:a89011fbde45c93fa529532401978ae86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a365239caeaf67a66106d3f319d9bbe8a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a365239caeaf67a66106d3f319d9bbe8a">operator==</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a> &amp;) const </td></tr>
<tr class="separator:a365239caeaf67a66106d3f319d9bbe8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aa9f38c26b61e767b81cb1b6ace5ed1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a5aa9f38c26b61e767b81cb1b6ace5ed1">operator!=</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a> &amp;) const </td></tr>
<tr class="separator:a5aa9f38c26b61e767b81cb1b6ace5ed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab45163c855aefd59f7f9212d722c9b20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#ab45163c855aefd59f7f9212d722c9b20">operator+=</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a> &amp;)</td></tr>
<tr class="separator:ab45163c855aefd59f7f9212d722c9b20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefa612dcc57d5864a4907da43daf2c8a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#aefa612dcc57d5864a4907da43daf2c8a">operator-=</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a> &amp;)</td></tr>
<tr class="separator:aefa612dcc57d5864a4907da43daf2c8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add7f4b123906d410f427114a6bdf2c2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#add7f4b123906d410f427114a6bdf2c2f">operator*=</a> (const Number factor)</td></tr>
<tr class="separator:add7f4b123906d410f427114a6bdf2c2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0152c69661bf2f22ecd32de0d6fcde4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a0152c69661bf2f22ecd32de0d6fcde4d">operator/=</a> (const Number factor)</td></tr>
<tr class="separator:a0152c69661bf2f22ecd32de0d6fcde4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66554fde95f61d551fbd9461203111fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a66554fde95f61d551fbd9461203111fc">operator+</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a> &amp;s) const </td></tr>
<tr class="separator:a66554fde95f61d551fbd9461203111fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8dc3ff15bbd5afa8673fb70bf0702b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#ad8dc3ff15bbd5afa8673fb70bf0702b9">operator-</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a> &amp;s) const </td></tr>
<tr class="separator:ad8dc3ff15bbd5afa8673fb70bf0702b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a932dec1dd77d6af3aa82eda1b6709d7b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a932dec1dd77d6af3aa82eda1b6709d7b">operator-</a> () const </td></tr>
<tr class="separator:a932dec1dd77d6af3aa82eda1b6709d7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3586fe5da69c834e642026d1dc310c65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinternal_1_1SymmetricTensorAccessors_1_1double__contraction__result.html">internal::SymmetricTensorAccessors::double_contraction_result</a><br class="typebreak"/>
&lt; rank, 2, dim, Number &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a3586fe5da69c834e642026d1dc310c65">operator*</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; &amp;s) const </td></tr>
<tr class="separator:a3586fe5da69c834e642026d1dc310c65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a77ced8a1583b5674a61ca69a63e08d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinternal_1_1SymmetricTensorAccessors_1_1double__contraction__result.html">internal::SymmetricTensorAccessors::double_contraction_result</a><br class="typebreak"/>
&lt; rank, 4, dim, Number &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a4a77ced8a1583b5674a61ca69a63e08d">operator*</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 4, dim, Number &gt; &amp;s) const </td></tr>
<tr class="separator:a4a77ced8a1583b5674a61ca69a63e08d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ba0e3f4e7e25c558aa9e5665ce31954"><td class="memItemLeft" align="right" valign="top">Number &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a4ba0e3f4e7e25c558aa9e5665ce31954">operator()</a> (const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; rank &gt; &amp;indices)</td></tr>
<tr class="separator:a4ba0e3f4e7e25c558aa9e5665ce31954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82b80e639b6a5e1f438a3ae0823db41c"><td class="memItemLeft" align="right" valign="top">Number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a82b80e639b6a5e1f438a3ae0823db41c">operator()</a> (const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; rank &gt; &amp;indices) const </td></tr>
<tr class="separator:a82b80e639b6a5e1f438a3ae0823db41c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a031484b067a1e21d4c4f2657d845bbc8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classinternal_1_1SymmetricTensorAccessors_1_1Accessor.html">internal::SymmetricTensorAccessors::Accessor</a><br class="typebreak"/>
&lt; rank, dim, true, rank-1, <br class="typebreak"/>
Number &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a031484b067a1e21d4c4f2657d845bbc8">operator[]</a> (const unsigned <a class="el" href="classint.html">int</a> row) const </td></tr>
<tr class="separator:a031484b067a1e21d4c4f2657d845bbc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eb8946b08212f67358f239d415426dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classinternal_1_1SymmetricTensorAccessors_1_1Accessor.html">internal::SymmetricTensorAccessors::Accessor</a><br class="typebreak"/>
&lt; rank, dim, false, rank-1, <br class="typebreak"/>
Number &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a1eb8946b08212f67358f239d415426dd">operator[]</a> (const unsigned <a class="el" href="classint.html">int</a> row)</td></tr>
<tr class="separator:a1eb8946b08212f67358f239d415426dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6608365f38d5efa68cdc251de1736ad6"><td class="memItemLeft" align="right" valign="top">Number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a6608365f38d5efa68cdc251de1736ad6">operator[]</a> (const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; rank &gt; &amp;indices) const </td></tr>
<tr class="separator:a6608365f38d5efa68cdc251de1736ad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ef258ef0eb5645e70834b88efe5da07"><td class="memItemLeft" align="right" valign="top">Number &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a9ef258ef0eb5645e70834b88efe5da07">operator[]</a> (const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; rank &gt; &amp;indices)</td></tr>
<tr class="separator:a9ef258ef0eb5645e70834b88efe5da07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab56769d0b6fed3ebba6f14ddec4de911"><td class="memItemLeft" align="right" valign="top">Number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#ab56769d0b6fed3ebba6f14ddec4de911">access_raw_entry</a> (const unsigned <a class="el" href="classint.html">int</a> unrolled_index) const </td></tr>
<tr class="separator:ab56769d0b6fed3ebba6f14ddec4de911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ee78bf76f6a50580dca65509efa7221"><td class="memItemLeft" align="right" valign="top">Number &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a0ee78bf76f6a50580dca65509efa7221">access_raw_entry</a> (const unsigned <a class="el" href="classint.html">int</a> unrolled_index)</td></tr>
<tr class="separator:a0ee78bf76f6a50580dca65509efa7221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cbba5df5d70fc66ab0b5fb959aea27e"><td class="memItemLeft" align="right" valign="top">Number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a2cbba5df5d70fc66ab0b5fb959aea27e">norm</a> () const </td></tr>
<tr class="separator:a2cbba5df5d70fc66ab0b5fb959aea27e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2428bd858f98bba9650c50786d068b48"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a2428bd858f98bba9650c50786d068b48">clear</a> ()</td></tr>
<tr class="separator:a2428bd858f98bba9650c50786d068b48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a867d6d5c07599504291c0f445f109337"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a867d6d5c07599504291c0f445f109337"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a867d6d5c07599504291c0f445f109337">serialize</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:a867d6d5c07599504291c0f445f109337"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a8a3806a78029858205695c5abb1d2f72"><td class="memItemLeft" align="right" valign="top">static unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a8a3806a78029858205695c5abb1d2f72">component_to_unrolled_index</a> (const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; rank &gt; &amp;indices)</td></tr>
<tr class="separator:a8a3806a78029858205695c5abb1d2f72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c052ca00daee61e07cec3b550bda6eb"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classTableIndices.html">TableIndices</a>&lt; rank &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a4c052ca00daee61e07cec3b550bda6eb">unrolled_to_component_indices</a> (const unsigned <a class="el" href="classint.html">int</a> i)</td></tr>
<tr class="separator:a4c052ca00daee61e07cec3b550bda6eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea74a460543343d71eeae935cb3e84a6"><td class="memItemLeft" align="right" valign="top">static std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#aea74a460543343d71eeae935cb3e84a6">memory_consumption</a> ()</td></tr>
<tr class="separator:aea74a460543343d71eeae935cb3e84a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a98c96e8433eaaeb52b2974829cf3c045"><td class="memItemLeft" align="right" valign="top">static const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a98c96e8433eaaeb52b2974829cf3c045">dimension</a> = dim</td></tr>
<tr class="separator:a98c96e8433eaaeb52b2974829cf3c045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf501ef6f23cafa2ff79081afbd8478d"><td class="memItemLeft" align="right" valign="top">static const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#adf501ef6f23cafa2ff79081afbd8478d">n_independent_components</a></td></tr>
<tr class="separator:adf501ef6f23cafa2ff79081afbd8478d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:a3cc3454cb081cb37737473834976131f"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="structinternal_1_1SymmetricTensorAccessors_1_1StorageType.html">internal::SymmetricTensorAccessors::StorageType</a><br class="typebreak"/>
&lt; rank, dim, Number &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a3cc3454cb081cb37737473834976131f">base_tensor_descriptor</a></td></tr>
<tr class="separator:a3cc3454cb081cb37737473834976131f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e231d16733e592721dfbe3f9385594f"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
base_tensor_descriptor::base_tensor_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a6e231d16733e592721dfbe3f9385594f">base_tensor_type</a></td></tr>
<tr class="separator:a6e231d16733e592721dfbe3f9385594f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a948c91e036e4a6cc8bdd5ba93e25cf9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSymmetricTensor.html#a6e231d16733e592721dfbe3f9385594f">base_tensor_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a948c91e036e4a6cc8bdd5ba93e25cf9f">data</a></td></tr>
<tr class="separator:a948c91e036e4a6cc8bdd5ba93e25cf9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a3b037cceee7751ec3a9d533d43122274"><td class="memTemplParams" colspan="2">template&lt;int , int , typename &gt; </td></tr>
<tr class="memitem:a3b037cceee7751ec3a9d533d43122274"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a3b037cceee7751ec3a9d533d43122274">SymmetricTensor</a></td></tr>
<tr class="separator:a3b037cceee7751ec3a9d533d43122274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93463f125d9286950a6846cb2b0e6c1a"><td class="memTemplParams" colspan="2">template&lt;int dim2, typename Number2 &gt; </td></tr>
<tr class="memitem:a93463f125d9286950a6846cb2b0e6c1a"><td class="memTemplItemLeft" align="right" valign="top">Number2&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a93463f125d9286950a6846cb2b0e6c1a">trace</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim2, Number2 &gt; &amp;d)</td></tr>
<tr class="separator:a93463f125d9286950a6846cb2b0e6c1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe564bc1eba7236d9a6ec9f285be3cb5"><td class="memTemplParams" colspan="2"><a class="anchor" id="abe564bc1eba7236d9a6ec9f285be3cb5"></a>
template&lt;int dim2, typename Number2 &gt; </td></tr>
<tr class="memitem:abe564bc1eba7236d9a6ec9f285be3cb5"><td class="memTemplItemLeft" align="right" valign="top">Number2&#160;</td><td class="memTemplItemRight" valign="bottom"><b>determinant</b> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim2, Number2 &gt; &amp;t)</td></tr>
<tr class="separator:abe564bc1eba7236d9a6ec9f285be3cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1619fdb00036770ad49cf8cd5093913"><td class="memTemplParams" colspan="2"><a class="anchor" id="af1619fdb00036770ad49cf8cd5093913"></a>
template&lt;int dim2, typename Number2 &gt; </td></tr>
<tr class="memitem:af1619fdb00036770ad49cf8cd5093913"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim2, Number2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>deviator</b> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim2, Number2 &gt; &amp;t)</td></tr>
<tr class="separator:af1619fdb00036770ad49cf8cd5093913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b919d70d4c4c5c0dfc06435b0482621"><td class="memTemplParams" colspan="2">template&lt;int dim2, typename Number2 &gt; </td></tr>
<tr class="memitem:a9b919d70d4c4c5c0dfc06435b0482621"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim2, Number2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a9b919d70d4c4c5c0dfc06435b0482621">unit_symmetric_tensor</a> ()</td></tr>
<tr class="separator:a9b919d70d4c4c5c0dfc06435b0482621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab4e15937306e30da53a7b34147ac1f9"><td class="memTemplParams" colspan="2">template&lt;int dim2, typename Number2 &gt; </td></tr>
<tr class="memitem:aab4e15937306e30da53a7b34147ac1f9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 4, dim2, Number2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#aab4e15937306e30da53a7b34147ac1f9">deviator_tensor</a> ()</td></tr>
<tr class="separator:aab4e15937306e30da53a7b34147ac1f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d40eac7f1138a9018c41564f5712ee1"><td class="memTemplParams" colspan="2">template&lt;int dim2, typename Number2 &gt; </td></tr>
<tr class="memitem:a0d40eac7f1138a9018c41564f5712ee1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 4, dim2, Number2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a0d40eac7f1138a9018c41564f5712ee1">identity_tensor</a> ()</td></tr>
<tr class="separator:a0d40eac7f1138a9018c41564f5712ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe35f5c0468a65e53ab696d8c276cedf"><td class="memTemplParams" colspan="2"><a class="anchor" id="abe35f5c0468a65e53ab696d8c276cedf"></a>
template&lt;int dim2, typename Number2 &gt; </td></tr>
<tr class="memitem:abe35f5c0468a65e53ab696d8c276cedf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 4, dim2, Number2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>invert</b> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 4, dim2, Number2 &gt; &amp;)</td></tr>
<tr class="separator:abe35f5c0468a65e53ab696d8c276cedf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a31d48ca1d251a7a32db8b673e6010193"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number &gt; </td></tr>
<tr class="memitem:a31d48ca1d251a7a32db8b673e6010193"><td class="memTemplItemLeft" align="right" valign="top">Number&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a31d48ca1d251a7a32db8b673e6010193">determinant</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; &amp;t)</td></tr>
<tr class="separator:a31d48ca1d251a7a32db8b673e6010193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c8cae195023acc719527e04b65b156d"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number &gt; </td></tr>
<tr class="memitem:a7c8cae195023acc719527e04b65b156d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a7c8cae195023acc719527e04b65b156d">third_invariant</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; &amp;t)</td></tr>
<tr class="separator:a7c8cae195023acc719527e04b65b156d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05096e7bc18fa734eae3bd1a5f08138e"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number &gt; </td></tr>
<tr class="memitem:a05096e7bc18fa734eae3bd1a5f08138e"><td class="memTemplItemLeft" align="right" valign="top">Number&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a05096e7bc18fa734eae3bd1a5f08138e">trace</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; &amp;d)</td></tr>
<tr class="separator:a05096e7bc18fa734eae3bd1a5f08138e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8beb998db1792cd540f3a72b162adead"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number &gt; </td></tr>
<tr class="memitem:a8beb998db1792cd540f3a72b162adead"><td class="memTemplItemLeft" align="right" valign="top">Number&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a8beb998db1792cd540f3a72b162adead">first_invariant</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; &amp;t)</td></tr>
<tr class="separator:a8beb998db1792cd540f3a72b162adead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bbdfc57da6931de6a1757a0fa7ee982"><td class="memTemplParams" colspan="2">template&lt;typename Number &gt; </td></tr>
<tr class="memitem:a7bbdfc57da6931de6a1757a0fa7ee982"><td class="memTemplItemLeft" align="right" valign="top">Number&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a7bbdfc57da6931de6a1757a0fa7ee982">second_invariant</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 1, Number &gt; &amp;)</td></tr>
<tr class="separator:a7bbdfc57da6931de6a1757a0fa7ee982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af02b5f4e4a6385e770f20a43f2e70f17"><td class="memTemplParams" colspan="2">template&lt;typename Number &gt; </td></tr>
<tr class="memitem:af02b5f4e4a6385e770f20a43f2e70f17"><td class="memTemplItemLeft" align="right" valign="top">Number&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#af02b5f4e4a6385e770f20a43f2e70f17">second_invariant</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 2, Number &gt; &amp;t)</td></tr>
<tr class="separator:af02b5f4e4a6385e770f20a43f2e70f17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37621ebbca1ac8a5946a41d8947243ab"><td class="memTemplParams" colspan="2">template&lt;typename Number &gt; </td></tr>
<tr class="memitem:a37621ebbca1ac8a5946a41d8947243ab"><td class="memTemplItemLeft" align="right" valign="top">Number&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a37621ebbca1ac8a5946a41d8947243ab">second_invariant</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 3, Number &gt; &amp;t)</td></tr>
<tr class="separator:a37621ebbca1ac8a5946a41d8947243ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab424a468e166675a7f327f14fe94620c"><td class="memTemplParams" colspan="2">template&lt;int rank, int dim, typename Number &gt; </td></tr>
<tr class="memitem:ab424a468e166675a7f327f14fe94620c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, <br class="typebreak"/>
Number &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#ab424a468e166675a7f327f14fe94620c">transpose</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, Number &gt; &amp;t)</td></tr>
<tr class="separator:ab424a468e166675a7f327f14fe94620c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1ba0db3d146ea2d13dca05de9a42c74"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number &gt; </td></tr>
<tr class="memitem:aa1ba0db3d146ea2d13dca05de9a42c74"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#aa1ba0db3d146ea2d13dca05de9a42c74">deviator</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; &amp;t)</td></tr>
<tr class="separator:aa1ba0db3d146ea2d13dca05de9a42c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a8f423c6a539ce339132bfd7264891d"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number &gt; </td></tr>
<tr class="memitem:a7a8f423c6a539ce339132bfd7264891d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 4, dim, Number &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a7a8f423c6a539ce339132bfd7264891d">invert</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 4, dim, Number &gt; &amp;t)</td></tr>
<tr class="separator:a7a8f423c6a539ce339132bfd7264891d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8214de44ccf8237189c6216b09bd5a66"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a8214de44ccf8237189c6216b09bd5a66"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 4, 3, <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a8214de44ccf8237189c6216b09bd5a66">invert</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 4, 3, <a class="el" href="classdouble.html">double</a> &gt; &amp;t)</td></tr>
<tr class="separator:a8214de44ccf8237189c6216b09bd5a66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8e50332a8602d09d12091217f775bec"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number &gt; </td></tr>
<tr class="memitem:ad8e50332a8602d09d12091217f775bec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 4, dim, Number &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#ad8e50332a8602d09d12091217f775bec">outer_product</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; &amp;t1, const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; &amp;t2)</td></tr>
<tr class="separator:ad8e50332a8602d09d12091217f775bec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3baaf527e57644da9a570eda3b837cda"><td class="memTemplParams" colspan="2">template&lt;typename Number &gt; </td></tr>
<tr class="memitem:a3baaf527e57644da9a570eda3b837cda"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 1, Number &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a3baaf527e57644da9a570eda3b837cda">symmetrize</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, 1, Number &gt; &amp;t)</td></tr>
<tr class="separator:a3baaf527e57644da9a570eda3b837cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af71365fbbaac4dde24b4f33072c0250e"><td class="memTemplParams" colspan="2">template&lt;typename Number &gt; </td></tr>
<tr class="memitem:af71365fbbaac4dde24b4f33072c0250e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 2, Number &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#af71365fbbaac4dde24b4f33072c0250e">symmetrize</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, 2, Number &gt; &amp;t)</td></tr>
<tr class="separator:af71365fbbaac4dde24b4f33072c0250e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab390eb29f4d7d6b985fded8ec1077587"><td class="memTemplParams" colspan="2">template&lt;typename Number &gt; </td></tr>
<tr class="memitem:ab390eb29f4d7d6b985fded8ec1077587"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 3, Number &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#ab390eb29f4d7d6b985fded8ec1077587">symmetrize</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, 3, Number &gt; &amp;t)</td></tr>
<tr class="separator:ab390eb29f4d7d6b985fded8ec1077587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa758cb79866b3852b0382088f00e08c5"><td class="memTemplParams" colspan="2">template&lt;int rank, int dim, typename Number &gt; </td></tr>
<tr class="memitem:aa758cb79866b3852b0382088f00e08c5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, <br class="typebreak"/>
Number &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#aa758cb79866b3852b0382088f00e08c5">operator*</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, Number &gt; &amp;t, const Number factor)</td></tr>
<tr class="separator:aa758cb79866b3852b0382088f00e08c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad84120be3b5efebadc21d2297be16547"><td class="memTemplParams" colspan="2">template&lt;int rank, int dim, typename Number &gt; </td></tr>
<tr class="memitem:ad84120be3b5efebadc21d2297be16547"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, <br class="typebreak"/>
Number &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#ad84120be3b5efebadc21d2297be16547">operator*</a> (const Number factor, const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, Number &gt; &amp;t)</td></tr>
<tr class="separator:ad84120be3b5efebadc21d2297be16547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1707a912c33ec49e82d2ed074ffe244a"><td class="memTemplParams" colspan="2">template&lt;int rank, int dim, typename Number &gt; </td></tr>
<tr class="memitem:a1707a912c33ec49e82d2ed074ffe244a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, <br class="typebreak"/>
Number &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a1707a912c33ec49e82d2ed074ffe244a">operator/</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, Number &gt; &amp;t, const Number factor)</td></tr>
<tr class="separator:a1707a912c33ec49e82d2ed074ffe244a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ac4538d6c5b7282d81fcd7664b49dc4"><td class="memTemplParams" colspan="2">template&lt;int rank, int dim&gt; </td></tr>
<tr class="memitem:a9ac4538d6c5b7282d81fcd7664b49dc4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a9ac4538d6c5b7282d81fcd7664b49dc4">operator*</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim &gt; &amp;t, const <a class="el" href="classdouble.html">double</a> factor)</td></tr>
<tr class="separator:a9ac4538d6c5b7282d81fcd7664b49dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afefb6990769ec7bfecb061b8184d5479"><td class="memTemplParams" colspan="2">template&lt;int rank, int dim&gt; </td></tr>
<tr class="memitem:afefb6990769ec7bfecb061b8184d5479"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#afefb6990769ec7bfecb061b8184d5479">operator*</a> (const <a class="el" href="classdouble.html">double</a> factor, const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim &gt; &amp;t)</td></tr>
<tr class="separator:afefb6990769ec7bfecb061b8184d5479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaaa2e097d2fd550703b66b8c9ca4b90"><td class="memTemplParams" colspan="2">template&lt;int rank, int dim&gt; </td></tr>
<tr class="memitem:aaaaa2e097d2fd550703b66b8c9ca4b90"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#aaaaa2e097d2fd550703b66b8c9ca4b90">operator/</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim &gt; &amp;t, const <a class="el" href="classdouble.html">double</a> factor)</td></tr>
<tr class="separator:aaaaa2e097d2fd550703b66b8c9ca4b90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78c4aa038ee57e9b06c1f91569a9478d"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number &gt; </td></tr>
<tr class="memitem:a78c4aa038ee57e9b06c1f91569a9478d"><td class="memTemplItemLeft" align="right" valign="top">Number&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a78c4aa038ee57e9b06c1f91569a9478d">scalar_product</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; &amp;t1, const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; &amp;t2)</td></tr>
<tr class="separator:a78c4aa038ee57e9b06c1f91569a9478d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f5c8afe4fbdcdbc8214e7ddfbcabb98"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number &gt; </td></tr>
<tr class="memitem:a6f5c8afe4fbdcdbc8214e7ddfbcabb98"><td class="memTemplItemLeft" align="right" valign="top">Number&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a6f5c8afe4fbdcdbc8214e7ddfbcabb98">scalar_product</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; &amp;t1, const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim, Number &gt; &amp;t2)</td></tr>
<tr class="separator:a6f5c8afe4fbdcdbc8214e7ddfbcabb98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65eaa97b84fb3440c5d49032add3d696"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number &gt; </td></tr>
<tr class="memitem:a65eaa97b84fb3440c5d49032add3d696"><td class="memTemplItemLeft" align="right" valign="top">Number&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a65eaa97b84fb3440c5d49032add3d696">scalar_product</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim, Number &gt; &amp;t1, const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; &amp;t2)</td></tr>
<tr class="separator:a65eaa97b84fb3440c5d49032add3d696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad80e651d99c008b2d05a750c1402147"><td class="memTemplParams" colspan="2">template&lt;typename Number &gt; </td></tr>
<tr class="memitem:aad80e651d99c008b2d05a750c1402147"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#aad80e651d99c008b2d05a750c1402147">double_contract</a> (<a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 1, Number &gt; &amp;tmp, const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 4, 1, Number &gt; &amp;t, const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 1, Number &gt; &amp;s)</td></tr>
<tr class="separator:aad80e651d99c008b2d05a750c1402147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad19ba6143220a51f9d54c2af3edc26dd"><td class="memTemplParams" colspan="2">template&lt;typename Number &gt; </td></tr>
<tr class="memitem:ad19ba6143220a51f9d54c2af3edc26dd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#ad19ba6143220a51f9d54c2af3edc26dd">double_contract</a> (<a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 1, Number &gt; &amp;tmp, const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 1, Number &gt; &amp;s, const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 4, 1, Number &gt; &amp;t)</td></tr>
<tr class="separator:ad19ba6143220a51f9d54c2af3edc26dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e1d653c4a59706a2c908cf269798038"><td class="memTemplParams" colspan="2">template&lt;typename Number &gt; </td></tr>
<tr class="memitem:a8e1d653c4a59706a2c908cf269798038"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a8e1d653c4a59706a2c908cf269798038">double_contract</a> (<a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 2, Number &gt; &amp;tmp, const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 4, 2, Number &gt; &amp;t, const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 2, Number &gt; &amp;s)</td></tr>
<tr class="separator:a8e1d653c4a59706a2c908cf269798038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe37726a6a60c5e44bdf503af5293031"><td class="memTemplParams" colspan="2">template&lt;typename Number &gt; </td></tr>
<tr class="memitem:abe37726a6a60c5e44bdf503af5293031"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#abe37726a6a60c5e44bdf503af5293031">double_contract</a> (<a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 2, Number &gt; &amp;tmp, const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 2, Number &gt; &amp;s, const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 4, 2, Number &gt; &amp;t)</td></tr>
<tr class="separator:abe37726a6a60c5e44bdf503af5293031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a804ac7f00e2b805bfac576db96b42c73"><td class="memTemplParams" colspan="2">template&lt;typename Number &gt; </td></tr>
<tr class="memitem:a804ac7f00e2b805bfac576db96b42c73"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a804ac7f00e2b805bfac576db96b42c73">double_contract</a> (<a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 3, Number &gt; &amp;tmp, const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 4, 3, Number &gt; &amp;t, const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 3, Number &gt; &amp;s)</td></tr>
<tr class="separator:a804ac7f00e2b805bfac576db96b42c73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c5ca348ab9bcbce975c01f5d04e3ed6"><td class="memTemplParams" colspan="2">template&lt;typename Number &gt; </td></tr>
<tr class="memitem:a2c5ca348ab9bcbce975c01f5d04e3ed6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a2c5ca348ab9bcbce975c01f5d04e3ed6">double_contract</a> (<a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 3, Number &gt; &amp;tmp, const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 3, Number &gt; &amp;s, const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 4, 3, Number &gt; &amp;t)</td></tr>
<tr class="separator:a2c5ca348ab9bcbce975c01f5d04e3ed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a875e8f9a6f19989ec921a0df143618f1"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number &gt; </td></tr>
<tr class="memitem:a875e8f9a6f19989ec921a0df143618f1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, Number &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a875e8f9a6f19989ec921a0df143618f1">operator*</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; &amp;src1, const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, Number &gt; &amp;src2)</td></tr>
<tr class="separator:a875e8f9a6f19989ec921a0df143618f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5cd683fd58a42e393c546cc4abedeed"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number &gt; </td></tr>
<tr class="memitem:aa5cd683fd58a42e393c546cc4abedeed"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#aa5cd683fd58a42e393c546cc4abedeed">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; &amp;t)</td></tr>
<tr class="separator:aa5cd683fd58a42e393c546cc4abedeed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a351a3d35263baee19d033e5c68bc8539"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number &gt; </td></tr>
<tr class="memitem:a351a3d35263baee19d033e5c68bc8539"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a351a3d35263baee19d033e5c68bc8539">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 4, dim, Number &gt; &amp;t)</td></tr>
<tr class="separator:a351a3d35263baee19d033e5c68bc8539"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int rank, int dim, typename Number = double&gt;<br/>
class SymmetricTensor&lt; rank, dim, Number &gt;</h3>

<p>Provide a class that stores symmetric tensors of rank 2,4,... efficiently, i.e. only store those off-diagonal elements of the full tensor that are not redundant. For example, for symmetric 2x2 tensors, this would be the elements 11, 22, and 12, while the element 21 is equal to the 12 element.</p>
<p>Using this class for symmetric tensors of rank 2 has advantages over matrices in many cases since the dimension is known to the compiler as well as the location of the data. It is therefore possible to produce far more efficient code than for matrices with runtime-dependent dimension. It is also more efficient than using the more general <code><a class="el" href="classTensor.html">Tensor</a></code> class, since less elements are stored, and the class automatically makes sure that the tensor represents a symmetric object.</p>
<p>For tensors of higher rank, the savings in storage are even higher. For example for the 3x3x3x3 tensors of rank 4, only 36 instead of the full 81 entries have to be stored.</p>
<p>While the definition of a symmetric rank-2 tensor is obvious, tensors of rank 4 are considered symmetric if they are operators mapping symmetric rank-2 tensors onto symmetric rank-2 tensors. This entails certain symmetry properties on the elements in their 4-dimensional index space, in particular that <code>C<sub>ijkl</sub>=C<sub>jikl</sub>=C<sub>ijlk</sub></code>. However, it does not imply the relation <code>C<sub>ijkl</sub>=C<sub>klij</sub></code>. Consequently, symmetric tensors of rank 4 as understood here are only tensors that map symmetric tensors onto symmetric tensors, but they do not necessarily induce a symmetric scalar product <code>a:C:b=b:C:a</code> or even a positive (semi-)definite form <code>a:C:a</code>, where <code>a,b</code> are symmetric rank-2 tensors and the colon indicates the common double-index contraction that acts as a product for symmetric tensors.</p>
<p>Symmetric tensors are most often used in structural and fluid mechanics, where strains and stresses are usually symmetric tensors, and the stress-strain relationship is given by a symmetric rank-4 tensor.</p>
<p>Note that symmetric tensors only exist with even numbers of indices. In other words, the only objects that you can use are <code>SymmetricTensor&lt;2,dim&gt;</code>, <code>SymmetricTensor&lt;4,dim&gt;</code>, etc, but <code>SymmetricTensor&lt;1,dim&gt;</code> and <code>SymmetricTensor&lt;3,dim&gt;</code> do not exist and their use will most likely lead to compiler errors.</p>
<h3>Accessing elements</h3>
<p>The elements of a tensor <code>t</code> can be accessed using the bracket operator, i.e. for a tensor of rank 4, <code>t[0][1][0][1]</code> accesses the element <code>t<sub>0101</sub></code>. This access can be used for both reading and writing (if the tensor is non-constant at least). You may also perform other operations on it, although that may lead to confusing situations because several elements of the tensor are stored at the same location. For example, for a rank-2 tensor that is assumed to be zero at the beginning, writing <code>t[0][1]+=1; t[1][0]+=1;</code> will lead to the same element being increased by one <em>twice</em>, because even though the accesses use different indices, the elements that are accessed are symmetric and therefore stored at the same location. It may therefore be useful in application programs to restrict operations on individual elements to simple reads or writes.</p>
<dl class="section author"><dt>Author</dt><dd>Wolfgang Bangerth, 2005 </dd></dl>

<p>Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l00026">26</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a3cc3454cb081cb37737473834976131f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structinternal_1_1SymmetricTensorAccessors_1_1StorageType.html">internal::SymmetricTensorAccessors::StorageType</a>&lt;rank,dim,Number&gt; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, Number &gt;::<a class="el" href="classSymmetricTensor.html#a3cc3454cb081cb37737473834976131f">base_tensor_descriptor</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A structure that describes properties of the base tensor. </p>

<p>Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l01009">1009</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6e231d16733e592721dfbe3f9385594f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef base_tensor_descriptor::base_tensor_type <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, Number &gt;::<a class="el" href="classSymmetricTensor.html#a6e231d16733e592721dfbe3f9385594f">base_tensor_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Data storage type for a symmetric tensor. </p>

<p>Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l01015">1015</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ac99c806b0335dedcf84555c6036cbe23"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, Number &gt;::<a class="el" href="classSymmetricTensor.html">SymmetricTensor</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default constructor. Creates a zero tensor. </p>

</div>
</div>
<a class="anchor" id="ac247404bad39c53d36784c9a7ba0bea9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, Number &gt;::<a class="el" href="classSymmetricTensor.html">SymmetricTensor</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. Generate a symmetric tensor from a general one. Assumes that <code>t</code> is already symmetric, and in debug mode this is in fact checked. Note that no provision is made to assure that the tensor is symmetric only up to round-off error: if the incoming tensor is not exactly symmetric, then an exception is thrown. If you know that incoming tensor is symmetric only up to round-off, then you may want to call the <code>symmetrize</code> function first. If you aren't sure, it is good practice to check before calling <code>symmetrize</code>. </p>

</div>
</div>
<a class="anchor" id="a2e7430a4b6db7f4a693c5746989bc9e1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, Number &gt;::<a class="el" href="classSymmetricTensor.html">SymmetricTensor</a> </td>
          <td>(</td>
          <td class="paramtype">const Number(&amp;)&#160;</td>
          <td class="paramname"><em>array</em>[n_independent_components]</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A constructor that creates a symmetric tensor from an array holding its independent elements. Using this constructor assumes that the caller knows the order in which elements are stored in symmetric tensors; its use is therefore discouraged, but if you think you want to use it anyway you can query the order of elements using the unrolled_index() function.</p>
<p>This constructor is currently only implemented for symmetric tensors of rank 2.</p>
<p>The size of the array passed is equal to SymmetricTensor&lt;rank,dim&gt;::n_independent_component; the reason for using the object from the internal namespace is to work around bugs in some older compilers. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="af0894b81f393a60b5527154775876bdb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&amp; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assignment operator. </p>

</div>
</div>
<a class="anchor" id="a0b43fde5bed166fa6b874f17b9c0bcd7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&amp; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This operator assigns a scalar to a tensor. To avoid confusion with what exactly it means to assign a scalar value to a tensor, zero is the only value allowed for <code>d</code>, allowing the intuitive notation <code>t=0</code> to reset all elements of the tensor to zero. </p>

</div>
</div>
<a class="anchor" id="a89011fbde45c93fa529532401978ae86"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, Number &gt;::operator <a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, Number &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert the present symmetric tensor into a full tensor with the same elements, but using the different storage scheme of full tensors. </p>

</div>
</div>
<a class="anchor" id="a365239caeaf67a66106d3f319d9bbe8a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, Number &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test for equality of two tensors. </p>

</div>
</div>
<a class="anchor" id="a5aa9f38c26b61e767b81cb1b6ace5ed1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, Number &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test for inequality of two tensors. </p>

</div>
</div>
<a class="anchor" id="ab45163c855aefd59f7f9212d722c9b20"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&amp; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, Number &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add another tensor. </p>

</div>
</div>
<a class="anchor" id="aefa612dcc57d5864a4907da43daf2c8a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&amp; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, Number &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Subtract another tensor. </p>

</div>
</div>
<a class="anchor" id="add7f4b123906d410f427114a6bdf2c2f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&amp; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, Number &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scale the tensor by <code>factor</code>, i.e. multiply all components by <code>factor</code>. </p>

</div>
</div>
<a class="anchor" id="a0152c69661bf2f22ecd32de0d6fcde4d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&amp; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, Number &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scale the vector by <code>1/factor</code>. </p>

</div>
</div>
<a class="anchor" id="a66554fde95f61d551fbd9461203111fc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a> <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, Number &gt;::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add two tensors. If possible, you should use <code>operator +=</code> instead since this does not need the creation of a temporary. </p>

</div>
</div>
<a class="anchor" id="ad8dc3ff15bbd5afa8673fb70bf0702b9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a> <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, Number &gt;::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Subtract two tensors. If possible, you should use <code>operator -=</code> instead since this does not need the creation of a temporary. </p>

</div>
</div>
<a class="anchor" id="a932dec1dd77d6af3aa82eda1b6709d7b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a> <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, Number &gt;::operator- </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unary minus operator. Negate all entries of a tensor. </p>

</div>
</div>
<a class="anchor" id="a3586fe5da69c834e642026d1dc310c65"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinternal_1_1SymmetricTensorAccessors_1_1double__contraction__result.html">internal::SymmetricTensorAccessors::double_contraction_result</a>&lt;rank,2,dim,Number&gt;::type <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, Number &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Product between the present symmetric tensor and a tensor of rank 2. For example, if the present object is also a rank-2 tensor, then this is the scalar-product double contraction <code>a<sub>ij</sub>b<sub>ij</sub></code> over all indices <code>i,j</code>. In this case, the return value evaluates to a single scalar. While it is possible to define other scalar product (and associated induced norms), this one seems to be the most appropriate one.</p>
<p>If the present object is a rank-4 tensor, then the result is a rank-2 tensor, i.e., the operation contracts over the last two indices of the present object and the indices of the argument, and the result is a tensor of rank 2.</p>
<p>Note that the multiplication operator for symmetrict tensors is defined to be a double contraction over two indices, while it is defined as a single contraction over only one index for regular <code><a class="el" href="classTensor.html">Tensor</a></code> objects. For symmetric tensors it therefore acts in a way that is commonly denoted by a "colon
multiplication" in the mathematica literature.</p>
<p>There are global functions <code>double_contract</code> that do the same work as this operator, but rather than returning the result as a return value, they write it into the first argument to the function. </p>

</div>
</div>
<a class="anchor" id="a4a77ced8a1583b5674a61ca69a63e08d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinternal_1_1SymmetricTensorAccessors_1_1double__contraction__result.html">internal::SymmetricTensorAccessors::double_contraction_result</a>&lt;rank,4,dim,Number&gt;::type <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, Number &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 4, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Contraction over two indices of the present object with the rank-4 symmetric tensor given as argument. </p>

</div>
</div>
<a class="anchor" id="a4ba0e3f4e7e25c558aa9e5665ce31954"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number&amp; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, Number &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; rank &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a read-write reference to the indicated element. </p>

</div>
</div>
<a class="anchor" id="a82b80e639b6a5e1f438a3ae0823db41c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, Number &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; rank &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the value of the indicated element as a read-only reference.</p>
<p>We return the requested value as a constant reference rather than by value since this object may hold data types that may be large, and we don't know here whether copying is expensive or not. </p>

</div>
</div>
<a class="anchor" id="a031484b067a1e21d4c4f2657d845bbc8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classinternal_1_1SymmetricTensorAccessors_1_1Accessor.html">internal::SymmetricTensorAccessors::Accessor</a>&lt;rank,dim,true,rank-1,Number&gt; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, Number &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>row</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access the elements of a row of this symmetric tensor. This function is called for constant tensors. </p>

</div>
</div>
<a class="anchor" id="a1eb8946b08212f67358f239d415426dd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classinternal_1_1SymmetricTensorAccessors_1_1Accessor.html">internal::SymmetricTensorAccessors::Accessor</a>&lt;rank,dim,false,rank-1,Number&gt; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, Number &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>row</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access the elements of a row of this symmetric tensor. This function is called for non-constant tensors. </p>

</div>
</div>
<a class="anchor" id="a6608365f38d5efa68cdc251de1736ad6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, Number &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; rank &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access to an element where you specify the entire set of indices. </p>

</div>
</div>
<a class="anchor" id="a9ef258ef0eb5645e70834b88efe5da07"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number&amp; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, Number &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; rank &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access to an element where you specify the entire set of indices. </p>

</div>
</div>
<a class="anchor" id="ab56769d0b6fed3ebba6f14ddec4de911"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, Number &gt;::access_raw_entry </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>unrolled_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access to an element according to unrolled index. The function <code>s.access_raw_entry(i)</code> does the same as <code>s[s.unrolled_to_component_indices(i)]</code>, but more efficiently. </p>

</div>
</div>
<a class="anchor" id="a0ee78bf76f6a50580dca65509efa7221"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number&amp; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, Number &gt;::access_raw_entry </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>unrolled_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access to an element according to unrolled index. The function <code>s.access_raw_entry(i)</code> does the same as <code>s[s.unrolled_to_component_indices(i)]</code>, but more efficiently. </p>

</div>
</div>
<a class="anchor" id="a2cbba5df5d70fc66ab0b5fb959aea27e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, Number &gt;::norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the Frobenius-norm of a tensor, i.e. the square root of the sum of squares of all entries. This norm is induced by the scalar product defined above for two symmetric tensors. Note that it includes <em>all</em> entries of the tensor, counting symmetry, not only the unique ones (for example, for rank-2 tensors, this norm includes adding up the squares of upper right as well as lower left entries, not just one of them, although they are equal for symmetric tensors). </p>

</div>
</div>
<a class="anchor" id="a8a3806a78029858205695c5abb1d2f72"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, Number &gt;::component_to_unrolled_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; rank &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tensors can be unrolled by simply pasting all elements into one long vector, but for this an order of elements has to be defined. For symmetric tensors, this function returns which index within the range <code>[0,n_independent_components)</code> the given entry in a symmetric tensor has. </p>

</div>
</div>
<a class="anchor" id="a4c052ca00daee61e07cec3b550bda6eb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classTableIndices.html">TableIndices</a>&lt;rank&gt; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, Number &gt;::unrolled_to_component_indices </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The opposite of the previous function: given an index <img class="formulaInl" alt="$i$" src="form_77.png"/> in the unrolled form of the tensor, return what set of indices <img class="formulaInl" alt="$(k,l)$" src="form_536.png"/> (for rank-2 tensors) or <img class="formulaInl" alt="$(k,l,m,n)$" src="form_537.png"/> (for rank-4 tensors) corresponds to it. </p>

</div>
</div>
<a class="anchor" id="a2428bd858f98bba9650c50786d068b48"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, Number &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reset all values to zero.</p>
<p>Note that this is partly inconsistent with the semantics of the <code><a class="el" href="classSymmetricTensor.html#a2428bd858f98bba9650c50786d068b48">clear()</a></code> member functions of the STL and of several other classes within deal.II which not only reset the values of stored elements to zero, but release all memory and return the object into a virginial state. However, since the size of objects of the present type is determined by its template parameters, resizing is not an option, and indeed the state where all elements have a zero value is the state right after construction of such an object. </p>

</div>
</div>
<a class="anchor" id="aea74a460543343d71eeae935cb3e84a6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::size_t <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, Number &gt;::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determine an estimate for the memory consumption (in bytes) of this object. </p>

</div>
</div>
<a class="anchor" id="a867d6d5c07599504291c0f445f109337"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number = double&gt; </div>
<div class="memtemplate">
template&lt;class Archive &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, Number &gt;::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read or write the data of this object to or from a stream for the purpose of serialization </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="a3b037cceee7751ec3a9d533d43122274"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number = double&gt; </div>
<div class="memtemplate">
template&lt;int , int , typename &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Make all other symmetric tensors friends. </p>

<p>Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l01026">1026</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a93463f125d9286950a6846cb2b0e6c1a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number = double&gt; </div>
<div class="memtemplate">
template&lt;int dim2, typename Number2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Number2 trace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim2, Number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Make a few more functions friends. </p>

</div>
</div>
<a class="anchor" id="a9b919d70d4c4c5c0dfc06435b0482621"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number = double&gt; </div>
<div class="memtemplate">
template&lt;int dim2, typename Number2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim &gt; unit_symmetric_tensor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a unit symmetric tensor of rank 2.</p>
<dl class="section author"><dt>Author</dt><dd>Wolfgang Bangerth, 2005</dd></dl>
<p>Return a unit symmetric tensor of rank 2 for double tensor.</p>
<dl class="section author"><dt>Author</dt><dd>Wolfgang Bangerth, 2005 </dd></dl>

<p>Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l02339">2339</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="aab4e15937306e30da53a7b34147ac1f9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number = double&gt; </div>
<div class="memtemplate">
template&lt;int dim2, typename Number2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 4, dim &gt; deviator_tensor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the tensor of rank 4 that, when multiplied by a symmetric rank 2 tensor <code>t</code> returns the deviator <img class="formulaInl" alt="$\textrm{dev}\ t$" src="form_533.png"/>. It is the operator representation of the linear deviator operator.</p>
<p>For every tensor <code>t</code>, there holds the identity <code>deviator(t)==deviator_tensor&lt;dim&gt;()*t</code>, up to numerical round-off. The reason this operator representation is provided is that one sometimes needs to invert operators like <code>identity_tensor&lt;dim&gt;() + delta_t*deviator_tensor&lt;dim&gt;()</code> or similar.</p>
<dl class="section author"><dt>Author</dt><dd>Wolfgang Bangerth, 2005</dd></dl>
<p>Return the tensor of rank 4 that, when multiplied by a symmetric rank 2 tensor <code>t</code> returns the deviator <code>dev t</code>. It is the operator representation of the linear deviator operator.</p>
<p>For every tensor <code>t</code>, there holds the identity <code>deviator(t)==deviator_tensor&lt;dim&gt;()*t</code>, up to numerical round-off. The reason this operator representation is provided is that one sometimes needs to invert operators like <code>identity_tensor&lt;dim&gt;() + delta_t*deviator_tensor&lt;dim&gt;()</code> or similar.</p>
<dl class="section author"><dt>Author</dt><dd>Wolfgang Bangerth, 2005 </dd></dl>

<p>Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l02395">2395</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0d40eac7f1138a9018c41564f5712ee1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number = double&gt; </div>
<div class="memtemplate">
template&lt;int dim2, typename Number2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 4, dim &gt; identity_tensor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the fourth-order symmetric identity tensor which maps symmetric second-order tensors to themselves.</p>
<p>Note that this tensor, even though it is the identity, has a somewhat funny form, and in particular does not only consist of zeros and ones. For example, for <code>dim=2</code>, the identity tensor has all zero entries except for <code>id[0][0][0][0]=id[1][1][1][1]=1</code> and <code>id[0][1][0][1]=id[0][1][1][0]=id[1][0][0][1]=id[1][0][1][0]=1/2</code>. To see why this factor of 1/2 is necessary, consider computing <code>A=Id : B</code>. For the element <code>a_01</code> we have <code>a_01=id_0100 b_00 + id_0111 b_11 + id_0101 b_01 + id_0110 b_10</code>. On the other hand, we need to have <code>a_01=b_01</code>, and symmetry implies <code>b_01=b_10</code>, leading to <code>a_01=(id_0101+id_0110) b_01</code>, or, again by symmetry, <code>id_0101=id_0110=1/2</code>. Similar considerations hold for the three-dimensional case.</p>
<p>This issue is also explained in the introduction to <a class="el" href="step_44.html">step-44</a>.</p>
<dl class="section author"><dt>Author</dt><dd>Wolfgang Bangerth, 2005</dd></dl>
<p>Return the tensor of rank 4 that, when multiplied by a symmetric rank 2 tensor <code>t</code> returns the deviator <code>dev t</code>. It is the operator representation of the linear deviator operator.</p>
<p>Note that this tensor, even though it is the identity, has a somewhat funny form, and in particular does not only consist of zeros and ones. For example, for <code>dim=2</code>, the identity tensor has all zero entries except for <code>id[0][0][0][0]=id[1][1][1][1]=1</code> and <code>id[0][1][0][1]=id[0][1][1][0]=id[1][0][0][1]=id[1][0][1][0]=1/2</code>. To see why this factor of 1/2 is necessary, consider computing <code>A=Id . B</code>. For the element <code>a_01</code> we have <code>a_01=id_0100 b_00 + id_0111 b_11 + id_0101 b_01 + id_0110 b_10</code>. On the other hand, we need to have <code>a_01=b_01</code>, and symmetry implies <code>b_01=b_10</code>, leading to <code>a_01=(id_0101+id_0110) b_01</code>, or, again by symmetry, <code>id_0101=id_0110=1/2</code>. Similar considerations hold for the three-dimensional case.</p>
<dl class="section author"><dt>Author</dt><dd>Wolfgang Bangerth, 2005 </dd></dl>

<p>Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l02468">2468</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a31d48ca1d251a7a32db8b673e6010193"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Number determinant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the determinant of a tensor or rank 2. The determinant is also commonly referred to as the third invariant of rank-2 tensors.</p>
<p>For a one-dimensional tensor, the determinant equals the only element and is therefore equivalent to the trace.</p>
<p>For greater notational simplicity, there is also a <code>third_invariant</code> function that returns the determinant of a tensor.</p>
<dl class="section author"><dt>Author</dt><dd>Wolfgang Bangerth, 2005 </dd></dl>

<p>Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l02157">2157</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7c8cae195023acc719527e04b65b156d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> third_invariant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the determinant of a tensor or rank 2. This function therefore computes the same value as the <code><a class="el" href="classTensor.html#a9cffa9df45112105bc2aa5bbc7c0b08d">determinant()</a></code> functions and is only provided for greater notational simplicity (since there are also functions <code>first_invariant</code> and <code>second_invariant</code>).</p>
<dl class="section author"><dt>Author</dt><dd>Wolfgang Bangerth, 2005 </dd></dl>

<p>Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l02193">2193</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a05096e7bc18fa734eae3bd1a5f08138e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Number trace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute and return the trace of a tensor of rank 2, i.e. the sum of its diagonal entries. The trace is the first invariant of a rank-2 tensor.</p>
<dl class="section author"><dt>Author</dt><dd>Wolfgang Bangerth, 2005 </dd></dl>

<p>Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l02209">2209</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8beb998db1792cd540f3a72b162adead"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Number first_invariant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the trace of a tensor or rank 2. This function therefore computes the same value as the <code><a class="el" href="classSymmetricTensor.html#a93463f125d9286950a6846cb2b0e6c1a">trace()</a></code> functions and is only provided for greater notational simplicity (since there are also functions <code>second_invariant</code> and <code>third_invariant</code>).</p>
<dl class="section author"><dt>Author</dt><dd>Wolfgang Bangerth, 2005 </dd></dl>

<p>Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l02229">2229</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7bbdfc57da6931de6a1757a0fa7ee982"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Number second_invariant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 1, Number &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the second invariant of a tensor of rank 2. The second invariant is defined as <code>I2 = 1/2[ (trace sigma)^2 - trace (sigma^2) ]</code>.</p>
<dl class="section author"><dt>Author</dt><dd>Wolfgang Bangerth, 2005, 2010 </dd></dl>

<p>Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l02244">2244</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="af02b5f4e4a6385e770f20a43f2e70f17"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Number second_invariant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 2, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the second invariant of a tensor of rank 2. The second invariant is defined as <code>I2 = 1/2[ (trace sigma)^2 - trace (sigma^2) ]</code>.</p>
<dl class="section author"><dt>Author</dt><dd>Wolfgang Bangerth, 2005, 2010 </dd></dl>

<p>Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l02260">2260</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a37621ebbca1ac8a5946a41d8947243ab"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Number second_invariant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 3, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the second invariant of a tensor of rank 2. The second invariant is defined as <code>I2 = 1/2[ (trace sigma)^2 - trace (sigma^2) ]</code>.</p>
<dl class="section author"><dt>Author</dt><dd>Wolfgang Bangerth, 2005, 2010 </dd></dl>

<p>Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l02276">2276</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab424a468e166675a7f327f14fe94620c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, Number &gt; transpose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the transpose of the given symmetric tensor. Since we are working with symmetric objects, the transpose is of course the same as the original tensor. This function mainly exists for compatibility with the <a class="el" href="classTensor.html">Tensor</a> class.</p>
<dl class="section author"><dt>Author</dt><dd>Wolfgang Bangerth, 2005 </dd></dl>

<p>Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l02297">2297</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa1ba0db3d146ea2d13dca05de9a42c74"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; deviator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the deviator of a symmetric tensor, which is defined as <code>dev[s] = s - 1/dim*tr[s]*I</code>, where <code>I</code> is the identity operator. This quantity equals the original tensor minus its contractive or dilative component and refers to the shear in, for example, elasticity.</p>
<dl class="section author"><dt>Author</dt><dd>Wolfgang Bangerth, 2005 </dd></dl>

<p>Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l02316">2316</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7a8f423c6a539ce339132bfd7264891d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 4, dim, Number &gt; invert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 4, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Invert a symmetric rank-4 tensor. Since symmetric rank-4 tensors are mappings from and to symmetric rank-2 tensors, they can have an inverse. This function computes it, if it exists, for the case that the dimension equals either 1 or 2.</p>
<p>If a tensor is not invertible, then the result is unspecified, but will likely contain the results of a division by zero or a very small number at the very least.</p>
<dl class="section author"><dt>Author</dt><dd>Wolfgang Bangerth, 2005 </dd></dl>

<p>Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l02538">2538</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8214de44ccf8237189c6216b09bd5a66"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 4, 3, <a class="el" href="classdouble.html">double</a> &gt; invert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 4, 3, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Invert a symmetric rank-4 tensor. Since symmetric rank-4 tensors are mappings from and to symmetric rank-2 tensors, they can have an inverse. This function computes it, if it exists, for the case that the dimension equals 3.</p>
<p>If a tensor is not invertible, then the result is unspecified, but will likely contain the results of a division by zero or a very small number at the very least.</p>
<dl class="section author"><dt>Author</dt><dd>Wolfgang Bangerth, 2005 </dd></dl>

</div>
</div>
<a class="anchor" id="ad8e50332a8602d09d12091217f775bec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 4, dim, Number &gt; outer_product </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the tensor of rank 4 that is the outer product of the two tensors given as arguments, i.e. the result <img class="formulaInl" alt="$T=t1 \otimes t2$" src="form_534.png"/> satisfies <code>T phi = t1 (t2 : phi)</code> for all symmetric tensors <code>phi</code>.</p>
<p>For example, the deviator tensor can be computed as <code><a class="el" href="classSymmetricTensor.html#a0d40eac7f1138a9018c41564f5712ee1">identity_tensor&lt;dim,Number&gt;()</a> - 1/d*outer_product(<a class="el" href="classSymmetricTensor.html#a9b919d70d4c4c5c0dfc06435b0482621">unit_symmetric_tensor&lt;dim,Number&gt;()</a>, <a class="el" href="classSymmetricTensor.html#a9b919d70d4c4c5c0dfc06435b0482621">unit_symmetric_tensor&lt;dim,Number&gt;()</a>)</code>, since the (double) contraction with the unit tensor yields the trace of a symmetric tensor.</p>
<dl class="section author"><dt>Author</dt><dd>Wolfgang Bangerth, 2005 </dd></dl>

<p>Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l02654">2654</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3baaf527e57644da9a570eda3b837cda"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 1, Number &gt; symmetrize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, 1, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the symmetrized version of a full rank-2 tensor, i.e. (t+transpose(t))/2, as a symmetric rank-2 tensor. This is the version for dim==1.</p>
<dl class="section author"><dt>Author</dt><dd>Wolfgang Bangerth, 2005 </dd></dl>

<p>Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l02682">2682</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="af71365fbbaac4dde24b4f33072c0250e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 2, Number &gt; symmetrize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, 2, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the symmetrized version of a full rank-2 tensor, i.e. (t+transpose(t))/2, as a symmetric rank-2 tensor. This is the version for dim==2.</p>
<dl class="section author"><dt>Author</dt><dd>Wolfgang Bangerth, 2005 </dd></dl>

<p>Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l02702">2702</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab390eb29f4d7d6b985fded8ec1077587"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 3, Number &gt; symmetrize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, 3, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the symmetrized version of a full rank-2 tensor, i.e. (t+transpose(t))/2, as a symmetric rank-2 tensor. This is the version for dim==3.</p>
<dl class="section author"><dt>Author</dt><dd>Wolfgang Bangerth, 2005 </dd></dl>

<p>Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l02722">2722</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa758cb79866b3852b0382088f00e08c5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, Number &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiplication of a symmetric tensor of general rank with a scalar from the right. </p>

<p>Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l02744">2744</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad84120be3b5efebadc21d2297be16547"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, Number &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiplication of a symmetric tensor of general rank with a scalar from the left. </p>

<p>Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l02763">2763</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1707a912c33ec49e82d2ed074ffe244a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, Number &gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Division of a symmetric tensor of general rank by a scalar. </p>

<p>Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l02781">2781</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9ac4538d6c5b7282d81fcd7664b49dc4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiplication of a symmetric tensor of general rank with a scalar from the right. </p>

<p>Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l02800">2800</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="afefb6990769ec7bfecb061b8184d5479"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiplication of a symmetric tensor of general rank with a scalar from the left. </p>

<p>Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l02819">2819</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="aaaaa2e097d2fd550703b66b8c9ca4b90"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim &gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Division of a symmetric tensor of general rank by a scalar. </p>

<p>Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l02837">2837</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a78c4aa038ee57e9b06c1f91569a9478d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Number scalar_product </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the scalar product <img class="formulaInl" alt="$a:b=\sum_{i,j} a_{ij}b_{ij}$" src="form_178.png"/> between two tensors <img class="formulaInl" alt="$a,b$" src="form_521.png"/> of rank 2. In the current case where both arguments are symmetric tensors, this is equivalent to calling the expression <code>t1*t2</code> which uses the overloaded <code>operator*</code> between two symmetric tensors of rank 2. </p>

<p>Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l02857">2857</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6f5c8afe4fbdcdbc8214e7ddfbcabb98"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Number scalar_product </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the scalar product <img class="formulaInl" alt="$a:b=\sum_{i,j} a_{ij}b_{ij}$" src="form_178.png"/> between two tensors <img class="formulaInl" alt="$a,b$" src="form_521.png"/> of rank 2. We don't use <code>operator*</code> for this operation since the product between two tensors is usually assumed to be the contraction over the last index of the first tensor and the first index of the second tensor, for example <img class="formulaInl" alt="$(a\cdot b)_{ij}=\sum_k a_{ik}b_{kj}$" src="form_522.png"/>. </p>

<p>Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l02877">2877</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a65eaa97b84fb3440c5d49032add3d696"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Number scalar_product </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the scalar product <img class="formulaInl" alt="$a:b=\sum_{i,j} a_{ij}b_{ij}$" src="form_178.png"/> between two tensors <img class="formulaInl" alt="$a,b$" src="form_521.png"/> of rank 2. We don't use <code>operator*</code> for this operation since the product between two tensors is usually assumed to be the contraction over the last index of the first tensor and the first index of the second tensor, for example <img class="formulaInl" alt="$(a\cdot b)_{ij}=\sum_k a_{ik}b_{kj}$" src="form_522.png"/>. </p>

<p>Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l02901">2901</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="aad80e651d99c008b2d05a750c1402147"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void double_contract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 1, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>tmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 4, 1, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 1, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Double contraction between a rank-4 and a rank-2 symmetric tensor, resulting in the symmetric tensor of rank 2 that is given as first argument to this function. This operation is the symmetric tensor analogon of a matrix-vector multiplication.</p>
<p>This function does the same as the member operator* of the <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a> class. It should not be used, however, since the member operator has knowledge of the actual data storage format and is at least 2 orders of magnitude faster. This function mostly exists for compatibility purposes with the general tensor class.</p>
<dl class="section author"><dt>Author</dt><dd>Wolfgang Bangerth, 2005 </dd></dl>

<p>Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l02926">2926</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad19ba6143220a51f9d54c2af3edc26dd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void double_contract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 1, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>tmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 1, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 4, 1, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Double contraction between a rank-4 and a rank-2 symmetric tensor, resulting in the symmetric tensor of rank 2 that is given as first argument to this function. This operation is the symmetric tensor analogon of a matrix-vector multiplication.</p>
<p>This function does the same as the member operator* of the <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a> class. It should not be used, however, since the member operator has knowledge of the actual data storage format and is at least 2 orders of magnitude faster. This function mostly exists for compatibility purposes with the general tensor class.</p>
<dl class="section author"><dt>Author</dt><dd>Wolfgang Bangerth, 2005 </dd></dl>

<p>Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l02953">2953</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8e1d653c4a59706a2c908cf269798038"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void double_contract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 2, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>tmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 4, 2, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 2, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Double contraction between a rank-4 and a rank-2 symmetric tensor, resulting in the symmetric tensor of rank 2 that is given as first argument to this function. This operation is the symmetric tensor analogon of a matrix-vector multiplication.</p>
<p>This function does the same as the member operator* of the <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a> class. It should not be used, however, since the member operator has knowledge of the actual data storage format and is at least 2 orders of magnitude faster. This function mostly exists for compatibility purposes with the general tensor class.</p>
<dl class="section author"><dt>Author</dt><dd>Wolfgang Bangerth, 2005 </dd></dl>

<p>Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l02979">2979</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="abe37726a6a60c5e44bdf503af5293031"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void double_contract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 2, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>tmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 2, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 4, 2, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Double contraction between a rank-4 and a rank-2 symmetric tensor, resulting in the symmetric tensor of rank 2 that is given as first argument to this function. This operation is the symmetric tensor analogon of a matrix-vector multiplication.</p>
<p>This function does the same as the member operator* of the <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a> class. It should not be used, however, since the member operator has knowledge of the actual data storage format and is at least 2 orders of magnitude faster. This function mostly exists for compatibility purposes with the general tensor class.</p>
<dl class="section author"><dt>Author</dt><dd>Wolfgang Bangerth, 2005 </dd></dl>

<p>Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l03012">3012</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a804ac7f00e2b805bfac576db96b42c73"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void double_contract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 3, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>tmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 4, 3, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 3, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Double contraction between a rank-4 and a rank-2 symmetric tensor, resulting in the symmetric tensor of rank 2 that is given as first argument to this function. This operation is the symmetric tensor analogon of a matrix-vector multiplication.</p>
<p>This function does the same as the member operator* of the <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a> class. It should not be used, however, since the member operator has knowledge of the actual data storage format and is at least 2 orders of magnitude faster. This function mostly exists for compatibility purposes with the general tensor class.</p>
<dl class="section author"><dt>Author</dt><dd>Wolfgang Bangerth, 2005 </dd></dl>

<p>Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l03045">3045</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2c5ca348ab9bcbce975c01f5d04e3ed6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void double_contract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 3, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>tmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 3, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 4, 3, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Double contraction between a rank-4 and a rank-2 symmetric tensor, resulting in the symmetric tensor of rank 2 that is given as first argument to this function. This operation is the symmetric tensor analogon of a matrix-vector multiplication.</p>
<p>This function does the same as the member operator* of the <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a> class. It should not be used, however, since the member operator has knowledge of the actual data storage format and is at least 2 orders of magnitude faster. This function mostly exists for compatibility purposes with the general tensor class.</p>
<dl class="section author"><dt>Author</dt><dd>Wolfgang Bangerth, 2005 </dd></dl>

<p>Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l03081">3081</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a875e8f9a6f19989ec921a0df143618f1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, Number &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiplication operator performing a contraction of the last index of the first argument and the first index of the second argument. This function therefore does the same as the corresponding <code>contract</code> function, but returns the result as a return value, rather than writing it into the reference given as the first argument to the <code>contract</code> function.</p>
<p>Note that for the <code><a class="el" href="classTensor.html">Tensor</a></code> class, the multiplication operator only performs a contraction over a single pair of indices. This is in contrast to the multiplication operator for symmetric tensors, which does the double contraction.</p>
<dl class="section author"><dt>Author</dt><dd>Wolfgang Bangerth, 2005 </dd></dl>

<p>Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l03117">3117</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa5cd683fd58a42e393c546cc4abedeed"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Output operator for symmetric tensors of rank 2. Print the elements consecutively, with a space in between, two spaces between rank 1 subtensors, three between rank 2 and so on. No special amends are made to represents the symmetry in the output, for example by outputting only the unique entries. </p>

<p>Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l03139">3139</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a351a3d35263baee19d033e5c68bc8539"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 4, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Output operator for symmetric tensors of rank 4. Print the elements consecutively, with a space in between, two spaces between rank 1 subtensors, three between rank 2 and so on. No special amends are made to represents the symmetry in the output, for example by outputting only the unique entries. </p>

<p>Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l03167">3167</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a98c96e8433eaaeb52b2974829cf3c045"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, Number &gt;::dimension = dim</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Provide a way to get the dimension of an object without explicit knowledge of it's data type. Implementation is this way instead of providing a function <code><a class="el" href="classSymmetricTensor.html#a98c96e8433eaaeb52b2974829cf3c045">dimension()</a></code> because now it is possible to get the dimension at compile time without the expansion and preevaluation of an inlined function; the compiler may therefore produce more efficient code and you may use this value to declare other data types. </p>

<p>Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l00629">629</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="adf501ef6f23cafa2ff79081afbd8478d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, Number &gt;::n_independent_components</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= <a class="code" href="structinternal_1_1SymmetricTensorAccessors_1_1StorageType.html">internal::SymmetricTensorAccessors::StorageType&lt;rank,dim,Number&gt;</a><a class="code" href="classSymmetricTensor.html#adf501ef6f23cafa2ff79081afbd8478d">::</a></div>
<div class="line"><a class="code" href="classSymmetricTensor.html#adf501ef6f23cafa2ff79081afbd8478d">      n_independent_components</a></div>
</div><!-- fragment --><p>An integer denoting the number of independent components that fully describe a symmetric tensor. In <img class="formulaInl" alt="$d$" src="form_172.png"/> space dimensions, this number equals <img class="formulaInl" alt="$\frac 12 (d^2+d)$" src="form_535.png"/> for symmetric tensors of rank 2. </p>

<p>Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l00640">640</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a948c91e036e4a6cc8bdd5ba93e25cf9f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSymmetricTensor.html#a6e231d16733e592721dfbe3f9385594f">base_tensor_type</a> <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, Number &gt;::data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The place where we store the data of the tensor. </p>

<p>Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l01021">1021</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/deal.II/base/<a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jan 27 2014 15:27:21 for The deal.II Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
