<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>The deal.II Library: FiniteElement&lt; dim, spacedim &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="http://www.dealii.org/deal.ico"></link>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2014 by the deal.II authors"></meta>
<meta name="deal.II-version" content="8.1.0"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 8.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classFiniteElement-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">FiniteElement&lt; dim, spacedim &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group__febase.html">Base classes</a> &#124; <a class="el" href="group__fe.html">Finite element space descriptions</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for FiniteElement&lt; dim, spacedim &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classFiniteElement__inherit__graph.svg" width="2187" height="1752"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a904941a97e1f4e87d2770c8e9fe455c1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a904941a97e1f4e87d2770c8e9fe455c1">FiniteElement</a> (const <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt; &amp;fe_data, const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;<a class="el" href="classFiniteElement.html#aa8f4833a318127b42d2dc806bffe1c2c">restriction_is_additive_flags</a>, const std::vector&lt; <a class="el" href="classComponentMask.html">ComponentMask</a> &gt; &amp;<a class="el" href="classFiniteElement.html#ae6fe073d1e3ce59791b142067482bd5b">nonzero_components</a>)</td></tr>
<tr class="separator:a904941a97e1f4e87d2770c8e9fe455c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e9539f277b1d01364c5b0cf2d6d804c"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a0e9539f277b1d01364c5b0cf2d6d804c">~FiniteElement</a> ()</td></tr>
<tr class="separator:a0e9539f277b1d01364c5b0cf2d6d804c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09655d1d2555af8dcd48caebd4039d29"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a09655d1d2555af8dcd48caebd4039d29">get_name</a> () const =0</td></tr>
<tr class="separator:a09655d1d2555af8dcd48caebd4039d29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea9442ccbb721a725ca67376302e1d22"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, <br class="typebreak"/>
spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#aea9442ccbb721a725ca67376302e1d22">operator[]</a> (const unsigned <a class="el" href="classint.html">int</a> fe_index) const </td></tr>
<tr class="separator:aea9442ccbb721a725ca67376302e1d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef56a3e1bd7610fa1a0029d9fbd5a1c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#aef56a3e1bd7610fa1a0029d9fbd5a1c6">operator==</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;) const </td></tr>
<tr class="separator:aef56a3e1bd7610fa1a0029d9fbd5a1c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a147d7f02d1fe78fc3294d43521ff7fb3"><td class="memItemLeft" align="right" valign="top">virtual std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a147d7f02d1fe78fc3294d43521ff7fb3">memory_consumption</a> () const </td></tr>
<tr class="separator:a147d7f02d1fe78fc3294d43521ff7fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga663d09822c597afdf3252fd2ee228484"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga663d09822c597afdf3252fd2ee228484">DeclException1</a> (ExcShapeFunctionNotPrimitive, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;The shape function with index &quot;&lt;&lt; arg1&lt;&lt; &quot; is not primitive, i.e. it is vector-valued and &quot;&lt;&lt; &quot;has more than one non-zero vector component. This &quot;&lt;&lt; &quot;function cannot be called for these shape functions. &quot;&lt;&lt; &quot;Maybe you want to use the same function with the &quot;&lt;&lt; &quot;_component suffix?&quot;)</td></tr>
<tr class="separator:ga663d09822c597afdf3252fd2ee228484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ec1b9715ae5de8ea67d626df81074e1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga6ec1b9715ae5de8ea67d626df81074e1">DeclException0</a> (ExcFENotPrimitive)</td></tr>
<tr class="separator:ga6ec1b9715ae5de8ea67d626df81074e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7779e99ae5d55f47a882ea8d4b76a3f8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga7779e99ae5d55f47a882ea8d4b76a3f8">DeclException0</a> (ExcUnitShapeValuesDoNotExist)</td></tr>
<tr class="separator:ga7779e99ae5d55f47a882ea8d4b76a3f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga441337b816672f5a56ced1df2d901cf1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga441337b816672f5a56ced1df2d901cf1">DeclException0</a> (ExcFEHasNoSupportPoints)</td></tr>
<tr class="separator:ga441337b816672f5a56ced1df2d901cf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacebeed4a61b578d9bc24ad7bb1328804"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gacebeed4a61b578d9bc24ad7bb1328804">DeclException0</a> (ExcEmbeddingVoid)</td></tr>
<tr class="separator:gacebeed4a61b578d9bc24ad7bb1328804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad56c1d2567712b78afb829e6b0a792de"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gad56c1d2567712b78afb829e6b0a792de">DeclException0</a> (ExcProjectionVoid)</td></tr>
<tr class="separator:gad56c1d2567712b78afb829e6b0a792de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga385daef8c785d024207d8ad0e67e4f64"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga385daef8c785d024207d8ad0e67e4f64">DeclException0</a> (ExcConstraintsVoid)</td></tr>
<tr class="separator:ga385daef8c785d024207d8ad0e67e4f64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga781b79cd1cd4ebbe994a8fc5a92d2e1c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga781b79cd1cd4ebbe994a8fc5a92d2e1c">DeclException2</a> (ExcWrongInterfaceMatrixSize, <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;The interface matrix has a size of &quot;&lt;&lt; arg1&lt;&lt; &quot;x&quot;&lt;&lt; arg2&lt;&lt; &quot;, which is not reasonable in the present dimension.&quot;)</td></tr>
<tr class="separator:ga781b79cd1cd4ebbe994a8fc5a92d2e1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e5b43ec35aea65d5a2893a25c4b58bb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga3e5b43ec35aea65d5a2893a25c4b58bb">DeclException2</a> (ExcComponentIndexInvalid, <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;The component-index pair (&quot;&lt;&lt; arg1&lt;&lt; &quot;, &quot;&lt;&lt; arg2&lt;&lt; &quot;) is invalid, i.e. non-existent.&quot;)</td></tr>
<tr class="separator:ga3e5b43ec35aea65d5a2893a25c4b58bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37396684147b41d9ffe6dfdd4210b1ce"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga37396684147b41d9ffe6dfdd4210b1ce">DeclException0</a> (ExcInterpolationNotImplemented)</td></tr>
<tr class="separator:ga37396684147b41d9ffe6dfdd4210b1ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaaea5af4df627df2a01eceaa7e89edba"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaaaea5af4df627df2a01eceaa7e89edba">DeclException0</a> (ExcBoundaryFaceUsed)</td></tr>
<tr class="separator:gaaaea5af4df627df2a01eceaa7e89edba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9fd5323aaba661afa76fba1344984ad"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf9fd5323aaba661afa76fba1344984ad">DeclException0</a> (ExcJacobiDeterminantHasWrongSign)</td></tr>
<tr class="separator:gaf9fd5323aaba661afa76fba1344984ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Shape function access</div></td></tr>
<tr class="memitem:a79da090fe75c199ea6800fbcfc351e93"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a79da090fe75c199ea6800fbcfc351e93">shape_value</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p) const </td></tr>
<tr class="separator:a79da090fe75c199ea6800fbcfc351e93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefcc7c236f03ca92cbce5cd1d838cc09"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#aefcc7c236f03ca92cbce5cd1d838cc09">shape_value_component</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, const unsigned <a class="el" href="classint.html">int</a> component) const </td></tr>
<tr class="separator:aefcc7c236f03ca92cbce5cd1d838cc09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeccda3bf6763cc33dd42f43c92395f64"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#aeccda3bf6763cc33dd42f43c92395f64">shape_grad</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p) const </td></tr>
<tr class="separator:aeccda3bf6763cc33dd42f43c92395f64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa251d27289ecc281cdd43753ccc748fb"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#aa251d27289ecc281cdd43753ccc748fb">shape_grad_component</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, const unsigned <a class="el" href="classint.html">int</a> component) const </td></tr>
<tr class="separator:aa251d27289ecc281cdd43753ccc748fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f84afe8e0b66037a9062cdcca290dcf"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a4f84afe8e0b66037a9062cdcca290dcf">shape_grad_grad</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p) const </td></tr>
<tr class="separator:a4f84afe8e0b66037a9062cdcca290dcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56ca24e50d926cdf10bf9ad743f7976f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a56ca24e50d926cdf10bf9ad743f7976f">shape_grad_grad_component</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, const unsigned <a class="el" href="classint.html">int</a> component) const </td></tr>
<tr class="separator:a56ca24e50d926cdf10bf9ad743f7976f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04ad0cca5800a68b8149d34865227d9d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a04ad0cca5800a68b8149d34865227d9d">has_support_on_face</a> (const unsigned <a class="el" href="classint.html">int</a> shape_index, const unsigned <a class="el" href="classint.html">int</a> face_index) const </td></tr>
<tr class="separator:a04ad0cca5800a68b8149d34865227d9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Transfer and constraint matrices</div></td></tr>
<tr class="memitem:a0238956d0afd1bd880bf84366c024dec"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classFullMatrix.html">FullMatrix</a><br class="typebreak"/>
&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a0238956d0afd1bd880bf84366c024dec">get_restriction_matrix</a> (const unsigned <a class="el" href="classint.html">int</a> child, const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt; &amp;refinement_case=<a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt;::isotropic_refinement) const </td></tr>
<tr class="separator:a0238956d0afd1bd880bf84366c024dec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5e488d17d3e34a84166d8c7ca95c22a"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classFullMatrix.html">FullMatrix</a><br class="typebreak"/>
&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#ac5e488d17d3e34a84166d8c7ca95c22a">get_prolongation_matrix</a> (const unsigned <a class="el" href="classint.html">int</a> child, const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt; &amp;refinement_case=<a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt;::isotropic_refinement) const </td></tr>
<tr class="separator:ac5e488d17d3e34a84166d8c7ca95c22a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8fdbb2a1b1a014473eb06950e7e7d05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#ac8fdbb2a1b1a014473eb06950e7e7d05">prolongation_is_implemented</a> () const </td></tr>
<tr class="separator:ac8fdbb2a1b1a014473eb06950e7e7d05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f707a015a3dbad884fcf775c7045db5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a1f707a015a3dbad884fcf775c7045db5">isotropic_prolongation_is_implemented</a> () const </td></tr>
<tr class="separator:a1f707a015a3dbad884fcf775c7045db5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af907ef944827248ff218ad6374787ebf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#af907ef944827248ff218ad6374787ebf">restriction_is_implemented</a> () const </td></tr>
<tr class="separator:af907ef944827248ff218ad6374787ebf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6f01c36e56f40779ab4130fb4c10673"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#ab6f01c36e56f40779ab4130fb4c10673">isotropic_restriction_is_implemented</a> () const </td></tr>
<tr class="separator:ab6f01c36e56f40779ab4130fb4c10673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c9ce7c266ff343d4d80109cfcc83896"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a4c9ce7c266ff343d4d80109cfcc83896">restriction_is_additive</a> (const unsigned <a class="el" href="classint.html">int</a> index) const </td></tr>
<tr class="separator:a4c9ce7c266ff343d4d80109cfcc83896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adca98da93286dc00c07a049dac9b0e50"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#adca98da93286dc00c07a049dac9b0e50">constraints</a> (const ::<a class="el" href="classinternal_1_1SubfaceCase.html">internal::SubfaceCase</a>&lt; dim &gt; &amp;subface_case=::<a class="el" href="classinternal_1_1SubfaceCase.html">internal::SubfaceCase</a>&lt; dim &gt;::case_isotropic) const </td></tr>
<tr class="separator:adca98da93286dc00c07a049dac9b0e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cb0b95fb7a683e493884133725a03e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a5cb0b95fb7a683e493884133725a03e9">constraints_are_implemented</a> (const ::<a class="el" href="classinternal_1_1SubfaceCase.html">internal::SubfaceCase</a>&lt; dim &gt; &amp;subface_case=::<a class="el" href="classinternal_1_1SubfaceCase.html">internal::SubfaceCase</a>&lt; dim &gt;::case_isotropic) const </td></tr>
<tr class="separator:a5cb0b95fb7a683e493884133725a03e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acea8a4ad78bb6511033ef40de259ace3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#acea8a4ad78bb6511033ef40de259ace3">hp_constraints_are_implemented</a> () const </td></tr>
<tr class="separator:acea8a4ad78bb6511033ef40de259ace3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab64ef474b3fd4bd155618584ddc1e9cc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#ab64ef474b3fd4bd155618584ddc1e9cc">get_interpolation_matrix</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;source, <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;matrix) const </td></tr>
<tr class="separator:ab64ef474b3fd4bd155618584ddc1e9cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Functions to support hp</div></td></tr>
<tr class="memitem:a9ffc5d5535913fe35f59131c0558c853"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a9ffc5d5535913fe35f59131c0558c853">get_face_interpolation_matrix</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;source, <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;matrix) const </td></tr>
<tr class="separator:a9ffc5d5535913fe35f59131c0558c853"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b92af4e841a90cd4b971f931b83c8dc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a1b92af4e841a90cd4b971f931b83c8dc">get_subface_interpolation_matrix</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;source, const unsigned <a class="el" href="classint.html">int</a> subface, <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;matrix) const </td></tr>
<tr class="separator:a1b92af4e841a90cd4b971f931b83c8dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa31b7fc6b4abd8bdbfa338676629e502"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::pair<br class="typebreak"/>
&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#aa31b7fc6b4abd8bdbfa338676629e502">hp_vertex_dof_identities</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe_other) const </td></tr>
<tr class="separator:aa31b7fc6b4abd8bdbfa338676629e502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaddbc3c71ae4f437f4e37b878dbe30b5"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::pair<br class="typebreak"/>
&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#aaddbc3c71ae4f437f4e37b878dbe30b5">hp_line_dof_identities</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe_other) const </td></tr>
<tr class="separator:aaddbc3c71ae4f437f4e37b878dbe30b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ad9e292f90a4812d231229295ac705f"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::pair<br class="typebreak"/>
&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a0ad9e292f90a4812d231229295ac705f">hp_quad_dof_identities</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe_other) const </td></tr>
<tr class="separator:a0ad9e292f90a4812d231229295ac705f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab205badd986d9bf0b6ed00641fbc0c50"><td class="memItemLeft" align="right" valign="top">virtual <br class="typebreak"/>
<a class="el" href="namespaceFiniteElementDomination.html#a65fdbe0cca5954df89a7af4f36769bf9">FiniteElementDomination::Domination</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#ab205badd986d9bf0b6ed00641fbc0c50">compare_for_face_domination</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe_other) const </td></tr>
<tr class="separator:ab205badd986d9bf0b6ed00641fbc0c50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Index computations</div></td></tr>
<tr class="memitem:a27220a135402b96c7e6eecbb04acda56"><td class="memItemLeft" align="right" valign="top">std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, <br class="typebreak"/>
unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a27220a135402b96c7e6eecbb04acda56">system_to_component_index</a> (const unsigned <a class="el" href="classint.html">int</a> index) const </td></tr>
<tr class="separator:a27220a135402b96c7e6eecbb04acda56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53c8af4e218c3257bd34b360c3163d3e"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a53c8af4e218c3257bd34b360c3163d3e">component_to_system_index</a> (const unsigned <a class="el" href="classint.html">int</a> component, const unsigned <a class="el" href="classint.html">int</a> index) const </td></tr>
<tr class="separator:a53c8af4e218c3257bd34b360c3163d3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44bd600481078ec8d037e1bcf80274b4"><td class="memItemLeft" align="right" valign="top">std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, <br class="typebreak"/>
unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a44bd600481078ec8d037e1bcf80274b4">face_system_to_component_index</a> (const unsigned <a class="el" href="classint.html">int</a> index) const </td></tr>
<tr class="separator:a44bd600481078ec8d037e1bcf80274b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac88c06986c3751adafbd089da7682b82"><td class="memItemLeft" align="right" valign="top">virtual unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#ac88c06986c3751adafbd089da7682b82">face_to_cell_index</a> (const unsigned <a class="el" href="classint.html">int</a> face_dof_index, const unsigned <a class="el" href="classint.html">int</a> face, const <a class="el" href="classbool.html">bool</a> face_orientation=true, const <a class="el" href="classbool.html">bool</a> face_flip=false, const <a class="el" href="classbool.html">bool</a> face_rotation=false) const </td></tr>
<tr class="separator:ac88c06986c3751adafbd089da7682b82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ed8437e4a8a433d8ac71c0765af72a2"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a5ed8437e4a8a433d8ac71c0765af72a2">adjust_quad_dof_index_for_face_orientation</a> (const unsigned <a class="el" href="classint.html">int</a> index, const <a class="el" href="classbool.html">bool</a> face_orientation, const <a class="el" href="classbool.html">bool</a> face_flip, const <a class="el" href="classbool.html">bool</a> face_rotation) const </td></tr>
<tr class="separator:a5ed8437e4a8a433d8ac71c0765af72a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb65b3fe01458595a74236112ae3b76d"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#aeb65b3fe01458595a74236112ae3b76d">adjust_line_dof_index_for_line_orientation</a> (const unsigned <a class="el" href="classint.html">int</a> index, const <a class="el" href="classbool.html">bool</a> line_orientation) const </td></tr>
<tr class="separator:aeb65b3fe01458595a74236112ae3b76d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a976cfdc58da9322c1cf1240cca4a86"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a0a976cfdc58da9322c1cf1240cca4a86">get_nonzero_components</a> (const unsigned <a class="el" href="classint.html">int</a> i) const </td></tr>
<tr class="separator:a0a976cfdc58da9322c1cf1240cca4a86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa55c38a01fb805aca08e1e6d6d0d272f"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#aa55c38a01fb805aca08e1e6d6d0d272f">n_nonzero_components</a> (const unsigned <a class="el" href="classint.html">int</a> i) const </td></tr>
<tr class="separator:aa55c38a01fb805aca08e1e6d6d0d272f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8a57013e9e027acbf1afa1296de42d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#ab8a57013e9e027acbf1afa1296de42d3">is_primitive</a> (const unsigned <a class="el" href="classint.html">int</a> i) const </td></tr>
<tr class="separator:ab8a57013e9e027acbf1afa1296de42d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47ab123a8a467b8d78664630dd7c8881"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a47ab123a8a467b8d78664630dd7c8881">n_base_elements</a> () const </td></tr>
<tr class="separator:a47ab123a8a467b8d78664630dd7c8881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae69718879703c808f7f774ec874ca075"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classFiniteElement.html">FiniteElement</a><br class="typebreak"/>
&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#ae69718879703c808f7f774ec874ca075">base_element</a> (const unsigned <a class="el" href="classint.html">int</a> index) const </td></tr>
<tr class="separator:ae69718879703c808f7f774ec874ca075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c4005d818c8034853c24e2bf24cc01d"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a9c4005d818c8034853c24e2bf24cc01d">element_multiplicity</a> (const unsigned <a class="el" href="classint.html">int</a> index) const </td></tr>
<tr class="separator:a9c4005d818c8034853c24e2bf24cc01d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c1a9946f93d090df3c0ab3ae03e1ac6"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::pair&lt; unsigned <br class="typebreak"/>
<a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;, unsigned <br class="typebreak"/>
<a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a2c1a9946f93d090df3c0ab3ae03e1ac6">system_to_base_index</a> (const unsigned <a class="el" href="classint.html">int</a> index) const </td></tr>
<tr class="separator:a2c1a9946f93d090df3c0ab3ae03e1ac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6ea8e30c668e0ec6431e24adf1946b5"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::pair&lt; unsigned <br class="typebreak"/>
<a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;, unsigned <br class="typebreak"/>
<a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#ae6ea8e30c668e0ec6431e24adf1946b5">face_system_to_base_index</a> (const unsigned <a class="el" href="classint.html">int</a> index) const </td></tr>
<tr class="separator:ae6ea8e30c668e0ec6431e24adf1946b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0ff206343b7dfd44728e62a32cd859a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#af0ff206343b7dfd44728e62a32cd859a">first_block_of_base</a> (const unsigned <a class="el" href="classint.html">int</a> b) const </td></tr>
<tr class="separator:af0ff206343b7dfd44728e62a32cd859a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada25262284d975d8576bd6a59c29e950"><td class="memItemLeft" align="right" valign="top">std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, <br class="typebreak"/>
unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#ada25262284d975d8576bd6a59c29e950">component_to_base_index</a> (const unsigned <a class="el" href="classint.html">int</a> component) const </td></tr>
<tr class="separator:ada25262284d975d8576bd6a59c29e950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d7612a2031e6c5d23a64734612f1ca9"><td class="memItemLeft" align="right" valign="top">std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, <br class="typebreak"/>
unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a1d7612a2031e6c5d23a64734612f1ca9">block_to_base_index</a> (const unsigned <a class="el" href="classint.html">int</a> block) const </td></tr>
<tr class="separator:a1d7612a2031e6c5d23a64734612f1ca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb422a6448b2bd45f2998ca68e242ca1"><td class="memItemLeft" align="right" valign="top">std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, <br class="typebreak"/>
<a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#abb422a6448b2bd45f2998ca68e242ca1">system_to_block_index</a> (const unsigned <a class="el" href="classint.html">int</a> component) const </td></tr>
<tr class="separator:abb422a6448b2bd45f2998ca68e242ca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae432507508728e19aca87bed4053992f"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#ae432507508728e19aca87bed4053992f">component_to_block_index</a> (const unsigned <a class="el" href="classint.html">int</a> component) const </td></tr>
<tr class="separator:ae432507508728e19aca87bed4053992f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Component and block matrices</div></td></tr>
<tr class="memitem:ace1f6cf0a9f0eb472be4df56743851aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classComponentMask.html">ComponentMask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#ace1f6cf0a9f0eb472be4df56743851aa">component_mask</a> (const <a class="el" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> &amp;scalar) const </td></tr>
<tr class="separator:ace1f6cf0a9f0eb472be4df56743851aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a530f6c3f6326e516aeb006e7533a4532"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classComponentMask.html">ComponentMask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a530f6c3f6326e516aeb006e7533a4532">component_mask</a> (const <a class="el" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> &amp;vector) const </td></tr>
<tr class="separator:a530f6c3f6326e516aeb006e7533a4532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c0845775110b0c056301527415e708a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classComponentMask.html">ComponentMask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a6c0845775110b0c056301527415e708a">component_mask</a> (const <a class="el" href="structFEValuesExtractors_1_1SymmetricTensor.html">FEValuesExtractors::SymmetricTensor</a>&lt; 2 &gt; &amp;sym_tensor) const </td></tr>
<tr class="separator:a6c0845775110b0c056301527415e708a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f10e446507800a1bdbf346282f9c11d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classComponentMask.html">ComponentMask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a7f10e446507800a1bdbf346282f9c11d">component_mask</a> (const <a class="el" href="classBlockMask.html">BlockMask</a> &amp;<a class="el" href="classFiniteElement.html#ae1359a1b1d3014a78bd523be8c3e7f29">block_mask</a>) const </td></tr>
<tr class="separator:a7f10e446507800a1bdbf346282f9c11d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1359a1b1d3014a78bd523be8c3e7f29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockMask.html">BlockMask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#ae1359a1b1d3014a78bd523be8c3e7f29">block_mask</a> (const <a class="el" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> &amp;scalar) const </td></tr>
<tr class="separator:ae1359a1b1d3014a78bd523be8c3e7f29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a548bef99cfe1ae9c2f3418392823e338"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockMask.html">BlockMask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a548bef99cfe1ae9c2f3418392823e338">block_mask</a> (const <a class="el" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> &amp;vector) const </td></tr>
<tr class="separator:a548bef99cfe1ae9c2f3418392823e338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a359b7c9f1f395e77ac8466f95a81304f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockMask.html">BlockMask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a359b7c9f1f395e77ac8466f95a81304f">block_mask</a> (const <a class="el" href="structFEValuesExtractors_1_1SymmetricTensor.html">FEValuesExtractors::SymmetricTensor</a>&lt; 2 &gt; &amp;sym_tensor) const </td></tr>
<tr class="separator:a359b7c9f1f395e77ac8466f95a81304f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7968a52626e5e89b3d6658bded5337bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockMask.html">BlockMask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a7968a52626e5e89b3d6658bded5337bc">block_mask</a> (const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;<a class="el" href="classFiniteElement.html#ace1f6cf0a9f0eb472be4df56743851aa">component_mask</a>) const </td></tr>
<tr class="separator:a7968a52626e5e89b3d6658bded5337bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Support points and interpolation</div></td></tr>
<tr class="memitem:a4d0bbfcff05ddbe1d766a5cf7e2adf51"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a4d0bbfcff05ddbe1d766a5cf7e2adf51">get_unit_support_points</a> () const </td></tr>
<tr class="separator:a4d0bbfcff05ddbe1d766a5cf7e2adf51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacd8adea5225d5aa5a24b7d1d60995ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#aacd8adea5225d5aa5a24b7d1d60995ff">has_support_points</a> () const </td></tr>
<tr class="separator:aacd8adea5225d5aa5a24b7d1d60995ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b45b4d2b3b8d3d056155e3c7c0d393b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a3b45b4d2b3b8d3d056155e3c7c0d393b">unit_support_point</a> (const unsigned <a class="el" href="classint.html">int</a> index) const </td></tr>
<tr class="separator:a3b45b4d2b3b8d3d056155e3c7c0d393b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c557f753676d89d4ddfc0cff9d845b4"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim-1 &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a3c557f753676d89d4ddfc0cff9d845b4">get_unit_face_support_points</a> () const </td></tr>
<tr class="separator:a3c557f753676d89d4ddfc0cff9d845b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8082dd2e9d3cd6000a8f57b699e8f66c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a8082dd2e9d3cd6000a8f57b699e8f66c">has_face_support_points</a> () const </td></tr>
<tr class="separator:a8082dd2e9d3cd6000a8f57b699e8f66c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aa894c8be8daf33c67b357ea36d88ea"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; dim-1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a2aa894c8be8daf33c67b357ea36d88ea">unit_face_support_point</a> (const unsigned <a class="el" href="classint.html">int</a> index) const </td></tr>
<tr class="separator:a2aa894c8be8daf33c67b357ea36d88ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d007ccbe875c84dd5848b8ee316dff0"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a9d007ccbe875c84dd5848b8ee316dff0">get_generalized_support_points</a> () const </td></tr>
<tr class="separator:a9d007ccbe875c84dd5848b8ee316dff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e9eebb69e53c5233c99e0e1d506e15d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a0e9eebb69e53c5233c99e0e1d506e15d">has_generalized_support_points</a> () const </td></tr>
<tr class="separator:a0e9eebb69e53c5233c99e0e1d506e15d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa301f369765abbecdf457c25639718ad"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa301f369765abbecdf457c25639718ad"></a>
const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim-1 &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>get_generalized_face_support_points</b> () const </td></tr>
<tr class="separator:aa301f369765abbecdf457c25639718ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a0d8732342cd7f8914b8ede6bd677f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a4a0d8732342cd7f8914b8ede6bd677f4">has_generalized_face_support_points</a> () const </td></tr>
<tr class="separator:a4a0d8732342cd7f8914b8ede6bd677f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9a8396437ea80e8a250eca1c258cca0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#ab9a8396437ea80e8a250eca1c258cca0">interpolate</a> (std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;local_dofs, const std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;values) const </td></tr>
<tr class="separator:ab9a8396437ea80e8a250eca1c258cca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ca0f2619808761bb8cc53ca907368e4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a1ca0f2619808761bb8cc53ca907368e4">interpolate</a> (std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;local_dofs, const std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt; &amp;values, unsigned <a class="el" href="classint.html">int</a> offset=0) const </td></tr>
<tr class="separator:a1ca0f2619808761bb8cc53ca907368e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17a9b5fdf8ba7c9fc2b00102715997d3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a17a9b5fdf8ba7c9fc2b00102715997d3">interpolate</a> (std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;local_dofs, const <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; const std::vector&lt; std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt; &gt; &amp;values) const </td></tr>
<tr class="separator:a17a9b5fdf8ba7c9fc2b00102715997d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSubscriptor"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSubscriptor')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSubscriptor.html">Subscriptor</a></td></tr>
<tr class="memitem:ae5541017c0966b0af345db75895106f2 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#ae5541017c0966b0af345db75895106f2">Subscriptor</a> ()</td></tr>
<tr class="separator:ae5541017c0966b0af345db75895106f2 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367fce3122075f05f168d14f114b4c65 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a367fce3122075f05f168d14f114b4c65">Subscriptor</a> (const <a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;)</td></tr>
<tr class="separator:a367fce3122075f05f168d14f114b4c65 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c6c557e06110d2127fa6459119e94af inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a6c6c557e06110d2127fa6459119e94af">~Subscriptor</a> ()</td></tr>
<tr class="separator:a6c6c557e06110d2127fa6459119e94af inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24ee69d4b3cf9690d1208b2443cbbb80 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a24ee69d4b3cf9690d1208b2443cbbb80">operator=</a> (const <a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;)</td></tr>
<tr class="separator:a24ee69d4b3cf9690d1208b2443cbbb80 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3422499827ecd52f1d12d65eb6cc3125 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a3422499827ecd52f1d12d65eb6cc3125">subscribe</a> (const char *identifier=0) const </td></tr>
<tr class="separator:a3422499827ecd52f1d12d65eb6cc3125 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b4839b1cffc18781144ede1744b35ea inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a2b4839b1cffc18781144ede1744b35ea">unsubscribe</a> (const char *identifier=0) const </td></tr>
<tr class="separator:a2b4839b1cffc18781144ede1744b35ea inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b45274c8e1936bff024df01d618e86f inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a7b45274c8e1936bff024df01d618e86f">n_subscriptions</a> () const </td></tr>
<tr class="separator:a7b45274c8e1936bff024df01d618e86f inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbbc5f845063b1f23223b7ac96e89e13 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#adbbc5f845063b1f23223b7ac96e89e13">list_subscribers</a> () const </td></tr>
<tr class="separator:adbbc5f845063b1f23223b7ac96e89e13 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2f0251d20c6a5295024de3b2e9b4359 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac2f0251d20c6a5295024de3b2e9b4359">DeclException3</a> (ExcInUse, <a class="el" href="classint.html">int</a>, char *, std::string &amp;,&lt;&lt; &quot;Object of class &quot;&lt;&lt; arg2&lt;&lt; &quot; is still used by &quot;&lt;&lt; arg1&lt;&lt; &quot; other objects.\n&quot;&lt;&lt; &quot;(Additional information: &quot;&lt;&lt; arg3&lt;&lt; &quot;)\n&quot;&lt;&lt; &quot;Note the entry in the Frequently Asked Questions of &quot;&lt;&lt; &quot;deal.II (linked to from http://www.dealii.org/) for &quot;&lt;&lt; &quot;more information on what this error means.&quot;)</td></tr>
<tr class="separator:gac2f0251d20c6a5295024de3b2e9b4359 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e000d9ce953da6afe4bbbaca4397344 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga9e000d9ce953da6afe4bbbaca4397344">DeclException2</a> (ExcNoSubscriber, char *, char *,&lt;&lt; &quot;No subscriber with identifier \&quot;&quot;&lt;&lt; arg2&lt;&lt; &quot;\&quot; did <a class="el" href="classSubscriptor.html#a3422499827ecd52f1d12d65eb6cc3125">subscribe</a> to this object of class &quot;&lt;&lt; arg1)</td></tr>
<tr class="separator:ga9e000d9ce953da6afe4bbbaca4397344 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38 inherit pub_methods_classSubscriptor"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38 inherit pub_methods_classSubscriptor"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:a68efd17a8330ab676d9cd711029b0f38 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classFiniteElementData"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classFiniteElementData')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classFiniteElementData.html">FiniteElementData&lt; dim &gt;</a></td></tr>
<tr class="memitem:a5c750454c98f6f6694676d26cdb52015 inherit pub_methods_classFiniteElementData"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a5c750454c98f6f6694676d26cdb52015">FiniteElementData</a> ()</td></tr>
<tr class="separator:a5c750454c98f6f6694676d26cdb52015 inherit pub_methods_classFiniteElementData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a362b97dc8feb2f4cfdcae6409af63957 inherit pub_methods_classFiniteElementData"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a362b97dc8feb2f4cfdcae6409af63957">FiniteElementData</a> (const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;dofs_per_object, const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElementData.html#a8d0f50693017e6c0f9d1ed774a847cd0">n_components</a>, const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a>, const <a class="el" href="classFiniteElementData.html#a0cd5f34c3ab828fac31004f3b52921a1">Conformity</a> conformity=<a class="el" href="classFiniteElementData.html#a0cd5f34c3ab828fac31004f3b52921a1afbb5ba93aed087d17dd0224e65a1bddc">unknown</a>, const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElementData.html#a9a6381005298cdd2440fabc8d9b870c6">n_blocks</a>=<a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>)</td></tr>
<tr class="separator:a362b97dc8feb2f4cfdcae6409af63957 inherit pub_methods_classFiniteElementData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2f91b504d14d849ec4178c444520f35 inherit pub_methods_classFiniteElementData"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#ad2f91b504d14d849ec4178c444520f35">n_dofs_per_vertex</a> () const </td></tr>
<tr class="separator:ad2f91b504d14d849ec4178c444520f35 inherit pub_methods_classFiniteElementData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bf469a8b81618891311bdf5324e6719 inherit pub_methods_classFiniteElementData"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a5bf469a8b81618891311bdf5324e6719">n_dofs_per_line</a> () const </td></tr>
<tr class="separator:a5bf469a8b81618891311bdf5324e6719 inherit pub_methods_classFiniteElementData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95256f9b235623edc8ec55b7528a155a inherit pub_methods_classFiniteElementData"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a95256f9b235623edc8ec55b7528a155a">n_dofs_per_quad</a> () const </td></tr>
<tr class="separator:a95256f9b235623edc8ec55b7528a155a inherit pub_methods_classFiniteElementData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8771a0edb69887e33eec356b8ff6a83f inherit pub_methods_classFiniteElementData"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a8771a0edb69887e33eec356b8ff6a83f">n_dofs_per_hex</a> () const </td></tr>
<tr class="separator:a8771a0edb69887e33eec356b8ff6a83f inherit pub_methods_classFiniteElementData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9045eaec8cb43bbe0378c1206db31680 inherit pub_methods_classFiniteElementData"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a9045eaec8cb43bbe0378c1206db31680">n_dofs_per_face</a> () const </td></tr>
<tr class="separator:a9045eaec8cb43bbe0378c1206db31680 inherit pub_methods_classFiniteElementData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae441da583aa2beff77c3ae9e6f7203e8 inherit pub_methods_classFiniteElementData"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#ae441da583aa2beff77c3ae9e6f7203e8">n_dofs_per_cell</a> () const </td></tr>
<tr class="separator:ae441da583aa2beff77c3ae9e6f7203e8 inherit pub_methods_classFiniteElementData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22c338b029e4c90d917b782a4678dad5 inherit pub_methods_classFiniteElementData"><td class="memTemplParams" colspan="2">template&lt;int structdim&gt; </td></tr>
<tr class="memitem:a22c338b029e4c90d917b782a4678dad5 inherit pub_methods_classFiniteElementData"><td class="memTemplItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a22c338b029e4c90d917b782a4678dad5">n_dofs_per_object</a> () const </td></tr>
<tr class="separator:a22c338b029e4c90d917b782a4678dad5 inherit pub_methods_classFiniteElementData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d0f50693017e6c0f9d1ed774a847cd0 inherit pub_methods_classFiniteElementData"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a8d0f50693017e6c0f9d1ed774a847cd0">n_components</a> () const </td></tr>
<tr class="separator:a8d0f50693017e6c0f9d1ed774a847cd0 inherit pub_methods_classFiniteElementData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a6381005298cdd2440fabc8d9b870c6 inherit pub_methods_classFiniteElementData"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a9a6381005298cdd2440fabc8d9b870c6">n_blocks</a> () const </td></tr>
<tr class="separator:a9a6381005298cdd2440fabc8d9b870c6 inherit pub_methods_classFiniteElementData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca7509a35e0bece72537e271e340d693 inherit pub_methods_classFiniteElementData"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classBlockIndices.html">BlockIndices</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#aca7509a35e0bece72537e271e340d693">block_indices</a> () const </td></tr>
<tr class="separator:aca7509a35e0bece72537e271e340d693 inherit pub_methods_classFiniteElementData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6801989eb6031b2d80e2ffa1e61b1eb0 inherit pub_methods_classFiniteElementData"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a6801989eb6031b2d80e2ffa1e61b1eb0">is_primitive</a> () const </td></tr>
<tr class="separator:a6801989eb6031b2d80e2ffa1e61b1eb0 inherit pub_methods_classFiniteElementData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac03cc798c4852be81a7a3524873f2dc inherit pub_methods_classFiniteElementData"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#aac03cc798c4852be81a7a3524873f2dc">tensor_degree</a> () const </td></tr>
<tr class="separator:aac03cc798c4852be81a7a3524873f2dc inherit pub_methods_classFiniteElementData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96c288c3aa66cfb1f6aa260d384c35c8 inherit pub_methods_classFiniteElementData"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a96c288c3aa66cfb1f6aa260d384c35c8">conforms</a> (const <a class="el" href="classFiniteElementData.html#a0cd5f34c3ab828fac31004f3b52921a1">Conformity</a>) const </td></tr>
<tr class="separator:a96c288c3aa66cfb1f6aa260d384c35c8 inherit pub_methods_classFiniteElementData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a688ca641960445a213263044b21f5ab0 inherit pub_methods_classFiniteElementData"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a688ca641960445a213263044b21f5ab0">operator==</a> (const <a class="el" href="classFiniteElementData.html">FiniteElementData</a> &amp;) const </td></tr>
<tr class="separator:a688ca641960445a213263044b21f5ab0 inherit pub_methods_classFiniteElementData"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a62838f7428ee56e34c4081ca6d03bc26"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a62838f7428ee56e34c4081ca6d03bc26">reinit_restriction_and_prolongation_matrices</a> (const <a class="el" href="classbool.html">bool</a> isotropic_restriction_only=false, const <a class="el" href="classbool.html">bool</a> isotropic_prolongation_only=false)</td></tr>
<tr class="separator:a62838f7428ee56e34c4081ca6d03bc26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc598cf9fe938a1700279c6c6230fd76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTableIndices.html">TableIndices</a>&lt; 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#afc598cf9fe938a1700279c6c6230fd76">interface_constraints_size</a> () const </td></tr>
<tr class="separator:afc598cf9fe938a1700279c6c6230fd76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d12c1ae13a333d1212847df4ec8ad1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a7d12c1ae13a333d1212847df4ec8ad1d">compute_2nd</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const unsigned <a class="el" href="classint.html">int</a> offset, typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &amp;mapping_internal, <a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &amp;fe_internal, <a class="el" href="classFEValuesData.html">FEValuesData</a>&lt; dim, spacedim &gt; &amp;data) const </td></tr>
<tr class="separator:a7d12c1ae13a333d1212847df4ec8ad1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53ec2e9b0b29a6c0df0b941528be0306"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a53ec2e9b0b29a6c0df0b941528be0306">update_once</a> (const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> flags) const =0</td></tr>
<tr class="separator:a53ec2e9b0b29a6c0df0b941528be0306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a876f0be1b38ad6ed2ccad297876e1287"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a876f0be1b38ad6ed2ccad297876e1287">update_each</a> (const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> flags) const =0</td></tr>
<tr class="separator:a876f0be1b38ad6ed2ccad297876e1287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7631a5a3cc67eaf6f498f2bd6ef4151c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, <br class="typebreak"/>
spacedim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a7631a5a3cc67eaf6f498f2bd6ef4151c">clone</a> () const =0</td></tr>
<tr class="separator:a7631a5a3cc67eaf6f498f2bd6ef4151c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classFiniteElementData"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classFiniteElementData')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classFiniteElementData.html">FiniteElementData&lt; dim &gt;</a></td></tr>
<tr class="memitem:ad3bd73d61a8fb121b2f599b44ddea8ce inherit pro_methods_classFiniteElementData"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#ad3bd73d61a8fb121b2f599b44ddea8ce">set_primitivity</a> (const <a class="el" href="classbool.html">bool</a> value)</td></tr>
<tr class="separator:ad3bd73d61a8fb121b2f599b44ddea8ce inherit pro_methods_classFiniteElementData"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:abe780620df7c633e43ca45aba2e4270f"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#abe780620df7c633e43ca45aba2e4270f">compute_n_nonzero_components</a> (const std::vector&lt; <a class="el" href="classComponentMask.html">ComponentMask</a> &gt; &amp;<a class="el" href="classFiniteElement.html#ae6fe073d1e3ce59791b142067482bd5b">nonzero_components</a>)</td></tr>
<tr class="separator:abe780620df7c633e43ca45aba2e4270f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a4993707a4ec342560ff74e5d22401794"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector<br class="typebreak"/>
&lt; <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a4993707a4ec342560ff74e5d22401794">restriction</a></td></tr>
<tr class="separator:a4993707a4ec342560ff74e5d22401794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbc42f850096c429fd39cfcbde1b6b56"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector<br class="typebreak"/>
&lt; <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#afbc42f850096c429fd39cfcbde1b6b56">prolongation</a></td></tr>
<tr class="separator:afbc42f850096c429fd39cfcbde1b6b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8d4cd5afce6a401892aeb5a40ccfa2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#ac8d4cd5afce6a401892aeb5a40ccfa2f">interface_constraints</a></td></tr>
<tr class="separator:ac8d4cd5afce6a401892aeb5a40ccfa2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4f6e0c83686b918fbb92716ead92313"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#ab4f6e0c83686b918fbb92716ead92313">unit_support_points</a></td></tr>
<tr class="separator:ab4f6e0c83686b918fbb92716ead92313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae029888ebd5d91b261bf45aa2bf40b5c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim-1 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#ae029888ebd5d91b261bf45aa2bf40b5c">unit_face_support_points</a></td></tr>
<tr class="separator:ae029888ebd5d91b261bf45aa2bf40b5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2531d00b5c9e77e1e64981864c3b8cc"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#ae2531d00b5c9e77e1e64981864c3b8cc">generalized_support_points</a></td></tr>
<tr class="separator:ae2531d00b5c9e77e1e64981864c3b8cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b614baaf527c796af876c8807f5d7d7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim-1 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a3b614baaf527c796af876c8807f5d7d7">generalized_face_support_points</a></td></tr>
<tr class="separator:a3b614baaf527c796af876c8807f5d7d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46646bf5621c347e3cb3a637857b14b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a46646bf5621c347e3cb3a637857b14b5">adjust_quad_dof_index_for_face_orientation_table</a></td></tr>
<tr class="separator:a46646bf5621c347e3cb3a637857b14b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6659bb0dccc62e2d680c964e5035daf6"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a6659bb0dccc62e2d680c964e5035daf6">adjust_line_dof_index_for_line_orientation_table</a></td></tr>
<tr class="separator:a6659bb0dccc62e2d680c964e5035daf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:aada317cd0cdd78de8f747bc458655218"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;<br class="typebreak"/>
::<a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#aada317cd0cdd78de8f747bc458655218">get_data</a> (const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> flags, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;quadrature) const =0</td></tr>
<tr class="separator:aada317cd0cdd78de8f747bc458655218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a998bb8e8b7ee2a035d039cc558f47898"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;<br class="typebreak"/>
::<a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a998bb8e8b7ee2a035d039cc558f47898">get_face_data</a> (const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> flags, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt; &amp;quadrature) const </td></tr>
<tr class="separator:a998bb8e8b7ee2a035d039cc558f47898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3da3d8441ecd90b4f0ffbb656811245"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;<br class="typebreak"/>
::<a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#ae3da3d8441ecd90b4f0ffbb656811245">get_subface_data</a> (const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> flags, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt; &amp;quadrature) const </td></tr>
<tr class="separator:ae3da3d8441ecd90b4f0ffbb656811245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f982cbcd77e6067fb61c8ec4573091a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a6f982cbcd77e6067fb61c8ec4573091a">fill_fe_values</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;quadrature, typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &amp;mapping_internal, typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &amp;fe_internal, <a class="el" href="classFEValuesData.html">FEValuesData</a>&lt; dim, spacedim &gt; &amp;data, CellSimilarity::Similarity &amp;cell_similarity) const =0</td></tr>
<tr class="separator:a6f982cbcd77e6067fb61c8ec4573091a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab19a60429e5405beb8447a1a7d51765c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#ab19a60429e5405beb8447a1a7d51765c">fill_fe_face_values</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const unsigned <a class="el" href="classint.html">int</a> face_no, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt; &amp;quadrature, typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &amp;mapping_internal, typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &amp;fe_internal, <a class="el" href="classFEValuesData.html">FEValuesData</a>&lt; dim, spacedim &gt; &amp;data) const =0</td></tr>
<tr class="separator:ab19a60429e5405beb8447a1a7d51765c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47a8b30d8917b398bcf9f01e98e16815"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a47a8b30d8917b398bcf9f01e98e16815">fill_fe_subface_values</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const unsigned <a class="el" href="classint.html">int</a> face_no, const unsigned <a class="el" href="classint.html">int</a> sub_no, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt; &amp;quadrature, typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &amp;mapping_internal, typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &amp;fe_internal, <a class="el" href="classFEValuesData.html">FEValuesData</a>&lt; dim, spacedim &gt; &amp;data) const =0</td></tr>
<tr class="separator:a47a8b30d8917b398bcf9f01e98e16815"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:aa95bff4580b63275178a411dfb7785fa"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair<br class="typebreak"/>
&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#aa95bff4580b63275178a411dfb7785fa">system_to_component_table</a></td></tr>
<tr class="separator:aa95bff4580b63275178a411dfb7785fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ea86779f24165679762a660741226ca"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair<br class="typebreak"/>
&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a1ea86779f24165679762a660741226ca">face_system_to_component_table</a></td></tr>
<tr class="separator:a1ea86779f24165679762a660741226ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b487f5fe482180d2c856363ae39ab13"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair<br class="typebreak"/>
&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, <br class="typebreak"/>
unsigned <a class="el" href="classint.html">int</a> &gt;, unsigned <a class="el" href="classint.html">int</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a4b487f5fe482180d2c856363ae39ab13">system_to_base_table</a></td></tr>
<tr class="separator:a4b487f5fe482180d2c856363ae39ab13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a2b6095ae0093bb6c024853d65969e4"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair<br class="typebreak"/>
&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, <br class="typebreak"/>
unsigned <a class="el" href="classint.html">int</a> &gt;, unsigned <a class="el" href="classint.html">int</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a0a2b6095ae0093bb6c024853d65969e4">face_system_to_base_table</a></td></tr>
<tr class="separator:a0a2b6095ae0093bb6c024853d65969e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61f62f39ded99d6525f1c33f4227ee8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockIndices.html">BlockIndices</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a61f62f39ded99d6525f1c33f4227ee8d">base_to_block_indices</a></td></tr>
<tr class="separator:a61f62f39ded99d6525f1c33f4227ee8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf2c44f3a207e0e11880820a29ac37a8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair<br class="typebreak"/>
&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, <br class="typebreak"/>
unsigned <a class="el" href="classint.html">int</a> &gt;, unsigned <a class="el" href="classint.html">int</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#aaf2c44f3a207e0e11880820a29ac37a8">component_to_base_table</a></td></tr>
<tr class="separator:aaf2c44f3a207e0e11880820a29ac37a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8f4833a318127b42d2dc806bffe1c2c"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#aa8f4833a318127b42d2dc806bffe1c2c">restriction_is_additive_flags</a></td></tr>
<tr class="separator:aa8f4833a318127b42d2dc806bffe1c2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6fe073d1e3ce59791b142067482bd5b"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classComponentMask.html">ComponentMask</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#ae6fe073d1e3ce59791b142067482bd5b">nonzero_components</a></td></tr>
<tr class="separator:ae6fe073d1e3ce59791b142067482bd5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b7cb6ef5342900727931ef983636502"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a0b7cb6ef5342900727931ef983636502">n_nonzero_components_table</a></td></tr>
<tr class="separator:a0b7cb6ef5342900727931ef983636502"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr class="memitem:a714350e735a4ade7a1e0d47dcb165b25"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a714350e735a4ade7a1e0d47dcb165b25">fd_step_length</a></td></tr>
<tr class="separator:a714350e735a4ade7a1e0d47dcb165b25"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ad9550b58ee4f8712411e9f795e7baebd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad9550b58ee4f8712411e9f795e7baebd"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>InternalDataBase</b></td></tr>
<tr class="separator:ad9550b58ee4f8712411e9f795e7baebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaae1cf0eb77f09ffb83fe685445f8cd4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaae1cf0eb77f09ffb83fe685445f8cd4"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>FEValuesBase&lt; dim, spacedim &gt;</b></td></tr>
<tr class="separator:aaae1cf0eb77f09ffb83fe685445f8cd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96dfe2e490e255ed133bf6289e47f46f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a96dfe2e490e255ed133bf6289e47f46f"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>FEValues&lt; dim, spacedim &gt;</b></td></tr>
<tr class="separator:a96dfe2e490e255ed133bf6289e47f46f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65a2ae7b2d193590c89e5a5f23d31f81"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a65a2ae7b2d193590c89e5a5f23d31f81"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>FEFaceValues&lt; dim, spacedim &gt;</b></td></tr>
<tr class="separator:a65a2ae7b2d193590c89e5a5f23d31f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5ff73a151c0885be1f554c91eb9668b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad5ff73a151c0885be1f554c91eb9668b"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>FESubfaceValues&lt; dim, spacedim &gt;</b></td></tr>
<tr class="separator:ad5ff73a151c0885be1f554c91eb9668b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78785be83fe52fe27d3efa953679c7b4"><td class="memTemplParams" colspan="2"><a class="anchor" id="a78785be83fe52fe27d3efa953679c7b4"></a>
template&lt;int , int &gt; </td></tr>
<tr class="memitem:a78785be83fe52fe27d3efa953679c7b4"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>FESystem</b></td></tr>
<tr class="separator:a78785be83fe52fe27d3efa953679c7b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b7695f4347ce5afab49759e9ca1b842"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4b7695f4347ce5afab49759e9ca1b842"></a>
template&lt;class POLY , int dim_, int spacedim_&gt; </td></tr>
<tr class="memitem:a4b7695f4347ce5afab49759e9ca1b842"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>FE_PolyTensor</b></td></tr>
<tr class="separator:a4b7695f4347ce5afab49759e9ca1b842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1eae3d5568cefdabdd682acbf1284d5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac1eae3d5568cefdabdd682acbf1284d5"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>hp::FECollection&lt; dim, spacedim &gt;</b></td></tr>
<tr class="separator:ac1eae3d5568cefdabdd682acbf1284d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classFiniteElementData"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classFiniteElementData')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classFiniteElementData.html">FiniteElementData&lt; dim &gt;</a></td></tr>
<tr class="memitem:a0cd5f34c3ab828fac31004f3b52921a1 inherit pub_types_classFiniteElementData"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a0cd5f34c3ab828fac31004f3b52921a1">Conformity</a> { <br/>
&#160;&#160;<a class="el" href="classFiniteElementData.html#a0cd5f34c3ab828fac31004f3b52921a1afbb5ba93aed087d17dd0224e65a1bddc">unknown</a> = 0x00, 
<a class="el" href="classFiniteElementData.html#a0cd5f34c3ab828fac31004f3b52921a1a349c581c3d0e392c33cc41d917eb038c">L2</a> = 0x01, 
<a class="el" href="classFiniteElementData.html#a0cd5f34c3ab828fac31004f3b52921a1a0787dd9aa05e57e4e6009dd73cb1d229">Hcurl</a> = 0x02, 
<a class="el" href="classFiniteElementData.html#a0cd5f34c3ab828fac31004f3b52921a1a11a375871bcf4978f67ff6d7435f81ee">Hdiv</a> = 0x04, 
<br/>
&#160;&#160;<a class="el" href="classFiniteElementData.html#a0cd5f34c3ab828fac31004f3b52921a1a0e986c9c300b61774d25c92ae2a9d054">H1</a> = Hcurl | Hdiv, 
<a class="el" href="classFiniteElementData.html#a0cd5f34c3ab828fac31004f3b52921a1a916ecb570449b2ad08281d708b39bae2">H2</a> = 0x0e
<br/>
 }</td></tr>
<tr class="separator:a0cd5f34c3ab828fac31004f3b52921a1 inherit pub_types_classFiniteElementData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_classFiniteElementData"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classFiniteElementData')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classFiniteElementData.html">FiniteElementData&lt; dim &gt;</a></td></tr>
<tr class="memitem:ad82fdeb0955b7d59f32d5371adaaadbc inherit pub_attribs_classFiniteElementData"><td class="memItemLeft" align="right" valign="top">const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#ad82fdeb0955b7d59f32d5371adaaadbc">dofs_per_vertex</a></td></tr>
<tr class="separator:ad82fdeb0955b7d59f32d5371adaaadbc inherit pub_attribs_classFiniteElementData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a490e2ded19c0a8cad0846e07e57e3e76 inherit pub_attribs_classFiniteElementData"><td class="memItemLeft" align="right" valign="top">const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a490e2ded19c0a8cad0846e07e57e3e76">dofs_per_line</a></td></tr>
<tr class="separator:a490e2ded19c0a8cad0846e07e57e3e76 inherit pub_attribs_classFiniteElementData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00ab27b2dfa5520f2aa56f9bb8223878 inherit pub_attribs_classFiniteElementData"><td class="memItemLeft" align="right" valign="top">const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a00ab27b2dfa5520f2aa56f9bb8223878">dofs_per_quad</a></td></tr>
<tr class="separator:a00ab27b2dfa5520f2aa56f9bb8223878 inherit pub_attribs_classFiniteElementData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9014d27be7564a42c962848db0d2fd75 inherit pub_attribs_classFiniteElementData"><td class="memItemLeft" align="right" valign="top">const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a9014d27be7564a42c962848db0d2fd75">dofs_per_hex</a></td></tr>
<tr class="separator:a9014d27be7564a42c962848db0d2fd75 inherit pub_attribs_classFiniteElementData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c172e26b87c60b3f7e5e3ebf155b62e inherit pub_attribs_classFiniteElementData"><td class="memItemLeft" align="right" valign="top">const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a8c172e26b87c60b3f7e5e3ebf155b62e">first_line_index</a></td></tr>
<tr class="separator:a8c172e26b87c60b3f7e5e3ebf155b62e inherit pub_attribs_classFiniteElementData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca9fc2a37fc1aa814ac73e93baca4bea inherit pub_attribs_classFiniteElementData"><td class="memItemLeft" align="right" valign="top">const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#aca9fc2a37fc1aa814ac73e93baca4bea">first_quad_index</a></td></tr>
<tr class="separator:aca9fc2a37fc1aa814ac73e93baca4bea inherit pub_attribs_classFiniteElementData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a649a135f376e3fba63ecf08c2b17cc64 inherit pub_attribs_classFiniteElementData"><td class="memItemLeft" align="right" valign="top">const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a649a135f376e3fba63ecf08c2b17cc64">first_hex_index</a></td></tr>
<tr class="separator:a649a135f376e3fba63ecf08c2b17cc64 inherit pub_attribs_classFiniteElementData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70cf27d2dabe49e0c1f57954d7d08500 inherit pub_attribs_classFiniteElementData"><td class="memItemLeft" align="right" valign="top">const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a70cf27d2dabe49e0c1f57954d7d08500">first_face_line_index</a></td></tr>
<tr class="separator:a70cf27d2dabe49e0c1f57954d7d08500 inherit pub_attribs_classFiniteElementData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f85f3eae2daee423441fce5e87fa2e6 inherit pub_attribs_classFiniteElementData"><td class="memItemLeft" align="right" valign="top">const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a0f85f3eae2daee423441fce5e87fa2e6">first_face_quad_index</a></td></tr>
<tr class="separator:a0f85f3eae2daee423441fce5e87fa2e6 inherit pub_attribs_classFiniteElementData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a358bffed1fba59ef4df715469473fd36 inherit pub_attribs_classFiniteElementData"><td class="memItemLeft" align="right" valign="top">const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a358bffed1fba59ef4df715469473fd36">dofs_per_face</a></td></tr>
<tr class="separator:a358bffed1fba59ef4df715469473fd36 inherit pub_attribs_classFiniteElementData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2fa3b8d578ba488b4f37061bb0278bb inherit pub_attribs_classFiniteElementData"><td class="memItemLeft" align="right" valign="top">const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a></td></tr>
<tr class="separator:ae2fa3b8d578ba488b4f37061bb0278bb inherit pub_attribs_classFiniteElementData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ccdb4fd2c40a3e3cd92cb0361cddaf8 inherit pub_attribs_classFiniteElementData"><td class="memItemLeft" align="right" valign="top">const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a1ccdb4fd2c40a3e3cd92cb0361cddaf8">components</a></td></tr>
<tr class="separator:a1ccdb4fd2c40a3e3cd92cb0361cddaf8 inherit pub_attribs_classFiniteElementData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cbf5ad6b464871261dbd054bced18a8 inherit pub_attribs_classFiniteElementData"><td class="memItemLeft" align="right" valign="top">const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a></td></tr>
<tr class="separator:a2cbf5ad6b464871261dbd054bced18a8 inherit pub_attribs_classFiniteElementData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca702ba3af0ed17eaffcfbbccf82067f inherit pub_attribs_classFiniteElementData"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classFiniteElementData.html#a0cd5f34c3ab828fac31004f3b52921a1">Conformity</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#aca702ba3af0ed17eaffcfbbccf82067f">conforming_space</a></td></tr>
<tr class="separator:aca702ba3af0ed17eaffcfbbccf82067f inherit pub_attribs_classFiniteElementData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84cc9f47562ef622ffc9825fed691550 inherit pub_attribs_classFiniteElementData"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockIndices.html">BlockIndices</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a84cc9f47562ef622ffc9825fed691550">block_indices_data</a></td></tr>
<tr class="separator:a84cc9f47562ef622ffc9825fed691550 inherit pub_attribs_classFiniteElementData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_attribs_classFiniteElementData"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classFiniteElementData')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="classFiniteElementData.html">FiniteElementData&lt; dim &gt;</a></td></tr>
<tr class="memitem:af40fa679812dc4fcc76496aa9a139050 inherit pub_static_attribs_classFiniteElementData"><td class="memItemLeft" align="right" valign="top">static const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#af40fa679812dc4fcc76496aa9a139050">dimension</a> = dim</td></tr>
<tr class="separator:af40fa679812dc4fcc76496aa9a139050 inherit pub_static_attribs_classFiniteElementData"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int dim, int spacedim&gt;<br/>
class FiniteElement&lt; dim, spacedim &gt;</h3>

<p>Base class for finite elements in arbitrary dimensions. This class provides several fields which describe a specific finite element and which are filled by derived classes. It more or less only offers the fields and access functions which makes it possible to copy finite elements without knowledge of the actual type (linear, quadratic, etc). In particular, the functions to fill the data fields of <a class="el" href="classFEValues.html">FEValues</a> and its derived classes are declared.</p>
<p>The interface of this class is very restrictive. The reason is that finite element values should be accessed only by use of <a class="el" href="classFEValues.html">FEValues</a> objects. These, together with <a class="el" href="classFiniteElement.html">FiniteElement</a> are responsible to provide an optimized implementation.</p>
<p>This class declares the shape functions and their derivatives on the unit cell <img class="formulaInl" alt="$[0,1]^d$" src="form_262.png"/>. The means to transform them onto a given cell in physical space is provided by the <a class="el" href="classFEValues.html">FEValues</a> class with a <a class="el" href="classMapping.html">Mapping</a> object.</p>
<p>The different matrices are initialized with the correct size, such that in the derived (concrete) finite element classes, their entries only have to be filled in; no resizing is needed. If the matrices are not defined by a concrete finite element, they should be resized to zero. This way functions using them can find out, that they are missing. On the other hand, it is possible to use finite element classes without implementation of the full functionality, if only part of it is needed. The functionality under consideration here is hanging nodes constraints and grid transfer, respectively.</p>
<p>The <code>spacedim</code> parameter has to be used if one wants to solve problems in the boundary element method formulation or in an equivalent one, as it is explained in the <a class="el" href="classTriangulation.html">Triangulation</a> class. If not specified, this parameter takes the default value <code>=dim</code> so that this class can be used to solve problems in the finite element method formulation.</p>
<h3>Components and blocks</h3>
<p>For vector valued elements shape functions may have nonzero entries in one or several <a class="el" href="DEALGlossary.html#GlossComponent">components</a> of the vector valued function. If the element is <a class="el" href="DEALGlossary.html#GlossPrimitive">primitive</a>, there is indeed a single component with a nonzero entry for each shape function. This component can be determined by <a class="el" href="classFiniteElement.html#a27220a135402b96c7e6eecbb04acda56">system_to_component_index()</a>, the number of components is <a class="el" href="classFiniteElementData.html#a8d0f50693017e6c0f9d1ed774a847cd0">FiniteElementData::n_components()</a>.</p>
<p>Furthermore, you may want to split your linear system into <a class="el" href="DEALGlossary.html#GlossBlock">blocks</a> for the use in <a class="el" href="classBlockVector.html">BlockVector</a>, <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>, <a class="el" href="classBlockMatrixArray.html">BlockMatrixArray</a> and so on. If you use non-primitive elements, you cannot determine the block number by <a class="el" href="classFiniteElement.html#a27220a135402b96c7e6eecbb04acda56">system_to_component_index()</a>. Instead, you can use <a class="el" href="classFiniteElement.html#abb422a6448b2bd45f2998ca68e242ca1">system_to_block_index()</a>, which will automatically take care of the additional components occupied by vector valued elements. The number of generated blocks can be determined by <a class="el" href="classFiniteElementData.html#a9a6381005298cdd2440fabc8d9b870c6">FiniteElementData::n_blocks()</a>.</p>
<p>If you decide to operate by base element and multiplicity, the function <a class="el" href="classFiniteElement.html#af0ff206343b7dfd44728e62a32cd859a">first_block_of_base()</a> will be helpful.</p>
<h3>Support points</h3>
<p>Since a <a class="el" href="classFiniteElement.html">FiniteElement</a> does not have information on the actual grid cell, it can only provide <a class="el" href="DEALGlossary.html#GlossSupport">support points</a> on the unit cell. Support points on the actual grid cell must be computed by mapping these points. The class used for this kind of operation is <a class="el" href="classFEValues.html">FEValues</a>. In most cases, code of the following type will serve to provide the mapped support points.</p>
<div class="fragment"><div class="line"><a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> dummy_quadrature (fe.get_unit_support_points());</div>
<div class="line"><a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>   fe_values (mapping, fe, dummy_quadrature,</div>
<div class="line">                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div>
<div class="line">fe_values.reinit (cell);</div>
<div class="line"><a class="code" href="classPoint.html">Point&lt;dim&gt;</a> mapped_point = fe_values.quadrature_point (i);</div>
</div><!-- fragment --><p>Alternatively, the points can be transformed one-by-one: </p>
<div class="fragment"><div class="line"><span class="keyword">const</span> vector&lt;Point&lt;dim&gt; &gt; &amp;unit_points =</div>
<div class="line">   fe.get_unit_support_points();</div>
<div class="line"></div>
<div class="line"><a class="code" href="classPoint.html">Point&lt;dim&gt;</a> mapped_point =</div>
<div class="line">   mapping.transform_unit_to_real_cell (cell, unit_points[i]);</div>
</div><!-- fragment --><p> This is a shortcut, and as all shortcuts should be used cautiously. If the mapping of all support points is needed, the first variant should be preferred for efficiency.</p>
<dl class="section note"><dt>Note</dt><dd>Finite elements' implementation of the <a class="el" href="classFiniteElement.html#a4d0bbfcff05ddbe1d766a5cf7e2adf51">get_unit_support_points()</a> returns these points in the same order as shape functions. As a consequence, the quadrature points accessed above are also ordered in this way. The order of shape functions is typically documented in the class documentation of the various finite element classes.</dd></dl>
<h3>Notes on the implementation of derived classes</h3>
<p>The following sections list the information to be provided by derived classes, depending on the dimension. They are followed by a list of functions helping to generate these values.</p>
<h4>Finite elements in one dimension</h4>
<p>Finite elements in one dimension need only set the <a class="el" href="classFiniteElement.html#a4993707a4ec342560ff74e5d22401794">restriction</a> and <a class="el" href="classFiniteElement.html#afbc42f850096c429fd39cfcbde1b6b56">prolongation</a> matrices. The constructor of this class in one dimension presets the <a class="el" href="classFiniteElement.html#ac8d4cd5afce6a401892aeb5a40ccfa2f">interface_constraints</a> matrix to have dimension zero. Changing this behaviour in derived classes is generally not a reasonable idea and you risk getting into trouble.</p>
<h4>Finite elements in two dimensions</h4>
<p>In addition to the fields already present in 1D, a constraint matrix is needed, if the finite element has node values located on edges or vertices. These constraints are represented by an <img class="formulaInl" alt="$m\times n$" src="form_263.png"/>-matrix <a class="el" href="classFiniteElement.html#ac8d4cd5afce6a401892aeb5a40ccfa2f">interface_constraints</a>, where <em>m</em> is the number of degrees of freedom on the refined side without the corner vertices (those dofs on the middle vertex plus those on the two lines), and <em>n</em> is that of the unrefined side (those dofs on the two vertices plus those on the line). The matrix is thus a rectangular one. The <img class="formulaInl" alt="$m\times n$" src="form_263.png"/> size of the <a class="el" href="classFiniteElement.html#ac8d4cd5afce6a401892aeb5a40ccfa2f">interface_constraints</a> matrix can also be accessed through the <a class="el" href="classFiniteElement.html#afc598cf9fe938a1700279c6c6230fd76">interface_constraints_size()</a> function.</p>
<p>The mapping of the dofs onto the indices of the matrix on the unrefined side is as follows: let <img class="formulaInl" alt="$d_v$" src="form_264.png"/> be the number of dofs on a vertex, <img class="formulaInl" alt="$d_l$" src="form_265.png"/> that on a line, then <img class="formulaInl" alt="$n=0...d_v-1$" src="form_266.png"/> refers to the dofs on vertex zero of the unrefined line, <img class="formulaInl" alt="$n=d_v...2d_v-1$" src="form_267.png"/> to those on vertex one, <img class="formulaInl" alt="$n=2d_v...2d_v+d_l-1$" src="form_268.png"/> to those on the line.</p>
<p>Similarly, <img class="formulaInl" alt="$m=0...d_v-1$" src="form_269.png"/> refers to the dofs on the middle vertex of the refined side (vertex one of child line zero, vertex zero of child line one), <img class="formulaInl" alt="$m=d_v...d_v+d_l-1$" src="form_270.png"/> refers to the dofs on child line zero, <img class="formulaInl" alt="$m=d_v+d_l...d_v+2d_l-1$" src="form_271.png"/> refers to the dofs on child line one. Please note that we do not need to reserve space for the dofs on the end vertices of the refined lines, since these must be mapped one-to-one to the appropriate dofs of the vertices of the unrefined line.</p>
<p>It should be noted that it is not possible to distribute a constrained degree of freedom to other degrees of freedom which are themselves constrained. Only one level of indirection is allowed. It is not known at the time of this writing whether this is a constraint itself.</p>
<h4>Finite elements in three dimensions</h4>
<p>For the interface constraints, almost the same holds as for the 2D case. The numbering for the indices <img class="formulaInl" alt="$n$" src="form_156.png"/> on the mother face is obvious and keeps to the usual numbering of degrees of freedom on quadrilaterals.</p>
<p>The numbering of the degrees of freedom on the interior of the refined faces for the index <img class="formulaInl" alt="$m$" src="form_272.png"/> is as follows: let <img class="formulaInl" alt="$d_v$" src="form_264.png"/> and <img class="formulaInl" alt="$d_l$" src="form_265.png"/> be as above, and <img class="formulaInl" alt="$d_q$" src="form_273.png"/> be the number of degrees of freedom per quadrilateral (and therefore per face), then <img class="formulaInl" alt="$m=0...d_v-1$" src="form_269.png"/> denote the dofs on the vertex at the center, <img class="formulaInl" alt="$m=d_v...5d_v-1$" src="form_274.png"/> for the dofs on the vertices at the center of the bounding lines of the quadrilateral, <img class="formulaInl" alt="$m=5d_v..5d_v+4*d_l-1$" src="form_275.png"/> are for the degrees of freedom on the four lines connecting the center vertex to the outer boundary of the mother face, <img class="formulaInl" alt="$m=5d_v+4*d_l...5d_v+4*d_l+8*d_l-1$" src="form_276.png"/> for the degrees of freedom on the small lines surrounding the quad, and <img class="formulaInl" alt="$m=5d_v+12*d_l...5d_v+12*d_l+4*d_q-1$" src="form_277.png"/> for the dofs on the four child faces. Note the direction of the lines at the boundary of the quads, as shown below.</p>
<p>The order of the twelve lines and the four child faces can be extracted from the following sketch, where the overall order of the different dof groups is depicted: </p>
<pre class="fragment">*    *--15--4--16--*
*    |      |      |
*    10 19  6  20  12
*    |      |      |
*    1--7---0--8---2
*    |      |      |
*    9  17  5  18  11
*    |      |      |
*    *--13--3--14--*
* </pre><p> The numbering of vertices and lines, as well as the numbering of children within a line is consistent with the one described in <a class="el" href="classTriangulation.html">Triangulation</a>. Therefore, this numbering is seen from the outside and inside, respectively, depending on the face.</p>
<p>The three-dimensional case has a few pitfalls available for derived classes that want to implement constraint matrices. Consider the following case: </p>
<pre class="fragment">*          *-------*
*         /       /|
*        /       / |
*       /       /  |
*      *-------*   |
*      |       |   *-------*
*      |       |  /       /|
*      |   1   | /       / |
*      |       |/       /  |
*      *-------*-------*   |
*      |       |       |   *
*      |       |       |  /
*      |   2   |   3   | /
*      |       |       |/
*      *-------*-------*
* </pre><p> Now assume that we want to refine cell 2. We will end up with two faces with hanging nodes, namely the faces between cells 1 and 2, as well as between cells 2 and 3. Constraints have to be applied to the degrees of freedom on both these faces. The problem is that there is now an edge (the top right one of cell 2) which is part of both faces. The hanging node(s) on this edge are therefore constrained twice, once from both faces. To be meaningful, these constraints of course have to be consistent: both faces have to constrain the hanging nodes on the edge to the same nodes on the coarse edge (and only on the edge, as there can then be no constraints to nodes on the rest of the face), and they have to do so with the same weights. This is sometimes tricky since the nodes on the edge may have different local numbers.</p>
<p>For the constraint matrix this means the following: if a degree of freedom on one edge of a face is constrained by some other nodes on the same edge with some weights, then the weights have to be exactly the same as those for constrained nodes on the three other edges with respect to the corresponding nodes on these edges. If this isn't the case, you will get into trouble with the <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> class that is the primary consumer of the constraint information: while that class is able to handle constraints that are entered more than once (as is necessary for the case above), it insists that the weights are exactly the same.</p>
<h4>Helper functions</h4>
<p>Construction of a finite element and computation of the matrices described above may be a tedious task, in particular if it has to be performed for several dimensions. Therefore, some functions in <a class="el" href="namespaceFETools.html">FETools</a> have been provided to help with these tasks.</p>
<h5>Computing the correct basis from "raw" basis functions</h5>
<p>First, already the basis of the shape function space may be difficult to implement for arbitrary order and dimension. On the other hand, if the <a class="el" href="DEALGlossary.html#GlossNodes">node values</a> are given, then the duality relation between node functionals and basis functions defines the basis. As a result, the shape function space may be defined with arbitrary "raw" basis functions, such that the actual finite element basis is computed from linear combinations of them. The coefficients of these combinations are determined by the duality of node values.</p>
<p>Using this matrix allows the construction of the basis of shape functions in two steps. </p>
<ol>
<li>
<p class="startli">Define the space of shape functions using an arbitrary basis <em>w<sub>j</sub></em> and compute the matrix <em>M</em> of node functionals <em>N<sub>i</sub></em> applied to these basis functions, such that its entries are <em>m<sub>ij</sub> = N<sub>i</sub>(w<sub>j</sub>)</em>.</p>
<p class="endli"></p>
</li>
<li>
Compute the basis <em>v<sub>j</sub></em> of the finite element shape function space by applying <em>M<sup>-1</sup></em> to the basis <em>w<sub>j</sub></em>. </li>
</ol>
<p>The function computing the matrix <em>M</em> for you is <a class="el" href="namespaceFETools.html#ab0b7f5e7d5fd89b6cef5141dfbeac3e9">FETools::compute_node_matrix()</a>. It relies on the existence of <a class="el" href="classFiniteElement.html#ae2531d00b5c9e77e1e64981864c3b8cc">generalized_support_points</a> and implementation of <a class="el" href="classFiniteElement.html#ab9a8396437ea80e8a250eca1c258cca0">interpolate()</a> with <a class="el" href="classVectorSlice.html">VectorSlice</a> argument. See the <a class="el" href="DEALGlossary.html#GlossGeneralizedSupport">glossary entry on generalized support points</a> for more information.</p>
<p>The piece of code in the constructor of a finite element responsible for this looks like </p>
<div class="fragment"><div class="line"><a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> M(this-&gt;<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>, this-&gt;<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>);</div>
<div class="line"><a class="code" href="namespaceFETools.html#ab0b7f5e7d5fd89b6cef5141dfbeac3e9">FETools::compute_node_matrix</a>(M, *<span class="keyword">this</span>);</div>
<div class="line">this-&gt;inverse_node_matrix.reinit(this-&gt;<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>, this-&gt;<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>);</div>
<div class="line">this-&gt;inverse_node_matrix.invert(M);</div>
</div><!-- fragment --><p> Don't forget to make sure that <a class="el" href="classFiniteElement.html#ab4f6e0c83686b918fbb92716ead92313">unit_support_points</a> or <a class="el" href="classFiniteElement.html#ae2531d00b5c9e77e1e64981864c3b8cc">generalized_support_points</a> are initialized before this!</p>
<h5>Computing the <a class="el" href="classFiniteElement.html#afbc42f850096c429fd39cfcbde1b6b56">prolongation</a> matrices for multigrid</h5>
<p>Once the shape functions are set up, the grid transfer matrices for <a class="el" href="classMultigrid.html">Multigrid</a> accessed by <a class="el" href="classFiniteElement.html#ac5e488d17d3e34a84166d8c7ca95c22a">get_prolongation_matrix()</a> can be computed automatically, using <a class="el" href="namespaceFETools.html#a62bdda6b45855efb3480abd6d586f8b6">FETools::compute_embedding_matrices()</a>.</p>
<p>This can be achieved by </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;GeometryInfo&lt;dim&gt;::children_per_cell; ++i)</div>
<div class="line">this-&gt;<a class="code" href="classFiniteElement.html#afbc42f850096c429fd39cfcbde1b6b56">prolongation</a>[i].reinit (this-&gt;<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>,</div>
<div class="line">this-&gt;<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>);</div>
<div class="line"><a class="code" href="namespaceFETools.html#a62bdda6b45855efb3480abd6d586f8b6">FETools::compute_embedding_matrices</a> (*<span class="keyword">this</span>, this-&gt;<a class="code" href="classFiniteElement.html#afbc42f850096c429fd39cfcbde1b6b56">prolongation</a>);</div>
</div><!-- fragment --><h5>Computing the <a class="el" href="classFiniteElement.html#a4993707a4ec342560ff74e5d22401794">restriction</a> matrices for error estimators</h5>
<p>missing...</p>
<h5>Computing <a class="el" href="classFiniteElement.html#ac8d4cd5afce6a401892aeb5a40ccfa2f">interface_constraints</a></h5>
<p>Constraint matrices can be computed semi-automatically using <a class="el" href="namespaceFETools.html#ae4ab9ff4946df4bb6a456659dfc281f3">FETools::compute_face_embedding_matrices()</a>. This function computes the representation of the coarse mesh functions by fine mesh functions for each child of a face separately. These matrices must be convoluted into a single rectangular constraint matrix, eliminating degrees of freedom on common vertices and edges as well as on the coarse grid vertices. See the discussion above for details.</p>
<dl class="section author"><dt>Author</dt><dd>Wolfgang Bangerth, Guido Kanschat, Ralf Hartmann, 1998, 2000, 2001, 2005 </dd></dl>

<p>Definition at line <a class="el" href="fe__tools_8h_source.html#l00037">37</a> of file <a class="el" href="fe__tools_8h_source.html">fe_tools.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a904941a97e1f4e87d2770c8e9fe455c1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::<a class="el" href="classFiniteElement.html">FiniteElement</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>restriction_is_additive_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classComponentMask.html">ComponentMask</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nonzero_components</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor </p>

</div>
</div>
<a class="anchor" id="a0e9539f277b1d01364c5b0cf2d6d804c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::~<a class="el" href="classFiniteElement.html">FiniteElement</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Virtual destructor. Makes sure that pointers to this class are deleted properly. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a09655d1d2555af8dcd48caebd4039d29"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::get_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a string that uniquely identifies a finite element. The general convention is that this is the class name, followed by the dimension in angle brackets, and the polynomial degree and whatever else is necessary in parentheses. For example, <code>FE_Q&lt;2&gt;(3)</code> is the value returned for a cubic element in 2d.</p>
<p>Systems of elements have their own naming convention, see the <a class="el" href="classFESystem.html">FESystem</a> class. </p>

<p>Implemented in <a class="el" href="classFE__DGQArbitraryNodes.html#adbbbae52cd3f65d9e6674878ff8f83aa">FE_DGQArbitraryNodes&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__RaviartThomasNodal.html#ab6227c8eceb6872013c47af395be8074">FE_RaviartThomasNodal&lt; dim &gt;</a>, <a class="el" href="classFE__DGBDM.html#ac5b832fd8e64c1264e6398dd275e3f7b">FE_DGBDM&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q.html#a168dff8e08bacd82c7c5fafc91cd0b74">FE_Q&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGRaviartThomas.html#a14df027db15e3a450916ae769f385400">FE_DGRaviartThomas&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q.html#a168dff8e08bacd82c7c5fafc91cd0b74">FE_Q&lt; dim &gt;</a>, <a class="el" href="classFE__Q__DG0.html#a689adb785942bd9a8ae05da2189b4838">FE_Q_DG0&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Hierarchical.html#ad297e788f77d946b9c38f27a4a44a1ad">FE_Q_Hierarchical&lt; dim &gt;</a>, <a class="el" href="classFESystem.html#aca20b77c640390e8b17a5bc4d5cfe3f6">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGNedelec.html#a945ba519aaa6a9ead78c4a4814ce813f">FE_DGNedelec&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Nedelec.html#a65d5b396cc4947ba082c3081b3baacfc">FE_Nedelec&lt; dim &gt;</a>, <a class="el" href="classFE__FaceP.html#a2b5624ae247c57e2ddd5373000d4541d">FE_FaceP&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGP.html#a0aee67fb4e541a1459df5d7020980f0f">FE_DGP&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__RaviartThomas.html#a5ec52509f005b33dee2f2a1da21e37f7">FE_RaviartThomas&lt; dim &gt;</a>, <a class="el" href="classFE__Q__iso__Q1.html#a35253744eca85fbab3398f40506acf8a">FE_Q_iso_Q1&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__ABF.html#a77e8af70ef904839573cccba779b08a8">FE_ABF&lt; dim &gt;</a>, <a class="el" href="classFE__Nothing.html#a11b7ffd4ba4a6bb707f165296bb816e1">FE_Nothing&lt; dim &gt;</a>, <a class="el" href="classFE__DGPMonomial.html#aa8021b978d7f0c9759d9410d6ad7f6b6">FE_DGPMonomial&lt; dim &gt;</a>, <a class="el" href="classFE__DGQ.html#a0d92cbb85e7f488b484c36f8803ae9ab">FE_DGQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGVector.html#ab78e8a7b001dc42975c1a04e90bf1f28">FE_DGVector&lt; POLY, dim, spacedim &gt;</a>, <a class="el" href="classFE__DGVector.html#ab78e8a7b001dc42975c1a04e90bf1f28">FE_DGVector&lt; PolynomialsRaviartThomas&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__DGVector.html#ab78e8a7b001dc42975c1a04e90bf1f28">FE_DGVector&lt; PolynomialsBDM&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__DGVector.html#ab78e8a7b001dc42975c1a04e90bf1f28">FE_DGVector&lt; PolynomialsNedelec&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__DGPNonparametric.html#abc91a8ad030faaf290ec36cd633a2dcd">FE_DGPNonparametric&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__BDM.html#a24c76054651a8a1b27d60fd5ed1a3f92">FE_BDM&lt; dim &gt;</a>, and <a class="el" href="classFE__FaceQ.html#acbc4751969f153bf3f1130414535bc35">FE_FaceQ&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="aea9442ccbb721a725ca67376302e1d22"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>fe_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This operator returns a reference to the present object if the argument given equals to zero. While this does not seem particularly useful, it is helpful in writing code that works with both <a class="el" href="classDoFHandler.html">DoFHandler</a> and the hp version <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>, since one can then write code like this: </p>
<div class="fragment"><div class="line"><a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a></div>
<div class="line">  = dof_handler-&gt;<a class="code" href="classDoFHandler.html#a3f667f0151bf00e5a364cb65ef2672ab">get_fe</a>()[cell-&gt;active_fe_index()].dofs_per_cell;</div>
</div><!-- fragment --><p>This code doesn't work in both situations without the present operator because <a class="el" href="classDoFHandler.html#a3f667f0151bf00e5a364cb65ef2672ab">DoFHandler::get_fe()</a> returns a finite element, whereas <a class="el" href="classhp_1_1DoFHandler.html#add638ef7c2aacf29ca8a4657034bc645">hp::DoFHandler::get_fe()</a> returns a collection of finite elements that doesn't offer a <code>dofs_per_cell</code> member variable: one first has to select which finite element to work on, which is done using the operator[]. Fortunately, <code>cell-&gt;active_fe_index()</code> also works for non-hp classes and simply returns zero in that case. The present operator[] accepts this zero argument, by returning the finite element with index zero within its collection (that, of course, consists only of the present finite element anyway). </p>

<p>Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02036">2036</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a class="anchor" id="a79da090fe75c199ea6800fbcfc351e93"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdouble.html">double</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::shape_value </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the value of the <code>ith</code> shape function at the point <code>p</code>. <code>p</code> is a point on the reference element. If the finite element is vector-valued, then return the value of the only non-zero component of the vector value of this shape function. If the shape function has more than one non-zero component (which we refer to with the term non-primitive), then derived classes implementing this function should throw an exception of type ExcShapeFunctionNotPrimitive. In that case, use the <a class="el" href="classFiniteElement.html#aefcc7c236f03ca92cbce5cd1d838cc09">shape_value_component()</a> function.</p>
<p>An ExcUnitShapeValuesDoNotExist is thrown if the shape values of the <a class="el" href="classFiniteElement.html">FiniteElement</a> under consideration depends on the shape of the cell in real space. </p>

<p>Reimplemented in <a class="el" href="classFESystem.html#a602059597f59626311ec9ce4f91f79ea">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Nothing.html#a10c7ac17f8db33c1d54feb0548523262">FE_Nothing&lt; dim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#ad45eef73fd08a2a465db38f053387abd">FE_PolyTensor&lt; POLY, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#ad45eef73fd08a2a465db38f053387abd">FE_PolyTensor&lt; PolynomialsRaviartThomas&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#ad45eef73fd08a2a465db38f053387abd">FE_PolyTensor&lt; PolynomialsNedelec&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#ad45eef73fd08a2a465db38f053387abd">FE_PolyTensor&lt; PolynomialsRaviartThomas&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#ad45eef73fd08a2a465db38f053387abd">FE_PolyTensor&lt; PolynomialsBDM&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#ad45eef73fd08a2a465db38f053387abd">FE_PolyTensor&lt; PolynomialsBDM&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#ad45eef73fd08a2a465db38f053387abd">FE_PolyTensor&lt; PolynomialsABF&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#ad45eef73fd08a2a465db38f053387abd">FE_PolyTensor&lt; PolynomialsNedelec&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#a534e0ba7998fe81b3bd4314a48b7b55d">FE_Poly&lt; POLY, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#a534e0ba7998fe81b3bd4314a48b7b55d">FE_Poly&lt; PolynomialSpace&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#a534e0ba7998fe81b3bd4314a48b7b55d">FE_Poly&lt; PolynomialsP&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__Poly.html#a534e0ba7998fe81b3bd4314a48b7b55d">FE_Poly&lt; TensorProductPolynomials&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__Poly.html#a534e0ba7998fe81b3bd4314a48b7b55d">FE_Poly&lt; TensorProductPolynomials&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#a534e0ba7998fe81b3bd4314a48b7b55d">FE_Poly&lt; TensorProductPolynomialsConst&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#a534e0ba7998fe81b3bd4314a48b7b55d">FE_Poly&lt; TensorProductPolynomials&lt; dim, Polynomials::PiecewisePolynomial&lt; double &gt; &gt;, dim, spacedim &gt;</a>, and <a class="el" href="classFE__DGPNonparametric.html#ac58a5113e04711d727d03a59af4b3915">FE_DGPNonparametric&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="aefcc7c236f03ca92cbce5cd1d838cc09"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdouble.html">double</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::shape_value_component </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Just like for <a class="el" href="classFiniteElement.html#a79da090fe75c199ea6800fbcfc351e93">shape_value()</a>, but this function will be called when the shape function has more than one non-zero vector component. In that case, this function should return the value of the <code>component-th</code> vector component of the <code>ith</code> shape function at point <code>p</code>. </p>

<p>Reimplemented in <a class="el" href="classFESystem.html#ab9e02a31bd6594575f84a9d0d0566077">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#aba114c20cec71ea7d55a9fa7ca832cbd">FE_PolyTensor&lt; POLY, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#aba114c20cec71ea7d55a9fa7ca832cbd">FE_PolyTensor&lt; PolynomialsRaviartThomas&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#aba114c20cec71ea7d55a9fa7ca832cbd">FE_PolyTensor&lt; PolynomialsNedelec&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#aba114c20cec71ea7d55a9fa7ca832cbd">FE_PolyTensor&lt; PolynomialsRaviartThomas&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#aba114c20cec71ea7d55a9fa7ca832cbd">FE_PolyTensor&lt; PolynomialsBDM&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#aba114c20cec71ea7d55a9fa7ca832cbd">FE_PolyTensor&lt; PolynomialsBDM&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#aba114c20cec71ea7d55a9fa7ca832cbd">FE_PolyTensor&lt; PolynomialsABF&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#aba114c20cec71ea7d55a9fa7ca832cbd">FE_PolyTensor&lt; PolynomialsNedelec&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#a447974614bfb70c459b59424b6a21e64">FE_Poly&lt; POLY, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#a447974614bfb70c459b59424b6a21e64">FE_Poly&lt; PolynomialSpace&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#a447974614bfb70c459b59424b6a21e64">FE_Poly&lt; PolynomialsP&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__Poly.html#a447974614bfb70c459b59424b6a21e64">FE_Poly&lt; TensorProductPolynomials&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__Poly.html#a447974614bfb70c459b59424b6a21e64">FE_Poly&lt; TensorProductPolynomials&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#a447974614bfb70c459b59424b6a21e64">FE_Poly&lt; TensorProductPolynomialsConst&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#a447974614bfb70c459b59424b6a21e64">FE_Poly&lt; TensorProductPolynomials&lt; dim, Polynomials::PiecewisePolynomial&lt; double &gt; &gt;, dim, spacedim &gt;</a>, and <a class="el" href="classFE__DGPNonparametric.html#a649c06017acf71d97a70e54d16551a32">FE_DGPNonparametric&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="aeccda3bf6763cc33dd42f43c92395f64"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classTensor.html">Tensor</a>&lt;1,dim&gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::shape_grad </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the gradient of the <code>ith</code> shape function at the point <code>p</code>. <code>p</code> is a point on the reference element, and likewise the gradient is the gradient on the unit cell with respect to unit cell coordinates. If the finite element is vector-valued, then return the value of the only non-zero component of the vector value of this shape function. If the shape function has more than one non-zero component (which we refer to with the term non-primitive), then derived classes implementing this function should throw an exception of type ExcShapeFunctionNotPrimitive. In that case, use the <a class="el" href="classFiniteElement.html#aa251d27289ecc281cdd43753ccc748fb">shape_grad_component()</a> function.</p>
<p>An ExcUnitShapeValuesDoNotExist is thrown if the shape values of the <a class="el" href="classFiniteElement.html">FiniteElement</a> under consideration depends on the shape of the cell in real space. </p>

<p>Reimplemented in <a class="el" href="classFESystem.html#a6012c59355e52cad321367dd847ca39b">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a83b3918fb1b7a31bf2a6dabae3aef5cd">FE_PolyTensor&lt; POLY, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a83b3918fb1b7a31bf2a6dabae3aef5cd">FE_PolyTensor&lt; PolynomialsRaviartThomas&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a83b3918fb1b7a31bf2a6dabae3aef5cd">FE_PolyTensor&lt; PolynomialsNedelec&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a83b3918fb1b7a31bf2a6dabae3aef5cd">FE_PolyTensor&lt; PolynomialsRaviartThomas&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a83b3918fb1b7a31bf2a6dabae3aef5cd">FE_PolyTensor&lt; PolynomialsBDM&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a83b3918fb1b7a31bf2a6dabae3aef5cd">FE_PolyTensor&lt; PolynomialsBDM&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a83b3918fb1b7a31bf2a6dabae3aef5cd">FE_PolyTensor&lt; PolynomialsABF&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a83b3918fb1b7a31bf2a6dabae3aef5cd">FE_PolyTensor&lt; PolynomialsNedelec&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#ae10c817d078ad872a7f68f3cbc4cebd9">FE_Poly&lt; POLY, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#ae10c817d078ad872a7f68f3cbc4cebd9">FE_Poly&lt; PolynomialSpace&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#ae10c817d078ad872a7f68f3cbc4cebd9">FE_Poly&lt; PolynomialsP&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__Poly.html#ae10c817d078ad872a7f68f3cbc4cebd9">FE_Poly&lt; TensorProductPolynomials&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__Poly.html#ae10c817d078ad872a7f68f3cbc4cebd9">FE_Poly&lt; TensorProductPolynomials&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#ae10c817d078ad872a7f68f3cbc4cebd9">FE_Poly&lt; TensorProductPolynomialsConst&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#ae10c817d078ad872a7f68f3cbc4cebd9">FE_Poly&lt; TensorProductPolynomials&lt; dim, Polynomials::PiecewisePolynomial&lt; double &gt; &gt;, dim, spacedim &gt;</a>, and <a class="el" href="classFE__DGPNonparametric.html#af99d3198296b2f0bd5888a1015ca698e">FE_DGPNonparametric&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="aa251d27289ecc281cdd43753ccc748fb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classTensor.html">Tensor</a>&lt;1,dim&gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::shape_grad_component </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Just like for <a class="el" href="classFiniteElement.html#aeccda3bf6763cc33dd42f43c92395f64">shape_grad()</a>, but this function will be called when the shape function has more than one non-zero vector component. In that case, this function should return the gradient of the <code>component-th</code> vector component of the <code>ith</code> shape function at point <code>p</code>. </p>

<p>Reimplemented in <a class="el" href="classFESystem.html#aa39a18eb894d4debcb2dccafa56f9f76">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a56b4fec87c113f7818cad3427540fec3">FE_PolyTensor&lt; POLY, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a56b4fec87c113f7818cad3427540fec3">FE_PolyTensor&lt; PolynomialsRaviartThomas&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a56b4fec87c113f7818cad3427540fec3">FE_PolyTensor&lt; PolynomialsNedelec&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a56b4fec87c113f7818cad3427540fec3">FE_PolyTensor&lt; PolynomialsRaviartThomas&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a56b4fec87c113f7818cad3427540fec3">FE_PolyTensor&lt; PolynomialsBDM&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a56b4fec87c113f7818cad3427540fec3">FE_PolyTensor&lt; PolynomialsBDM&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a56b4fec87c113f7818cad3427540fec3">FE_PolyTensor&lt; PolynomialsABF&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a56b4fec87c113f7818cad3427540fec3">FE_PolyTensor&lt; PolynomialsNedelec&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__DGPNonparametric.html#aa31e64ecd357681d743b141be3439158">FE_DGPNonparametric&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#a904821e8e3222c6f38af87560be609e4">FE_Poly&lt; POLY, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#a904821e8e3222c6f38af87560be609e4">FE_Poly&lt; PolynomialSpace&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#a904821e8e3222c6f38af87560be609e4">FE_Poly&lt; PolynomialsP&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__Poly.html#a904821e8e3222c6f38af87560be609e4">FE_Poly&lt; TensorProductPolynomials&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__Poly.html#a904821e8e3222c6f38af87560be609e4">FE_Poly&lt; TensorProductPolynomials&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#a904821e8e3222c6f38af87560be609e4">FE_Poly&lt; TensorProductPolynomialsConst&lt; dim &gt;, dim, spacedim &gt;</a>, and <a class="el" href="classFE__Poly.html#a904821e8e3222c6f38af87560be609e4">FE_Poly&lt; TensorProductPolynomials&lt; dim, Polynomials::PiecewisePolynomial&lt; double &gt; &gt;, dim, spacedim &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a4f84afe8e0b66037a9062cdcca290dcf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classTensor.html">Tensor</a>&lt;2,dim&gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::shape_grad_grad </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the tensor of second derivatives of the <code>ith</code> shape function at point <code>p</code> on the unit cell. The derivatives are derivatives on the unit cell with respect to unit cell coordinates. If the finite element is vector-valued, then return the value of the only non-zero component of the vector value of this shape function. If the shape function has more than one non-zero component (which we refer to with the term non-primitive), then derived classes implementing this function should throw an exception of type ExcShapeFunctionNotPrimitive. In that case, use the <a class="el" href="classFiniteElement.html#a56ca24e50d926cdf10bf9ad743f7976f">shape_grad_grad_component()</a> function.</p>
<p>An ExcUnitShapeValuesDoNotExist is thrown if the shape values of the <a class="el" href="classFiniteElement.html">FiniteElement</a> under consideration depends on the shape of the cell in real space. </p>

<p>Reimplemented in <a class="el" href="classFESystem.html#aea45ceb752c925f4492c89f6c13e6507">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a4472d99f0a08b64593ef2063904e1254">FE_PolyTensor&lt; POLY, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a4472d99f0a08b64593ef2063904e1254">FE_PolyTensor&lt; PolynomialsRaviartThomas&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a4472d99f0a08b64593ef2063904e1254">FE_PolyTensor&lt; PolynomialsNedelec&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a4472d99f0a08b64593ef2063904e1254">FE_PolyTensor&lt; PolynomialsRaviartThomas&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a4472d99f0a08b64593ef2063904e1254">FE_PolyTensor&lt; PolynomialsBDM&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a4472d99f0a08b64593ef2063904e1254">FE_PolyTensor&lt; PolynomialsBDM&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a4472d99f0a08b64593ef2063904e1254">FE_PolyTensor&lt; PolynomialsABF&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a4472d99f0a08b64593ef2063904e1254">FE_PolyTensor&lt; PolynomialsNedelec&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__DGPNonparametric.html#a6ffccc2cdc1f237423a131c78bb69be0">FE_DGPNonparametric&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#a76ef05c0c8f5d02a887355284d75917c">FE_Poly&lt; POLY, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#a76ef05c0c8f5d02a887355284d75917c">FE_Poly&lt; PolynomialSpace&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#a76ef05c0c8f5d02a887355284d75917c">FE_Poly&lt; PolynomialsP&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__Poly.html#a76ef05c0c8f5d02a887355284d75917c">FE_Poly&lt; TensorProductPolynomials&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__Poly.html#a76ef05c0c8f5d02a887355284d75917c">FE_Poly&lt; TensorProductPolynomials&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#a76ef05c0c8f5d02a887355284d75917c">FE_Poly&lt; TensorProductPolynomialsConst&lt; dim &gt;, dim, spacedim &gt;</a>, and <a class="el" href="classFE__Poly.html#a76ef05c0c8f5d02a887355284d75917c">FE_Poly&lt; TensorProductPolynomials&lt; dim, Polynomials::PiecewisePolynomial&lt; double &gt; &gt;, dim, spacedim &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a56ca24e50d926cdf10bf9ad743f7976f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classTensor.html">Tensor</a>&lt;2,dim&gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::shape_grad_grad_component </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Just like for <a class="el" href="classFiniteElement.html#a4f84afe8e0b66037a9062cdcca290dcf">shape_grad_grad()</a>, but this function will be called when the shape function has more than one non-zero vector component. In that case, this function should return the gradient of the <code>component-th</code> vector component of the <code>ith</code> shape function at point <code>p</code>. </p>

<p>Reimplemented in <a class="el" href="classFESystem.html#a80b05bd5ea76743c3a89a1e691a9de13">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGPNonparametric.html#a41d05aabbea1967e003ae69ca9263f62">FE_DGPNonparametric&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a18fd28f10de2fb064ba1d898a2a0e206">FE_PolyTensor&lt; POLY, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a18fd28f10de2fb064ba1d898a2a0e206">FE_PolyTensor&lt; PolynomialsRaviartThomas&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a18fd28f10de2fb064ba1d898a2a0e206">FE_PolyTensor&lt; PolynomialsNedelec&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a18fd28f10de2fb064ba1d898a2a0e206">FE_PolyTensor&lt; PolynomialsRaviartThomas&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a18fd28f10de2fb064ba1d898a2a0e206">FE_PolyTensor&lt; PolynomialsBDM&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a18fd28f10de2fb064ba1d898a2a0e206">FE_PolyTensor&lt; PolynomialsBDM&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a18fd28f10de2fb064ba1d898a2a0e206">FE_PolyTensor&lt; PolynomialsABF&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a18fd28f10de2fb064ba1d898a2a0e206">FE_PolyTensor&lt; PolynomialsNedelec&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#a53454efb5660d353b18094b09ee63abf">FE_Poly&lt; POLY, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#a53454efb5660d353b18094b09ee63abf">FE_Poly&lt; PolynomialSpace&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#a53454efb5660d353b18094b09ee63abf">FE_Poly&lt; PolynomialsP&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__Poly.html#a53454efb5660d353b18094b09ee63abf">FE_Poly&lt; TensorProductPolynomials&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__Poly.html#a53454efb5660d353b18094b09ee63abf">FE_Poly&lt; TensorProductPolynomials&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#a53454efb5660d353b18094b09ee63abf">FE_Poly&lt; TensorProductPolynomialsConst&lt; dim &gt;, dim, spacedim &gt;</a>, and <a class="el" href="classFE__Poly.html#a53454efb5660d353b18094b09ee63abf">FE_Poly&lt; TensorProductPolynomials&lt; dim, Polynomials::PiecewisePolynomial&lt; double &gt; &gt;, dim, spacedim &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a04ad0cca5800a68b8149d34865227d9d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::has_support_on_face </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>shape_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check for non-zero values on a face in order to optimize out matrix elements.</p>
<p>This function returns <code>true</code>, if the shape function <code>shape_index</code> has non-zero values on the face <code>face_index</code>.</p>
<p>A default implementation is provided in this basis class which always returns <code>true</code>. This is the safe way to go. </p>

<p>Reimplemented in <a class="el" href="classFE__Q__Hierarchical.html#a6919653dcc9803b74731d78406d4ce9d">FE_Q_Hierarchical&lt; dim &gt;</a>, <a class="el" href="classFE__RaviartThomasNodal.html#a966fe06bf57e30eefd17ba79ba88a405">FE_RaviartThomasNodal&lt; dim &gt;</a>, <a class="el" href="classFESystem.html#a4d114a8ad31c24188b03d6d8f04cbd0d">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGPNonparametric.html#adbc90dc03ecfbbfd94d12f9604148e43">FE_DGPNonparametric&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__DG0.html#adda7d587484b9c37484d9ef039cc724c">FE_Q_DG0&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGPMonomial.html#afbc0867469b60d6211b1192381fd230b">FE_DGPMonomial&lt; dim &gt;</a>, <a class="el" href="classFE__DGP.html#a3b33a3458a5afc1a9e228c59ad0da427">FE_DGP&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGQ.html#a866b2b0ba8c5e6976b9171e4133941cf">FE_DGQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Hierarchical.html#a13e6b2089ff535ff2c0d2a404e25efef">FE_Q_Hierarchical&lt; dim &gt;</a>, <a class="el" href="classFE__FaceP.html#a123261967120962f142b5d4d099272bc">FE_FaceP&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Nedelec.html#af72b0650a7ecc0f465d540605ddc26e2">FE_Nedelec&lt; dim &gt;</a>, <a class="el" href="classFE__RaviartThomas.html#adf362b46668f23423e8c7158116c066b">FE_RaviartThomas&lt; dim &gt;</a>, <a class="el" href="classFE__ABF.html#a893646125bbd330a3327c12cb6774bbb">FE_ABF&lt; dim &gt;</a>, <a class="el" href="classFE__FaceQ.html#a06f1021f1e67f50df9bf60f2e871deee">FE_FaceQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#ae933714b68c483986074e362bf4ea3fd">FE_Q_Base&lt; POLY, dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#ae933714b68c483986074e362bf4ea3fd">FE_Q_Base&lt; TensorProductPolynomials&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#ae933714b68c483986074e362bf4ea3fd">FE_Q_Base&lt; TensorProductPolynomialsConst&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#ae933714b68c483986074e362bf4ea3fd">FE_Q_Base&lt; TensorProductPolynomials&lt; dim, Polynomials::PiecewisePolynomial&lt; double &gt; &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__DGVector.html#a19fd727dc597eaac147c784f5df3df52">FE_DGVector&lt; POLY, dim, spacedim &gt;</a>, <a class="el" href="classFE__DGVector.html#a19fd727dc597eaac147c784f5df3df52">FE_DGVector&lt; PolynomialsRaviartThomas&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__DGVector.html#a19fd727dc597eaac147c784f5df3df52">FE_DGVector&lt; PolynomialsBDM&lt; dim &gt;, dim, spacedim &gt;</a>, and <a class="el" href="classFE__DGVector.html#a19fd727dc597eaac147c784f5df3df52">FE_DGVector&lt; PolynomialsNedelec&lt; dim &gt;, dim, spacedim &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a0238956d0afd1bd880bf84366c024dec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt;<a class="el" href="classdouble.html">double</a>&gt;&amp; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::get_restriction_matrix </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>refinement_case</em> = <code><a class="el" href="classRefinementCase.html">RefinementCase</a>&lt;&#160;dim&#160;&gt;::isotropic_refinement</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Projection from a fine grid space onto a coarse grid space. If this projection operator is associated with a matrix <code>P</code>, then the restriction of this matrix <code>P_i</code> to a single child cell is returned here.</p>
<p>The matrix <code>P</code> is the concatenation or the sum of the cell matrices <code>P_i</code>, depending on the <a class="el" href="classFiniteElement.html#aa8f4833a318127b42d2dc806bffe1c2c">restriction_is_additive_flags</a>. This distinguishes interpolation (concatenation) and projection with respect to scalar products (summation).</p>
<p>Row and column indices are related to coarse grid and fine grid spaces, respectively, consistent with the definition of the associated operator.</p>
<p>If projection matrices are not implemented in the derived finite element class, this function aborts with ExcProjectionVoid. You can check whether this is the case by calling the <a class="el" href="classFiniteElement.html#af907ef944827248ff218ad6374787ebf">restriction_is_implemented()</a> or the <a class="el" href="classFiniteElement.html#ab6f01c36e56f40779ab4130fb4c10673">isotropic_restriction_is_implemented()</a> function. </p>

<p>Reimplemented in <a class="el" href="classFESystem.html#a0d840d30e6cb9a5340c221b4015b7621">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a571ef1e26134b2d3e9f63cb012f7ca02">FE_Q_Base&lt; POLY, dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a571ef1e26134b2d3e9f63cb012f7ca02">FE_Q_Base&lt; TensorProductPolynomials&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a571ef1e26134b2d3e9f63cb012f7ca02">FE_Q_Base&lt; TensorProductPolynomialsConst&lt; dim &gt;, dim, spacedim &gt;</a>, and <a class="el" href="classFE__Q__Base.html#a571ef1e26134b2d3e9f63cb012f7ca02">FE_Q_Base&lt; TensorProductPolynomials&lt; dim, Polynomials::PiecewisePolynomial&lt; double &gt; &gt;, dim, spacedim &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ac5e488d17d3e34a84166d8c7ca95c22a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt;<a class="el" href="classdouble.html">double</a>&gt;&amp; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::get_prolongation_matrix </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>refinement_case</em> = <code><a class="el" href="classRefinementCase.html">RefinementCase</a>&lt;&#160;dim&#160;&gt;::isotropic_refinement</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Embedding matrix between grids.</p>
<p>The identity operator from a coarse grid space into a fine grid space is associated with a matrix <code>P</code>. The restriction of this matrix <code>P_i</code> to a single child cell is returned here.</p>
<p>The matrix <code>P</code> is the concatenation, not the sum of the cell matrices <code>P_i</code>. That is, if the same non-zero entry <code>j,k</code> exists in in two different child matrices <code>P_i</code>, the value should be the same in both matrices and it is copied into the matrix <code>P</code> only once.</p>
<p>Row and column indices are related to fine grid and coarse grid spaces, respectively, consistent with the definition of the associated operator.</p>
<p>These matrices are used by routines assembling the prolongation matrix for multi-level methods. Upon assembling the transfer matrix between cells using this matrix array, zero elements in the prolongation matrix are discarded and will not fill up the transfer matrix.</p>
<p>If projection matrices are not implemented in the derived finite element class, this function aborts with ExcEmbeddingVoid. You can check whether this is the case by calling the <a class="el" href="classFiniteElement.html#ac8fdbb2a1b1a014473eb06950e7e7d05">prolongation_is_implemented()</a> or the <a class="el" href="classFiniteElement.html#a1f707a015a3dbad884fcf775c7045db5">isotropic_prolongation_is_implemented()</a> function. </p>

<p>Reimplemented in <a class="el" href="classFESystem.html#a8777a21801991395b6711b5ebdf364d5">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a0510caea5b9559108f99009a16ba1524">FE_Q_Base&lt; POLY, dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a0510caea5b9559108f99009a16ba1524">FE_Q_Base&lt; TensorProductPolynomials&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a0510caea5b9559108f99009a16ba1524">FE_Q_Base&lt; TensorProductPolynomialsConst&lt; dim &gt;, dim, spacedim &gt;</a>, and <a class="el" href="classFE__Q__Base.html#a0510caea5b9559108f99009a16ba1524">FE_Q_Base&lt; TensorProductPolynomials&lt; dim, Polynomials::PiecewisePolynomial&lt; double &gt; &gt;, dim, spacedim &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ac8fdbb2a1b1a014473eb06950e7e7d05"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::prolongation_is_implemented </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether this element implements its prolongation matrices. The return value also indicates whether a call to the <a class="el" href="classFiniteElement.html#ac5e488d17d3e34a84166d8c7ca95c22a">get_prolongation_matrix()</a> function will generate an error or not.</p>
<p>Note, that this function returns <code>true</code> only if the prolongation matrices of the isotropic and all anisotropic refinement cases are implemented. If you are interested in the prolongation matrices for isotropic refinement only, use the isotropic_prolongation_is_implemented function instead.</p>
<p>This function is mostly here in order to allow us to write more efficient test programs which we run on all kinds of weird elements, and for which we simply need to exclude certain tests in case something is not implemented. It will in general probably not be a great help in applications, since there is not much one can do if one needs these features and they are not implemented. This function could be used to check whether a call to <code><a class="el" href="classFiniteElement.html#ac5e488d17d3e34a84166d8c7ca95c22a">get_prolongation_matrix()</a></code> will succeed; however, one then still needs to cope with the lack of information this just expresses. </p>

</div>
</div>
<a class="anchor" id="a1f707a015a3dbad884fcf775c7045db5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::isotropic_prolongation_is_implemented </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether this element implements its prolongation matrices for isotropic children. The return value also indicates whether a call to the <code>get_prolongation_matrix</code> function will generate an error or not.</p>
<p>This function is mostly here in order to allow us to write more efficient test programs which we run on all kinds of weird elements, and for which we simply need to exclude certain tests in case something is not implemented. It will in general probably not be a great help in applications, since there is not much one can do if one needs these features and they are not implemented. This function could be used to check whether a call to <code><a class="el" href="classFiniteElement.html#ac5e488d17d3e34a84166d8c7ca95c22a">get_prolongation_matrix()</a></code> will succeed; however, one then still needs to cope with the lack of information this just expresses. </p>

</div>
</div>
<a class="anchor" id="af907ef944827248ff218ad6374787ebf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::restriction_is_implemented </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether this element implements its restriction matrices. The return value also indicates whether a call to the <a class="el" href="classFiniteElement.html#a0238956d0afd1bd880bf84366c024dec">get_restriction_matrix()</a> function will generate an error or not.</p>
<p>Note, that this function returns <code>true</code> only if the restriction matrices of the isotropic and all anisotropic refinement cases are implemented. If you are interested in the restriction matrices for isotropic refinement only, use the isotropic_restriction_is_implemented function instead.</p>
<p>This function is mostly here in order to allow us to write more efficient test programs which we run on all kinds of weird elements, and for which we simply need to exclude certain tests in case something is not implemented. It will in general probably not be a great help in applications, since there is not much one can do if one needs these features and they are not implemented. This function could be used to check whether a call to <code><a class="el" href="classFiniteElement.html#a0238956d0afd1bd880bf84366c024dec">get_restriction_matrix()</a></code> will succeed; however, one then still needs to cope with the lack of information this just expresses. </p>

</div>
</div>
<a class="anchor" id="ab6f01c36e56f40779ab4130fb4c10673"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::isotropic_restriction_is_implemented </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether this element implements its restriction matrices for isotropic children. The return value also indicates whether a call to the <code>get_restriction_matrix</code> function will generate an error or not.</p>
<p>This function is mostly here in order to allow us to write more efficient test programs which we run on all kinds of weird elements, and for which we simply need to exclude certain tests in case something is not implemented. It will in general probably not be a great help in applications, since there is not much one can do if one needs these features and they are not implemented. This function could be used to check whether a call to <code><a class="el" href="classFiniteElement.html#a0238956d0afd1bd880bf84366c024dec">get_restriction_matrix()</a></code> will succeed; however, one then still needs to cope with the lack of information this just expresses. </p>

</div>
</div>
<a class="anchor" id="a4c9ce7c266ff343d4d80109cfcc83896"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::restriction_is_additive </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Access the <a class="el" href="classFiniteElement.html#aa8f4833a318127b42d2dc806bffe1c2c">restriction_is_additive_flags</a> field. See there for more information on its contents.</p>
<p>The index must be between zero and the number of shape functions of this element. </p>

<p>Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02203">2203</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a class="anchor" id="adca98da93286dc00c07a049dac9b0e50"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt;<a class="el" href="classdouble.html">double</a>&gt;&amp; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::constraints </td>
          <td>(</td>
          <td class="paramtype">const ::<a class="el" href="classinternal_1_1SubfaceCase.html">internal::SubfaceCase</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>subface_case</em> = <code>::<a class="el" href="classinternal_1_1SubfaceCase.html">internal::SubfaceCase</a>&lt;&#160;dim&#160;&gt;::case_isotropic</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a read only reference to the matrix which describes the constraints at the interface between a refined and an unrefined cell.</p>
<p>The matrix is obviously empty in only one dimension, since there are no constraints then.</p>
<p>Note that some finite elements do not (yet) implement hanging node constraints. If this is the case, then this function will generate an exception, since no useful return value can be generated. If you should have a way to live with this, then you might want to use the <a class="el" href="classFiniteElement.html#a5cb0b95fb7a683e493884133725a03e9">constraints_are_implemented()</a> function to check up front whether this function will succeed or generate the exception. </p>

</div>
</div>
<a class="anchor" id="a5cb0b95fb7a683e493884133725a03e9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::constraints_are_implemented </td>
          <td>(</td>
          <td class="paramtype">const ::<a class="el" href="classinternal_1_1SubfaceCase.html">internal::SubfaceCase</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>subface_case</em> = <code>::<a class="el" href="classinternal_1_1SubfaceCase.html">internal::SubfaceCase</a>&lt;&#160;dim&#160;&gt;::case_isotropic</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether this element implements its hanging node constraints. The return value also indicates whether a call to the <a class="el" href="classFiniteElement.html#adca98da93286dc00c07a049dac9b0e50">constraints()</a> function will generate an error or not.</p>
<p>This function is mostly here in order to allow us to write more efficient test programs which we run on all kinds of weird elements, and for which we simply need to exclude certain tests in case hanging node constraints are not implemented. It will in general probably not be a great help in applications, since there is not much one can do if one needs hanging node constraints and they are not implemented. This function could be used to check whether a call to <code><a class="el" href="classFiniteElement.html#adca98da93286dc00c07a049dac9b0e50">constraints()</a></code> will succeed; however, one then still needs to cope with the lack of information this just expresses. </p>

</div>
</div>
<a class="anchor" id="acea8a4ad78bb6511033ef40de259ace3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::hp_constraints_are_implemented </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return whether this element implements its hanging node constraints in the new way, which has to be used to make elements "hp compatible". That means, the element properly implements the get_face_interpolation_matrix and get_subface_interpolation_matrix methods. Therefore the return value also indicates whether a call to the <a class="el" href="classFiniteElement.html#a9ffc5d5535913fe35f59131c0558c853">get_face_interpolation_matrix()</a> method and the <a class="el" href="classFiniteElement.html#a1b92af4e841a90cd4b971f931b83c8dc">get_subface_interpolation_matrix()</a> method will generate an error or not.</p>
<p>Currently the main purpose of this function is to allow the make_hanging_node_constraints method to decide whether the new procedures, which are supposed to work in the hp framework can be used, or if the old well verified but not hp capable functions should be used. Once the transition to the new scheme for computing the interface constraints is complete, this function will be superfluous and will probably go away.</p>
<p>Derived classes should implement this function accordingly. The default assumption is that a finite element does not provide hp capable face interpolation, and the default implementation therefore returns <code>false</code>. </p>

<p>Reimplemented in <a class="el" href="classFESystem.html#a2eaa3cfcfae3aa93de395c680b00404c">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__RaviartThomasNodal.html#a600b5d0f27d5735a003b071bbd9fec35">FE_RaviartThomasNodal&lt; dim &gt;</a>, <a class="el" href="classFE__Nothing.html#adcc944daaa04ea818ebfb4b45d5abf8b">FE_Nothing&lt; dim &gt;</a>, <a class="el" href="classFE__DGPNonparametric.html#ac9e0ee41c87b631caa73ee313423544e">FE_DGPNonparametric&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Hierarchical.html#a20d416c7593734a160b424c3a70b6990">FE_Q_Hierarchical&lt; dim &gt;</a>, <a class="el" href="classFE__DGQ.html#a9bba4a045b78575dfcf532d822b17007">FE_DGQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__FaceP.html#ab61ceebda6ddcf2f13c8450390ebd5dd">FE_FaceP&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#aae6258db5ecd93b2274f7f4180dc05ea">FE_Q_Base&lt; POLY, dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#aae6258db5ecd93b2274f7f4180dc05ea">FE_Q_Base&lt; TensorProductPolynomials&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#aae6258db5ecd93b2274f7f4180dc05ea">FE_Q_Base&lt; TensorProductPolynomialsConst&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#aae6258db5ecd93b2274f7f4180dc05ea">FE_Q_Base&lt; TensorProductPolynomials&lt; dim, Polynomials::PiecewisePolynomial&lt; double &gt; &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__DGP.html#acc67ce42005314b073ae306eec6a9f9c">FE_DGP&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Nedelec.html#a502f2b7621387edebe2078734a006677">FE_Nedelec&lt; dim &gt;</a>, <a class="el" href="classFE__DGPMonomial.html#af2d8d274ea3a8754563caeccbc06213a">FE_DGPMonomial&lt; dim &gt;</a>, and <a class="el" href="classFE__FaceQ.html#a1a42d8af1499fb12ef9263b4109a6cac">FE_FaceQ&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ab64ef474b3fd4bd155618584ddc1e9cc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::get_interpolation_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the matrix interpolating from the given finite element to the present one. The size of the matrix is then <a class="el" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a> times <code>source.<a class="el" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a></code>.</p>
<p>Derived elements will have to implement this function. They may only provide interpolation matrices for certain source finite elements, for example those from the same family. If they don't implement interpolation from a given element, then they must throw an exception of type ExcInterpolationNotImplemented. </p>

<p>Reimplemented in <a class="el" href="classFESystem.html#ab08f5e095783607209990bbf28595a3d">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__DG0.html#aae68b6e7f4e92861bd31f8a7e81ac8a0">FE_Q_DG0&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGQ.html#ab67fec87d95507b5141af3e17a8d63fb">FE_DGQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a87fb7c0144ab7eaa630cdf0b0b14013e">FE_Q_Base&lt; POLY, dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a87fb7c0144ab7eaa630cdf0b0b14013e">FE_Q_Base&lt; TensorProductPolynomials&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a87fb7c0144ab7eaa630cdf0b0b14013e">FE_Q_Base&lt; TensorProductPolynomialsConst&lt; dim &gt;, dim, spacedim &gt;</a>, and <a class="el" href="classFE__Q__Base.html#a87fb7c0144ab7eaa630cdf0b0b14013e">FE_Q_Base&lt; TensorProductPolynomials&lt; dim, Polynomials::PiecewisePolynomial&lt; double &gt; &gt;, dim, spacedim &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a9ffc5d5535913fe35f59131c0558c853"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::get_face_interpolation_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the matrix interpolating from a face of of one element to the face of the neighboring element. The size of the matrix is then <code>source.<a class="el" href="classFiniteElementData.html#a358bffed1fba59ef4df715469473fd36">dofs_per_face</a></code> times <code>this-&gt;<a class="el" href="classFiniteElementData.html#a358bffed1fba59ef4df715469473fd36">dofs_per_face</a></code>.</p>
<p>Derived elements will have to implement this function. They may only provide interpolation matrices for certain source finite elements, for example those from the same family. If they don't implement interpolation from a given element, then they must throw an exception of type ExcInterpolationNotImplemented. </p>

<p>Reimplemented in <a class="el" href="classFESystem.html#a143d9346dbafacdd67f8f4d53db776dd">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGP.html#af9f108d89fe90bb6ad08065e4cda5645">FE_DGP&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGPNonparametric.html#ad7ee175e71b0b9300f69cee4bf6941ca">FE_DGPNonparametric&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__FaceP.html#aa5fd57d11557eb337ab3cba589cb06b6">FE_FaceP&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGQ.html#acec8d86dbbcb391b1473a1d6822aa801">FE_DGQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__FaceQ.html#abeaae60788b2c54ba5edb33782738d0d">FE_FaceQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a47d735f9940bc2fe419663016a767c10">FE_Q_Base&lt; POLY, dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a47d735f9940bc2fe419663016a767c10">FE_Q_Base&lt; TensorProductPolynomials&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a47d735f9940bc2fe419663016a767c10">FE_Q_Base&lt; TensorProductPolynomialsConst&lt; dim &gt;, dim, spacedim &gt;</a>, and <a class="el" href="classFE__Q__Base.html#a47d735f9940bc2fe419663016a767c10">FE_Q_Base&lt; TensorProductPolynomials&lt; dim, Polynomials::PiecewisePolynomial&lt; double &gt; &gt;, dim, spacedim &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a1b92af4e841a90cd4b971f931b83c8dc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::get_subface_interpolation_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>subface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the matrix interpolating from a face of of one element to the subface of the neighboring element. The size of the matrix is then <code>source.<a class="el" href="classFiniteElementData.html#a358bffed1fba59ef4df715469473fd36">dofs_per_face</a></code> times <code>this-&gt;<a class="el" href="classFiniteElementData.html#a358bffed1fba59ef4df715469473fd36">dofs_per_face</a></code>.</p>
<p>Derived elements will have to implement this function. They may only provide interpolation matrices for certain source finite elements, for example those from the same family. If they don't implement interpolation from a given element, then they must throw an exception of type ExcInterpolationNotImplemented. </p>

<p>Reimplemented in <a class="el" href="classFESystem.html#acaa8cad376efc3f3055f6c63d64bb954">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGP.html#a0da30cdb44a63b8434250a569ae00c96">FE_DGP&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGPNonparametric.html#abc0bfdf3efa8e3e7fa3fd36700d601ca">FE_DGPNonparametric&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__FaceP.html#a6972699585dab03b19875f91e43d07f0">FE_FaceP&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGQ.html#aea32b0ca54b7d5c6c27d2d389412dced">FE_DGQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__FaceQ.html#abfd76533eac374e2cf793d085e31adc9">FE_FaceQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a1811b6b13c200f5600bbcd1b1597e5cc">FE_Q_Base&lt; POLY, dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a1811b6b13c200f5600bbcd1b1597e5cc">FE_Q_Base&lt; TensorProductPolynomials&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a1811b6b13c200f5600bbcd1b1597e5cc">FE_Q_Base&lt; TensorProductPolynomialsConst&lt; dim &gt;, dim, spacedim &gt;</a>, and <a class="el" href="classFE__Q__Base.html#a1811b6b13c200f5600bbcd1b1597e5cc">FE_Q_Base&lt; TensorProductPolynomials&lt; dim, Polynomials::PiecewisePolynomial&lt; double &gt; &gt;, dim, spacedim &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="aa31b7fc6b4abd8bdbfa338676629e502"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::pair&lt;unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>&gt; &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::hp_vertex_dof_identities </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe_other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If, on a vertex, several finite elements are active, the hp code first assigns the degrees of freedom of each of these FEs different global indices. It then calls this function to find out which of them should get identical values, and consequently can receive the same global DoF index. This function therefore returns a list of identities between DoFs of the present finite element object with the DoFs of <code>fe_other</code>, which is a reference to a finite element object representing one of the other finite elements active on this particular vertex. The function computes which of the degrees of freedom of the two finite element objects are equivalent, both numbered between zero and the corresponding value of dofs_per_vertex of the two finite elements. The first index of each pair denotes one of the vertex dofs of the present element, whereas the second is the corresponding index of the other finite element. </p>

<p>Reimplemented in <a class="el" href="classFESystem.html#af0b5b3e249d6a9785bdc12c039df3b8f">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGPNonparametric.html#a1799a0192b814b497e9beebed0a662a5">FE_DGPNonparametric&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a0f73d2aac0553b7143f87fddaff7ac3d">FE_Q_Base&lt; POLY, dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a0f73d2aac0553b7143f87fddaff7ac3d">FE_Q_Base&lt; TensorProductPolynomials&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a0f73d2aac0553b7143f87fddaff7ac3d">FE_Q_Base&lt; TensorProductPolynomialsConst&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a0f73d2aac0553b7143f87fddaff7ac3d">FE_Q_Base&lt; TensorProductPolynomials&lt; dim, Polynomials::PiecewisePolynomial&lt; double &gt; &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__DGQ.html#acc9a338749aa5bf0a94ef982e36777b1">FE_DGQ&lt; dim, spacedim &gt;</a>, and <a class="el" href="classFE__DGP.html#ad4c5b22e34d222f6fea7445cdb26670a">FE_DGP&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="aaddbc3c71ae4f437f4e37b878dbe30b5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::pair&lt;unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>&gt; &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::hp_line_dof_identities </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe_other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as hp_vertex_dof_indices(), except that the function treats degrees of freedom on lines. </p>

<p>Reimplemented in <a class="el" href="classFESystem.html#af796548bd67680a04590a3c8a04703ce">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGPNonparametric.html#a8f856549fe152db149896f46f1fb7289">FE_DGPNonparametric&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a22a4ddf2ce47f75cec3a42ddab328af7">FE_Q_Base&lt; POLY, dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a22a4ddf2ce47f75cec3a42ddab328af7">FE_Q_Base&lt; TensorProductPolynomials&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a22a4ddf2ce47f75cec3a42ddab328af7">FE_Q_Base&lt; TensorProductPolynomialsConst&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a22a4ddf2ce47f75cec3a42ddab328af7">FE_Q_Base&lt; TensorProductPolynomials&lt; dim, Polynomials::PiecewisePolynomial&lt; double &gt; &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__DGQ.html#aa08cc7750393a332ccbfc43978ce320b">FE_DGQ&lt; dim, spacedim &gt;</a>, and <a class="el" href="classFE__DGP.html#a59a916cc56b867755d3b643ac791b446">FE_DGP&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a0ad9e292f90a4812d231229295ac705f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::pair&lt;unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>&gt; &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::hp_quad_dof_identities </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe_other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as hp_vertex_dof_indices(), except that the function treats degrees of freedom on quads. </p>

<p>Reimplemented in <a class="el" href="classFESystem.html#a68b351bd9acf0de9f1134e65400e4b13">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGPNonparametric.html#ae152f56c40fed00e278a8c336db85739">FE_DGPNonparametric&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a93c5273561151e7f1116c2f4c8fb5128">FE_Q_Base&lt; POLY, dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a93c5273561151e7f1116c2f4c8fb5128">FE_Q_Base&lt; TensorProductPolynomials&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a93c5273561151e7f1116c2f4c8fb5128">FE_Q_Base&lt; TensorProductPolynomialsConst&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a93c5273561151e7f1116c2f4c8fb5128">FE_Q_Base&lt; TensorProductPolynomials&lt; dim, Polynomials::PiecewisePolynomial&lt; double &gt; &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__DGQ.html#aaff50bb650ea5f7f40f262292edbbb72">FE_DGQ&lt; dim, spacedim &gt;</a>, and <a class="el" href="classFE__DGP.html#a39a3dcaab627ba42fc833dbea9f32aa9">FE_DGP&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ab205badd986d9bf0b6ed00641fbc0c50"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceFiniteElementDomination.html#a65fdbe0cca5954df89a7af4f36769bf9">FiniteElementDomination::Domination</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::compare_for_face_domination </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe_other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return whether this element dominates the one given as argument when they meet at a common face, whether it is the other way around, whether neither dominates, or if either could dominate.</p>
<p>For a definition of domination, see FiniteElementBase::Domination and in particular the <a class="el" href="DEALGlossary.html#hp_paper">hp paper</a>. </p>

<p>Reimplemented in <a class="el" href="classFESystem.html#a596c422ef3f12e9515c5b89644ea0ff3">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGPNonparametric.html#a27c519e294cbcbc6c3c09afa8b8ec1e7">FE_DGPNonparametric&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGQ.html#a19ef3c7a32b3cf20108027b953b273e2">FE_DGQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#aa246a6bb36400b6ba0f90de7c6b83480">FE_Q_Base&lt; POLY, dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#aa246a6bb36400b6ba0f90de7c6b83480">FE_Q_Base&lt; TensorProductPolynomials&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#aa246a6bb36400b6ba0f90de7c6b83480">FE_Q_Base&lt; TensorProductPolynomialsConst&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#aa246a6bb36400b6ba0f90de7c6b83480">FE_Q_Base&lt; TensorProductPolynomials&lt; dim, Polynomials::PiecewisePolynomial&lt; double &gt; &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__FaceP.html#a9aead982619f32c9090fd787bcdc1013">FE_FaceP&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGP.html#aa7a17c5faa1b1744e40c6a5c4133a805">FE_DGP&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__iso__Q1.html#a8f756f19895f41e087e4e92cd0811672">FE_Q_iso_Q1&lt; dim, spacedim &gt;</a>, and <a class="el" href="classFE__FaceQ.html#ab30cd47727aed3823f393df1cdcd88d0">FE_FaceQ&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="aef56a3e1bd7610fa1a0029d9fbd5a1c6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Comparison operator. We also check for equality of the constraint matrix, which is quite an expensive operation. Do therefore use this function with care, if possible only for debugging purposes.</p>
<p>Since this function is not that important, we avoid an implementational question about comparing arrays and do not compare the matrix arrays <a class="el" href="classFiniteElement.html#a4993707a4ec342560ff74e5d22401794">restriction</a> and <a class="el" href="classFiniteElement.html#afbc42f850096c429fd39cfcbde1b6b56">prolongation</a>. </p>

</div>
</div>
<a class="anchor" id="a27220a135402b96c7e6eecbb04acda56"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::system_to_component_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute vector component and index of this shape function within the shape functions corresponding to this component from the index of a shape function within this finite element.</p>
<p>If the element is scalar, then the component is always zero, and the index within this component is equal to the overall index.</p>
<p>If the shape function referenced has more than one non-zero component, then it cannot be associated with one vector component, and an exception of type ExcShapeFunctionNotPrimitive will be raised.</p>
<p>Note that if the element is composed of other (base) elements, and a base element has more than one component but all its shape functions are primitive (i.e. are non-zero in only one component), then this mapping contains valid information. However, the index of a shape function of this element within one component (i.e. the second number of the respective entry of this array) does not indicate the index of the respective shape function within the base element (since that has more than one vector-component). For this information, refer to the <a class="el" href="classFiniteElement.html#a4b487f5fe482180d2c856363ae39ab13">system_to_base_table</a> field and the <a class="el" href="classFiniteElement.html#a2c1a9946f93d090df3c0ab3ae03e1ac6">system_to_base_index()</a> function.</p>
<p>The use of this function is explained extensively in the <a class="el" href="step_8.html">step-8</a> and <a class="el" href="step_20.html">step-20</a> tutorial programs as well as in the <a class="el" href="group__vector__valued.html">Handling vector valued problems</a> module. </p>

<p>Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02048">2048</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a class="anchor" id="a53c8af4e218c3257bd34b360c3163d3e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::component_to_system_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the shape function for the given vector component and index.</p>
<p>If the element is scalar, then the component must be zero, and the index within this component is equal to the overall index.</p>
<p>This is the opposite operation from the <a class="el" href="classFiniteElement.html#a27220a135402b96c7e6eecbb04acda56">system_to_component_index()</a> function. </p>

<p>Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02082">2082</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a class="anchor" id="a44bd600481078ec8d037e1bcf80274b4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::face_system_to_component_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as <a class="el" href="classFiniteElement.html#a27220a135402b96c7e6eecbb04acda56">system_to_component_index()</a>, but do it for shape functions and their indices on a face. The range of allowed indices is therefore 0..<a class="el" href="classFiniteElementData.html#a358bffed1fba59ef4df715469473fd36">dofs_per_face</a>.</p>
<p>You will rarely need this function in application programs, since almost all application codes only need to deal with cell indices, not face indices. The function is mainly there for use inside the library. </p>

<p>Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02098">2098</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac88c06986c3751adafbd089da7682b82"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::face_to_cell_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_dof_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_orientation</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_flip</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_rotation</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given an index in the natural ordering of indices on a face, return the index of the same degree of freedom on the cell.</p>
<p>To explain the concept, consider the case where we would like to know whether a degree of freedom on a face, for example as part of an <a class="el" href="classFESystem.html">FESystem</a> element, is primitive. Unfortunately, the <a class="el" href="classFiniteElement.html#ab8a57013e9e027acbf1afa1296de42d3">is_primitive()</a> function in the <a class="el" href="classFiniteElement.html">FiniteElement</a> class takes a cell index, so we would need to find the cell index of the shape function that corresponds to the present face index. This function does that.</p>
<p>Code implementing this would then look like this: </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classFiniteElementData.html#a358bffed1fba59ef4df715469473fd36">dofs_per_face</a>; ++i)</div>
<div class="line"> <span class="keywordflow">if</span> (fe.is_primitive(fe.face_to_equivalent_cell_index(i, some_face_no)))</div>
<div class="line">  ... <span class="keywordflow">do</span> whatever</div>
</div><!-- fragment --><p> The function takes additional arguments that account for the fact that actual faces can be in their standard ordering with respect to the cell under consideration, or can be flipped, oriented, etc.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">face_dof_index</td><td>The index of the degree of freedom on a face. This index must be between zero and dofs_per_face. </td></tr>
    <tr><td class="paramname">face</td><td>The number of the face this degree of freedom lives on. This number must be between zero and <a class="el" href="structGeometryInfo.html#a16f862f2b86e608697f7a36acffcaec4">GeometryInfo::faces_per_cell</a>. </td></tr>
    <tr><td class="paramname">face_orientation</td><td>One part of the description of the orientation of the face. See <a class="el" href="DEALGlossary.html#GlossFaceOrientation">GlossFaceOrientation</a> . </td></tr>
    <tr><td class="paramname">face_flip</td><td>One part of the description of the orientation of the face. See <a class="el" href="DEALGlossary.html#GlossFaceOrientation">GlossFaceOrientation</a> . </td></tr>
    <tr><td class="paramname">face_rotation</td><td>One part of the description of the orientation of the face. See <a class="el" href="DEALGlossary.html#GlossFaceOrientation">GlossFaceOrientation</a> . </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of this degree of freedom within the set of degrees of freedom on the entire cell. The returned value will be between zero and dofs_per_cell.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function exists in this class because that is where it was first implemented. However, it can't really work in the most general case without knowing what element we have. The reason is that when a face is flipped or rotated, we also need to know whether we need to swap the degrees of freedom on this face, or whether they are immune from this. For this, consider the situation of a <img class="formulaInl" alt="$Q_3$" src="form_278.png"/> element in 2d. If face_flip is true, then we need to consider the two degrees of freedom on the edge in reverse order. On the other hand, if the element were a <img class="formulaInl" alt="$Q_1^2$" src="form_279.png"/>, then because the two degrees of freedom on this edge belong to different vector components, they should not be considered in reverse order. What all of this shows is that the function can't work if there are more than one degree of freedom per line or quad, and that in these cases the function will throw an exception pointing out that this functionality will need to be provided by a derived class that knows what degrees of freedom actually represent. </dd></dl>

<p>Reimplemented in <a class="el" href="classFESystem.html#a7f61be63b5286fe141b7ecf4588f5f57">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#ac0055b8bfdc0fec9724227f9cc629475">FE_Q_Base&lt; POLY, dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#ac0055b8bfdc0fec9724227f9cc629475">FE_Q_Base&lt; TensorProductPolynomials&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#ac0055b8bfdc0fec9724227f9cc629475">FE_Q_Base&lt; TensorProductPolynomialsConst&lt; dim &gt;, dim, spacedim &gt;</a>, and <a class="el" href="classFE__Q__Base.html#ac0055b8bfdc0fec9724227f9cc629475">FE_Q_Base&lt; TensorProductPolynomials&lt; dim, Polynomials::PiecewisePolynomial&lt; double &gt; &gt;, dim, spacedim &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a5ed8437e4a8a433d8ac71c0765af72a2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::adjust_quad_dof_index_for_face_orientation </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_orientation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_flip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_rotation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For faces with non-standard face_orientation in 3D, the dofs on faces (quads) have to be permuted in order to be combined with the correct shape functions. Given a local dof <code>index</code> on a quad, return the local index, if the face has non-standard face_orientation, face_flip or face_rotation. In 2D and 1D there is no need for permutation and consequently an exception is thrown. </p>

</div>
</div>
<a class="anchor" id="aeb65b3fe01458595a74236112ae3b76d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::adjust_line_dof_index_for_line_orientation </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>line_orientation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For lines with non-standard line_orientation in 3D, the dofs on lines have to be permuted in order to be combined with the correct shape functions. Given a local dof <code>index</code> on a line, return the local index, if the line has non-standard line_orientation. In 2D and 1D there is no need for permutation, so the given index is simply returned. </p>

</div>
</div>
<a class="anchor" id="a0a976cfdc58da9322c1cf1240cca4a86"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::get_nonzero_components </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return in which of the vector components of this finite element the <code>ith</code> shape function is non-zero. The length of the returned array is equal to the number of vector components of this element.</p>
<p>For most finite element spaces, the result of this function will be a vector with exactly one element being <code>true</code>, since for most spaces the individual vector components are independent. In that case, the component with the single zero is also the first element of what <a class="el" href="classFiniteElement.html#a27220a135402b96c7e6eecbb04acda56">system_to_component_index()</a> returns.</p>
<p>Only for those spaces that couple the components, for example to make a shape function divergence free, will there be more than one <code>true</code> entry. Elements for which this is true are called non-primitive (see <a class="el" href="DEALGlossary.html#GlossPrimitive">GlossPrimitive</a>). </p>

<p>Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02215">2215</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa55c38a01fb805aca08e1e6d6d0d272f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::n_nonzero_components </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return in how many vector components the <code>ith</code> shape function is non-zero. This value equals the number of entries equal to <code>true</code> in the result of the <a class="el" href="classFiniteElement.html#a0a976cfdc58da9322c1cf1240cca4a86">get_nonzero_components()</a> function.</p>
<p>For most finite element spaces, the result will be equal to one. It is not equal to one only for those ansatz spaces for which vector-valued shape functions couple the individual components, for example in order to make them divergence-free. </p>

<p>Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02226">2226</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab8a57013e9e027acbf1afa1296de42d3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::is_primitive </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return whether the <code>ith</code> shape function is primitive in the sense that the shape function is non-zero in only one vector component. Non-primitive shape functions would then, for example, be those of divergence free ansatz spaces, in which the individual vector components are coupled.</p>
<p>The result of the function is <code>true</code> if and only if the result of <code>n_nonzero_components(i)</code> is equal to one. </p>

<p>Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02237">2237</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a class="anchor" id="a47ab123a8a467b8d78664630dd7c8881"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::n_base_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of base elements in a mixed discretization.</p>
<p>Note that even for vector valued finite elements, the number of components needs not coincide with the number of base elements, since they may be reused. For example, if you create a <a class="el" href="classFESystem.html">FESystem</a> with three identical finite element classes by using the constructor that takes one finite element and a multiplicity, then the number of base elements is still one, although the number of components of the finite element is equal to the multiplicity. </p>

<p>Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02062">2062</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae69718879703c808f7f774ec874ca075"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt;dim,spacedim&gt;&amp; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::base_element </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Access to base element objects. If the element is atomic, then <code>base_element(0)</code> is <code>this</code>. </p>

<p>Reimplemented in <a class="el" href="classFESystem.html#a71b15430429ed646f1f5669a311ca074">FESystem&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a9c4005d818c8034853c24e2bf24cc01d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::element_multiplicity </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This index denotes how often the base element <code>index</code> is used in a composed element. If the element is atomic, then the result is always equal to one. See the documentation for the <a class="el" href="classFiniteElement.html#a47ab123a8a467b8d78664630dd7c8881">n_base_elements()</a> function for more details. </p>

<p>Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02072">2072</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2c1a9946f93d090df3c0ab3ae03e1ac6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;, unsigned <a class="el" href="classint.html">int</a> &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::system_to_base_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return for shape function <code>index</code> the base element it belongs to, the number of the copy of this base element (which is between zero and the multiplicity of this element), and the index of this shape function within this base element.</p>
<p>If the element is not composed of others, then base and instance are always zero, and the index is equal to the number of the shape function. If the element is composed of single instances of other elements (i.e. all with multiplicity one) all of which are scalar, then base values and dof indices within this element are equal to the <a class="el" href="classFiniteElement.html#aa95bff4580b63275178a411dfb7785fa">system_to_component_table</a>. It differs only in case the element is composed of other elements and at least one of them is vector-valued itself.</p>
<p>This function returns valid values also in the case of vector-valued (i.e. non-primitive) shape functions, in contrast to the <a class="el" href="classFiniteElement.html#a27220a135402b96c7e6eecbb04acda56">system_to_component_index()</a> function. </p>

<p>Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02127">2127</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae6ea8e30c668e0ec6431e24adf1946b5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;, unsigned <a class="el" href="classint.html">int</a> &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::face_system_to_base_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as <a class="el" href="classFiniteElement.html#a2c1a9946f93d090df3c0ab3ae03e1ac6">system_to_base_index()</a>, but for degrees of freedom located on a face. The range of allowed indices is therefore 0..<a class="el" href="classFiniteElementData.html#a358bffed1fba59ef4df715469473fd36">dofs_per_face</a>.</p>
<p>You will rarely need this function in application programs, since almost all application codes only need to deal with cell indices, not face indices. The function is mainly there for use inside the library. </p>

<p>Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02140">2140</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a class="anchor" id="af0ff206343b7dfd44728e62a32cd859a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::first_block_of_base </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a base element number, return the first block of a <a class="el" href="classBlockVector.html">BlockVector</a> it would generate. </p>

<p>Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02152">2152</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a class="anchor" id="ada25262284d975d8576bd6a59c29e950"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::component_to_base_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For each vector component, return which base element implements this component and which vector component in this base element this is. This information is only of interest for vector-valued finite elements which are composed of several sub-elements. In that case, one may want to obtain information about the element implementing a certain vector component, which can be done using this function and the <a class="el" href="classFESystem.html#a71b15430429ed646f1f5669a311ca074">FESystem::base_element()</a> function.</p>
<p>If this is a scalar finite element, then the return value is always equal to a pair of zeros. </p>

<p>Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02162">2162</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1d7612a2031e6c5d23a64734612f1ca9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::block_to_base_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the base element for this block and the number of the copy of the base element. </p>

<p>Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02175">2175</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a class="anchor" id="abb422a6448b2bd45f2998ca68e242ca1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::system_to_block_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The vector block and the index inside the block for this shape function. </p>

<p>Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02185">2185</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae432507508728e19aca87bed4053992f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::component_to_block_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The vector block for this component. </p>

</div>
</div>
<a class="anchor" id="ace1f6cf0a9f0eb472be4df56743851aa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classComponentMask.html">ComponentMask</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::component_mask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a component mask with as many elements as this object has vector components and of which exactly the one component is true that corresponds to the given argument. See <a class="el" href="DEALGlossary.html#GlossComponentMask">the</a>glossary" for more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>An object that represents a single scalar vector component of this finite element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A component mask that is false in all components except for the one that corresponds to the argument. </dd></dl>

</div>
</div>
<a class="anchor" id="a530f6c3f6326e516aeb006e7533a4532"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classComponentMask.html">ComponentMask</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::component_mask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a component mask with as many elements as this object has vector components and of which exactly the <code>dim</code> components are true that correspond to the given argument. See <a class="el" href="DEALGlossary.html#GlossComponentMask">the</a>glossary" for more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>An object that represents dim vector components of this finite element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A component mask that is false in all components except for the ones that corresponds to the argument. </dd></dl>

</div>
</div>
<a class="anchor" id="a6c0845775110b0c056301527415e708a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classComponentMask.html">ComponentMask</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::component_mask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structFEValuesExtractors_1_1SymmetricTensor.html">FEValuesExtractors::SymmetricTensor</a>&lt; 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>sym_tensor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a component mask with as many elements as this object has vector components and of which exactly the <code>dim*(dim+1)/2</code> components are true that correspond to the given argument. See <a class="el" href="DEALGlossary.html#GlossComponentMask">the glossary</a> for more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sym_tensor</td><td>An object that represents dim*(dim+1)/2 components of this finite element that are jointly to be interpreted as forming a symmetric tensor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A component mask that is false in all components except for the ones that corresponds to the argument. </dd></dl>

</div>
</div>
<a class="anchor" id="a7f10e446507800a1bdbf346282f9c11d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classComponentMask.html">ComponentMask</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::component_mask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockMask.html">BlockMask</a> &amp;&#160;</td>
          <td class="paramname"><em>block_mask</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a block mask (see <a class="el" href="DEALGlossary.html#GlossBlockMask">this glossary entry</a>), produce a component mask (see <a class="el" href="DEALGlossary.html#GlossComponentMask">this glossary</a>entry") that represents the components that correspond to the blocks selected in the input argument. This is essentially a conversion operator from <a class="el" href="classBlockMask.html">BlockMask</a> to <a class="el" href="classComponentMask.html">ComponentMask</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_mask</td><td>The mask that selects individual blocks of the finite element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A mask that selects those components corresponding to the selected blocks of the input argument. </dd></dl>

</div>
</div>
<a class="anchor" id="ae1359a1b1d3014a78bd523be8c3e7f29"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockMask.html">BlockMask</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::block_mask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a block mask with as many elements as this object has blocks and of which exactly the one component is true that corresponds to the given argument. See <a class="el" href="DEALGlossary.html#GlossBlockMask">the glossary</a> for more information.</p>
<dl class="section note"><dt>Note</dt><dd>This function will only succeed if the scalar referenced by the argument encompasses a complete block. In other words, if, for example, you pass an extractor for the single <img class="formulaInl" alt="$x$" src="form_9.png"/> velocity and this object represents an <a class="el" href="classFE__RaviartThomas.html">FE_RaviartThomas</a> object, then the single scalar object you selected is part of a larger block and consequently there is no block mask that would represent it. The function will then produce an exception.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>An object that represents a single scalar vector component of this finite element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A component mask that is false in all components except for the one that corresponds to the argument. </dd></dl>

</div>
</div>
<a class="anchor" id="a548bef99cfe1ae9c2f3418392823e338"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockMask.html">BlockMask</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::block_mask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a component mask with as many elements as this object has vector components and of which exactly the <code>dim</code> components are true that correspond to the given argument. See <a class="el" href="DEALGlossary.html#GlossBlockMask">the</a>glossary" for more information.</p>
<dl class="section note"><dt>Note</dt><dd>The same caveat applies as to the version of the function above: The extractor object passed as argument must be so that it corresponds to full blocks and does not split blocks of this element.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>An object that represents dim vector components of this finite element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A component mask that is false in all components except for the ones that corresponds to the argument. </dd></dl>

</div>
</div>
<a class="anchor" id="a359b7c9f1f395e77ac8466f95a81304f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockMask.html">BlockMask</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::block_mask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structFEValuesExtractors_1_1SymmetricTensor.html">FEValuesExtractors::SymmetricTensor</a>&lt; 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>sym_tensor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a component mask with as many elements as this object has vector components and of which exactly the <code>dim*(dim+1)/2</code> components are true that correspond to the given argument. See <a class="el" href="DEALGlossary.html#GlossBlockMask">the glossary</a> for more information.</p>
<dl class="section note"><dt>Note</dt><dd>The same caveat applies as to the version of the function above: The extractor object passed as argument must be so that it corresponds to full blocks and does not split blocks of this element.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sym_tensor</td><td>An object that represents dim*(dim+1)/2 components of this finite element that are jointly to be interpreted as forming a symmetric tensor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A component mask that is false in all components except for the ones that corresponds to the argument. </dd></dl>

</div>
</div>
<a class="anchor" id="a7968a52626e5e89b3d6658bded5337bc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockMask.html">BlockMask</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::block_mask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a component mask (see <a class="el" href="DEALGlossary.html#GlossComponentMask">this glossary</a>entry"), produce a block mask (see @ref GlossBlockMask "this glossary entry") that represents the blocks that correspond to the components selected in the input argument. This is essentially a conversion operator from <a class="el" href="classComponentMask.html">ComponentMask</a> to <a class="el" href="classBlockMask.html">BlockMask</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This function will only succeed if the components referenced by the argument encompasses complete blocks. In other words, if, for example, you pass an component mask for the single <img class="formulaInl" alt="$x$" src="form_9.png"/> velocity and this object represents an <a class="el" href="classFE__RaviartThomas.html">FE_RaviartThomas</a> object, then the single component you selected is part of a larger block and consequently there is no block mask that would represent it. The function will then produce an exception.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">component_mask</td><td>The mask that selects individual components of the finite element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A mask that selects those blocks corresponding to the selected blocks of the input argument. </dd></dl>

</div>
</div>
<a class="anchor" id="a4d0bbfcff05ddbe1d766a5cf7e2adf51"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classPoint.html">Point</a>&lt;dim&gt; &gt;&amp; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::get_unit_support_points </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the support points of the trial functions on the unit cell, if the derived finite element defines them. Finite elements that allow some kind of interpolation operation usually have support points. On the other hand, elements that define their degrees of freedom by, for example, moments on faces, or as derivatives, don't have support points. In that case, the returned field is empty.</p>
<p>If the finite element defines support points, then their number equals the number of degrees of freedom of the element. The order of points in the array matches that returned by the <code>cell-&gt;get_dof_indices</code> function.</p>
<p>See the class documentation for details on support points.</p>
<dl class="section note"><dt>Note</dt><dd>Finite elements' implementation of this function returns these points in the same order as shape functions. The order of shape functions is typically documented in the class documentation of the various finite element classes. In particular, shape functions (and consequently the mapped quadrature points discussed in the class documentation of this class) will then traverse first those shape functions located on vertices, then on lines, then on quads, etc.</dd>
<dd>
If this element implements support points, then it will return one such point per shape function. Since multiple shape functions may be defined at the same location, the support points returned here may be duplicated. An example would be an element of the kind <code><a class="el" href="classFESystem.html">FESystem(FE_Q(1),3)</a></code> for which each support point would appear three times in the returned array. </dd></dl>

</div>
</div>
<a class="anchor" id="aacd8adea5225d5aa5a24b7d1d60995ff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::has_support_points </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether a finite element has defined support points. If the result is true, then a call to the <a class="el" href="classFiniteElement.html#a4d0bbfcff05ddbe1d766a5cf7e2adf51">get_unit_support_points()</a> yields a non-empty array.</p>
<p>The result may be false if an element is not defined by interpolating shape functions, for example by P-elements on quadrilaterals. It will usually only be true if the element constructs its shape functions by the requirement that they be one at a certain point and zero at all the points associated with the other shape functions.</p>
<p>In composed elements (i.e. for the <a class="el" href="classFESystem.html">FESystem</a> class, the result will be true if all all the base elements have defined support points. </p>

</div>
</div>
<a class="anchor" id="a3b45b4d2b3b8d3d056155e3c7c0d393b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPoint.html">Point</a>&lt;dim&gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::unit_support_point </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the position of the support point of the <code>indexth</code> shape function. If it does not exist, raise an exception.</p>
<p>The default implementation simply returns the respective element from the array you get from <a class="el" href="classFiniteElement.html#a4d0bbfcff05ddbe1d766a5cf7e2adf51">get_unit_support_points()</a>, but derived elements may overload this function. In particular, note that the <a class="el" href="classFESystem.html">FESystem</a> class overloads it so that it can return the support points of individual base elements, if not all the base elements define support points. In this way, you can still ask for certain support points, even if <a class="el" href="classFiniteElement.html#a4d0bbfcff05ddbe1d766a5cf7e2adf51">get_unit_support_points()</a> only returns an empty array. </p>

<p>Reimplemented in <a class="el" href="classFESystem.html#a88cb7b2bf9ee8afeb1dc999375fb47fb">FESystem&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a3c557f753676d89d4ddfc0cff9d845b4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classPoint.html">Point</a>&lt;dim-1&gt; &gt;&amp; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::get_unit_face_support_points </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the support points of the trial functions on the unit face, if the derived finite element defines some. Finite elements that allow some kind of interpolation operation usually have support points. On the other hand, elements that define their degrees of freedom by, for example, moments on faces, or as derivatives, don't have support points. In that case, the returned field is empty</p>
<p>Note that elements that have support points need not necessarily have some on the faces, even if the interpolation points are located physically on a face. For example, the discontinuous elements have interpolation points on the vertices, and for higher degree elements also on the faces, but they are not defined to be on faces since in that case degrees of freedom from both sides of a face (or from all adjacent elements to a vertex) would be identified with each other, which is not what we would like to have). Logically, these degrees of freedom are therefore defined to belong to the cell, rather than the face or vertex. In that case, the returned element would therefore have length zero.</p>
<p>If the finite element defines support points, then their number equals the number of degrees of freedom on the face (<a class="el" href="classFiniteElementData.html#a358bffed1fba59ef4df715469473fd36">dofs_per_face</a>). The order of points in the array matches that returned by the <code>cell-&gt;get_dof_indices</code> function.</p>
<p>See the class documentation for details on support points. </p>

</div>
</div>
<a class="anchor" id="a8082dd2e9d3cd6000a8f57b699e8f66c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::has_face_support_points </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether a finite element has defined support points on faces. If the result is true, then a call to the <a class="el" href="classFiniteElement.html#a3c557f753676d89d4ddfc0cff9d845b4">get_unit_face_support_points()</a> yields a non-empty array.</p>
<p>For more information, see the documentation for the <a class="el" href="classFiniteElement.html#aacd8adea5225d5aa5a24b7d1d60995ff">has_support_points()</a> function. </p>

</div>
</div>
<a class="anchor" id="a2aa894c8be8daf33c67b357ea36d88ea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPoint.html">Point</a>&lt;dim-1&gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::unit_face_support_point </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function corresponding to the <a class="el" href="classFiniteElement.html#a3b45b4d2b3b8d3d056155e3c7c0d393b">unit_support_point()</a> function, but for faces. See there for more information. </p>

<p>Reimplemented in <a class="el" href="classFESystem.html#a4632f49bc19228fbdf4acb4eb42c6d21">FESystem&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a9d007ccbe875c84dd5848b8ee316dff0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classPoint.html">Point</a>&lt;dim&gt; &gt;&amp; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::get_generalized_support_points </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a support point vector for generalized interpolation.</p>
<p>See the <a class="el" href="DEALGlossary.html#GlossGeneralizedSupport">glossary entry on generalized</a>support points" for more information. </p>

</div>
</div>
<a class="anchor" id="a0e9eebb69e53c5233c99e0e1d506e15d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::has_generalized_support_points </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns <code>true</code> if the class provides nonempty vectors either from <a class="el" href="classFiniteElement.html#a4d0bbfcff05ddbe1d766a5cf7e2adf51">get_unit_support_points()</a> or <a class="el" href="classFiniteElement.html#a9d007ccbe875c84dd5848b8ee316dff0">get_generalized_support_points()</a>.</p>
<p>See the <a class="el" href="DEALGlossary.html#GlossGeneralizedSupport">glossary entry on generalized</a>support points" for more information. </p>

</div>
</div>
<a class="anchor" id="a4a0d8732342cd7f8914b8ede6bd677f4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::has_generalized_face_support_points </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether a finite element has defined generalized support points on faces. If the result is true, then a call to the get_generalized_face_support_points yields a non-empty array.</p>
<p>For more information, see the documentation for the <a class="el" href="classFiniteElement.html#aacd8adea5225d5aa5a24b7d1d60995ff">has_support_points()</a> function. </p>

</div>
</div>
<a class="anchor" id="ab9a8396437ea80e8a250eca1c258cca0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::interpolate </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_dofs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Interpolate a set of scalar values, computed in the generalized support points.</p>
<dl class="section note"><dt>Note</dt><dd>This function is implemented in <a class="el" href="classFiniteElement.html">FiniteElement</a> for the case that the element has support points. In this case, the resulting coefficients are just the values in the suport points. All other elements must reimplement it. </dd></dl>

<p>Reimplemented in <a class="el" href="classFE__RaviartThomasNodal.html#a0d5c8eb9828ac6e96550a3696882f9aa">FE_RaviartThomasNodal&lt; dim &gt;</a>, <a class="el" href="classFE__Nedelec.html#aeeaf173215a35f799f3a220b15da45b6">FE_Nedelec&lt; dim &gt;</a>, <a class="el" href="classFE__Q__DG0.html#ab5cf588915acef050a1dbb25178f40ac">FE_Q_DG0&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__RaviartThomas.html#a6c446410856cb83784023d265f9328e3">FE_RaviartThomas&lt; dim &gt;</a>, <a class="el" href="classFE__ABF.html#a9fb37355529c3347a00ac75eadd6480e">FE_ABF&lt; dim &gt;</a>, <a class="el" href="classFE__DGVector.html#ab4e4037a69d130bd970742addd128eba">FE_DGVector&lt; POLY, dim, spacedim &gt;</a>, <a class="el" href="classFE__DGVector.html#ab4e4037a69d130bd970742addd128eba">FE_DGVector&lt; PolynomialsRaviartThomas&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__DGVector.html#ab4e4037a69d130bd970742addd128eba">FE_DGVector&lt; PolynomialsBDM&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__DGVector.html#ab4e4037a69d130bd970742addd128eba">FE_DGVector&lt; PolynomialsNedelec&lt; dim &gt;, dim, spacedim &gt;</a>, and <a class="el" href="classFE__BDM.html#a3bd4a3902fe8ea421582af2609156f94">FE_BDM&lt; dim &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a1ca0f2619808761bb8cc53ca907368e4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::interpolate </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_dofs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Interpolate a set of vector values, computed in the generalized support points.</p>
<p>Since a finite element often only interpolates part of a vector, <code>offset</code> is used to determine the first component of the vector to be interpolated. Maybe consider changing your data structures to use the next function. </p>

<p>Reimplemented in <a class="el" href="classFE__RaviartThomasNodal.html#a75fce0155366955b740f2e60ab159c95">FE_RaviartThomasNodal&lt; dim &gt;</a>, <a class="el" href="classFE__Q__DG0.html#a2b197cf5eae7961e5308195fa93f742b">FE_Q_DG0&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Nedelec.html#a9317d5ddabb49465544099615012f470">FE_Nedelec&lt; dim &gt;</a>, <a class="el" href="classFE__RaviartThomas.html#a86f0a72b3c7b0467ce58ca96cf47160a">FE_RaviartThomas&lt; dim &gt;</a>, <a class="el" href="classFE__ABF.html#ab8d6189b4633bb099226d6ae98ab7b9f">FE_ABF&lt; dim &gt;</a>, <a class="el" href="classFE__DGVector.html#a95edd17c88e16136abd2e1089e30ee2e">FE_DGVector&lt; POLY, dim, spacedim &gt;</a>, <a class="el" href="classFE__DGVector.html#a95edd17c88e16136abd2e1089e30ee2e">FE_DGVector&lt; PolynomialsRaviartThomas&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__DGVector.html#a95edd17c88e16136abd2e1089e30ee2e">FE_DGVector&lt; PolynomialsBDM&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__DGVector.html#a95edd17c88e16136abd2e1089e30ee2e">FE_DGVector&lt; PolynomialsNedelec&lt; dim &gt;, dim, spacedim &gt;</a>, and <a class="el" href="classFE__BDM.html#a1bdde3bddaadedbbd1ec3bb0c6458d53">FE_BDM&lt; dim &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a17a9b5fdf8ba7c9fc2b00102715997d3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::interpolate </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_dofs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; const std::vector&lt; std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Interpolate a set of vector values, computed in the generalized support points. </p>

<p>Reimplemented in <a class="el" href="classFE__RaviartThomasNodal.html#a034d5136c76f405381518f50388765ae">FE_RaviartThomasNodal&lt; dim &gt;</a>, <a class="el" href="classFE__Q__DG0.html#a0726a9673615ea77ccd63af42d12a38f">FE_Q_DG0&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Nedelec.html#a08f9885ca5d297e4da585950a1f1e509">FE_Nedelec&lt; dim &gt;</a>, <a class="el" href="classFE__RaviartThomas.html#afdfdfaf403dfd1e6b3a122ba22e452fe">FE_RaviartThomas&lt; dim &gt;</a>, <a class="el" href="classFE__ABF.html#abbe6fcc1e0b8e2f157e096f962a46068">FE_ABF&lt; dim &gt;</a>, <a class="el" href="classFE__DGVector.html#ac2143fbaafc1fb1661bc7991e9dbc206">FE_DGVector&lt; POLY, dim, spacedim &gt;</a>, <a class="el" href="classFE__DGVector.html#ac2143fbaafc1fb1661bc7991e9dbc206">FE_DGVector&lt; PolynomialsRaviartThomas&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__DGVector.html#ac2143fbaafc1fb1661bc7991e9dbc206">FE_DGVector&lt; PolynomialsBDM&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__DGVector.html#ac2143fbaafc1fb1661bc7991e9dbc206">FE_DGVector&lt; PolynomialsNedelec&lt; dim &gt;, dim, spacedim &gt;</a>, and <a class="el" href="classFE__BDM.html#aa61451f72955953611aa98b164190e6c">FE_BDM&lt; dim &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a147d7f02d1fe78fc3294d43521ff7fb3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::size_t <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determine an estimate for the memory consumption (in bytes) of this object.</p>
<p>This function is made virtual, since finite element objects are usually accessed through pointers to their base class, rather than the class itself. </p>

<p>Reimplemented in <a class="el" href="classFESystem.html#a297b100333b0fcc8809f98d03bd2e5af">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Hierarchical.html#a85a8188de3f62e09cbcbaa01a28685b0">FE_Q_Hierarchical&lt; dim &gt;</a>, <a class="el" href="classFE__DGPNonparametric.html#a472d8dcf78de889f33b4b1ff168505dd">FE_DGPNonparametric&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGPMonomial.html#a9695c0ed590cb248289a4bbdb1068c8c">FE_DGPMonomial&lt; dim &gt;</a>, <a class="el" href="classFE__DGP.html#abb0287cc5d0cba53359c9a2ea49a70a3">FE_DGP&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGQ.html#a1e84abc5a04b545b8251de5e3ed1af06">FE_DGQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Nedelec.html#ad5ed4a6f74895db91e472d9e06537bb7">FE_Nedelec&lt; dim &gt;</a>, <a class="el" href="classFE__RaviartThomas.html#a22ae443a646528b5878cb8bec1911249">FE_RaviartThomas&lt; dim &gt;</a>, <a class="el" href="classFE__ABF.html#adaaf9fc6d691dd3292abe981a6f6b366">FE_ABF&lt; dim &gt;</a>, <a class="el" href="classFE__DGVector.html#adc0e74f84f6f986ffbd703b6dfc79150">FE_DGVector&lt; POLY, dim, spacedim &gt;</a>, <a class="el" href="classFE__DGVector.html#adc0e74f84f6f986ffbd703b6dfc79150">FE_DGVector&lt; PolynomialsRaviartThomas&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__DGVector.html#adc0e74f84f6f986ffbd703b6dfc79150">FE_DGVector&lt; PolynomialsBDM&lt; dim &gt;, dim, spacedim &gt;</a>, and <a class="el" href="classFE__DGVector.html#adc0e74f84f6f986ffbd703b6dfc79150">FE_DGVector&lt; PolynomialsNedelec&lt; dim &gt;, dim, spacedim &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a62838f7428ee56e34c4081ca6d03bc26"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::reinit_restriction_and_prolongation_matrices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>isotropic_restriction_only</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>isotropic_prolongation_only</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reinit the vectors of restriction and prolongation matrices to the right sizes: For every refinement case, except for RefinementCase::no_refinement, and for every child of that refinement case the space of one restriction and prolongation matrix is allocated, see the documentation of the restriction and prolongation vectors for more detail on the actual vector sizes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">isotropic_restriction_only</td><td>only the restriction matrices required for isotropic refinement are reinited to the right size. </td></tr>
    <tr><td class="paramname">isotropic_prolongation_only</td><td>only the prolongation matrices required for isotropic refinement are reinited to the right size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afc598cf9fe938a1700279c6c6230fd76"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTableIndices.html">TableIndices</a>&lt;2&gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::interface_constraints_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the size of interface constraint matrices. Since this is needed in every derived finite element class when initializing their size, it is placed into this function, to avoid having to recompute the dimension-dependent size of these matrices each time.</p>
<p>Note that some elements do not implement the interface constraints for certain polynomial degrees. In this case, this function still returns the size these matrices should have when implemented, but the actual matrices are empty. </p>

</div>
</div>
<a class="anchor" id="a7d12c1ae13a333d1212847df4ec8ad1d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::compute_2nd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>mapping_internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>fe_internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFEValuesData.html">FEValuesData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute second derivatives by finite differences of gradients. </p>

</div>
</div>
<a class="anchor" id="abe780620df7c633e43ca45aba2e4270f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt;unsigned <a class="el" href="classint.html">int</a>&gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::compute_n_nonzero_components </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classComponentMask.html">ComponentMask</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nonzero_components</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given the pattern of nonzero components for each shape function, compute for each entry how many components are non-zero for each shape function. This function is used in the constructor of this class. </p>

</div>
</div>
<a class="anchor" id="a53ec2e9b0b29a6c0df0b941528be0306"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::update_once </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determine the values a finite element should compute on initialization of data for <a class="el" href="classFEValues.html">FEValues</a>.</p>
<p>Given a set of flags indicating what quantities are requested from a <a class="el" href="classFEValues.html">FEValues</a> object, <a class="el" href="classFiniteElement.html#a53ec2e9b0b29a6c0df0b941528be0306">update_once()</a> and <a class="el" href="classFiniteElement.html#a876f0be1b38ad6ed2ccad297876e1287">update_each()</a> compute which values must really be computed. Then, the <code>fill_*_values</code> functions are called with the result of these.</p>
<p>Furthermore, values must be computed either on the unit cell or on the physical cell. For instance, the function values of <a class="el" href="classFE__Q.html">FE_Q</a> do only depend on the quadrature points on the unit cell. Therefore, this flags will be returned by <a class="el" href="classFiniteElement.html#a53ec2e9b0b29a6c0df0b941528be0306">update_once()</a>. The gradients require computation of the covariant transformation matrix. Therefore, <code>update_covariant_transformation</code> and <code>update_gradients</code> will be returned by <a class="el" href="classFiniteElement.html#a876f0be1b38ad6ed2ccad297876e1287">update_each()</a>.</p>
<p>For an example see the same function in the derived class <a class="el" href="classFE__Q.html">FE_Q</a>. </p>

<p>Implemented in <a class="el" href="classFESystem.html#ab5c3621066fab3c8c7c18c2e310fcd7d">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGPNonparametric.html#aac2be803823de3a60fac2457af9ea912">FE_DGPNonparametric&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyFace.html#ae9453a95af596a642ef473619bb45f7f">FE_PolyFace&lt; POLY, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyFace.html#ae9453a95af596a642ef473619bb45f7f">FE_PolyFace&lt; PolynomialSpace&lt; dim-1 &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyFace.html#ae9453a95af596a642ef473619bb45f7f">FE_PolyFace&lt; TensorProductPolynomials&lt; dim-1 &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__ABF.html#adb7a3b1c5d70070baaf9cf3cb555e546">FE_ABF&lt; dim &gt;</a>, <a class="el" href="classFE__Poly.html#a583459170e8ba219e18c5485141edd75">FE_Poly&lt; POLY, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#a583459170e8ba219e18c5485141edd75">FE_Poly&lt; PolynomialSpace&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#a583459170e8ba219e18c5485141edd75">FE_Poly&lt; PolynomialsP&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__Poly.html#a583459170e8ba219e18c5485141edd75">FE_Poly&lt; TensorProductPolynomials&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__Poly.html#a583459170e8ba219e18c5485141edd75">FE_Poly&lt; TensorProductPolynomials&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#a583459170e8ba219e18c5485141edd75">FE_Poly&lt; TensorProductPolynomialsConst&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#a583459170e8ba219e18c5485141edd75">FE_Poly&lt; TensorProductPolynomials&lt; dim, Polynomials::PiecewisePolynomial&lt; double &gt; &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#ab3d66aa2b9db45e121445c331b077692">FE_PolyTensor&lt; POLY, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#ab3d66aa2b9db45e121445c331b077692">FE_PolyTensor&lt; PolynomialsRaviartThomas&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#ab3d66aa2b9db45e121445c331b077692">FE_PolyTensor&lt; PolynomialsNedelec&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#ab3d66aa2b9db45e121445c331b077692">FE_PolyTensor&lt; PolynomialsRaviartThomas&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#ab3d66aa2b9db45e121445c331b077692">FE_PolyTensor&lt; PolynomialsBDM&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#ab3d66aa2b9db45e121445c331b077692">FE_PolyTensor&lt; PolynomialsBDM&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#ab3d66aa2b9db45e121445c331b077692">FE_PolyTensor&lt; PolynomialsABF&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#ab3d66aa2b9db45e121445c331b077692">FE_PolyTensor&lt; PolynomialsNedelec&lt; dim &gt;, dim, spacedim &gt;</a>, and <a class="el" href="classFE__Nothing.html#afec688d5f70d14b2cb041e7494f41f15">FE_Nothing&lt; dim &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a876f0be1b38ad6ed2ccad297876e1287"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::update_each </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Complementary function for <a class="el" href="classFiniteElement.html#a53ec2e9b0b29a6c0df0b941528be0306">update_once()</a>.</p>
<p>While <a class="el" href="classFiniteElement.html#a53ec2e9b0b29a6c0df0b941528be0306">update_once()</a> returns the values to be computed on the unit cell for yielding the required data, this function determines the values that must be recomputed on each cell.</p>
<p>Refer to <a class="el" href="classFiniteElement.html#a53ec2e9b0b29a6c0df0b941528be0306">update_once()</a> for more details. </p>

<p>Implemented in <a class="el" href="classFESystem.html#a659c206925de4e6bee6738e342699309">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGPNonparametric.html#a197cb3621eb3a88e7ed2575c1111d8c5">FE_DGPNonparametric&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyFace.html#a4953dbfe636ed78af4e7c03c83c91b56">FE_PolyFace&lt; POLY, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyFace.html#a4953dbfe636ed78af4e7c03c83c91b56">FE_PolyFace&lt; PolynomialSpace&lt; dim-1 &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyFace.html#a4953dbfe636ed78af4e7c03c83c91b56">FE_PolyFace&lt; TensorProductPolynomials&lt; dim-1 &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#abc9057919d8f91dbceb97f4e448a4ce6">FE_Poly&lt; POLY, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#abc9057919d8f91dbceb97f4e448a4ce6">FE_Poly&lt; PolynomialSpace&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#abc9057919d8f91dbceb97f4e448a4ce6">FE_Poly&lt; PolynomialsP&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__Poly.html#abc9057919d8f91dbceb97f4e448a4ce6">FE_Poly&lt; TensorProductPolynomials&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__Poly.html#abc9057919d8f91dbceb97f4e448a4ce6">FE_Poly&lt; TensorProductPolynomials&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#abc9057919d8f91dbceb97f4e448a4ce6">FE_Poly&lt; TensorProductPolynomialsConst&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#abc9057919d8f91dbceb97f4e448a4ce6">FE_Poly&lt; TensorProductPolynomials&lt; dim, Polynomials::PiecewisePolynomial&lt; double &gt; &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__ABF.html#a592506f6a3e0acbe5ddf7a4a368dc2ea">FE_ABF&lt; dim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a597364894f48598267e5327736b4722b">FE_PolyTensor&lt; POLY, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a597364894f48598267e5327736b4722b">FE_PolyTensor&lt; PolynomialsRaviartThomas&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a597364894f48598267e5327736b4722b">FE_PolyTensor&lt; PolynomialsNedelec&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a597364894f48598267e5327736b4722b">FE_PolyTensor&lt; PolynomialsRaviartThomas&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a597364894f48598267e5327736b4722b">FE_PolyTensor&lt; PolynomialsBDM&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a597364894f48598267e5327736b4722b">FE_PolyTensor&lt; PolynomialsBDM&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a597364894f48598267e5327736b4722b">FE_PolyTensor&lt; PolynomialsABF&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a597364894f48598267e5327736b4722b">FE_PolyTensor&lt; PolynomialsNedelec&lt; dim &gt;, dim, spacedim &gt;</a>, and <a class="el" href="classFE__Nothing.html#a1484157d5145e87667346c454938c0c7">FE_Nothing&lt; dim &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a7631a5a3cc67eaf6f498f2bd6ef4151c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt;dim,spacedim&gt;* <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A sort of virtual copy constructor. Some places in the library, for example the constructors of <a class="el" href="classFESystem.html">FESystem</a> as well as the <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a> class, need to make copies of finite elements without knowing their exact type. They do so through this function. </p>

<p>Implemented in <a class="el" href="classFESystem.html#aea73b878ab435355032adea9c22c1e94">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGQArbitraryNodes.html#a327e2d184a0cbe7afe70fd0c3455fef9">FE_DGQArbitraryNodes&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGPNonparametric.html#a84da29af338285dc948face0fff345f6">FE_DGPNonparametric&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Hierarchical.html#ab8693ac80e224902ae0ced66520664ca">FE_Q_Hierarchical&lt; dim &gt;</a>, <a class="el" href="classFE__RaviartThomasNodal.html#ac9f843c820062b9472f4e371506c7f1e">FE_RaviartThomasNodal&lt; dim &gt;</a>, <a class="el" href="classFE__DGP.html#a9aa4841520fa944b4fd5c33163f86400">FE_DGP&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__DG0.html#a9cd73ee4e57e1fa42c37e2f1569b3436">FE_Q_DG0&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGQ.html#a033a77b1b585ba32cfd07a96bace73dd">FE_DGQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGPMonomial.html#a2bfd7ce0d2e4c12b9b822cbcefebb131">FE_DGPMonomial&lt; dim &gt;</a>, <a class="el" href="classFE__Nedelec.html#a6a540419a8bf5d7d231e63cb8c4dade8">FE_Nedelec&lt; dim &gt;</a>, <a class="el" href="classFE__Q.html#af51fa5e81c41f8aea1ca2da307c006e1">FE_Q&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q.html#af51fa5e81c41f8aea1ca2da307c006e1">FE_Q&lt; dim &gt;</a>, <a class="el" href="classFE__FaceP.html#af28fce971f8684081158d7820a37467d">FE_FaceP&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__iso__Q1.html#ad1c2276328f0c8cc8bf9150fab924679">FE_Q_iso_Q1&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__RaviartThomas.html#a92741ab1e32c5e927957e7ada8a73ca8">FE_RaviartThomas&lt; dim &gt;</a>, <a class="el" href="classFE__ABF.html#a117cef7b6eb9244b325d06c7c32b9bf2">FE_ABF&lt; dim &gt;</a>, <a class="el" href="classFE__Nothing.html#a72d35f8e94eddc5671b474d071945322">FE_Nothing&lt; dim &gt;</a>, <a class="el" href="classFE__BDM.html#ada3e6b1a8f5d10e5d89d1a3e2ebaf29d">FE_BDM&lt; dim &gt;</a>, <a class="el" href="classFE__DGVector.html#aab0f631385f22ce40dd3e1d95f2b398c">FE_DGVector&lt; POLY, dim, spacedim &gt;</a>, <a class="el" href="classFE__DGVector.html#aab0f631385f22ce40dd3e1d95f2b398c">FE_DGVector&lt; PolynomialsRaviartThomas&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__DGVector.html#aab0f631385f22ce40dd3e1d95f2b398c">FE_DGVector&lt; PolynomialsBDM&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__DGVector.html#aab0f631385f22ce40dd3e1d95f2b398c">FE_DGVector&lt; PolynomialsNedelec&lt; dim &gt;, dim, spacedim &gt;</a>, and <a class="el" href="classFE__FaceQ.html#a29e85ba0bd11449160dd51bc5c372a7d">FE_FaceQ&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="aada317cd0cdd78de8f747bc458655218"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMapping.html">Mapping</a>&lt;dim,spacedim&gt;::<a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a>* <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::get_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Prepare internal data structures and fill in values independent of the cell. Returns a pointer to an object of which the caller of this function then has to assume ownership (which includes destruction when it is no more needed). </p>

<p>Implemented in <a class="el" href="classFESystem.html#a08c1056f5fc972b02277c264f9d11893">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGPNonparametric.html#a91a8c18f3eacaf0eb4bf5a0a3b4c8cd4">FE_DGPNonparametric&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a6f8dfde746b48a8d5026d10003ba8fd8">FE_PolyTensor&lt; POLY, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a6f8dfde746b48a8d5026d10003ba8fd8">FE_PolyTensor&lt; PolynomialsRaviartThomas&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a6f8dfde746b48a8d5026d10003ba8fd8">FE_PolyTensor&lt; PolynomialsNedelec&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a6f8dfde746b48a8d5026d10003ba8fd8">FE_PolyTensor&lt; PolynomialsRaviartThomas&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a6f8dfde746b48a8d5026d10003ba8fd8">FE_PolyTensor&lt; PolynomialsBDM&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a6f8dfde746b48a8d5026d10003ba8fd8">FE_PolyTensor&lt; PolynomialsBDM&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a6f8dfde746b48a8d5026d10003ba8fd8">FE_PolyTensor&lt; PolynomialsABF&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a6f8dfde746b48a8d5026d10003ba8fd8">FE_PolyTensor&lt; PolynomialsNedelec&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyFace.html#a73617d556c1b25f2baf979ce94e81240">FE_PolyFace&lt; POLY, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyFace.html#a73617d556c1b25f2baf979ce94e81240">FE_PolyFace&lt; PolynomialSpace&lt; dim-1 &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyFace.html#a73617d556c1b25f2baf979ce94e81240">FE_PolyFace&lt; TensorProductPolynomials&lt; dim-1 &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#a88e3961fbbc852a6b7c73bbf86a2ae81">FE_Poly&lt; POLY, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#a88e3961fbbc852a6b7c73bbf86a2ae81">FE_Poly&lt; PolynomialSpace&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#a88e3961fbbc852a6b7c73bbf86a2ae81">FE_Poly&lt; PolynomialsP&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__Poly.html#a88e3961fbbc852a6b7c73bbf86a2ae81">FE_Poly&lt; TensorProductPolynomials&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__Poly.html#a88e3961fbbc852a6b7c73bbf86a2ae81">FE_Poly&lt; TensorProductPolynomials&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#a88e3961fbbc852a6b7c73bbf86a2ae81">FE_Poly&lt; TensorProductPolynomialsConst&lt; dim &gt;, dim, spacedim &gt;</a>, and <a class="el" href="classFE__Poly.html#a88e3961fbbc852a6b7c73bbf86a2ae81">FE_Poly&lt; TensorProductPolynomials&lt; dim, Polynomials::PiecewisePolynomial&lt; double &gt; &gt;, dim, spacedim &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a998bb8e8b7ee2a035d039cc558f47898"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMapping.html">Mapping</a>&lt;dim,spacedim&gt;::<a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a>* <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::get_face_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Prepare internal data structure for transformation of faces and fill in values independent of the cell. Returns a pointer to an object of which the caller of this function then has to assume ownership (which includes destruction when it is no more needed). </p>

<p>Reimplemented in <a class="el" href="classFESystem.html#ab952e9df68dd22f310589f259f9868c0">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyFace.html#a9c3fab3e9bacabc9cb8dc588c5d30730">FE_PolyFace&lt; POLY, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyFace.html#a9c3fab3e9bacabc9cb8dc588c5d30730">FE_PolyFace&lt; PolynomialSpace&lt; dim-1 &gt;, dim, spacedim &gt;</a>, and <a class="el" href="classFE__PolyFace.html#a9c3fab3e9bacabc9cb8dc588c5d30730">FE_PolyFace&lt; TensorProductPolynomials&lt; dim-1 &gt;, dim, spacedim &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ae3da3d8441ecd90b4f0ffbb656811245"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMapping.html">Mapping</a>&lt;dim,spacedim&gt;::<a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a>* <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::get_subface_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Prepare internal data structure for transformation of children of faces and fill in values independent of the cell. Returns a pointer to an object of which the caller of this function then has to assume ownership (which includes destruction when it is no more needed). </p>

<p>Reimplemented in <a class="el" href="classFESystem.html#a121ee8a0da0dd6d9279ba33a385d62a4">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyFace.html#a0efb910cb592c8f7fe7dc7ebb7aa4164">FE_PolyFace&lt; POLY, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyFace.html#a0efb910cb592c8f7fe7dc7ebb7aa4164">FE_PolyFace&lt; PolynomialSpace&lt; dim-1 &gt;, dim, spacedim &gt;</a>, and <a class="el" href="classFE__PolyFace.html#a0efb910cb592c8f7fe7dc7ebb7aa4164">FE_PolyFace&lt; TensorProductPolynomials&lt; dim-1 &gt;, dim, spacedim &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a6f982cbcd77e6067fb61c8ec4573091a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::fill_fe_values </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>mapping_internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>fe_internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFEValuesData.html">FEValuesData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CellSimilarity::Similarity &amp;&#160;</td>
          <td class="paramname"><em>cell_similarity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fill the fields of <a class="el" href="classFEValues.html">FEValues</a>. This function performs all the operations needed to compute the data of an <a class="el" href="classFEValues.html">FEValues</a> object.</p>
<p>The same function in <code>mapping</code> must have been called for the same cell first! </p>

<p>Implemented in <a class="el" href="classFESystem.html#aafd3426acb8de687ba803fc5f7884113">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGPNonparametric.html#a354728c341cf8a235765350114a7e080">FE_DGPNonparametric&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a7d05fec4a765ac4deb859a7a034264ca">FE_PolyTensor&lt; POLY, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a7d05fec4a765ac4deb859a7a034264ca">FE_PolyTensor&lt; PolynomialsRaviartThomas&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a7d05fec4a765ac4deb859a7a034264ca">FE_PolyTensor&lt; PolynomialsNedelec&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a7d05fec4a765ac4deb859a7a034264ca">FE_PolyTensor&lt; PolynomialsRaviartThomas&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a7d05fec4a765ac4deb859a7a034264ca">FE_PolyTensor&lt; PolynomialsBDM&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a7d05fec4a765ac4deb859a7a034264ca">FE_PolyTensor&lt; PolynomialsBDM&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a7d05fec4a765ac4deb859a7a034264ca">FE_PolyTensor&lt; PolynomialsABF&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a7d05fec4a765ac4deb859a7a034264ca">FE_PolyTensor&lt; PolynomialsNedelec&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyFace.html#a5db35d26905c2f0d62c882413c8f4d30">FE_PolyFace&lt; POLY, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyFace.html#a5db35d26905c2f0d62c882413c8f4d30">FE_PolyFace&lt; PolynomialSpace&lt; dim-1 &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyFace.html#a5db35d26905c2f0d62c882413c8f4d30">FE_PolyFace&lt; TensorProductPolynomials&lt; dim-1 &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#abe3603dd2a3ccbb22f29a3c37d5ca18e">FE_Poly&lt; POLY, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#abe3603dd2a3ccbb22f29a3c37d5ca18e">FE_Poly&lt; PolynomialSpace&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#abe3603dd2a3ccbb22f29a3c37d5ca18e">FE_Poly&lt; PolynomialsP&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__Poly.html#abe3603dd2a3ccbb22f29a3c37d5ca18e">FE_Poly&lt; TensorProductPolynomials&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__Poly.html#abe3603dd2a3ccbb22f29a3c37d5ca18e">FE_Poly&lt; TensorProductPolynomials&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#abe3603dd2a3ccbb22f29a3c37d5ca18e">FE_Poly&lt; TensorProductPolynomialsConst&lt; dim &gt;, dim, spacedim &gt;</a>, and <a class="el" href="classFE__Poly.html#abe3603dd2a3ccbb22f29a3c37d5ca18e">FE_Poly&lt; TensorProductPolynomials&lt; dim, Polynomials::PiecewisePolynomial&lt; double &gt; &gt;, dim, spacedim &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ab19a60429e5405beb8447a1a7d51765c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::fill_fe_face_values </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>mapping_internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>fe_internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFEValuesData.html">FEValuesData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fill the fields of <a class="el" href="classFEFaceValues.html">FEFaceValues</a>. This function performs all the operations needed to compute the data of an <a class="el" href="classFEFaceValues.html">FEFaceValues</a> object.</p>
<p>The same function in <code>mapping</code> must have been called for the same cell first! </p>

<p>Implemented in <a class="el" href="classFESystem.html#a7212e5316731c82c8be1d63cb99e9255">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGPNonparametric.html#a08f020e213ac6dd25bd35190374c6dc6">FE_DGPNonparametric&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a33ac26ab987566828481d256a73b5f80">FE_PolyTensor&lt; POLY, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a33ac26ab987566828481d256a73b5f80">FE_PolyTensor&lt; PolynomialsRaviartThomas&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a33ac26ab987566828481d256a73b5f80">FE_PolyTensor&lt; PolynomialsNedelec&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a33ac26ab987566828481d256a73b5f80">FE_PolyTensor&lt; PolynomialsRaviartThomas&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a33ac26ab987566828481d256a73b5f80">FE_PolyTensor&lt; PolynomialsBDM&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a33ac26ab987566828481d256a73b5f80">FE_PolyTensor&lt; PolynomialsBDM&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a33ac26ab987566828481d256a73b5f80">FE_PolyTensor&lt; PolynomialsABF&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a33ac26ab987566828481d256a73b5f80">FE_PolyTensor&lt; PolynomialsNedelec&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyFace.html#a75536a9bbeba12c678b1ae0bf9332d4d">FE_PolyFace&lt; POLY, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyFace.html#a75536a9bbeba12c678b1ae0bf9332d4d">FE_PolyFace&lt; PolynomialSpace&lt; dim-1 &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyFace.html#a75536a9bbeba12c678b1ae0bf9332d4d">FE_PolyFace&lt; TensorProductPolynomials&lt; dim-1 &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#a44fbafd84ca7a45b99a5c2a023101140">FE_Poly&lt; POLY, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#a44fbafd84ca7a45b99a5c2a023101140">FE_Poly&lt; PolynomialSpace&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#a44fbafd84ca7a45b99a5c2a023101140">FE_Poly&lt; PolynomialsP&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__Poly.html#a44fbafd84ca7a45b99a5c2a023101140">FE_Poly&lt; TensorProductPolynomials&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__Poly.html#a44fbafd84ca7a45b99a5c2a023101140">FE_Poly&lt; TensorProductPolynomials&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#a44fbafd84ca7a45b99a5c2a023101140">FE_Poly&lt; TensorProductPolynomialsConst&lt; dim &gt;, dim, spacedim &gt;</a>, and <a class="el" href="classFE__Poly.html#a44fbafd84ca7a45b99a5c2a023101140">FE_Poly&lt; TensorProductPolynomials&lt; dim, Polynomials::PiecewisePolynomial&lt; double &gt; &gt;, dim, spacedim &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a47a8b30d8917b398bcf9f01e98e16815"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::fill_fe_subface_values </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>sub_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>mapping_internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>fe_internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFEValuesData.html">FEValuesData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fill the fields of <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a>. This function performs all the operations needed to compute the data of an <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object.</p>
<p>The same function in <code>mapping</code> must have been called for the same cell first! </p>

<p>Implemented in <a class="el" href="classFESystem.html#a39876bedec83cd45e8a512036ace3349">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGPNonparametric.html#ac19bd6ea85790196dc5c130e65105e54">FE_DGPNonparametric&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a9e8e52bb900ed14733e1301ea273b154">FE_PolyTensor&lt; POLY, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a9e8e52bb900ed14733e1301ea273b154">FE_PolyTensor&lt; PolynomialsRaviartThomas&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a9e8e52bb900ed14733e1301ea273b154">FE_PolyTensor&lt; PolynomialsNedelec&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a9e8e52bb900ed14733e1301ea273b154">FE_PolyTensor&lt; PolynomialsRaviartThomas&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a9e8e52bb900ed14733e1301ea273b154">FE_PolyTensor&lt; PolynomialsBDM&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a9e8e52bb900ed14733e1301ea273b154">FE_PolyTensor&lt; PolynomialsBDM&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a9e8e52bb900ed14733e1301ea273b154">FE_PolyTensor&lt; PolynomialsABF&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a9e8e52bb900ed14733e1301ea273b154">FE_PolyTensor&lt; PolynomialsNedelec&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyFace.html#a464436b9592169257d8bd9243b5407ca">FE_PolyFace&lt; POLY, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyFace.html#a464436b9592169257d8bd9243b5407ca">FE_PolyFace&lt; PolynomialSpace&lt; dim-1 &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyFace.html#a464436b9592169257d8bd9243b5407ca">FE_PolyFace&lt; TensorProductPolynomials&lt; dim-1 &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#a90e39630de42785cf7fbf62ed3888457">FE_Poly&lt; POLY, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#a90e39630de42785cf7fbf62ed3888457">FE_Poly&lt; PolynomialSpace&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#a90e39630de42785cf7fbf62ed3888457">FE_Poly&lt; PolynomialsP&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__Poly.html#a90e39630de42785cf7fbf62ed3888457">FE_Poly&lt; TensorProductPolynomials&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__Poly.html#a90e39630de42785cf7fbf62ed3888457">FE_Poly&lt; TensorProductPolynomials&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#a90e39630de42785cf7fbf62ed3888457">FE_Poly&lt; TensorProductPolynomialsConst&lt; dim &gt;, dim, spacedim &gt;</a>, and <a class="el" href="classFE__Poly.html#a90e39630de42785cf7fbf62ed3888457">FE_Poly&lt; TensorProductPolynomials&lt; dim, Polynomials::PiecewisePolynomial&lt; double &gt; &gt;, dim, spacedim &gt;</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a4993707a4ec342560ff74e5d22401794"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;<a class="el" href="classFullMatrix.html">FullMatrix</a>&lt;<a class="el" href="classdouble.html">double</a>&gt; &gt; &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::restriction</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classVector.html">Vector</a> of projection matrices. See <a class="el" href="classFiniteElement.html#a0238956d0afd1bd880bf84366c024dec">get_restriction_matrix()</a> above. The constructor initializes these matrices to zero dimensions, which can be changed by derived classes implementing them.</p>
<p>Note, that <code>restriction[refinement_case-1][child]</code> includes the restriction matrix of child <code>child</code> for the <a class="el" href="classRefinementCase.html">RefinementCase</a> <code>refinement_case</code>. Here, we use <code>refinement_case-1</code> instead of <code>refinement_case</code> as for RefinementCase::no_refinement(=0) there are no restriction matrices available. </p>

<p>Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l01639">1639</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a class="anchor" id="afbc42f850096c429fd39cfcbde1b6b56"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;<a class="el" href="classFullMatrix.html">FullMatrix</a>&lt;<a class="el" href="classdouble.html">double</a>&gt; &gt; &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::prolongation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classVector.html">Vector</a> of embedding matrices. See <code><a class="el" href="classFiniteElement.html#ac5e488d17d3e34a84166d8c7ca95c22a">get_prolongation_matrix()</a></code> above. The constructor initializes these matrices to zero dimensions, which can be changed by derived classes implementing them.</p>
<p>Note, that <code>prolongation[refinement_case-1][child]</code> includes the prolongation matrix of child <code>child</code> for the <a class="el" href="classRefinementCase.html">RefinementCase</a> <code>refinement_case</code>. Here, we use <code>refinement_case-1</code> instead of <code>refinement_case</code> as for RefinementCase::no_refinement(=0) there are no prolongation matrices available. </p>

<p>Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l01653">1653</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac8d4cd5afce6a401892aeb5a40ccfa2f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt;<a class="el" href="classdouble.html">double</a>&gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::interface_constraints</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Specify the constraints which the dofs on the two sides of a cell interface underly if the line connects two cells of which one is refined once.</p>
<p>For further details see the general description of the derived class.</p>
<p>This field is obviously useless in one dimension and has there a zero size. </p>

<p>Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l01665">1665</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab4f6e0c83686b918fbb92716ead92313"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classPoint.html">Point</a>&lt;dim&gt; &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::unit_support_points</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List of support points on the unit cell, in case the finite element has any. The constructor leaves this field empty, derived classes may write in some contents.</p>
<p>Finite elements that allow some kind of interpolation operation usually have support points. On the other hand, elements that define their degrees of freedom by, for example, moments on faces, or as derivatives, don't have support points. In that case, this field remains empty. </p>

<p>Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l01677">1677</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae029888ebd5d91b261bf45aa2bf40b5c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classPoint.html">Point</a>&lt;dim-1&gt; &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::unit_face_support_points</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same for the faces. See the description of the <a class="el" href="classFiniteElement.html#a3c557f753676d89d4ddfc0cff9d845b4">get_unit_face_support_points()</a> function for a discussion of what contributes a face support point. </p>

<p>Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l01684">1684</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae2531d00b5c9e77e1e64981864c3b8cc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classPoint.html">Point</a>&lt;dim&gt; &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::generalized_support_points</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Support points used for interpolation functions of non-Lagrangian elements. </p>

<p>Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l01690">1690</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3b614baaf527c796af876c8807f5d7d7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classPoint.html">Point</a>&lt;dim-1&gt; &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::generalized_face_support_points</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Face support points used for interpolation functions of non-Lagrangian elements. </p>

<p>Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l01696">1696</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a class="anchor" id="a46646bf5621c347e3cb3a637857b14b5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTable.html">Table</a>&lt;2,<a class="el" href="classint.html">int</a>&gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::adjust_quad_dof_index_for_face_orientation_table</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For faces with non-standard face_orientation in 3D, the dofs on faces (quads) have to be permuted in order to be combined with the correct shape functions. Given a local dof <code>index</code> on a quad, return the shift in the local index, if the face has non-standard face_orientation, i.e. <code>old_index + shift = new_index</code>. In 2D and 1D there is no need for permutation so the vector is empty. In 3D it has the size of <code> <a class="el" href="classFiniteElementData.html#a00ab27b2dfa5520f2aa56f9bb8223878">dofs_per_quad</a> * 8 </code>, where 8 is the number of orientations, a face can be in (all combinations of the three bool flags face_orientation, face_flip and face_rotation).</p>
<p>The standard implementation fills this with zeros, i.e. no permuatation at all. Derived finite element classes have to fill this <a class="el" href="classTable.html">Table</a> with the correct values. </p>

<p>Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l01713">1713</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6659bb0dccc62e2d680c964e5035daf6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classint.html">int</a>&gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::adjust_line_dof_index_for_line_orientation_table</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For lines with non-standard line_orientation in 3D, the dofs on lines have to be permuted in order to be combined with the correct shape functions. Given a local dof <code>index</code> on a line, return the shift in the local index, if the line has non-standard line_orientation, i.e. <code>old_index + shift = new_index</code>. In 2D and 1D there is no need for permutation so the vector is empty. In 3D it has the size of <a class="el" href="classFiniteElementData.html#a490e2ded19c0a8cad0846e07e57e3e76">dofs_per_line</a>.</p>
<p>The standard implementation fills this with zeros, i.e. no permutation at all. Derived finite element classes have to fill this vector with the correct values. </p>

<p>Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l01728">1728</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa95bff4580b63275178a411dfb7785fa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt;unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>&gt; &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::system_to_component_table</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Store what <a class="el" href="classFiniteElement.html#a27220a135402b96c7e6eecbb04acda56">system_to_component_index()</a> will return. </p>

<p>Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l01807">1807</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1ea86779f24165679762a660741226ca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt;unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>&gt; &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::face_system_to_component_table</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Map between linear dofs and component dofs on face. This is filled with default values in the constructor, but derived classes will have to overwrite the information if necessary.</p>
<p>By component, we mean the vector component, not the base element. The information thus makes only sense if a shape function is non-zero in only one component. </p>

<p>Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l01818">1818</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4b487f5fe482180d2c856363ae39ab13"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::pair&lt;std::pair&lt;unsigned <a class="el" href="classint.html">int</a>,unsigned <a class="el" href="classint.html">int</a>&gt;,unsigned <a class="el" href="classint.html">int</a>&gt; &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::system_to_base_table</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For each shape function, store to which base element and which instance of this base element (in case its multiplicity is greater than one) it belongs, and its index within this base element. If the element is not composed of others, then base and instance are always zero, and the index is equal to the number of the shape function. If the element is composed of single instances of other elements (i.e. all with multiplicity one) all of which are scalar, then base values and dof indices within this element are equal to the <a class="el" href="classFiniteElement.html#aa95bff4580b63275178a411dfb7785fa">system_to_component_table</a>. It differs only in case the element is composed of other elements and at least one of them is vector-valued itself.</p>
<p>This array has valid values also in the case of vector-valued (i.e. non-primitive) shape functions, in contrast to the <a class="el" href="classFiniteElement.html#aa95bff4580b63275178a411dfb7785fa">system_to_component_table</a>. </p>

<p>Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l01837">1837</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0a2b6095ae0093bb6c024853d65969e4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::pair&lt;std::pair&lt;unsigned <a class="el" href="classint.html">int</a>,unsigned <a class="el" href="classint.html">int</a>&gt;,unsigned <a class="el" href="classint.html">int</a>&gt; &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::face_system_to_base_table</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Likewise for the indices on faces. </p>

<p>Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l01843">1843</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a class="anchor" id="a61f62f39ded99d6525f1c33f4227ee8d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockIndices.html">BlockIndices</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::base_to_block_indices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For each base element, store the number of blocks generated by the base and the first block in a block vector it will generate. </p>

<p>Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l01849">1849</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a class="anchor" id="aaf2c44f3a207e0e11880820a29ac37a8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::pair&lt;std::pair&lt;unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>&gt;, unsigned <a class="el" href="classint.html">int</a>&gt; &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::component_to_base_table</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The base element establishing a component.</p>
<p>For each component number <code>c</code>, the entries have the following meaning: </p>
<dl>
<dt><code>table[c].first.first</code> </dt>
<dd>Number of the base element for <code>c</code>. </dd>
<dt><code>table[c].first.second</code> </dt>
<dd>Component in the base element for <code>c</code>. </dd>
<dt><code>table[c].second</code> </dt>
<dd>Multiple of the base element for <code>c</code>. </dd>
</dl>
<p>This variable is set to the correct size by the constructor of this class, but needs to be initialized by derived classes, unless its size is one and the only entry is a zero, which is the case for scalar elements. In that case, the initialization by the base class is sufficient. </p>

<p>Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l01872">1872</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa8f4833a318127b42d2dc806bffe1c2c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classbool.html">bool</a>&gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::restriction_is_additive_flags</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Projection matrices are concatenated or summed up.</p>
<p>This flags decides on how the projection matrices of the children of the same father are put together to one operator. The possible modes are concatenation and summation.</p>
<p>If the projection is defined by an interpolation operator, the child matrices are concatenated, i.e. values belonging to the same node functional are identified and enter the interpolated value only once. In this case, the flag must be <code>false</code>.</p>
<p>For projections with respect to scalar products, the child matrices must be summed up to build the complete matrix. The flag should be <code>true</code>.</p>
<p>For examples of use of these flags, see the places in the library where it is queried.</p>
<p>There is one flag per shape function, indicating whether it belongs to the class of shape functions that are additive in the restriction or not.</p>
<p>Note that in previous versions of the library, there was one flag per vector component of the element. This is based on the fact that all the shape functions that belong to the same vector component must necessarily behave in the same way, to make things reasonable. However, the problem is that it is sometimes impossible to query this flag in the vector-valued case: this used to be done with the <a class="el" href="classFiniteElement.html#a27220a135402b96c7e6eecbb04acda56">system_to_component_index</a> function that returns which vector component a shape function is associated with. The point is that since we now support shape functions that are associated with more than one vector component (for example the shape functions of Raviart-Thomas, or Nedelec elements), that function can no more be used, so it can be difficult to find out which for vector component we would like to query the restriction-is-additive flags. </p>

<p>Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l01909">1909</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae6fe073d1e3ce59791b142067482bd5b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classComponentMask.html">ComponentMask</a>&gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::nonzero_components</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For each shape function, give a vector of bools (with size equal to the number of vector components which this finite element has) indicating in which component each of these shape functions is non-zero.</p>
<p>For primitive elements, there is only one non-zero component. </p>

<p>Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l01918">1918</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0b7cb6ef5342900727931ef983636502"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;unsigned <a class="el" href="classint.html">int</a>&gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::n_nonzero_components_table</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This array holds how many values in the respective entry of the <a class="el" href="classFiniteElement.html#ae6fe073d1e3ce59791b142067482bd5b">nonzero_components</a> element are non-zero. The array is thus a short-cut to allow faster access to this information than if we had to count the non-zero entries upon each request for this information. The field is initialized in the constructor of this class. </p>

<p>Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l01927">1927</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a class="anchor" id="a714350e735a4ade7a1e0d47dcb165b25"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdouble.html">double</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::fd_step_length</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Second derivatives of shapes functions are not computed analytically, but by finite differences of the gradients. This static variable denotes the step length to be used for that. It's value is set to 1e-6. </p>

<p>Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l01934">1934</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/deal.II/fe/<a class="el" href="fe__tools_8h_source.html">fe_tools.h</a></li>
<li>include/deal.II/fe/<a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jan 27 2014 15:27:19 for The deal.II Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
