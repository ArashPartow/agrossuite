namespace GridTools {
 template
 std::list<std::pair<MGDoFHandler< 1 >::cell_iterator, MGDoFHandler< 1 >::cell_iterator> >
 get_finest_common_cells (const MGDoFHandler< 1 > &mesh_1,
 const MGDoFHandler< 1 > &mesh_2);
 }
 
namespace GridTools {
 template
 std::list<std::pair<MGDoFHandler< 2 >::cell_iterator, MGDoFHandler< 2 >::cell_iterator> >
 get_finest_common_cells (const MGDoFHandler< 2 > &mesh_1,
 const MGDoFHandler< 2 > &mesh_2);
 }
 
namespace GridTools {
 template
 std::list<std::pair<MGDoFHandler< 3 >::cell_iterator, MGDoFHandler< 3 >::cell_iterator> >
 get_finest_common_cells (const MGDoFHandler< 3 > &mesh_1,
 const MGDoFHandler< 3 > &mesh_2);
 }
 
#if  1  <=  1 
 namespace GridTools {

 template
 unsigned int
 find_closest_vertex (const  Triangulation< 1 ,  1 >  &,
 const Point< 1 > &);

 template
 std::vector< Triangulation< 1 ,  1 > ::active_cell_iterator>
 find_cells_adjacent_to_vertex(const  Triangulation< 1 ,  1 >  &,
 const unsigned int);
 template
  Triangulation< 1 ,  1 > ::active_cell_iterator
 find_active_cell_around_point (const  Triangulation< 1 ,  1 >  &,
 const Point< 1 > &p);

 template
 std::pair< Triangulation< 1 ,  1 > ::active_cell_iterator, Point< 1 > >
 find_active_cell_around_point (const Mapping< 1 ,  1 > &,
 const  Triangulation< 1 ,  1 >  &,
 const Point< 1 > &);

 template
 std::list<std::pair< Triangulation< 1 ,  1 > ::cell_iterator,  Triangulation< 1 ,  1 > ::cell_iterator> >
 get_finest_common_cells (const  Triangulation< 1 ,  1 >  &mesh_1,
 const  Triangulation< 1 ,  1 >  &mesh_2);


 template
 bool
 have_same_coarse_mesh (const  Triangulation< 1 ,  1 >  &mesh_1,
 const  Triangulation< 1 ,  1 >  &mesh_2);

 }

 #endif

#if  1  <=  2 
 namespace GridTools {

 template
 unsigned int
 find_closest_vertex (const  Triangulation< 1 ,  2 >  &,
 const Point< 2 > &);

 template
 std::vector< Triangulation< 1 ,  2 > ::active_cell_iterator>
 find_cells_adjacent_to_vertex(const  Triangulation< 1 ,  2 >  &,
 const unsigned int);
 template
  Triangulation< 1 ,  2 > ::active_cell_iterator
 find_active_cell_around_point (const  Triangulation< 1 ,  2 >  &,
 const Point< 2 > &p);

 template
 std::pair< Triangulation< 1 ,  2 > ::active_cell_iterator, Point< 1 > >
 find_active_cell_around_point (const Mapping< 1 ,  2 > &,
 const  Triangulation< 1 ,  2 >  &,
 const Point< 2 > &);

 template
 std::list<std::pair< Triangulation< 1 ,  2 > ::cell_iterator,  Triangulation< 1 ,  2 > ::cell_iterator> >
 get_finest_common_cells (const  Triangulation< 1 ,  2 >  &mesh_1,
 const  Triangulation< 1 ,  2 >  &mesh_2);


 template
 bool
 have_same_coarse_mesh (const  Triangulation< 1 ,  2 >  &mesh_1,
 const  Triangulation< 1 ,  2 >  &mesh_2);

 }

 #endif

#if  1  <=  3 
 namespace GridTools {

 template
 unsigned int
 find_closest_vertex (const  Triangulation< 1 ,  3 >  &,
 const Point< 3 > &);

 template
 std::vector< Triangulation< 1 ,  3 > ::active_cell_iterator>
 find_cells_adjacent_to_vertex(const  Triangulation< 1 ,  3 >  &,
 const unsigned int);
 template
  Triangulation< 1 ,  3 > ::active_cell_iterator
 find_active_cell_around_point (const  Triangulation< 1 ,  3 >  &,
 const Point< 3 > &p);

 template
 std::pair< Triangulation< 1 ,  3 > ::active_cell_iterator, Point< 1 > >
 find_active_cell_around_point (const Mapping< 1 ,  3 > &,
 const  Triangulation< 1 ,  3 >  &,
 const Point< 3 > &);

 template
 std::list<std::pair< Triangulation< 1 ,  3 > ::cell_iterator,  Triangulation< 1 ,  3 > ::cell_iterator> >
 get_finest_common_cells (const  Triangulation< 1 ,  3 >  &mesh_1,
 const  Triangulation< 1 ,  3 >  &mesh_2);


 template
 bool
 have_same_coarse_mesh (const  Triangulation< 1 ,  3 >  &mesh_1,
 const  Triangulation< 1 ,  3 >  &mesh_2);

 }

 #endif

#if  2  <=  1 
 namespace GridTools {

 template
 unsigned int
 find_closest_vertex (const  Triangulation< 2 ,  1 >  &,
 const Point< 1 > &);

 template
 std::vector< Triangulation< 2 ,  1 > ::active_cell_iterator>
 find_cells_adjacent_to_vertex(const  Triangulation< 2 ,  1 >  &,
 const unsigned int);
 template
  Triangulation< 2 ,  1 > ::active_cell_iterator
 find_active_cell_around_point (const  Triangulation< 2 ,  1 >  &,
 const Point< 1 > &p);

 template
 std::pair< Triangulation< 2 ,  1 > ::active_cell_iterator, Point< 2 > >
 find_active_cell_around_point (const Mapping< 2 ,  1 > &,
 const  Triangulation< 2 ,  1 >  &,
 const Point< 1 > &);

 template
 std::list<std::pair< Triangulation< 2 ,  1 > ::cell_iterator,  Triangulation< 2 ,  1 > ::cell_iterator> >
 get_finest_common_cells (const  Triangulation< 2 ,  1 >  &mesh_1,
 const  Triangulation< 2 ,  1 >  &mesh_2);


 template
 bool
 have_same_coarse_mesh (const  Triangulation< 2 ,  1 >  &mesh_1,
 const  Triangulation< 2 ,  1 >  &mesh_2);

 }

 #endif

#if  2  <=  2 
 namespace GridTools {

 template
 unsigned int
 find_closest_vertex (const  Triangulation< 2 ,  2 >  &,
 const Point< 2 > &);

 template
 std::vector< Triangulation< 2 ,  2 > ::active_cell_iterator>
 find_cells_adjacent_to_vertex(const  Triangulation< 2 ,  2 >  &,
 const unsigned int);
 template
  Triangulation< 2 ,  2 > ::active_cell_iterator
 find_active_cell_around_point (const  Triangulation< 2 ,  2 >  &,
 const Point< 2 > &p);

 template
 std::pair< Triangulation< 2 ,  2 > ::active_cell_iterator, Point< 2 > >
 find_active_cell_around_point (const Mapping< 2 ,  2 > &,
 const  Triangulation< 2 ,  2 >  &,
 const Point< 2 > &);

 template
 std::list<std::pair< Triangulation< 2 ,  2 > ::cell_iterator,  Triangulation< 2 ,  2 > ::cell_iterator> >
 get_finest_common_cells (const  Triangulation< 2 ,  2 >  &mesh_1,
 const  Triangulation< 2 ,  2 >  &mesh_2);


 template
 bool
 have_same_coarse_mesh (const  Triangulation< 2 ,  2 >  &mesh_1,
 const  Triangulation< 2 ,  2 >  &mesh_2);

 }

 #endif

#if  2  <=  3 
 namespace GridTools {

 template
 unsigned int
 find_closest_vertex (const  Triangulation< 2 ,  3 >  &,
 const Point< 3 > &);

 template
 std::vector< Triangulation< 2 ,  3 > ::active_cell_iterator>
 find_cells_adjacent_to_vertex(const  Triangulation< 2 ,  3 >  &,
 const unsigned int);
 template
  Triangulation< 2 ,  3 > ::active_cell_iterator
 find_active_cell_around_point (const  Triangulation< 2 ,  3 >  &,
 const Point< 3 > &p);

 template
 std::pair< Triangulation< 2 ,  3 > ::active_cell_iterator, Point< 2 > >
 find_active_cell_around_point (const Mapping< 2 ,  3 > &,
 const  Triangulation< 2 ,  3 >  &,
 const Point< 3 > &);

 template
 std::list<std::pair< Triangulation< 2 ,  3 > ::cell_iterator,  Triangulation< 2 ,  3 > ::cell_iterator> >
 get_finest_common_cells (const  Triangulation< 2 ,  3 >  &mesh_1,
 const  Triangulation< 2 ,  3 >  &mesh_2);


 template
 bool
 have_same_coarse_mesh (const  Triangulation< 2 ,  3 >  &mesh_1,
 const  Triangulation< 2 ,  3 >  &mesh_2);

 }

 #endif

#if  3  <=  1 
 namespace GridTools {

 template
 unsigned int
 find_closest_vertex (const  Triangulation< 3 ,  1 >  &,
 const Point< 1 > &);

 template
 std::vector< Triangulation< 3 ,  1 > ::active_cell_iterator>
 find_cells_adjacent_to_vertex(const  Triangulation< 3 ,  1 >  &,
 const unsigned int);
 template
  Triangulation< 3 ,  1 > ::active_cell_iterator
 find_active_cell_around_point (const  Triangulation< 3 ,  1 >  &,
 const Point< 1 > &p);

 template
 std::pair< Triangulation< 3 ,  1 > ::active_cell_iterator, Point< 3 > >
 find_active_cell_around_point (const Mapping< 3 ,  1 > &,
 const  Triangulation< 3 ,  1 >  &,
 const Point< 1 > &);

 template
 std::list<std::pair< Triangulation< 3 ,  1 > ::cell_iterator,  Triangulation< 3 ,  1 > ::cell_iterator> >
 get_finest_common_cells (const  Triangulation< 3 ,  1 >  &mesh_1,
 const  Triangulation< 3 ,  1 >  &mesh_2);


 template
 bool
 have_same_coarse_mesh (const  Triangulation< 3 ,  1 >  &mesh_1,
 const  Triangulation< 3 ,  1 >  &mesh_2);

 }

 #endif

#if  3  <=  2 
 namespace GridTools {

 template
 unsigned int
 find_closest_vertex (const  Triangulation< 3 ,  2 >  &,
 const Point< 2 > &);

 template
 std::vector< Triangulation< 3 ,  2 > ::active_cell_iterator>
 find_cells_adjacent_to_vertex(const  Triangulation< 3 ,  2 >  &,
 const unsigned int);
 template
  Triangulation< 3 ,  2 > ::active_cell_iterator
 find_active_cell_around_point (const  Triangulation< 3 ,  2 >  &,
 const Point< 2 > &p);

 template
 std::pair< Triangulation< 3 ,  2 > ::active_cell_iterator, Point< 3 > >
 find_active_cell_around_point (const Mapping< 3 ,  2 > &,
 const  Triangulation< 3 ,  2 >  &,
 const Point< 2 > &);

 template
 std::list<std::pair< Triangulation< 3 ,  2 > ::cell_iterator,  Triangulation< 3 ,  2 > ::cell_iterator> >
 get_finest_common_cells (const  Triangulation< 3 ,  2 >  &mesh_1,
 const  Triangulation< 3 ,  2 >  &mesh_2);


 template
 bool
 have_same_coarse_mesh (const  Triangulation< 3 ,  2 >  &mesh_1,
 const  Triangulation< 3 ,  2 >  &mesh_2);

 }

 #endif

#if  3  <=  3 
 namespace GridTools {

 template
 unsigned int
 find_closest_vertex (const  Triangulation< 3 ,  3 >  &,
 const Point< 3 > &);

 template
 std::vector< Triangulation< 3 ,  3 > ::active_cell_iterator>
 find_cells_adjacent_to_vertex(const  Triangulation< 3 ,  3 >  &,
 const unsigned int);
 template
  Triangulation< 3 ,  3 > ::active_cell_iterator
 find_active_cell_around_point (const  Triangulation< 3 ,  3 >  &,
 const Point< 3 > &p);

 template
 std::pair< Triangulation< 3 ,  3 > ::active_cell_iterator, Point< 3 > >
 find_active_cell_around_point (const Mapping< 3 ,  3 > &,
 const  Triangulation< 3 ,  3 >  &,
 const Point< 3 > &);

 template
 std::list<std::pair< Triangulation< 3 ,  3 > ::cell_iterator,  Triangulation< 3 ,  3 > ::cell_iterator> >
 get_finest_common_cells (const  Triangulation< 3 ,  3 >  &mesh_1,
 const  Triangulation< 3 ,  3 >  &mesh_2);


 template
 bool
 have_same_coarse_mesh (const  Triangulation< 3 ,  3 >  &mesh_1,
 const  Triangulation< 3 ,  3 >  &mesh_2);

 }

 #endif

#if  1  <=  1 
 namespace GridTools {

 template
 unsigned int
 find_closest_vertex (const  DoFHandler< 1 ,  1 >  &,
 const Point< 1 > &);

 template
 std::vector< DoFHandler< 1 ,  1 > ::active_cell_iterator>
 find_cells_adjacent_to_vertex(const  DoFHandler< 1 ,  1 >  &,
 const unsigned int);
 template
  DoFHandler< 1 ,  1 > ::active_cell_iterator
 find_active_cell_around_point (const  DoFHandler< 1 ,  1 >  &,
 const Point< 1 > &p);

 template
 std::pair< DoFHandler< 1 ,  1 > ::active_cell_iterator, Point< 1 > >
 find_active_cell_around_point (const Mapping< 1 ,  1 > &,
 const  DoFHandler< 1 ,  1 >  &,
 const Point< 1 > &);

 template
 std::list<std::pair< DoFHandler< 1 ,  1 > ::cell_iterator,  DoFHandler< 1 ,  1 > ::cell_iterator> >
 get_finest_common_cells (const  DoFHandler< 1 ,  1 >  &mesh_1,
 const  DoFHandler< 1 ,  1 >  &mesh_2);


 template
 bool
 have_same_coarse_mesh (const  DoFHandler< 1 ,  1 >  &mesh_1,
 const  DoFHandler< 1 ,  1 >  &mesh_2);

 }

 #endif

#if  1  <=  2 
 namespace GridTools {

 template
 unsigned int
 find_closest_vertex (const  DoFHandler< 1 ,  2 >  &,
 const Point< 2 > &);

 template
 std::vector< DoFHandler< 1 ,  2 > ::active_cell_iterator>
 find_cells_adjacent_to_vertex(const  DoFHandler< 1 ,  2 >  &,
 const unsigned int);
 template
  DoFHandler< 1 ,  2 > ::active_cell_iterator
 find_active_cell_around_point (const  DoFHandler< 1 ,  2 >  &,
 const Point< 2 > &p);

 template
 std::pair< DoFHandler< 1 ,  2 > ::active_cell_iterator, Point< 1 > >
 find_active_cell_around_point (const Mapping< 1 ,  2 > &,
 const  DoFHandler< 1 ,  2 >  &,
 const Point< 2 > &);

 template
 std::list<std::pair< DoFHandler< 1 ,  2 > ::cell_iterator,  DoFHandler< 1 ,  2 > ::cell_iterator> >
 get_finest_common_cells (const  DoFHandler< 1 ,  2 >  &mesh_1,
 const  DoFHandler< 1 ,  2 >  &mesh_2);


 template
 bool
 have_same_coarse_mesh (const  DoFHandler< 1 ,  2 >  &mesh_1,
 const  DoFHandler< 1 ,  2 >  &mesh_2);

 }

 #endif

#if  1  <=  3 
 namespace GridTools {

 template
 unsigned int
 find_closest_vertex (const  DoFHandler< 1 ,  3 >  &,
 const Point< 3 > &);

 template
 std::vector< DoFHandler< 1 ,  3 > ::active_cell_iterator>
 find_cells_adjacent_to_vertex(const  DoFHandler< 1 ,  3 >  &,
 const unsigned int);
 template
  DoFHandler< 1 ,  3 > ::active_cell_iterator
 find_active_cell_around_point (const  DoFHandler< 1 ,  3 >  &,
 const Point< 3 > &p);

 template
 std::pair< DoFHandler< 1 ,  3 > ::active_cell_iterator, Point< 1 > >
 find_active_cell_around_point (const Mapping< 1 ,  3 > &,
 const  DoFHandler< 1 ,  3 >  &,
 const Point< 3 > &);

 template
 std::list<std::pair< DoFHandler< 1 ,  3 > ::cell_iterator,  DoFHandler< 1 ,  3 > ::cell_iterator> >
 get_finest_common_cells (const  DoFHandler< 1 ,  3 >  &mesh_1,
 const  DoFHandler< 1 ,  3 >  &mesh_2);


 template
 bool
 have_same_coarse_mesh (const  DoFHandler< 1 ,  3 >  &mesh_1,
 const  DoFHandler< 1 ,  3 >  &mesh_2);

 }

 #endif

#if  2  <=  1 
 namespace GridTools {

 template
 unsigned int
 find_closest_vertex (const  DoFHandler< 2 ,  1 >  &,
 const Point< 1 > &);

 template
 std::vector< DoFHandler< 2 ,  1 > ::active_cell_iterator>
 find_cells_adjacent_to_vertex(const  DoFHandler< 2 ,  1 >  &,
 const unsigned int);
 template
  DoFHandler< 2 ,  1 > ::active_cell_iterator
 find_active_cell_around_point (const  DoFHandler< 2 ,  1 >  &,
 const Point< 1 > &p);

 template
 std::pair< DoFHandler< 2 ,  1 > ::active_cell_iterator, Point< 2 > >
 find_active_cell_around_point (const Mapping< 2 ,  1 > &,
 const  DoFHandler< 2 ,  1 >  &,
 const Point< 1 > &);

 template
 std::list<std::pair< DoFHandler< 2 ,  1 > ::cell_iterator,  DoFHandler< 2 ,  1 > ::cell_iterator> >
 get_finest_common_cells (const  DoFHandler< 2 ,  1 >  &mesh_1,
 const  DoFHandler< 2 ,  1 >  &mesh_2);


 template
 bool
 have_same_coarse_mesh (const  DoFHandler< 2 ,  1 >  &mesh_1,
 const  DoFHandler< 2 ,  1 >  &mesh_2);

 }

 #endif

#if  2  <=  2 
 namespace GridTools {

 template
 unsigned int
 find_closest_vertex (const  DoFHandler< 2 ,  2 >  &,
 const Point< 2 > &);

 template
 std::vector< DoFHandler< 2 ,  2 > ::active_cell_iterator>
 find_cells_adjacent_to_vertex(const  DoFHandler< 2 ,  2 >  &,
 const unsigned int);
 template
  DoFHandler< 2 ,  2 > ::active_cell_iterator
 find_active_cell_around_point (const  DoFHandler< 2 ,  2 >  &,
 const Point< 2 > &p);

 template
 std::pair< DoFHandler< 2 ,  2 > ::active_cell_iterator, Point< 2 > >
 find_active_cell_around_point (const Mapping< 2 ,  2 > &,
 const  DoFHandler< 2 ,  2 >  &,
 const Point< 2 > &);

 template
 std::list<std::pair< DoFHandler< 2 ,  2 > ::cell_iterator,  DoFHandler< 2 ,  2 > ::cell_iterator> >
 get_finest_common_cells (const  DoFHandler< 2 ,  2 >  &mesh_1,
 const  DoFHandler< 2 ,  2 >  &mesh_2);


 template
 bool
 have_same_coarse_mesh (const  DoFHandler< 2 ,  2 >  &mesh_1,
 const  DoFHandler< 2 ,  2 >  &mesh_2);

 }

 #endif

#if  2  <=  3 
 namespace GridTools {

 template
 unsigned int
 find_closest_vertex (const  DoFHandler< 2 ,  3 >  &,
 const Point< 3 > &);

 template
 std::vector< DoFHandler< 2 ,  3 > ::active_cell_iterator>
 find_cells_adjacent_to_vertex(const  DoFHandler< 2 ,  3 >  &,
 const unsigned int);
 template
  DoFHandler< 2 ,  3 > ::active_cell_iterator
 find_active_cell_around_point (const  DoFHandler< 2 ,  3 >  &,
 const Point< 3 > &p);

 template
 std::pair< DoFHandler< 2 ,  3 > ::active_cell_iterator, Point< 2 > >
 find_active_cell_around_point (const Mapping< 2 ,  3 > &,
 const  DoFHandler< 2 ,  3 >  &,
 const Point< 3 > &);

 template
 std::list<std::pair< DoFHandler< 2 ,  3 > ::cell_iterator,  DoFHandler< 2 ,  3 > ::cell_iterator> >
 get_finest_common_cells (const  DoFHandler< 2 ,  3 >  &mesh_1,
 const  DoFHandler< 2 ,  3 >  &mesh_2);


 template
 bool
 have_same_coarse_mesh (const  DoFHandler< 2 ,  3 >  &mesh_1,
 const  DoFHandler< 2 ,  3 >  &mesh_2);

 }

 #endif

#if  3  <=  1 
 namespace GridTools {

 template
 unsigned int
 find_closest_vertex (const  DoFHandler< 3 ,  1 >  &,
 const Point< 1 > &);

 template
 std::vector< DoFHandler< 3 ,  1 > ::active_cell_iterator>
 find_cells_adjacent_to_vertex(const  DoFHandler< 3 ,  1 >  &,
 const unsigned int);
 template
  DoFHandler< 3 ,  1 > ::active_cell_iterator
 find_active_cell_around_point (const  DoFHandler< 3 ,  1 >  &,
 const Point< 1 > &p);

 template
 std::pair< DoFHandler< 3 ,  1 > ::active_cell_iterator, Point< 3 > >
 find_active_cell_around_point (const Mapping< 3 ,  1 > &,
 const  DoFHandler< 3 ,  1 >  &,
 const Point< 1 > &);

 template
 std::list<std::pair< DoFHandler< 3 ,  1 > ::cell_iterator,  DoFHandler< 3 ,  1 > ::cell_iterator> >
 get_finest_common_cells (const  DoFHandler< 3 ,  1 >  &mesh_1,
 const  DoFHandler< 3 ,  1 >  &mesh_2);


 template
 bool
 have_same_coarse_mesh (const  DoFHandler< 3 ,  1 >  &mesh_1,
 const  DoFHandler< 3 ,  1 >  &mesh_2);

 }

 #endif

#if  3  <=  2 
 namespace GridTools {

 template
 unsigned int
 find_closest_vertex (const  DoFHandler< 3 ,  2 >  &,
 const Point< 2 > &);

 template
 std::vector< DoFHandler< 3 ,  2 > ::active_cell_iterator>
 find_cells_adjacent_to_vertex(const  DoFHandler< 3 ,  2 >  &,
 const unsigned int);
 template
  DoFHandler< 3 ,  2 > ::active_cell_iterator
 find_active_cell_around_point (const  DoFHandler< 3 ,  2 >  &,
 const Point< 2 > &p);

 template
 std::pair< DoFHandler< 3 ,  2 > ::active_cell_iterator, Point< 3 > >
 find_active_cell_around_point (const Mapping< 3 ,  2 > &,
 const  DoFHandler< 3 ,  2 >  &,
 const Point< 2 > &);

 template
 std::list<std::pair< DoFHandler< 3 ,  2 > ::cell_iterator,  DoFHandler< 3 ,  2 > ::cell_iterator> >
 get_finest_common_cells (const  DoFHandler< 3 ,  2 >  &mesh_1,
 const  DoFHandler< 3 ,  2 >  &mesh_2);


 template
 bool
 have_same_coarse_mesh (const  DoFHandler< 3 ,  2 >  &mesh_1,
 const  DoFHandler< 3 ,  2 >  &mesh_2);

 }

 #endif

#if  3  <=  3 
 namespace GridTools {

 template
 unsigned int
 find_closest_vertex (const  DoFHandler< 3 ,  3 >  &,
 const Point< 3 > &);

 template
 std::vector< DoFHandler< 3 ,  3 > ::active_cell_iterator>
 find_cells_adjacent_to_vertex(const  DoFHandler< 3 ,  3 >  &,
 const unsigned int);
 template
  DoFHandler< 3 ,  3 > ::active_cell_iterator
 find_active_cell_around_point (const  DoFHandler< 3 ,  3 >  &,
 const Point< 3 > &p);

 template
 std::pair< DoFHandler< 3 ,  3 > ::active_cell_iterator, Point< 3 > >
 find_active_cell_around_point (const Mapping< 3 ,  3 > &,
 const  DoFHandler< 3 ,  3 >  &,
 const Point< 3 > &);

 template
 std::list<std::pair< DoFHandler< 3 ,  3 > ::cell_iterator,  DoFHandler< 3 ,  3 > ::cell_iterator> >
 get_finest_common_cells (const  DoFHandler< 3 ,  3 >  &mesh_1,
 const  DoFHandler< 3 ,  3 >  &mesh_2);


 template
 bool
 have_same_coarse_mesh (const  DoFHandler< 3 ,  3 >  &mesh_1,
 const  DoFHandler< 3 ,  3 >  &mesh_2);

 }

 #endif

#if  1  <=  1 
 namespace GridTools {

 template
 unsigned int
 find_closest_vertex (const  hp::DoFHandler< 1 ,  1 >  &,
 const Point< 1 > &);

 template
 std::vector< hp::DoFHandler< 1 ,  1 > ::active_cell_iterator>
 find_cells_adjacent_to_vertex(const  hp::DoFHandler< 1 ,  1 >  &,
 const unsigned int);
 template
  hp::DoFHandler< 1 ,  1 > ::active_cell_iterator
 find_active_cell_around_point (const  hp::DoFHandler< 1 ,  1 >  &,
 const Point< 1 > &p);

 template
 std::pair< hp::DoFHandler< 1 ,  1 > ::active_cell_iterator, Point< 1 > >
 find_active_cell_around_point (const Mapping< 1 ,  1 > &,
 const  hp::DoFHandler< 1 ,  1 >  &,
 const Point< 1 > &);

 template
 std::list<std::pair< hp::DoFHandler< 1 ,  1 > ::cell_iterator,  hp::DoFHandler< 1 ,  1 > ::cell_iterator> >
 get_finest_common_cells (const  hp::DoFHandler< 1 ,  1 >  &mesh_1,
 const  hp::DoFHandler< 1 ,  1 >  &mesh_2);


 template
 bool
 have_same_coarse_mesh (const  hp::DoFHandler< 1 ,  1 >  &mesh_1,
 const  hp::DoFHandler< 1 ,  1 >  &mesh_2);

 }

 #endif

#if  1  <=  2 
 namespace GridTools {

 template
 unsigned int
 find_closest_vertex (const  hp::DoFHandler< 1 ,  2 >  &,
 const Point< 2 > &);

 template
 std::vector< hp::DoFHandler< 1 ,  2 > ::active_cell_iterator>
 find_cells_adjacent_to_vertex(const  hp::DoFHandler< 1 ,  2 >  &,
 const unsigned int);
 template
  hp::DoFHandler< 1 ,  2 > ::active_cell_iterator
 find_active_cell_around_point (const  hp::DoFHandler< 1 ,  2 >  &,
 const Point< 2 > &p);

 template
 std::pair< hp::DoFHandler< 1 ,  2 > ::active_cell_iterator, Point< 1 > >
 find_active_cell_around_point (const Mapping< 1 ,  2 > &,
 const  hp::DoFHandler< 1 ,  2 >  &,
 const Point< 2 > &);

 template
 std::list<std::pair< hp::DoFHandler< 1 ,  2 > ::cell_iterator,  hp::DoFHandler< 1 ,  2 > ::cell_iterator> >
 get_finest_common_cells (const  hp::DoFHandler< 1 ,  2 >  &mesh_1,
 const  hp::DoFHandler< 1 ,  2 >  &mesh_2);


 template
 bool
 have_same_coarse_mesh (const  hp::DoFHandler< 1 ,  2 >  &mesh_1,
 const  hp::DoFHandler< 1 ,  2 >  &mesh_2);

 }

 #endif

#if  1  <=  3 
 namespace GridTools {

 template
 unsigned int
 find_closest_vertex (const  hp::DoFHandler< 1 ,  3 >  &,
 const Point< 3 > &);

 template
 std::vector< hp::DoFHandler< 1 ,  3 > ::active_cell_iterator>
 find_cells_adjacent_to_vertex(const  hp::DoFHandler< 1 ,  3 >  &,
 const unsigned int);
 template
  hp::DoFHandler< 1 ,  3 > ::active_cell_iterator
 find_active_cell_around_point (const  hp::DoFHandler< 1 ,  3 >  &,
 const Point< 3 > &p);

 template
 std::pair< hp::DoFHandler< 1 ,  3 > ::active_cell_iterator, Point< 1 > >
 find_active_cell_around_point (const Mapping< 1 ,  3 > &,
 const  hp::DoFHandler< 1 ,  3 >  &,
 const Point< 3 > &);

 template
 std::list<std::pair< hp::DoFHandler< 1 ,  3 > ::cell_iterator,  hp::DoFHandler< 1 ,  3 > ::cell_iterator> >
 get_finest_common_cells (const  hp::DoFHandler< 1 ,  3 >  &mesh_1,
 const  hp::DoFHandler< 1 ,  3 >  &mesh_2);


 template
 bool
 have_same_coarse_mesh (const  hp::DoFHandler< 1 ,  3 >  &mesh_1,
 const  hp::DoFHandler< 1 ,  3 >  &mesh_2);

 }

 #endif

#if  2  <=  1 
 namespace GridTools {

 template
 unsigned int
 find_closest_vertex (const  hp::DoFHandler< 2 ,  1 >  &,
 const Point< 1 > &);

 template
 std::vector< hp::DoFHandler< 2 ,  1 > ::active_cell_iterator>
 find_cells_adjacent_to_vertex(const  hp::DoFHandler< 2 ,  1 >  &,
 const unsigned int);
 template
  hp::DoFHandler< 2 ,  1 > ::active_cell_iterator
 find_active_cell_around_point (const  hp::DoFHandler< 2 ,  1 >  &,
 const Point< 1 > &p);

 template
 std::pair< hp::DoFHandler< 2 ,  1 > ::active_cell_iterator, Point< 2 > >
 find_active_cell_around_point (const Mapping< 2 ,  1 > &,
 const  hp::DoFHandler< 2 ,  1 >  &,
 const Point< 1 > &);

 template
 std::list<std::pair< hp::DoFHandler< 2 ,  1 > ::cell_iterator,  hp::DoFHandler< 2 ,  1 > ::cell_iterator> >
 get_finest_common_cells (const  hp::DoFHandler< 2 ,  1 >  &mesh_1,
 const  hp::DoFHandler< 2 ,  1 >  &mesh_2);


 template
 bool
 have_same_coarse_mesh (const  hp::DoFHandler< 2 ,  1 >  &mesh_1,
 const  hp::DoFHandler< 2 ,  1 >  &mesh_2);

 }

 #endif

#if  2  <=  2 
 namespace GridTools {

 template
 unsigned int
 find_closest_vertex (const  hp::DoFHandler< 2 ,  2 >  &,
 const Point< 2 > &);

 template
 std::vector< hp::DoFHandler< 2 ,  2 > ::active_cell_iterator>
 find_cells_adjacent_to_vertex(const  hp::DoFHandler< 2 ,  2 >  &,
 const unsigned int);
 template
  hp::DoFHandler< 2 ,  2 > ::active_cell_iterator
 find_active_cell_around_point (const  hp::DoFHandler< 2 ,  2 >  &,
 const Point< 2 > &p);

 template
 std::pair< hp::DoFHandler< 2 ,  2 > ::active_cell_iterator, Point< 2 > >
 find_active_cell_around_point (const Mapping< 2 ,  2 > &,
 const  hp::DoFHandler< 2 ,  2 >  &,
 const Point< 2 > &);

 template
 std::list<std::pair< hp::DoFHandler< 2 ,  2 > ::cell_iterator,  hp::DoFHandler< 2 ,  2 > ::cell_iterator> >
 get_finest_common_cells (const  hp::DoFHandler< 2 ,  2 >  &mesh_1,
 const  hp::DoFHandler< 2 ,  2 >  &mesh_2);


 template
 bool
 have_same_coarse_mesh (const  hp::DoFHandler< 2 ,  2 >  &mesh_1,
 const  hp::DoFHandler< 2 ,  2 >  &mesh_2);

 }

 #endif

#if  2  <=  3 
 namespace GridTools {

 template
 unsigned int
 find_closest_vertex (const  hp::DoFHandler< 2 ,  3 >  &,
 const Point< 3 > &);

 template
 std::vector< hp::DoFHandler< 2 ,  3 > ::active_cell_iterator>
 find_cells_adjacent_to_vertex(const  hp::DoFHandler< 2 ,  3 >  &,
 const unsigned int);
 template
  hp::DoFHandler< 2 ,  3 > ::active_cell_iterator
 find_active_cell_around_point (const  hp::DoFHandler< 2 ,  3 >  &,
 const Point< 3 > &p);

 template
 std::pair< hp::DoFHandler< 2 ,  3 > ::active_cell_iterator, Point< 2 > >
 find_active_cell_around_point (const Mapping< 2 ,  3 > &,
 const  hp::DoFHandler< 2 ,  3 >  &,
 const Point< 3 > &);

 template
 std::list<std::pair< hp::DoFHandler< 2 ,  3 > ::cell_iterator,  hp::DoFHandler< 2 ,  3 > ::cell_iterator> >
 get_finest_common_cells (const  hp::DoFHandler< 2 ,  3 >  &mesh_1,
 const  hp::DoFHandler< 2 ,  3 >  &mesh_2);


 template
 bool
 have_same_coarse_mesh (const  hp::DoFHandler< 2 ,  3 >  &mesh_1,
 const  hp::DoFHandler< 2 ,  3 >  &mesh_2);

 }

 #endif

#if  3  <=  1 
 namespace GridTools {

 template
 unsigned int
 find_closest_vertex (const  hp::DoFHandler< 3 ,  1 >  &,
 const Point< 1 > &);

 template
 std::vector< hp::DoFHandler< 3 ,  1 > ::active_cell_iterator>
 find_cells_adjacent_to_vertex(const  hp::DoFHandler< 3 ,  1 >  &,
 const unsigned int);
 template
  hp::DoFHandler< 3 ,  1 > ::active_cell_iterator
 find_active_cell_around_point (const  hp::DoFHandler< 3 ,  1 >  &,
 const Point< 1 > &p);

 template
 std::pair< hp::DoFHandler< 3 ,  1 > ::active_cell_iterator, Point< 3 > >
 find_active_cell_around_point (const Mapping< 3 ,  1 > &,
 const  hp::DoFHandler< 3 ,  1 >  &,
 const Point< 1 > &);

 template
 std::list<std::pair< hp::DoFHandler< 3 ,  1 > ::cell_iterator,  hp::DoFHandler< 3 ,  1 > ::cell_iterator> >
 get_finest_common_cells (const  hp::DoFHandler< 3 ,  1 >  &mesh_1,
 const  hp::DoFHandler< 3 ,  1 >  &mesh_2);


 template
 bool
 have_same_coarse_mesh (const  hp::DoFHandler< 3 ,  1 >  &mesh_1,
 const  hp::DoFHandler< 3 ,  1 >  &mesh_2);

 }

 #endif

#if  3  <=  2 
 namespace GridTools {

 template
 unsigned int
 find_closest_vertex (const  hp::DoFHandler< 3 ,  2 >  &,
 const Point< 2 > &);

 template
 std::vector< hp::DoFHandler< 3 ,  2 > ::active_cell_iterator>
 find_cells_adjacent_to_vertex(const  hp::DoFHandler< 3 ,  2 >  &,
 const unsigned int);
 template
  hp::DoFHandler< 3 ,  2 > ::active_cell_iterator
 find_active_cell_around_point (const  hp::DoFHandler< 3 ,  2 >  &,
 const Point< 2 > &p);

 template
 std::pair< hp::DoFHandler< 3 ,  2 > ::active_cell_iterator, Point< 3 > >
 find_active_cell_around_point (const Mapping< 3 ,  2 > &,
 const  hp::DoFHandler< 3 ,  2 >  &,
 const Point< 2 > &);

 template
 std::list<std::pair< hp::DoFHandler< 3 ,  2 > ::cell_iterator,  hp::DoFHandler< 3 ,  2 > ::cell_iterator> >
 get_finest_common_cells (const  hp::DoFHandler< 3 ,  2 >  &mesh_1,
 const  hp::DoFHandler< 3 ,  2 >  &mesh_2);


 template
 bool
 have_same_coarse_mesh (const  hp::DoFHandler< 3 ,  2 >  &mesh_1,
 const  hp::DoFHandler< 3 ,  2 >  &mesh_2);

 }

 #endif

#if  3  <=  3 
 namespace GridTools {

 template
 unsigned int
 find_closest_vertex (const  hp::DoFHandler< 3 ,  3 >  &,
 const Point< 3 > &);

 template
 std::vector< hp::DoFHandler< 3 ,  3 > ::active_cell_iterator>
 find_cells_adjacent_to_vertex(const  hp::DoFHandler< 3 ,  3 >  &,
 const unsigned int);
 template
  hp::DoFHandler< 3 ,  3 > ::active_cell_iterator
 find_active_cell_around_point (const  hp::DoFHandler< 3 ,  3 >  &,
 const Point< 3 > &p);

 template
 std::pair< hp::DoFHandler< 3 ,  3 > ::active_cell_iterator, Point< 3 > >
 find_active_cell_around_point (const Mapping< 3 ,  3 > &,
 const  hp::DoFHandler< 3 ,  3 >  &,
 const Point< 3 > &);

 template
 std::list<std::pair< hp::DoFHandler< 3 ,  3 > ::cell_iterator,  hp::DoFHandler< 3 ,  3 > ::cell_iterator> >
 get_finest_common_cells (const  hp::DoFHandler< 3 ,  3 >  &mesh_1,
 const  hp::DoFHandler< 3 ,  3 >  &mesh_2);


 template
 bool
 have_same_coarse_mesh (const  hp::DoFHandler< 3 ,  3 >  &mesh_1,
 const  hp::DoFHandler< 3 ,  3 >  &mesh_2);

 }

 #endif

#if  1  <=  1 
 namespace GridTools {

 template
 unsigned int
 find_closest_vertex (const parallel::distributed::Triangulation< 1 , 1 > &,
 const Point< 1 > &);

 template
 std::vector<parallel::distributed::Triangulation< 1 , 1 >::active_cell_iterator>
 find_cells_adjacent_to_vertex(const parallel::distributed::Triangulation< 1 , 1 > &,
 const unsigned int);
 template
 parallel::distributed::Triangulation< 1 , 1 >::active_cell_iterator
 find_active_cell_around_point (const parallel::distributed::Triangulation< 1 , 1 > &,
 const Point< 1 > &p);

 template
 std::pair<parallel::distributed::Triangulation< 1 , 1 >::active_cell_iterator, Point< 1 > >
 find_active_cell_around_point (const Mapping< 1 ,  1 > &,
 const parallel::distributed::Triangulation< 1 , 1 > &,
 const Point< 1 > &);

 template
 std::list<std::pair<parallel::distributed::Triangulation< 1 , 1 >::cell_iterator, parallel::distributed::Triangulation< 1 , 1 >::cell_iterator> >
 get_finest_common_cells (const parallel::distributed::Triangulation< 1 , 1 > &mesh_1,
 const parallel::distributed::Triangulation< 1 , 1 > &mesh_2);


 template
 bool
 have_same_coarse_mesh (const parallel::distributed::Triangulation< 1 , 1 > &mesh_1,
 const parallel::distributed::Triangulation< 1 , 1 > &mesh_2);

 }

 #endif

#if  1  <=  2 
 namespace GridTools {

 template
 unsigned int
 find_closest_vertex (const parallel::distributed::Triangulation< 1 , 2 > &,
 const Point< 2 > &);

 template
 std::vector<parallel::distributed::Triangulation< 1 , 2 >::active_cell_iterator>
 find_cells_adjacent_to_vertex(const parallel::distributed::Triangulation< 1 , 2 > &,
 const unsigned int);
 template
 parallel::distributed::Triangulation< 1 , 2 >::active_cell_iterator
 find_active_cell_around_point (const parallel::distributed::Triangulation< 1 , 2 > &,
 const Point< 2 > &p);

 template
 std::pair<parallel::distributed::Triangulation< 1 , 2 >::active_cell_iterator, Point< 1 > >
 find_active_cell_around_point (const Mapping< 1 ,  2 > &,
 const parallel::distributed::Triangulation< 1 , 2 > &,
 const Point< 2 > &);

 template
 std::list<std::pair<parallel::distributed::Triangulation< 1 , 2 >::cell_iterator, parallel::distributed::Triangulation< 1 , 2 >::cell_iterator> >
 get_finest_common_cells (const parallel::distributed::Triangulation< 1 , 2 > &mesh_1,
 const parallel::distributed::Triangulation< 1 , 2 > &mesh_2);


 template
 bool
 have_same_coarse_mesh (const parallel::distributed::Triangulation< 1 , 2 > &mesh_1,
 const parallel::distributed::Triangulation< 1 , 2 > &mesh_2);

 }

 #endif

#if  1  <=  3 
 namespace GridTools {

 template
 unsigned int
 find_closest_vertex (const parallel::distributed::Triangulation< 1 , 3 > &,
 const Point< 3 > &);

 template
 std::vector<parallel::distributed::Triangulation< 1 , 3 >::active_cell_iterator>
 find_cells_adjacent_to_vertex(const parallel::distributed::Triangulation< 1 , 3 > &,
 const unsigned int);
 template
 parallel::distributed::Triangulation< 1 , 3 >::active_cell_iterator
 find_active_cell_around_point (const parallel::distributed::Triangulation< 1 , 3 > &,
 const Point< 3 > &p);

 template
 std::pair<parallel::distributed::Triangulation< 1 , 3 >::active_cell_iterator, Point< 1 > >
 find_active_cell_around_point (const Mapping< 1 ,  3 > &,
 const parallel::distributed::Triangulation< 1 , 3 > &,
 const Point< 3 > &);

 template
 std::list<std::pair<parallel::distributed::Triangulation< 1 , 3 >::cell_iterator, parallel::distributed::Triangulation< 1 , 3 >::cell_iterator> >
 get_finest_common_cells (const parallel::distributed::Triangulation< 1 , 3 > &mesh_1,
 const parallel::distributed::Triangulation< 1 , 3 > &mesh_2);


 template
 bool
 have_same_coarse_mesh (const parallel::distributed::Triangulation< 1 , 3 > &mesh_1,
 const parallel::distributed::Triangulation< 1 , 3 > &mesh_2);

 }

 #endif

#if  2  <=  1 
 namespace GridTools {

 template
 unsigned int
 find_closest_vertex (const parallel::distributed::Triangulation< 2 , 1 > &,
 const Point< 1 > &);

 template
 std::vector<parallel::distributed::Triangulation< 2 , 1 >::active_cell_iterator>
 find_cells_adjacent_to_vertex(const parallel::distributed::Triangulation< 2 , 1 > &,
 const unsigned int);
 template
 parallel::distributed::Triangulation< 2 , 1 >::active_cell_iterator
 find_active_cell_around_point (const parallel::distributed::Triangulation< 2 , 1 > &,
 const Point< 1 > &p);

 template
 std::pair<parallel::distributed::Triangulation< 2 , 1 >::active_cell_iterator, Point< 2 > >
 find_active_cell_around_point (const Mapping< 2 ,  1 > &,
 const parallel::distributed::Triangulation< 2 , 1 > &,
 const Point< 1 > &);

 template
 std::list<std::pair<parallel::distributed::Triangulation< 2 , 1 >::cell_iterator, parallel::distributed::Triangulation< 2 , 1 >::cell_iterator> >
 get_finest_common_cells (const parallel::distributed::Triangulation< 2 , 1 > &mesh_1,
 const parallel::distributed::Triangulation< 2 , 1 > &mesh_2);


 template
 bool
 have_same_coarse_mesh (const parallel::distributed::Triangulation< 2 , 1 > &mesh_1,
 const parallel::distributed::Triangulation< 2 , 1 > &mesh_2);

 }

 #endif

#if  2  <=  2 
 namespace GridTools {

 template
 unsigned int
 find_closest_vertex (const parallel::distributed::Triangulation< 2 , 2 > &,
 const Point< 2 > &);

 template
 std::vector<parallel::distributed::Triangulation< 2 , 2 >::active_cell_iterator>
 find_cells_adjacent_to_vertex(const parallel::distributed::Triangulation< 2 , 2 > &,
 const unsigned int);
 template
 parallel::distributed::Triangulation< 2 , 2 >::active_cell_iterator
 find_active_cell_around_point (const parallel::distributed::Triangulation< 2 , 2 > &,
 const Point< 2 > &p);

 template
 std::pair<parallel::distributed::Triangulation< 2 , 2 >::active_cell_iterator, Point< 2 > >
 find_active_cell_around_point (const Mapping< 2 ,  2 > &,
 const parallel::distributed::Triangulation< 2 , 2 > &,
 const Point< 2 > &);

 template
 std::list<std::pair<parallel::distributed::Triangulation< 2 , 2 >::cell_iterator, parallel::distributed::Triangulation< 2 , 2 >::cell_iterator> >
 get_finest_common_cells (const parallel::distributed::Triangulation< 2 , 2 > &mesh_1,
 const parallel::distributed::Triangulation< 2 , 2 > &mesh_2);


 template
 bool
 have_same_coarse_mesh (const parallel::distributed::Triangulation< 2 , 2 > &mesh_1,
 const parallel::distributed::Triangulation< 2 , 2 > &mesh_2);

 }

 #endif

#if  2  <=  3 
 namespace GridTools {

 template
 unsigned int
 find_closest_vertex (const parallel::distributed::Triangulation< 2 , 3 > &,
 const Point< 3 > &);

 template
 std::vector<parallel::distributed::Triangulation< 2 , 3 >::active_cell_iterator>
 find_cells_adjacent_to_vertex(const parallel::distributed::Triangulation< 2 , 3 > &,
 const unsigned int);
 template
 parallel::distributed::Triangulation< 2 , 3 >::active_cell_iterator
 find_active_cell_around_point (const parallel::distributed::Triangulation< 2 , 3 > &,
 const Point< 3 > &p);

 template
 std::pair<parallel::distributed::Triangulation< 2 , 3 >::active_cell_iterator, Point< 2 > >
 find_active_cell_around_point (const Mapping< 2 ,  3 > &,
 const parallel::distributed::Triangulation< 2 , 3 > &,
 const Point< 3 > &);

 template
 std::list<std::pair<parallel::distributed::Triangulation< 2 , 3 >::cell_iterator, parallel::distributed::Triangulation< 2 , 3 >::cell_iterator> >
 get_finest_common_cells (const parallel::distributed::Triangulation< 2 , 3 > &mesh_1,
 const parallel::distributed::Triangulation< 2 , 3 > &mesh_2);


 template
 bool
 have_same_coarse_mesh (const parallel::distributed::Triangulation< 2 , 3 > &mesh_1,
 const parallel::distributed::Triangulation< 2 , 3 > &mesh_2);

 }

 #endif

#if  3  <=  1 
 namespace GridTools {

 template
 unsigned int
 find_closest_vertex (const parallel::distributed::Triangulation< 3 , 1 > &,
 const Point< 1 > &);

 template
 std::vector<parallel::distributed::Triangulation< 3 , 1 >::active_cell_iterator>
 find_cells_adjacent_to_vertex(const parallel::distributed::Triangulation< 3 , 1 > &,
 const unsigned int);
 template
 parallel::distributed::Triangulation< 3 , 1 >::active_cell_iterator
 find_active_cell_around_point (const parallel::distributed::Triangulation< 3 , 1 > &,
 const Point< 1 > &p);

 template
 std::pair<parallel::distributed::Triangulation< 3 , 1 >::active_cell_iterator, Point< 3 > >
 find_active_cell_around_point (const Mapping< 3 ,  1 > &,
 const parallel::distributed::Triangulation< 3 , 1 > &,
 const Point< 1 > &);

 template
 std::list<std::pair<parallel::distributed::Triangulation< 3 , 1 >::cell_iterator, parallel::distributed::Triangulation< 3 , 1 >::cell_iterator> >
 get_finest_common_cells (const parallel::distributed::Triangulation< 3 , 1 > &mesh_1,
 const parallel::distributed::Triangulation< 3 , 1 > &mesh_2);


 template
 bool
 have_same_coarse_mesh (const parallel::distributed::Triangulation< 3 , 1 > &mesh_1,
 const parallel::distributed::Triangulation< 3 , 1 > &mesh_2);

 }

 #endif

#if  3  <=  2 
 namespace GridTools {

 template
 unsigned int
 find_closest_vertex (const parallel::distributed::Triangulation< 3 , 2 > &,
 const Point< 2 > &);

 template
 std::vector<parallel::distributed::Triangulation< 3 , 2 >::active_cell_iterator>
 find_cells_adjacent_to_vertex(const parallel::distributed::Triangulation< 3 , 2 > &,
 const unsigned int);
 template
 parallel::distributed::Triangulation< 3 , 2 >::active_cell_iterator
 find_active_cell_around_point (const parallel::distributed::Triangulation< 3 , 2 > &,
 const Point< 2 > &p);

 template
 std::pair<parallel::distributed::Triangulation< 3 , 2 >::active_cell_iterator, Point< 3 > >
 find_active_cell_around_point (const Mapping< 3 ,  2 > &,
 const parallel::distributed::Triangulation< 3 , 2 > &,
 const Point< 2 > &);

 template
 std::list<std::pair<parallel::distributed::Triangulation< 3 , 2 >::cell_iterator, parallel::distributed::Triangulation< 3 , 2 >::cell_iterator> >
 get_finest_common_cells (const parallel::distributed::Triangulation< 3 , 2 > &mesh_1,
 const parallel::distributed::Triangulation< 3 , 2 > &mesh_2);


 template
 bool
 have_same_coarse_mesh (const parallel::distributed::Triangulation< 3 , 2 > &mesh_1,
 const parallel::distributed::Triangulation< 3 , 2 > &mesh_2);

 }

 #endif

#if  3  <=  3 
 namespace GridTools {

 template
 unsigned int
 find_closest_vertex (const parallel::distributed::Triangulation< 3 , 3 > &,
 const Point< 3 > &);

 template
 std::vector<parallel::distributed::Triangulation< 3 , 3 >::active_cell_iterator>
 find_cells_adjacent_to_vertex(const parallel::distributed::Triangulation< 3 , 3 > &,
 const unsigned int);
 template
 parallel::distributed::Triangulation< 3 , 3 >::active_cell_iterator
 find_active_cell_around_point (const parallel::distributed::Triangulation< 3 , 3 > &,
 const Point< 3 > &p);

 template
 std::pair<parallel::distributed::Triangulation< 3 , 3 >::active_cell_iterator, Point< 3 > >
 find_active_cell_around_point (const Mapping< 3 ,  3 > &,
 const parallel::distributed::Triangulation< 3 , 3 > &,
 const Point< 3 > &);

 template
 std::list<std::pair<parallel::distributed::Triangulation< 3 , 3 >::cell_iterator, parallel::distributed::Triangulation< 3 , 3 >::cell_iterator> >
 get_finest_common_cells (const parallel::distributed::Triangulation< 3 , 3 > &mesh_1,
 const parallel::distributed::Triangulation< 3 , 3 > &mesh_2);


 template
 bool
 have_same_coarse_mesh (const parallel::distributed::Triangulation< 3 , 3 > &mesh_1,
 const parallel::distributed::Triangulation< 3 , 3 > &mesh_2);

 }

 #endif

parallel::distributed::Triangulation< 1 >::active_cell_iterator
 find_active_cell_around_point (const parallel::distributed::Triangulation< 1 > &,
 const Point< 1 > &p);

 
 std::pair<parallel::distributed::Triangulation< 1 >::active_cell_iterator, Point< 1 > >
 find_active_cell_around_point (const Mapping< 1 > &,
 const parallel::distributed::Triangulation< 1 > &,
 const Point< 1 > &);

parallel::distributed::Triangulation< 2 >::active_cell_iterator
 find_active_cell_around_point (const parallel::distributed::Triangulation< 2 > &,
 const Point< 2 > &p);

 
 std::pair<parallel::distributed::Triangulation< 2 >::active_cell_iterator, Point< 2 > >
 find_active_cell_around_point (const Mapping< 2 > &,
 const parallel::distributed::Triangulation< 2 > &,
 const Point< 2 > &);

parallel::distributed::Triangulation< 3 >::active_cell_iterator
 find_active_cell_around_point (const parallel::distributed::Triangulation< 3 > &,
 const Point< 3 > &p);

 
 std::pair<parallel::distributed::Triangulation< 3 >::active_cell_iterator, Point< 3 > >
 find_active_cell_around_point (const Mapping< 3 > &,
 const parallel::distributed::Triangulation< 3 > &,
 const Point< 3 > &);

#if  1  <=  1 
 namespace GridTools {
 template
 bool
 have_same_coarse_mesh (const MGDoFHandler< 1 , 1 > &mesh_1,
 const MGDoFHandler< 1 , 1 > &mesh_2);

 }

 #endif

#if  1  <=  2 
 namespace GridTools {
 template
 bool
 have_same_coarse_mesh (const MGDoFHandler< 1 , 2 > &mesh_1,
 const MGDoFHandler< 1 , 2 > &mesh_2);

 }

 #endif

#if  1  <=  3 
 namespace GridTools {
 template
 bool
 have_same_coarse_mesh (const MGDoFHandler< 1 , 3 > &mesh_1,
 const MGDoFHandler< 1 , 3 > &mesh_2);

 }

 #endif

#if  2  <=  1 
 namespace GridTools {
 template
 bool
 have_same_coarse_mesh (const MGDoFHandler< 2 , 1 > &mesh_1,
 const MGDoFHandler< 2 , 1 > &mesh_2);

 }

 #endif

#if  2  <=  2 
 namespace GridTools {
 template
 bool
 have_same_coarse_mesh (const MGDoFHandler< 2 , 2 > &mesh_1,
 const MGDoFHandler< 2 , 2 > &mesh_2);

 }

 #endif

#if  2  <=  3 
 namespace GridTools {
 template
 bool
 have_same_coarse_mesh (const MGDoFHandler< 2 , 3 > &mesh_1,
 const MGDoFHandler< 2 , 3 > &mesh_2);

 }

 #endif

#if  3  <=  1 
 namespace GridTools {
 template
 bool
 have_same_coarse_mesh (const MGDoFHandler< 3 , 1 > &mesh_1,
 const MGDoFHandler< 3 , 1 > &mesh_2);

 }

 #endif

#if  3  <=  2 
 namespace GridTools {
 template
 bool
 have_same_coarse_mesh (const MGDoFHandler< 3 , 2 > &mesh_1,
 const MGDoFHandler< 3 , 2 > &mesh_2);

 }

 #endif

#if  3  <=  3 
 namespace GridTools {
 template
 bool
 have_same_coarse_mesh (const MGDoFHandler< 3 , 3 > &mesh_1,
 const MGDoFHandler< 3 , 3 > &mesh_2);

 }

 #endif

#if  1  <=  1 
 namespace GridTools {

 template
 double
 diameter
 (const Triangulation< 1 ,  1 > &);

 template
 double
 volume
 (const Triangulation< 1 ,  1 > &,
 const Mapping< 1 ,  1 > &);

 template
 void delete_unused_vertices (std::vector<Point< 1 > > &,
 std::vector<CellData< 1 > > &,
 SubCellData &);

 template
 void delete_duplicated_vertices (std::vector<Point< 1 > > &,
 std::vector<CellData< 1 > > &,
 SubCellData &,
 std::vector<unsigned int> &,
 double);

 template
 void shift< 1 > (const Point< 1 > &,
 Triangulation< 1 ,  1 > &);

 template
 void scale< 1 > (const double,
 Triangulation< 1 ,  1 > &);

 template
 void distort_random< 1 > (const double,
 Triangulation< 1 ,  1 > &,
 const bool);

 template
 void get_face_connectivity_of_cells
 (const Triangulation< 1 ,  1 > &triangulation,
 SparsityPattern &cell_connectivity);


 template
 void partition_triangulation (const unsigned int,
 Triangulation< 1 ,  1 > &);

 template
 void partition_triangulation (const unsigned int,
 const SparsityPattern &,
 Triangulation< 1 ,  1 > &);

 template
 std::pair<hp::DoFHandler< 1 ,  1 >::active_cell_iterator,
 Point< 1 > >
 find_active_cell_around_point
 (const hp::MappingCollection< 1 ,  1 > &,
 const hp::DoFHandler< 1 ,  1 > &,
 const Point< 1 > &);



 template
 void get_subdomain_association (const Triangulation< 1 ,  1 > &,
 std::vector<types::subdomain_id> &);

 template
 unsigned int count_cells_with_subdomain_association(
 const Triangulation< 1 ,  1 > &,
 const types::subdomain_id);

 template
 double
 minimal_cell_diameter (const Triangulation< 1 ,  1 > &triangulation);

 template
 double
 maximal_cell_diameter (const Triangulation< 1 ,  1 > &triangulation);

 template
 void
 create_union_triangulation (
 const Triangulation< 1 ,  1 > &triangulation_1,
 const Triangulation< 1 ,  1 > &triangulation_2,
 Triangulation< 1 ,  1 > &result);
#if  1  ==  1 
 template
 void
 laplace_transform (const std::map<unsigned int,Point< 1 > > &new_points,
 Triangulation< 1 > &triangulation);

 template
 Triangulation< 1 , 1 >::DistortedCellList
 fix_up_distorted_child_cells
 (const Triangulation< 1 , 1 >::DistortedCellList &distorted_cells,
 Triangulation< 1 , 1 > &triangulation);

#endif

 }
#endif



 
#if  1  <=  2 
 namespace GridTools {

 template
 double
 diameter
 (const Triangulation< 1 ,  2 > &);

 template
 double
 volume
 (const Triangulation< 1 ,  2 > &,
 const Mapping< 1 ,  2 > &);

 template
 void delete_unused_vertices (std::vector<Point< 2 > > &,
 std::vector<CellData< 1 > > &,
 SubCellData &);

 template
 void delete_duplicated_vertices (std::vector<Point< 2 > > &,
 std::vector<CellData< 1 > > &,
 SubCellData &,
 std::vector<unsigned int> &,
 double);

 template
 void shift< 1 > (const Point< 2 > &,
 Triangulation< 1 ,  2 > &);

 template
 void scale< 1 > (const double,
 Triangulation< 1 ,  2 > &);

 template
 void distort_random< 1 > (const double,
 Triangulation< 1 ,  2 > &,
 const bool);

 template
 void get_face_connectivity_of_cells
 (const Triangulation< 1 ,  2 > &triangulation,
 SparsityPattern &cell_connectivity);


 template
 void partition_triangulation (const unsigned int,
 Triangulation< 1 ,  2 > &);

 template
 void partition_triangulation (const unsigned int,
 const SparsityPattern &,
 Triangulation< 1 ,  2 > &);

 template
 std::pair<hp::DoFHandler< 1 ,  2 >::active_cell_iterator,
 Point< 1 > >
 find_active_cell_around_point
 (const hp::MappingCollection< 1 ,  2 > &,
 const hp::DoFHandler< 1 ,  2 > &,
 const Point< 2 > &);



 template
 void get_subdomain_association (const Triangulation< 1 ,  2 > &,
 std::vector<types::subdomain_id> &);

 template
 unsigned int count_cells_with_subdomain_association(
 const Triangulation< 1 ,  2 > &,
 const types::subdomain_id);

 template
 double
 minimal_cell_diameter (const Triangulation< 1 ,  2 > &triangulation);

 template
 double
 maximal_cell_diameter (const Triangulation< 1 ,  2 > &triangulation);

 template
 void
 create_union_triangulation (
 const Triangulation< 1 ,  2 > &triangulation_1,
 const Triangulation< 1 ,  2 > &triangulation_2,
 Triangulation< 1 ,  2 > &result);
#if  1  ==  2 
 template
 void
 laplace_transform (const std::map<unsigned int,Point< 1 > > &new_points,
 Triangulation< 1 > &triangulation);

 template
 Triangulation< 1 , 2 >::DistortedCellList
 fix_up_distorted_child_cells
 (const Triangulation< 1 , 2 >::DistortedCellList &distorted_cells,
 Triangulation< 1 , 2 > &triangulation);

#endif

 }
#endif



 
#if  1  <=  3 
 namespace GridTools {

 template
 double
 diameter
 (const Triangulation< 1 ,  3 > &);

 template
 double
 volume
 (const Triangulation< 1 ,  3 > &,
 const Mapping< 1 ,  3 > &);

 template
 void delete_unused_vertices (std::vector<Point< 3 > > &,
 std::vector<CellData< 1 > > &,
 SubCellData &);

 template
 void delete_duplicated_vertices (std::vector<Point< 3 > > &,
 std::vector<CellData< 1 > > &,
 SubCellData &,
 std::vector<unsigned int> &,
 double);

 template
 void shift< 1 > (const Point< 3 > &,
 Triangulation< 1 ,  3 > &);

 template
 void scale< 1 > (const double,
 Triangulation< 1 ,  3 > &);

 template
 void distort_random< 1 > (const double,
 Triangulation< 1 ,  3 > &,
 const bool);

 template
 void get_face_connectivity_of_cells
 (const Triangulation< 1 ,  3 > &triangulation,
 SparsityPattern &cell_connectivity);


 template
 void partition_triangulation (const unsigned int,
 Triangulation< 1 ,  3 > &);

 template
 void partition_triangulation (const unsigned int,
 const SparsityPattern &,
 Triangulation< 1 ,  3 > &);

 template
 std::pair<hp::DoFHandler< 1 ,  3 >::active_cell_iterator,
 Point< 1 > >
 find_active_cell_around_point
 (const hp::MappingCollection< 1 ,  3 > &,
 const hp::DoFHandler< 1 ,  3 > &,
 const Point< 3 > &);



 template
 void get_subdomain_association (const Triangulation< 1 ,  3 > &,
 std::vector<types::subdomain_id> &);

 template
 unsigned int count_cells_with_subdomain_association(
 const Triangulation< 1 ,  3 > &,
 const types::subdomain_id);

 template
 double
 minimal_cell_diameter (const Triangulation< 1 ,  3 > &triangulation);

 template
 double
 maximal_cell_diameter (const Triangulation< 1 ,  3 > &triangulation);

 template
 void
 create_union_triangulation (
 const Triangulation< 1 ,  3 > &triangulation_1,
 const Triangulation< 1 ,  3 > &triangulation_2,
 Triangulation< 1 ,  3 > &result);
#if  1  ==  3 
 template
 void
 laplace_transform (const std::map<unsigned int,Point< 1 > > &new_points,
 Triangulation< 1 > &triangulation);

 template
 Triangulation< 1 , 3 >::DistortedCellList
 fix_up_distorted_child_cells
 (const Triangulation< 1 , 3 >::DistortedCellList &distorted_cells,
 Triangulation< 1 , 3 > &triangulation);

#endif

 }
#endif



 
#if  2  <=  1 
 namespace GridTools {

 template
 double
 diameter
 (const Triangulation< 2 ,  1 > &);

 template
 double
 volume
 (const Triangulation< 2 ,  1 > &,
 const Mapping< 2 ,  1 > &);

 template
 void delete_unused_vertices (std::vector<Point< 1 > > &,
 std::vector<CellData< 2 > > &,
 SubCellData &);

 template
 void delete_duplicated_vertices (std::vector<Point< 1 > > &,
 std::vector<CellData< 2 > > &,
 SubCellData &,
 std::vector<unsigned int> &,
 double);

 template
 void shift< 2 > (const Point< 1 > &,
 Triangulation< 2 ,  1 > &);

 template
 void scale< 2 > (const double,
 Triangulation< 2 ,  1 > &);

 template
 void distort_random< 2 > (const double,
 Triangulation< 2 ,  1 > &,
 const bool);

 template
 void get_face_connectivity_of_cells
 (const Triangulation< 2 ,  1 > &triangulation,
 SparsityPattern &cell_connectivity);


 template
 void partition_triangulation (const unsigned int,
 Triangulation< 2 ,  1 > &);

 template
 void partition_triangulation (const unsigned int,
 const SparsityPattern &,
 Triangulation< 2 ,  1 > &);

 template
 std::pair<hp::DoFHandler< 2 ,  1 >::active_cell_iterator,
 Point< 2 > >
 find_active_cell_around_point
 (const hp::MappingCollection< 2 ,  1 > &,
 const hp::DoFHandler< 2 ,  1 > &,
 const Point< 1 > &);



 template
 void get_subdomain_association (const Triangulation< 2 ,  1 > &,
 std::vector<types::subdomain_id> &);

 template
 unsigned int count_cells_with_subdomain_association(
 const Triangulation< 2 ,  1 > &,
 const types::subdomain_id);

 template
 double
 minimal_cell_diameter (const Triangulation< 2 ,  1 > &triangulation);

 template
 double
 maximal_cell_diameter (const Triangulation< 2 ,  1 > &triangulation);

 template
 void
 create_union_triangulation (
 const Triangulation< 2 ,  1 > &triangulation_1,
 const Triangulation< 2 ,  1 > &triangulation_2,
 Triangulation< 2 ,  1 > &result);
#if  2  ==  1 
 template
 void
 laplace_transform (const std::map<unsigned int,Point< 2 > > &new_points,
 Triangulation< 2 > &triangulation);

 template
 Triangulation< 2 , 1 >::DistortedCellList
 fix_up_distorted_child_cells
 (const Triangulation< 2 , 1 >::DistortedCellList &distorted_cells,
 Triangulation< 2 , 1 > &triangulation);

#endif

 }
#endif



 
#if  2  <=  2 
 namespace GridTools {

 template
 double
 diameter
 (const Triangulation< 2 ,  2 > &);

 template
 double
 volume
 (const Triangulation< 2 ,  2 > &,
 const Mapping< 2 ,  2 > &);

 template
 void delete_unused_vertices (std::vector<Point< 2 > > &,
 std::vector<CellData< 2 > > &,
 SubCellData &);

 template
 void delete_duplicated_vertices (std::vector<Point< 2 > > &,
 std::vector<CellData< 2 > > &,
 SubCellData &,
 std::vector<unsigned int> &,
 double);

 template
 void shift< 2 > (const Point< 2 > &,
 Triangulation< 2 ,  2 > &);

 template
 void scale< 2 > (const double,
 Triangulation< 2 ,  2 > &);

 template
 void distort_random< 2 > (const double,
 Triangulation< 2 ,  2 > &,
 const bool);

 template
 void get_face_connectivity_of_cells
 (const Triangulation< 2 ,  2 > &triangulation,
 SparsityPattern &cell_connectivity);


 template
 void partition_triangulation (const unsigned int,
 Triangulation< 2 ,  2 > &);

 template
 void partition_triangulation (const unsigned int,
 const SparsityPattern &,
 Triangulation< 2 ,  2 > &);

 template
 std::pair<hp::DoFHandler< 2 ,  2 >::active_cell_iterator,
 Point< 2 > >
 find_active_cell_around_point
 (const hp::MappingCollection< 2 ,  2 > &,
 const hp::DoFHandler< 2 ,  2 > &,
 const Point< 2 > &);



 template
 void get_subdomain_association (const Triangulation< 2 ,  2 > &,
 std::vector<types::subdomain_id> &);

 template
 unsigned int count_cells_with_subdomain_association(
 const Triangulation< 2 ,  2 > &,
 const types::subdomain_id);

 template
 double
 minimal_cell_diameter (const Triangulation< 2 ,  2 > &triangulation);

 template
 double
 maximal_cell_diameter (const Triangulation< 2 ,  2 > &triangulation);

 template
 void
 create_union_triangulation (
 const Triangulation< 2 ,  2 > &triangulation_1,
 const Triangulation< 2 ,  2 > &triangulation_2,
 Triangulation< 2 ,  2 > &result);
#if  2  ==  2 
 template
 void
 laplace_transform (const std::map<unsigned int,Point< 2 > > &new_points,
 Triangulation< 2 > &triangulation);

 template
 Triangulation< 2 , 2 >::DistortedCellList
 fix_up_distorted_child_cells
 (const Triangulation< 2 , 2 >::DistortedCellList &distorted_cells,
 Triangulation< 2 , 2 > &triangulation);

#endif

 }
#endif



 
#if  2  <=  3 
 namespace GridTools {

 template
 double
 diameter
 (const Triangulation< 2 ,  3 > &);

 template
 double
 volume
 (const Triangulation< 2 ,  3 > &,
 const Mapping< 2 ,  3 > &);

 template
 void delete_unused_vertices (std::vector<Point< 3 > > &,
 std::vector<CellData< 2 > > &,
 SubCellData &);

 template
 void delete_duplicated_vertices (std::vector<Point< 3 > > &,
 std::vector<CellData< 2 > > &,
 SubCellData &,
 std::vector<unsigned int> &,
 double);

 template
 void shift< 2 > (const Point< 3 > &,
 Triangulation< 2 ,  3 > &);

 template
 void scale< 2 > (const double,
 Triangulation< 2 ,  3 > &);

 template
 void distort_random< 2 > (const double,
 Triangulation< 2 ,  3 > &,
 const bool);

 template
 void get_face_connectivity_of_cells
 (const Triangulation< 2 ,  3 > &triangulation,
 SparsityPattern &cell_connectivity);


 template
 void partition_triangulation (const unsigned int,
 Triangulation< 2 ,  3 > &);

 template
 void partition_triangulation (const unsigned int,
 const SparsityPattern &,
 Triangulation< 2 ,  3 > &);

 template
 std::pair<hp::DoFHandler< 2 ,  3 >::active_cell_iterator,
 Point< 2 > >
 find_active_cell_around_point
 (const hp::MappingCollection< 2 ,  3 > &,
 const hp::DoFHandler< 2 ,  3 > &,
 const Point< 3 > &);



 template
 void get_subdomain_association (const Triangulation< 2 ,  3 > &,
 std::vector<types::subdomain_id> &);

 template
 unsigned int count_cells_with_subdomain_association(
 const Triangulation< 2 ,  3 > &,
 const types::subdomain_id);

 template
 double
 minimal_cell_diameter (const Triangulation< 2 ,  3 > &triangulation);

 template
 double
 maximal_cell_diameter (const Triangulation< 2 ,  3 > &triangulation);

 template
 void
 create_union_triangulation (
 const Triangulation< 2 ,  3 > &triangulation_1,
 const Triangulation< 2 ,  3 > &triangulation_2,
 Triangulation< 2 ,  3 > &result);
#if  2  ==  3 
 template
 void
 laplace_transform (const std::map<unsigned int,Point< 2 > > &new_points,
 Triangulation< 2 > &triangulation);

 template
 Triangulation< 2 , 3 >::DistortedCellList
 fix_up_distorted_child_cells
 (const Triangulation< 2 , 3 >::DistortedCellList &distorted_cells,
 Triangulation< 2 , 3 > &triangulation);

#endif

 }
#endif



 
#if  3  <=  1 
 namespace GridTools {

 template
 double
 diameter
 (const Triangulation< 3 ,  1 > &);

 template
 double
 volume
 (const Triangulation< 3 ,  1 > &,
 const Mapping< 3 ,  1 > &);

 template
 void delete_unused_vertices (std::vector<Point< 1 > > &,
 std::vector<CellData< 3 > > &,
 SubCellData &);

 template
 void delete_duplicated_vertices (std::vector<Point< 1 > > &,
 std::vector<CellData< 3 > > &,
 SubCellData &,
 std::vector<unsigned int> &,
 double);

 template
 void shift< 3 > (const Point< 1 > &,
 Triangulation< 3 ,  1 > &);

 template
 void scale< 3 > (const double,
 Triangulation< 3 ,  1 > &);

 template
 void distort_random< 3 > (const double,
 Triangulation< 3 ,  1 > &,
 const bool);

 template
 void get_face_connectivity_of_cells
 (const Triangulation< 3 ,  1 > &triangulation,
 SparsityPattern &cell_connectivity);


 template
 void partition_triangulation (const unsigned int,
 Triangulation< 3 ,  1 > &);

 template
 void partition_triangulation (const unsigned int,
 const SparsityPattern &,
 Triangulation< 3 ,  1 > &);

 template
 std::pair<hp::DoFHandler< 3 ,  1 >::active_cell_iterator,
 Point< 3 > >
 find_active_cell_around_point
 (const hp::MappingCollection< 3 ,  1 > &,
 const hp::DoFHandler< 3 ,  1 > &,
 const Point< 1 > &);



 template
 void get_subdomain_association (const Triangulation< 3 ,  1 > &,
 std::vector<types::subdomain_id> &);

 template
 unsigned int count_cells_with_subdomain_association(
 const Triangulation< 3 ,  1 > &,
 const types::subdomain_id);

 template
 double
 minimal_cell_diameter (const Triangulation< 3 ,  1 > &triangulation);

 template
 double
 maximal_cell_diameter (const Triangulation< 3 ,  1 > &triangulation);

 template
 void
 create_union_triangulation (
 const Triangulation< 3 ,  1 > &triangulation_1,
 const Triangulation< 3 ,  1 > &triangulation_2,
 Triangulation< 3 ,  1 > &result);
#if  3  ==  1 
 template
 void
 laplace_transform (const std::map<unsigned int,Point< 3 > > &new_points,
 Triangulation< 3 > &triangulation);

 template
 Triangulation< 3 , 1 >::DistortedCellList
 fix_up_distorted_child_cells
 (const Triangulation< 3 , 1 >::DistortedCellList &distorted_cells,
 Triangulation< 3 , 1 > &triangulation);

#endif

 }
#endif



 
#if  3  <=  2 
 namespace GridTools {

 template
 double
 diameter
 (const Triangulation< 3 ,  2 > &);

 template
 double
 volume
 (const Triangulation< 3 ,  2 > &,
 const Mapping< 3 ,  2 > &);

 template
 void delete_unused_vertices (std::vector<Point< 2 > > &,
 std::vector<CellData< 3 > > &,
 SubCellData &);

 template
 void delete_duplicated_vertices (std::vector<Point< 2 > > &,
 std::vector<CellData< 3 > > &,
 SubCellData &,
 std::vector<unsigned int> &,
 double);

 template
 void shift< 3 > (const Point< 2 > &,
 Triangulation< 3 ,  2 > &);

 template
 void scale< 3 > (const double,
 Triangulation< 3 ,  2 > &);

 template
 void distort_random< 3 > (const double,
 Triangulation< 3 ,  2 > &,
 const bool);

 template
 void get_face_connectivity_of_cells
 (const Triangulation< 3 ,  2 > &triangulation,
 SparsityPattern &cell_connectivity);


 template
 void partition_triangulation (const unsigned int,
 Triangulation< 3 ,  2 > &);

 template
 void partition_triangulation (const unsigned int,
 const SparsityPattern &,
 Triangulation< 3 ,  2 > &);

 template
 std::pair<hp::DoFHandler< 3 ,  2 >::active_cell_iterator,
 Point< 3 > >
 find_active_cell_around_point
 (const hp::MappingCollection< 3 ,  2 > &,
 const hp::DoFHandler< 3 ,  2 > &,
 const Point< 2 > &);



 template
 void get_subdomain_association (const Triangulation< 3 ,  2 > &,
 std::vector<types::subdomain_id> &);

 template
 unsigned int count_cells_with_subdomain_association(
 const Triangulation< 3 ,  2 > &,
 const types::subdomain_id);

 template
 double
 minimal_cell_diameter (const Triangulation< 3 ,  2 > &triangulation);

 template
 double
 maximal_cell_diameter (const Triangulation< 3 ,  2 > &triangulation);

 template
 void
 create_union_triangulation (
 const Triangulation< 3 ,  2 > &triangulation_1,
 const Triangulation< 3 ,  2 > &triangulation_2,
 Triangulation< 3 ,  2 > &result);
#if  3  ==  2 
 template
 void
 laplace_transform (const std::map<unsigned int,Point< 3 > > &new_points,
 Triangulation< 3 > &triangulation);

 template
 Triangulation< 3 , 2 >::DistortedCellList
 fix_up_distorted_child_cells
 (const Triangulation< 3 , 2 >::DistortedCellList &distorted_cells,
 Triangulation< 3 , 2 > &triangulation);

#endif

 }
#endif



 
#if  3  <=  3 
 namespace GridTools {

 template
 double
 diameter
 (const Triangulation< 3 ,  3 > &);

 template
 double
 volume
 (const Triangulation< 3 ,  3 > &,
 const Mapping< 3 ,  3 > &);

 template
 void delete_unused_vertices (std::vector<Point< 3 > > &,
 std::vector<CellData< 3 > > &,
 SubCellData &);

 template
 void delete_duplicated_vertices (std::vector<Point< 3 > > &,
 std::vector<CellData< 3 > > &,
 SubCellData &,
 std::vector<unsigned int> &,
 double);

 template
 void shift< 3 > (const Point< 3 > &,
 Triangulation< 3 ,  3 > &);

 template
 void scale< 3 > (const double,
 Triangulation< 3 ,  3 > &);

 template
 void distort_random< 3 > (const double,
 Triangulation< 3 ,  3 > &,
 const bool);

 template
 void get_face_connectivity_of_cells
 (const Triangulation< 3 ,  3 > &triangulation,
 SparsityPattern &cell_connectivity);


 template
 void partition_triangulation (const unsigned int,
 Triangulation< 3 ,  3 > &);

 template
 void partition_triangulation (const unsigned int,
 const SparsityPattern &,
 Triangulation< 3 ,  3 > &);

 template
 std::pair<hp::DoFHandler< 3 ,  3 >::active_cell_iterator,
 Point< 3 > >
 find_active_cell_around_point
 (const hp::MappingCollection< 3 ,  3 > &,
 const hp::DoFHandler< 3 ,  3 > &,
 const Point< 3 > &);



 template
 void get_subdomain_association (const Triangulation< 3 ,  3 > &,
 std::vector<types::subdomain_id> &);

 template
 unsigned int count_cells_with_subdomain_association(
 const Triangulation< 3 ,  3 > &,
 const types::subdomain_id);

 template
 double
 minimal_cell_diameter (const Triangulation< 3 ,  3 > &triangulation);

 template
 double
 maximal_cell_diameter (const Triangulation< 3 ,  3 > &triangulation);

 template
 void
 create_union_triangulation (
 const Triangulation< 3 ,  3 > &triangulation_1,
 const Triangulation< 3 ,  3 > &triangulation_2,
 Triangulation< 3 ,  3 > &result);
#if  3  ==  3 
 template
 void
 laplace_transform (const std::map<unsigned int,Point< 3 > > &new_points,
 Triangulation< 3 > &triangulation);

 template
 Triangulation< 3 , 3 >::DistortedCellList
 fix_up_distorted_child_cells
 (const Triangulation< 3 , 3 >::DistortedCellList &distorted_cells,
 Triangulation< 3 , 3 > &triangulation);

#endif

 }
#endif



 
#if  1  <=  1 
#if  1  != 1
 namespace GridTools {

 template
 std::map<  Triangulation < 1 -1, 1 >::cell_iterator,
  Triangulation < 1 , 1 >::face_iterator>
 extract_boundary_mesh (const  Triangulation < 1 ,  1 > &mesh,
  Triangulation < 1 -1, 1 > &boundary_mesh,
 const std::set<types::boundary_id> &boundary_ids);
 }
#endif
#endif

 
#if  1  <=  1 
#if  1  != 1
 namespace GridTools {

 template
 std::map<  DoFHandler < 1 -1, 1 >::cell_iterator,
  DoFHandler < 1 , 1 >::face_iterator>
 extract_boundary_mesh (const  DoFHandler < 1 ,  1 > &mesh,
  DoFHandler < 1 -1, 1 > &boundary_mesh,
 const std::set<types::boundary_id> &boundary_ids);
 }
#endif
#endif

 
#if  1  <=  1 
#if  1  != 1
 namespace GridTools {

 template
 std::map<  hp::DoFHandler < 1 -1, 1 >::cell_iterator,
  hp::DoFHandler < 1 , 1 >::face_iterator>
 extract_boundary_mesh (const  hp::DoFHandler < 1 ,  1 > &mesh,
  hp::DoFHandler < 1 -1, 1 > &boundary_mesh,
 const std::set<types::boundary_id> &boundary_ids);
 }
#endif
#endif

 
#if  1  <=  2 
#if  1  != 1
 namespace GridTools {

 template
 std::map<  Triangulation < 1 -1, 2 >::cell_iterator,
  Triangulation < 1 , 2 >::face_iterator>
 extract_boundary_mesh (const  Triangulation < 1 ,  2 > &mesh,
  Triangulation < 1 -1, 2 > &boundary_mesh,
 const std::set<types::boundary_id> &boundary_ids);
 }
#endif
#endif

 
#if  1  <=  2 
#if  1  != 1
 namespace GridTools {

 template
 std::map<  DoFHandler < 1 -1, 2 >::cell_iterator,
  DoFHandler < 1 , 2 >::face_iterator>
 extract_boundary_mesh (const  DoFHandler < 1 ,  2 > &mesh,
  DoFHandler < 1 -1, 2 > &boundary_mesh,
 const std::set<types::boundary_id> &boundary_ids);
 }
#endif
#endif

 
#if  1  <=  2 
#if  1  != 1
 namespace GridTools {

 template
 std::map<  hp::DoFHandler < 1 -1, 2 >::cell_iterator,
  hp::DoFHandler < 1 , 2 >::face_iterator>
 extract_boundary_mesh (const  hp::DoFHandler < 1 ,  2 > &mesh,
  hp::DoFHandler < 1 -1, 2 > &boundary_mesh,
 const std::set<types::boundary_id> &boundary_ids);
 }
#endif
#endif

 
#if  1  <=  3 
#if  1  != 1
 namespace GridTools {

 template
 std::map<  Triangulation < 1 -1, 3 >::cell_iterator,
  Triangulation < 1 , 3 >::face_iterator>
 extract_boundary_mesh (const  Triangulation < 1 ,  3 > &mesh,
  Triangulation < 1 -1, 3 > &boundary_mesh,
 const std::set<types::boundary_id> &boundary_ids);
 }
#endif
#endif

 
#if  1  <=  3 
#if  1  != 1
 namespace GridTools {

 template
 std::map<  DoFHandler < 1 -1, 3 >::cell_iterator,
  DoFHandler < 1 , 3 >::face_iterator>
 extract_boundary_mesh (const  DoFHandler < 1 ,  3 > &mesh,
  DoFHandler < 1 -1, 3 > &boundary_mesh,
 const std::set<types::boundary_id> &boundary_ids);
 }
#endif
#endif

 
#if  1  <=  3 
#if  1  != 1
 namespace GridTools {

 template
 std::map<  hp::DoFHandler < 1 -1, 3 >::cell_iterator,
  hp::DoFHandler < 1 , 3 >::face_iterator>
 extract_boundary_mesh (const  hp::DoFHandler < 1 ,  3 > &mesh,
  hp::DoFHandler < 1 -1, 3 > &boundary_mesh,
 const std::set<types::boundary_id> &boundary_ids);
 }
#endif
#endif

 
#if  2  <=  1 
#if  2  != 1
 namespace GridTools {

 template
 std::map<  Triangulation < 2 -1, 1 >::cell_iterator,
  Triangulation < 2 , 1 >::face_iterator>
 extract_boundary_mesh (const  Triangulation < 2 ,  1 > &mesh,
  Triangulation < 2 -1, 1 > &boundary_mesh,
 const std::set<types::boundary_id> &boundary_ids);
 }
#endif
#endif

 
#if  2  <=  1 
#if  2  != 1
 namespace GridTools {

 template
 std::map<  DoFHandler < 2 -1, 1 >::cell_iterator,
  DoFHandler < 2 , 1 >::face_iterator>
 extract_boundary_mesh (const  DoFHandler < 2 ,  1 > &mesh,
  DoFHandler < 2 -1, 1 > &boundary_mesh,
 const std::set<types::boundary_id> &boundary_ids);
 }
#endif
#endif

 
#if  2  <=  1 
#if  2  != 1
 namespace GridTools {

 template
 std::map<  hp::DoFHandler < 2 -1, 1 >::cell_iterator,
  hp::DoFHandler < 2 , 1 >::face_iterator>
 extract_boundary_mesh (const  hp::DoFHandler < 2 ,  1 > &mesh,
  hp::DoFHandler < 2 -1, 1 > &boundary_mesh,
 const std::set<types::boundary_id> &boundary_ids);
 }
#endif
#endif

 
#if  2  <=  2 
#if  2  != 1
 namespace GridTools {

 template
 std::map<  Triangulation < 2 -1, 2 >::cell_iterator,
  Triangulation < 2 , 2 >::face_iterator>
 extract_boundary_mesh (const  Triangulation < 2 ,  2 > &mesh,
  Triangulation < 2 -1, 2 > &boundary_mesh,
 const std::set<types::boundary_id> &boundary_ids);
 }
#endif
#endif

 
#if  2  <=  2 
#if  2  != 1
 namespace GridTools {

 template
 std::map<  DoFHandler < 2 -1, 2 >::cell_iterator,
  DoFHandler < 2 , 2 >::face_iterator>
 extract_boundary_mesh (const  DoFHandler < 2 ,  2 > &mesh,
  DoFHandler < 2 -1, 2 > &boundary_mesh,
 const std::set<types::boundary_id> &boundary_ids);
 }
#endif
#endif

 
#if  2  <=  2 
#if  2  != 1
 namespace GridTools {

 template
 std::map<  hp::DoFHandler < 2 -1, 2 >::cell_iterator,
  hp::DoFHandler < 2 , 2 >::face_iterator>
 extract_boundary_mesh (const  hp::DoFHandler < 2 ,  2 > &mesh,
  hp::DoFHandler < 2 -1, 2 > &boundary_mesh,
 const std::set<types::boundary_id> &boundary_ids);
 }
#endif
#endif

 
#if  2  <=  3 
#if  2  != 1
 namespace GridTools {

 template
 std::map<  Triangulation < 2 -1, 3 >::cell_iterator,
  Triangulation < 2 , 3 >::face_iterator>
 extract_boundary_mesh (const  Triangulation < 2 ,  3 > &mesh,
  Triangulation < 2 -1, 3 > &boundary_mesh,
 const std::set<types::boundary_id> &boundary_ids);
 }
#endif
#endif

 
#if  2  <=  3 
#if  2  != 1
 namespace GridTools {

 template
 std::map<  DoFHandler < 2 -1, 3 >::cell_iterator,
  DoFHandler < 2 , 3 >::face_iterator>
 extract_boundary_mesh (const  DoFHandler < 2 ,  3 > &mesh,
  DoFHandler < 2 -1, 3 > &boundary_mesh,
 const std::set<types::boundary_id> &boundary_ids);
 }
#endif
#endif

 
#if  2  <=  3 
#if  2  != 1
 namespace GridTools {

 template
 std::map<  hp::DoFHandler < 2 -1, 3 >::cell_iterator,
  hp::DoFHandler < 2 , 3 >::face_iterator>
 extract_boundary_mesh (const  hp::DoFHandler < 2 ,  3 > &mesh,
  hp::DoFHandler < 2 -1, 3 > &boundary_mesh,
 const std::set<types::boundary_id> &boundary_ids);
 }
#endif
#endif

 
#if  3  <=  1 
#if  3  != 1
 namespace GridTools {

 template
 std::map<  Triangulation < 3 -1, 1 >::cell_iterator,
  Triangulation < 3 , 1 >::face_iterator>
 extract_boundary_mesh (const  Triangulation < 3 ,  1 > &mesh,
  Triangulation < 3 -1, 1 > &boundary_mesh,
 const std::set<types::boundary_id> &boundary_ids);
 }
#endif
#endif

 
#if  3  <=  1 
#if  3  != 1
 namespace GridTools {

 template
 std::map<  DoFHandler < 3 -1, 1 >::cell_iterator,
  DoFHandler < 3 , 1 >::face_iterator>
 extract_boundary_mesh (const  DoFHandler < 3 ,  1 > &mesh,
  DoFHandler < 3 -1, 1 > &boundary_mesh,
 const std::set<types::boundary_id> &boundary_ids);
 }
#endif
#endif

 
#if  3  <=  1 
#if  3  != 1
 namespace GridTools {

 template
 std::map<  hp::DoFHandler < 3 -1, 1 >::cell_iterator,
  hp::DoFHandler < 3 , 1 >::face_iterator>
 extract_boundary_mesh (const  hp::DoFHandler < 3 ,  1 > &mesh,
  hp::DoFHandler < 3 -1, 1 > &boundary_mesh,
 const std::set<types::boundary_id> &boundary_ids);
 }
#endif
#endif

 
#if  3  <=  2 
#if  3  != 1
 namespace GridTools {

 template
 std::map<  Triangulation < 3 -1, 2 >::cell_iterator,
  Triangulation < 3 , 2 >::face_iterator>
 extract_boundary_mesh (const  Triangulation < 3 ,  2 > &mesh,
  Triangulation < 3 -1, 2 > &boundary_mesh,
 const std::set<types::boundary_id> &boundary_ids);
 }
#endif
#endif

 
#if  3  <=  2 
#if  3  != 1
 namespace GridTools {

 template
 std::map<  DoFHandler < 3 -1, 2 >::cell_iterator,
  DoFHandler < 3 , 2 >::face_iterator>
 extract_boundary_mesh (const  DoFHandler < 3 ,  2 > &mesh,
  DoFHandler < 3 -1, 2 > &boundary_mesh,
 const std::set<types::boundary_id> &boundary_ids);
 }
#endif
#endif

 
#if  3  <=  2 
#if  3  != 1
 namespace GridTools {

 template
 std::map<  hp::DoFHandler < 3 -1, 2 >::cell_iterator,
  hp::DoFHandler < 3 , 2 >::face_iterator>
 extract_boundary_mesh (const  hp::DoFHandler < 3 ,  2 > &mesh,
  hp::DoFHandler < 3 -1, 2 > &boundary_mesh,
 const std::set<types::boundary_id> &boundary_ids);
 }
#endif
#endif

 
#if  3  <=  3 
#if  3  != 1
 namespace GridTools {

 template
 std::map<  Triangulation < 3 -1, 3 >::cell_iterator,
  Triangulation < 3 , 3 >::face_iterator>
 extract_boundary_mesh (const  Triangulation < 3 ,  3 > &mesh,
  Triangulation < 3 -1, 3 > &boundary_mesh,
 const std::set<types::boundary_id> &boundary_ids);
 }
#endif
#endif

 
#if  3  <=  3 
#if  3  != 1
 namespace GridTools {

 template
 std::map<  DoFHandler < 3 -1, 3 >::cell_iterator,
  DoFHandler < 3 , 3 >::face_iterator>
 extract_boundary_mesh (const  DoFHandler < 3 ,  3 > &mesh,
  DoFHandler < 3 -1, 3 > &boundary_mesh,
 const std::set<types::boundary_id> &boundary_ids);
 }
#endif
#endif

 
#if  3  <=  3 
#if  3  != 1
 namespace GridTools {

 template
 std::map<  hp::DoFHandler < 3 -1, 3 >::cell_iterator,
  hp::DoFHandler < 3 , 3 >::face_iterator>
 extract_boundary_mesh (const  hp::DoFHandler < 3 ,  3 > &mesh,
  hp::DoFHandler < 3 -1, 3 > &boundary_mesh,
 const std::set<types::boundary_id> &boundary_ids);
 }
#endif
#endif

 
#if  1  <=  1 
 namespace GridTools {

 template
 bool orthogonal_equality< Triangulation< 1 ,  1 > ::active_face_iterator> (std::bitset<3> &,
 const  Triangulation< 1 ,  1 > ::active_face_iterator&,
 const  Triangulation< 1 ,  1 > ::active_face_iterator&,
 const int,
 const Tensor<1, 1 > &);

 template
 bool orthogonal_equality< Triangulation< 1 ,  1 > ::face_iterator> (std::bitset<3> &,
 const  Triangulation< 1 ,  1 > ::face_iterator&,
 const  Triangulation< 1 ,  1 > ::face_iterator&,
 const int,
 const Tensor<1, 1 > &);

 template
 bool orthogonal_equality< Triangulation< 1 ,  1 > ::active_face_iterator> (const  Triangulation< 1 ,  1 > ::active_face_iterator&,
 const  Triangulation< 1 ,  1 > ::active_face_iterator&,
 const int,
 const Tensor<1, 1 > &);

 template
 bool orthogonal_equality< Triangulation< 1 ,  1 > ::face_iterator> (const  Triangulation< 1 ,  1 > ::face_iterator&,
 const  Triangulation< 1 ,  1 > ::face_iterator&,
 const int,
 const Tensor<1, 1 > &);

 #if  1  >= 2

 template
 void collect_periodic_faces< Triangulation< 1 ,  1 > > (const  Triangulation< 1 ,  1 >  &,
 const types::boundary_id,
 const types::boundary_id,
 const int,
 std::vector<PeriodicFacePair< Triangulation< 1 ,  1 > ::cell_iterator> > &,
 const Tensor<1, Triangulation< 1 ,  1 > ::space_dimension> &);

 template
 void collect_periodic_faces< Triangulation< 1 ,  1 > > (const  Triangulation< 1 ,  1 >  &,
 const types::boundary_id,
 const int,
 std::vector<PeriodicFacePair< Triangulation< 1 ,  1 > ::cell_iterator> > &,
 const Tensor<1, Triangulation< 1 ,  1 > ::space_dimension> &);

 #endif

 }
#endif

#if  1  <=  2 
 namespace GridTools {

 template
 bool orthogonal_equality< Triangulation< 1 ,  2 > ::active_face_iterator> (std::bitset<3> &,
 const  Triangulation< 1 ,  2 > ::active_face_iterator&,
 const  Triangulation< 1 ,  2 > ::active_face_iterator&,
 const int,
 const Tensor<1, 2 > &);

 template
 bool orthogonal_equality< Triangulation< 1 ,  2 > ::face_iterator> (std::bitset<3> &,
 const  Triangulation< 1 ,  2 > ::face_iterator&,
 const  Triangulation< 1 ,  2 > ::face_iterator&,
 const int,
 const Tensor<1, 2 > &);

 template
 bool orthogonal_equality< Triangulation< 1 ,  2 > ::active_face_iterator> (const  Triangulation< 1 ,  2 > ::active_face_iterator&,
 const  Triangulation< 1 ,  2 > ::active_face_iterator&,
 const int,
 const Tensor<1, 2 > &);

 template
 bool orthogonal_equality< Triangulation< 1 ,  2 > ::face_iterator> (const  Triangulation< 1 ,  2 > ::face_iterator&,
 const  Triangulation< 1 ,  2 > ::face_iterator&,
 const int,
 const Tensor<1, 2 > &);

 #if  1  >= 2

 template
 void collect_periodic_faces< Triangulation< 1 ,  2 > > (const  Triangulation< 1 ,  2 >  &,
 const types::boundary_id,
 const types::boundary_id,
 const int,
 std::vector<PeriodicFacePair< Triangulation< 1 ,  2 > ::cell_iterator> > &,
 const Tensor<1, Triangulation< 1 ,  2 > ::space_dimension> &);

 template
 void collect_periodic_faces< Triangulation< 1 ,  2 > > (const  Triangulation< 1 ,  2 >  &,
 const types::boundary_id,
 const int,
 std::vector<PeriodicFacePair< Triangulation< 1 ,  2 > ::cell_iterator> > &,
 const Tensor<1, Triangulation< 1 ,  2 > ::space_dimension> &);

 #endif

 }
#endif

#if  1  <=  3 
 namespace GridTools {

 template
 bool orthogonal_equality< Triangulation< 1 ,  3 > ::active_face_iterator> (std::bitset<3> &,
 const  Triangulation< 1 ,  3 > ::active_face_iterator&,
 const  Triangulation< 1 ,  3 > ::active_face_iterator&,
 const int,
 const Tensor<1, 3 > &);

 template
 bool orthogonal_equality< Triangulation< 1 ,  3 > ::face_iterator> (std::bitset<3> &,
 const  Triangulation< 1 ,  3 > ::face_iterator&,
 const  Triangulation< 1 ,  3 > ::face_iterator&,
 const int,
 const Tensor<1, 3 > &);

 template
 bool orthogonal_equality< Triangulation< 1 ,  3 > ::active_face_iterator> (const  Triangulation< 1 ,  3 > ::active_face_iterator&,
 const  Triangulation< 1 ,  3 > ::active_face_iterator&,
 const int,
 const Tensor<1, 3 > &);

 template
 bool orthogonal_equality< Triangulation< 1 ,  3 > ::face_iterator> (const  Triangulation< 1 ,  3 > ::face_iterator&,
 const  Triangulation< 1 ,  3 > ::face_iterator&,
 const int,
 const Tensor<1, 3 > &);

 #if  1  >= 2

 template
 void collect_periodic_faces< Triangulation< 1 ,  3 > > (const  Triangulation< 1 ,  3 >  &,
 const types::boundary_id,
 const types::boundary_id,
 const int,
 std::vector<PeriodicFacePair< Triangulation< 1 ,  3 > ::cell_iterator> > &,
 const Tensor<1, Triangulation< 1 ,  3 > ::space_dimension> &);

 template
 void collect_periodic_faces< Triangulation< 1 ,  3 > > (const  Triangulation< 1 ,  3 >  &,
 const types::boundary_id,
 const int,
 std::vector<PeriodicFacePair< Triangulation< 1 ,  3 > ::cell_iterator> > &,
 const Tensor<1, Triangulation< 1 ,  3 > ::space_dimension> &);

 #endif

 }
#endif

#if  2  <=  1 
 namespace GridTools {

 template
 bool orthogonal_equality< Triangulation< 2 ,  1 > ::active_face_iterator> (std::bitset<3> &,
 const  Triangulation< 2 ,  1 > ::active_face_iterator&,
 const  Triangulation< 2 ,  1 > ::active_face_iterator&,
 const int,
 const Tensor<1, 1 > &);

 template
 bool orthogonal_equality< Triangulation< 2 ,  1 > ::face_iterator> (std::bitset<3> &,
 const  Triangulation< 2 ,  1 > ::face_iterator&,
 const  Triangulation< 2 ,  1 > ::face_iterator&,
 const int,
 const Tensor<1, 1 > &);

 template
 bool orthogonal_equality< Triangulation< 2 ,  1 > ::active_face_iterator> (const  Triangulation< 2 ,  1 > ::active_face_iterator&,
 const  Triangulation< 2 ,  1 > ::active_face_iterator&,
 const int,
 const Tensor<1, 1 > &);

 template
 bool orthogonal_equality< Triangulation< 2 ,  1 > ::face_iterator> (const  Triangulation< 2 ,  1 > ::face_iterator&,
 const  Triangulation< 2 ,  1 > ::face_iterator&,
 const int,
 const Tensor<1, 1 > &);

 #if  2  >= 2

 template
 void collect_periodic_faces< Triangulation< 2 ,  1 > > (const  Triangulation< 2 ,  1 >  &,
 const types::boundary_id,
 const types::boundary_id,
 const int,
 std::vector<PeriodicFacePair< Triangulation< 2 ,  1 > ::cell_iterator> > &,
 const Tensor<1, Triangulation< 2 ,  1 > ::space_dimension> &);

 template
 void collect_periodic_faces< Triangulation< 2 ,  1 > > (const  Triangulation< 2 ,  1 >  &,
 const types::boundary_id,
 const int,
 std::vector<PeriodicFacePair< Triangulation< 2 ,  1 > ::cell_iterator> > &,
 const Tensor<1, Triangulation< 2 ,  1 > ::space_dimension> &);

 #endif

 }
#endif

#if  2  <=  2 
 namespace GridTools {

 template
 bool orthogonal_equality< Triangulation< 2 ,  2 > ::active_face_iterator> (std::bitset<3> &,
 const  Triangulation< 2 ,  2 > ::active_face_iterator&,
 const  Triangulation< 2 ,  2 > ::active_face_iterator&,
 const int,
 const Tensor<1, 2 > &);

 template
 bool orthogonal_equality< Triangulation< 2 ,  2 > ::face_iterator> (std::bitset<3> &,
 const  Triangulation< 2 ,  2 > ::face_iterator&,
 const  Triangulation< 2 ,  2 > ::face_iterator&,
 const int,
 const Tensor<1, 2 > &);

 template
 bool orthogonal_equality< Triangulation< 2 ,  2 > ::active_face_iterator> (const  Triangulation< 2 ,  2 > ::active_face_iterator&,
 const  Triangulation< 2 ,  2 > ::active_face_iterator&,
 const int,
 const Tensor<1, 2 > &);

 template
 bool orthogonal_equality< Triangulation< 2 ,  2 > ::face_iterator> (const  Triangulation< 2 ,  2 > ::face_iterator&,
 const  Triangulation< 2 ,  2 > ::face_iterator&,
 const int,
 const Tensor<1, 2 > &);

 #if  2  >= 2

 template
 void collect_periodic_faces< Triangulation< 2 ,  2 > > (const  Triangulation< 2 ,  2 >  &,
 const types::boundary_id,
 const types::boundary_id,
 const int,
 std::vector<PeriodicFacePair< Triangulation< 2 ,  2 > ::cell_iterator> > &,
 const Tensor<1, Triangulation< 2 ,  2 > ::space_dimension> &);

 template
 void collect_periodic_faces< Triangulation< 2 ,  2 > > (const  Triangulation< 2 ,  2 >  &,
 const types::boundary_id,
 const int,
 std::vector<PeriodicFacePair< Triangulation< 2 ,  2 > ::cell_iterator> > &,
 const Tensor<1, Triangulation< 2 ,  2 > ::space_dimension> &);

 #endif

 }
#endif

#if  2  <=  3 
 namespace GridTools {

 template
 bool orthogonal_equality< Triangulation< 2 ,  3 > ::active_face_iterator> (std::bitset<3> &,
 const  Triangulation< 2 ,  3 > ::active_face_iterator&,
 const  Triangulation< 2 ,  3 > ::active_face_iterator&,
 const int,
 const Tensor<1, 3 > &);

 template
 bool orthogonal_equality< Triangulation< 2 ,  3 > ::face_iterator> (std::bitset<3> &,
 const  Triangulation< 2 ,  3 > ::face_iterator&,
 const  Triangulation< 2 ,  3 > ::face_iterator&,
 const int,
 const Tensor<1, 3 > &);

 template
 bool orthogonal_equality< Triangulation< 2 ,  3 > ::active_face_iterator> (const  Triangulation< 2 ,  3 > ::active_face_iterator&,
 const  Triangulation< 2 ,  3 > ::active_face_iterator&,
 const int,
 const Tensor<1, 3 > &);

 template
 bool orthogonal_equality< Triangulation< 2 ,  3 > ::face_iterator> (const  Triangulation< 2 ,  3 > ::face_iterator&,
 const  Triangulation< 2 ,  3 > ::face_iterator&,
 const int,
 const Tensor<1, 3 > &);

 #if  2  >= 2

 template
 void collect_periodic_faces< Triangulation< 2 ,  3 > > (const  Triangulation< 2 ,  3 >  &,
 const types::boundary_id,
 const types::boundary_id,
 const int,
 std::vector<PeriodicFacePair< Triangulation< 2 ,  3 > ::cell_iterator> > &,
 const Tensor<1, Triangulation< 2 ,  3 > ::space_dimension> &);

 template
 void collect_periodic_faces< Triangulation< 2 ,  3 > > (const  Triangulation< 2 ,  3 >  &,
 const types::boundary_id,
 const int,
 std::vector<PeriodicFacePair< Triangulation< 2 ,  3 > ::cell_iterator> > &,
 const Tensor<1, Triangulation< 2 ,  3 > ::space_dimension> &);

 #endif

 }
#endif

#if  3  <=  1 
 namespace GridTools {

 template
 bool orthogonal_equality< Triangulation< 3 ,  1 > ::active_face_iterator> (std::bitset<3> &,
 const  Triangulation< 3 ,  1 > ::active_face_iterator&,
 const  Triangulation< 3 ,  1 > ::active_face_iterator&,
 const int,
 const Tensor<1, 1 > &);

 template
 bool orthogonal_equality< Triangulation< 3 ,  1 > ::face_iterator> (std::bitset<3> &,
 const  Triangulation< 3 ,  1 > ::face_iterator&,
 const  Triangulation< 3 ,  1 > ::face_iterator&,
 const int,
 const Tensor<1, 1 > &);

 template
 bool orthogonal_equality< Triangulation< 3 ,  1 > ::active_face_iterator> (const  Triangulation< 3 ,  1 > ::active_face_iterator&,
 const  Triangulation< 3 ,  1 > ::active_face_iterator&,
 const int,
 const Tensor<1, 1 > &);

 template
 bool orthogonal_equality< Triangulation< 3 ,  1 > ::face_iterator> (const  Triangulation< 3 ,  1 > ::face_iterator&,
 const  Triangulation< 3 ,  1 > ::face_iterator&,
 const int,
 const Tensor<1, 1 > &);

 #if  3  >= 2

 template
 void collect_periodic_faces< Triangulation< 3 ,  1 > > (const  Triangulation< 3 ,  1 >  &,
 const types::boundary_id,
 const types::boundary_id,
 const int,
 std::vector<PeriodicFacePair< Triangulation< 3 ,  1 > ::cell_iterator> > &,
 const Tensor<1, Triangulation< 3 ,  1 > ::space_dimension> &);

 template
 void collect_periodic_faces< Triangulation< 3 ,  1 > > (const  Triangulation< 3 ,  1 >  &,
 const types::boundary_id,
 const int,
 std::vector<PeriodicFacePair< Triangulation< 3 ,  1 > ::cell_iterator> > &,
 const Tensor<1, Triangulation< 3 ,  1 > ::space_dimension> &);

 #endif

 }
#endif

#if  3  <=  2 
 namespace GridTools {

 template
 bool orthogonal_equality< Triangulation< 3 ,  2 > ::active_face_iterator> (std::bitset<3> &,
 const  Triangulation< 3 ,  2 > ::active_face_iterator&,
 const  Triangulation< 3 ,  2 > ::active_face_iterator&,
 const int,
 const Tensor<1, 2 > &);

 template
 bool orthogonal_equality< Triangulation< 3 ,  2 > ::face_iterator> (std::bitset<3> &,
 const  Triangulation< 3 ,  2 > ::face_iterator&,
 const  Triangulation< 3 ,  2 > ::face_iterator&,
 const int,
 const Tensor<1, 2 > &);

 template
 bool orthogonal_equality< Triangulation< 3 ,  2 > ::active_face_iterator> (const  Triangulation< 3 ,  2 > ::active_face_iterator&,
 const  Triangulation< 3 ,  2 > ::active_face_iterator&,
 const int,
 const Tensor<1, 2 > &);

 template
 bool orthogonal_equality< Triangulation< 3 ,  2 > ::face_iterator> (const  Triangulation< 3 ,  2 > ::face_iterator&,
 const  Triangulation< 3 ,  2 > ::face_iterator&,
 const int,
 const Tensor<1, 2 > &);

 #if  3  >= 2

 template
 void collect_periodic_faces< Triangulation< 3 ,  2 > > (const  Triangulation< 3 ,  2 >  &,
 const types::boundary_id,
 const types::boundary_id,
 const int,
 std::vector<PeriodicFacePair< Triangulation< 3 ,  2 > ::cell_iterator> > &,
 const Tensor<1, Triangulation< 3 ,  2 > ::space_dimension> &);

 template
 void collect_periodic_faces< Triangulation< 3 ,  2 > > (const  Triangulation< 3 ,  2 >  &,
 const types::boundary_id,
 const int,
 std::vector<PeriodicFacePair< Triangulation< 3 ,  2 > ::cell_iterator> > &,
 const Tensor<1, Triangulation< 3 ,  2 > ::space_dimension> &);

 #endif

 }
#endif

#if  3  <=  3 
 namespace GridTools {

 template
 bool orthogonal_equality< Triangulation< 3 ,  3 > ::active_face_iterator> (std::bitset<3> &,
 const  Triangulation< 3 ,  3 > ::active_face_iterator&,
 const  Triangulation< 3 ,  3 > ::active_face_iterator&,
 const int,
 const Tensor<1, 3 > &);

 template
 bool orthogonal_equality< Triangulation< 3 ,  3 > ::face_iterator> (std::bitset<3> &,
 const  Triangulation< 3 ,  3 > ::face_iterator&,
 const  Triangulation< 3 ,  3 > ::face_iterator&,
 const int,
 const Tensor<1, 3 > &);

 template
 bool orthogonal_equality< Triangulation< 3 ,  3 > ::active_face_iterator> (const  Triangulation< 3 ,  3 > ::active_face_iterator&,
 const  Triangulation< 3 ,  3 > ::active_face_iterator&,
 const int,
 const Tensor<1, 3 > &);

 template
 bool orthogonal_equality< Triangulation< 3 ,  3 > ::face_iterator> (const  Triangulation< 3 ,  3 > ::face_iterator&,
 const  Triangulation< 3 ,  3 > ::face_iterator&,
 const int,
 const Tensor<1, 3 > &);

 #if  3  >= 2

 template
 void collect_periodic_faces< Triangulation< 3 ,  3 > > (const  Triangulation< 3 ,  3 >  &,
 const types::boundary_id,
 const types::boundary_id,
 const int,
 std::vector<PeriodicFacePair< Triangulation< 3 ,  3 > ::cell_iterator> > &,
 const Tensor<1, Triangulation< 3 ,  3 > ::space_dimension> &);

 template
 void collect_periodic_faces< Triangulation< 3 ,  3 > > (const  Triangulation< 3 ,  3 >  &,
 const types::boundary_id,
 const int,
 std::vector<PeriodicFacePair< Triangulation< 3 ,  3 > ::cell_iterator> > &,
 const Tensor<1, Triangulation< 3 ,  3 > ::space_dimension> &);

 #endif

 }
#endif

#if  1  <=  1 
 namespace GridTools {

 template
 bool orthogonal_equality< DoFHandler< 1 ,  1 > ::active_face_iterator> (std::bitset<3> &,
 const  DoFHandler< 1 ,  1 > ::active_face_iterator&,
 const  DoFHandler< 1 ,  1 > ::active_face_iterator&,
 const int,
 const Tensor<1, 1 > &);

 template
 bool orthogonal_equality< DoFHandler< 1 ,  1 > ::face_iterator> (std::bitset<3> &,
 const  DoFHandler< 1 ,  1 > ::face_iterator&,
 const  DoFHandler< 1 ,  1 > ::face_iterator&,
 const int,
 const Tensor<1, 1 > &);

 template
 bool orthogonal_equality< DoFHandler< 1 ,  1 > ::active_face_iterator> (const  DoFHandler< 1 ,  1 > ::active_face_iterator&,
 const  DoFHandler< 1 ,  1 > ::active_face_iterator&,
 const int,
 const Tensor<1, 1 > &);

 template
 bool orthogonal_equality< DoFHandler< 1 ,  1 > ::face_iterator> (const  DoFHandler< 1 ,  1 > ::face_iterator&,
 const  DoFHandler< 1 ,  1 > ::face_iterator&,
 const int,
 const Tensor<1, 1 > &);

 #if  1  >= 2

 template
 void collect_periodic_faces< DoFHandler< 1 ,  1 > > (const  DoFHandler< 1 ,  1 >  &,
 const types::boundary_id,
 const types::boundary_id,
 const int,
 std::vector<PeriodicFacePair< DoFHandler< 1 ,  1 > ::cell_iterator> > &,
 const Tensor<1, DoFHandler< 1 ,  1 > ::space_dimension> &);

 template
 void collect_periodic_faces< DoFHandler< 1 ,  1 > > (const  DoFHandler< 1 ,  1 >  &,
 const types::boundary_id,
 const int,
 std::vector<PeriodicFacePair< DoFHandler< 1 ,  1 > ::cell_iterator> > &,
 const Tensor<1, DoFHandler< 1 ,  1 > ::space_dimension> &);

 #endif

 }
#endif

#if  1  <=  2 
 namespace GridTools {

 template
 bool orthogonal_equality< DoFHandler< 1 ,  2 > ::active_face_iterator> (std::bitset<3> &,
 const  DoFHandler< 1 ,  2 > ::active_face_iterator&,
 const  DoFHandler< 1 ,  2 > ::active_face_iterator&,
 const int,
 const Tensor<1, 2 > &);

 template
 bool orthogonal_equality< DoFHandler< 1 ,  2 > ::face_iterator> (std::bitset<3> &,
 const  DoFHandler< 1 ,  2 > ::face_iterator&,
 const  DoFHandler< 1 ,  2 > ::face_iterator&,
 const int,
 const Tensor<1, 2 > &);

 template
 bool orthogonal_equality< DoFHandler< 1 ,  2 > ::active_face_iterator> (const  DoFHandler< 1 ,  2 > ::active_face_iterator&,
 const  DoFHandler< 1 ,  2 > ::active_face_iterator&,
 const int,
 const Tensor<1, 2 > &);

 template
 bool orthogonal_equality< DoFHandler< 1 ,  2 > ::face_iterator> (const  DoFHandler< 1 ,  2 > ::face_iterator&,
 const  DoFHandler< 1 ,  2 > ::face_iterator&,
 const int,
 const Tensor<1, 2 > &);

 #if  1  >= 2

 template
 void collect_periodic_faces< DoFHandler< 1 ,  2 > > (const  DoFHandler< 1 ,  2 >  &,
 const types::boundary_id,
 const types::boundary_id,
 const int,
 std::vector<PeriodicFacePair< DoFHandler< 1 ,  2 > ::cell_iterator> > &,
 const Tensor<1, DoFHandler< 1 ,  2 > ::space_dimension> &);

 template
 void collect_periodic_faces< DoFHandler< 1 ,  2 > > (const  DoFHandler< 1 ,  2 >  &,
 const types::boundary_id,
 const int,
 std::vector<PeriodicFacePair< DoFHandler< 1 ,  2 > ::cell_iterator> > &,
 const Tensor<1, DoFHandler< 1 ,  2 > ::space_dimension> &);

 #endif

 }
#endif

#if  1  <=  3 
 namespace GridTools {

 template
 bool orthogonal_equality< DoFHandler< 1 ,  3 > ::active_face_iterator> (std::bitset<3> &,
 const  DoFHandler< 1 ,  3 > ::active_face_iterator&,
 const  DoFHandler< 1 ,  3 > ::active_face_iterator&,
 const int,
 const Tensor<1, 3 > &);

 template
 bool orthogonal_equality< DoFHandler< 1 ,  3 > ::face_iterator> (std::bitset<3> &,
 const  DoFHandler< 1 ,  3 > ::face_iterator&,
 const  DoFHandler< 1 ,  3 > ::face_iterator&,
 const int,
 const Tensor<1, 3 > &);

 template
 bool orthogonal_equality< DoFHandler< 1 ,  3 > ::active_face_iterator> (const  DoFHandler< 1 ,  3 > ::active_face_iterator&,
 const  DoFHandler< 1 ,  3 > ::active_face_iterator&,
 const int,
 const Tensor<1, 3 > &);

 template
 bool orthogonal_equality< DoFHandler< 1 ,  3 > ::face_iterator> (const  DoFHandler< 1 ,  3 > ::face_iterator&,
 const  DoFHandler< 1 ,  3 > ::face_iterator&,
 const int,
 const Tensor<1, 3 > &);

 #if  1  >= 2

 template
 void collect_periodic_faces< DoFHandler< 1 ,  3 > > (const  DoFHandler< 1 ,  3 >  &,
 const types::boundary_id,
 const types::boundary_id,
 const int,
 std::vector<PeriodicFacePair< DoFHandler< 1 ,  3 > ::cell_iterator> > &,
 const Tensor<1, DoFHandler< 1 ,  3 > ::space_dimension> &);

 template
 void collect_periodic_faces< DoFHandler< 1 ,  3 > > (const  DoFHandler< 1 ,  3 >  &,
 const types::boundary_id,
 const int,
 std::vector<PeriodicFacePair< DoFHandler< 1 ,  3 > ::cell_iterator> > &,
 const Tensor<1, DoFHandler< 1 ,  3 > ::space_dimension> &);

 #endif

 }
#endif

#if  2  <=  1 
 namespace GridTools {

 template
 bool orthogonal_equality< DoFHandler< 2 ,  1 > ::active_face_iterator> (std::bitset<3> &,
 const  DoFHandler< 2 ,  1 > ::active_face_iterator&,
 const  DoFHandler< 2 ,  1 > ::active_face_iterator&,
 const int,
 const Tensor<1, 1 > &);

 template
 bool orthogonal_equality< DoFHandler< 2 ,  1 > ::face_iterator> (std::bitset<3> &,
 const  DoFHandler< 2 ,  1 > ::face_iterator&,
 const  DoFHandler< 2 ,  1 > ::face_iterator&,
 const int,
 const Tensor<1, 1 > &);

 template
 bool orthogonal_equality< DoFHandler< 2 ,  1 > ::active_face_iterator> (const  DoFHandler< 2 ,  1 > ::active_face_iterator&,
 const  DoFHandler< 2 ,  1 > ::active_face_iterator&,
 const int,
 const Tensor<1, 1 > &);

 template
 bool orthogonal_equality< DoFHandler< 2 ,  1 > ::face_iterator> (const  DoFHandler< 2 ,  1 > ::face_iterator&,
 const  DoFHandler< 2 ,  1 > ::face_iterator&,
 const int,
 const Tensor<1, 1 > &);

 #if  2  >= 2

 template
 void collect_periodic_faces< DoFHandler< 2 ,  1 > > (const  DoFHandler< 2 ,  1 >  &,
 const types::boundary_id,
 const types::boundary_id,
 const int,
 std::vector<PeriodicFacePair< DoFHandler< 2 ,  1 > ::cell_iterator> > &,
 const Tensor<1, DoFHandler< 2 ,  1 > ::space_dimension> &);

 template
 void collect_periodic_faces< DoFHandler< 2 ,  1 > > (const  DoFHandler< 2 ,  1 >  &,
 const types::boundary_id,
 const int,
 std::vector<PeriodicFacePair< DoFHandler< 2 ,  1 > ::cell_iterator> > &,
 const Tensor<1, DoFHandler< 2 ,  1 > ::space_dimension> &);

 #endif

 }
#endif

#if  2  <=  2 
 namespace GridTools {

 template
 bool orthogonal_equality< DoFHandler< 2 ,  2 > ::active_face_iterator> (std::bitset<3> &,
 const  DoFHandler< 2 ,  2 > ::active_face_iterator&,
 const  DoFHandler< 2 ,  2 > ::active_face_iterator&,
 const int,
 const Tensor<1, 2 > &);

 template
 bool orthogonal_equality< DoFHandler< 2 ,  2 > ::face_iterator> (std::bitset<3> &,
 const  DoFHandler< 2 ,  2 > ::face_iterator&,
 const  DoFHandler< 2 ,  2 > ::face_iterator&,
 const int,
 const Tensor<1, 2 > &);

 template
 bool orthogonal_equality< DoFHandler< 2 ,  2 > ::active_face_iterator> (const  DoFHandler< 2 ,  2 > ::active_face_iterator&,
 const  DoFHandler< 2 ,  2 > ::active_face_iterator&,
 const int,
 const Tensor<1, 2 > &);

 template
 bool orthogonal_equality< DoFHandler< 2 ,  2 > ::face_iterator> (const  DoFHandler< 2 ,  2 > ::face_iterator&,
 const  DoFHandler< 2 ,  2 > ::face_iterator&,
 const int,
 const Tensor<1, 2 > &);

 #if  2  >= 2

 template
 void collect_periodic_faces< DoFHandler< 2 ,  2 > > (const  DoFHandler< 2 ,  2 >  &,
 const types::boundary_id,
 const types::boundary_id,
 const int,
 std::vector<PeriodicFacePair< DoFHandler< 2 ,  2 > ::cell_iterator> > &,
 const Tensor<1, DoFHandler< 2 ,  2 > ::space_dimension> &);

 template
 void collect_periodic_faces< DoFHandler< 2 ,  2 > > (const  DoFHandler< 2 ,  2 >  &,
 const types::boundary_id,
 const int,
 std::vector<PeriodicFacePair< DoFHandler< 2 ,  2 > ::cell_iterator> > &,
 const Tensor<1, DoFHandler< 2 ,  2 > ::space_dimension> &);

 #endif

 }
#endif

#if  2  <=  3 
 namespace GridTools {

 template
 bool orthogonal_equality< DoFHandler< 2 ,  3 > ::active_face_iterator> (std::bitset<3> &,
 const  DoFHandler< 2 ,  3 > ::active_face_iterator&,
 const  DoFHandler< 2 ,  3 > ::active_face_iterator&,
 const int,
 const Tensor<1, 3 > &);

 template
 bool orthogonal_equality< DoFHandler< 2 ,  3 > ::face_iterator> (std::bitset<3> &,
 const  DoFHandler< 2 ,  3 > ::face_iterator&,
 const  DoFHandler< 2 ,  3 > ::face_iterator&,
 const int,
 const Tensor<1, 3 > &);

 template
 bool orthogonal_equality< DoFHandler< 2 ,  3 > ::active_face_iterator> (const  DoFHandler< 2 ,  3 > ::active_face_iterator&,
 const  DoFHandler< 2 ,  3 > ::active_face_iterator&,
 const int,
 const Tensor<1, 3 > &);

 template
 bool orthogonal_equality< DoFHandler< 2 ,  3 > ::face_iterator> (const  DoFHandler< 2 ,  3 > ::face_iterator&,
 const  DoFHandler< 2 ,  3 > ::face_iterator&,
 const int,
 const Tensor<1, 3 > &);

 #if  2  >= 2

 template
 void collect_periodic_faces< DoFHandler< 2 ,  3 > > (const  DoFHandler< 2 ,  3 >  &,
 const types::boundary_id,
 const types::boundary_id,
 const int,
 std::vector<PeriodicFacePair< DoFHandler< 2 ,  3 > ::cell_iterator> > &,
 const Tensor<1, DoFHandler< 2 ,  3 > ::space_dimension> &);

 template
 void collect_periodic_faces< DoFHandler< 2 ,  3 > > (const  DoFHandler< 2 ,  3 >  &,
 const types::boundary_id,
 const int,
 std::vector<PeriodicFacePair< DoFHandler< 2 ,  3 > ::cell_iterator> > &,
 const Tensor<1, DoFHandler< 2 ,  3 > ::space_dimension> &);

 #endif

 }
#endif

#if  3  <=  1 
 namespace GridTools {

 template
 bool orthogonal_equality< DoFHandler< 3 ,  1 > ::active_face_iterator> (std::bitset<3> &,
 const  DoFHandler< 3 ,  1 > ::active_face_iterator&,
 const  DoFHandler< 3 ,  1 > ::active_face_iterator&,
 const int,
 const Tensor<1, 1 > &);

 template
 bool orthogonal_equality< DoFHandler< 3 ,  1 > ::face_iterator> (std::bitset<3> &,
 const  DoFHandler< 3 ,  1 > ::face_iterator&,
 const  DoFHandler< 3 ,  1 > ::face_iterator&,
 const int,
 const Tensor<1, 1 > &);

 template
 bool orthogonal_equality< DoFHandler< 3 ,  1 > ::active_face_iterator> (const  DoFHandler< 3 ,  1 > ::active_face_iterator&,
 const  DoFHandler< 3 ,  1 > ::active_face_iterator&,
 const int,
 const Tensor<1, 1 > &);

 template
 bool orthogonal_equality< DoFHandler< 3 ,  1 > ::face_iterator> (const  DoFHandler< 3 ,  1 > ::face_iterator&,
 const  DoFHandler< 3 ,  1 > ::face_iterator&,
 const int,
 const Tensor<1, 1 > &);

 #if  3  >= 2

 template
 void collect_periodic_faces< DoFHandler< 3 ,  1 > > (const  DoFHandler< 3 ,  1 >  &,
 const types::boundary_id,
 const types::boundary_id,
 const int,
 std::vector<PeriodicFacePair< DoFHandler< 3 ,  1 > ::cell_iterator> > &,
 const Tensor<1, DoFHandler< 3 ,  1 > ::space_dimension> &);

 template
 void collect_periodic_faces< DoFHandler< 3 ,  1 > > (const  DoFHandler< 3 ,  1 >  &,
 const types::boundary_id,
 const int,
 std::vector<PeriodicFacePair< DoFHandler< 3 ,  1 > ::cell_iterator> > &,
 const Tensor<1, DoFHandler< 3 ,  1 > ::space_dimension> &);

 #endif

 }
#endif

#if  3  <=  2 
 namespace GridTools {

 template
 bool orthogonal_equality< DoFHandler< 3 ,  2 > ::active_face_iterator> (std::bitset<3> &,
 const  DoFHandler< 3 ,  2 > ::active_face_iterator&,
 const  DoFHandler< 3 ,  2 > ::active_face_iterator&,
 const int,
 const Tensor<1, 2 > &);

 template
 bool orthogonal_equality< DoFHandler< 3 ,  2 > ::face_iterator> (std::bitset<3> &,
 const  DoFHandler< 3 ,  2 > ::face_iterator&,
 const  DoFHandler< 3 ,  2 > ::face_iterator&,
 const int,
 const Tensor<1, 2 > &);

 template
 bool orthogonal_equality< DoFHandler< 3 ,  2 > ::active_face_iterator> (const  DoFHandler< 3 ,  2 > ::active_face_iterator&,
 const  DoFHandler< 3 ,  2 > ::active_face_iterator&,
 const int,
 const Tensor<1, 2 > &);

 template
 bool orthogonal_equality< DoFHandler< 3 ,  2 > ::face_iterator> (const  DoFHandler< 3 ,  2 > ::face_iterator&,
 const  DoFHandler< 3 ,  2 > ::face_iterator&,
 const int,
 const Tensor<1, 2 > &);

 #if  3  >= 2

 template
 void collect_periodic_faces< DoFHandler< 3 ,  2 > > (const  DoFHandler< 3 ,  2 >  &,
 const types::boundary_id,
 const types::boundary_id,
 const int,
 std::vector<PeriodicFacePair< DoFHandler< 3 ,  2 > ::cell_iterator> > &,
 const Tensor<1, DoFHandler< 3 ,  2 > ::space_dimension> &);

 template
 void collect_periodic_faces< DoFHandler< 3 ,  2 > > (const  DoFHandler< 3 ,  2 >  &,
 const types::boundary_id,
 const int,
 std::vector<PeriodicFacePair< DoFHandler< 3 ,  2 > ::cell_iterator> > &,
 const Tensor<1, DoFHandler< 3 ,  2 > ::space_dimension> &);

 #endif

 }
#endif

#if  3  <=  3 
 namespace GridTools {

 template
 bool orthogonal_equality< DoFHandler< 3 ,  3 > ::active_face_iterator> (std::bitset<3> &,
 const  DoFHandler< 3 ,  3 > ::active_face_iterator&,
 const  DoFHandler< 3 ,  3 > ::active_face_iterator&,
 const int,
 const Tensor<1, 3 > &);

 template
 bool orthogonal_equality< DoFHandler< 3 ,  3 > ::face_iterator> (std::bitset<3> &,
 const  DoFHandler< 3 ,  3 > ::face_iterator&,
 const  DoFHandler< 3 ,  3 > ::face_iterator&,
 const int,
 const Tensor<1, 3 > &);

 template
 bool orthogonal_equality< DoFHandler< 3 ,  3 > ::active_face_iterator> (const  DoFHandler< 3 ,  3 > ::active_face_iterator&,
 const  DoFHandler< 3 ,  3 > ::active_face_iterator&,
 const int,
 const Tensor<1, 3 > &);

 template
 bool orthogonal_equality< DoFHandler< 3 ,  3 > ::face_iterator> (const  DoFHandler< 3 ,  3 > ::face_iterator&,
 const  DoFHandler< 3 ,  3 > ::face_iterator&,
 const int,
 const Tensor<1, 3 > &);

 #if  3  >= 2

 template
 void collect_periodic_faces< DoFHandler< 3 ,  3 > > (const  DoFHandler< 3 ,  3 >  &,
 const types::boundary_id,
 const types::boundary_id,
 const int,
 std::vector<PeriodicFacePair< DoFHandler< 3 ,  3 > ::cell_iterator> > &,
 const Tensor<1, DoFHandler< 3 ,  3 > ::space_dimension> &);

 template
 void collect_periodic_faces< DoFHandler< 3 ,  3 > > (const  DoFHandler< 3 ,  3 >  &,
 const types::boundary_id,
 const int,
 std::vector<PeriodicFacePair< DoFHandler< 3 ,  3 > ::cell_iterator> > &,
 const Tensor<1, DoFHandler< 3 ,  3 > ::space_dimension> &);

 #endif

 }
#endif

#if  1  <=  1 
 namespace GridTools {

 template
 bool orthogonal_equality< hp::DoFHandler< 1 ,  1 > ::active_face_iterator> (std::bitset<3> &,
 const  hp::DoFHandler< 1 ,  1 > ::active_face_iterator&,
 const  hp::DoFHandler< 1 ,  1 > ::active_face_iterator&,
 const int,
 const Tensor<1, 1 > &);

 template
 bool orthogonal_equality< hp::DoFHandler< 1 ,  1 > ::face_iterator> (std::bitset<3> &,
 const  hp::DoFHandler< 1 ,  1 > ::face_iterator&,
 const  hp::DoFHandler< 1 ,  1 > ::face_iterator&,
 const int,
 const Tensor<1, 1 > &);

 template
 bool orthogonal_equality< hp::DoFHandler< 1 ,  1 > ::active_face_iterator> (const  hp::DoFHandler< 1 ,  1 > ::active_face_iterator&,
 const  hp::DoFHandler< 1 ,  1 > ::active_face_iterator&,
 const int,
 const Tensor<1, 1 > &);

 template
 bool orthogonal_equality< hp::DoFHandler< 1 ,  1 > ::face_iterator> (const  hp::DoFHandler< 1 ,  1 > ::face_iterator&,
 const  hp::DoFHandler< 1 ,  1 > ::face_iterator&,
 const int,
 const Tensor<1, 1 > &);

 #if  1  >= 2

 template
 void collect_periodic_faces< hp::DoFHandler< 1 ,  1 > > (const  hp::DoFHandler< 1 ,  1 >  &,
 const types::boundary_id,
 const types::boundary_id,
 const int,
 std::vector<PeriodicFacePair< hp::DoFHandler< 1 ,  1 > ::cell_iterator> > &,
 const Tensor<1, hp::DoFHandler< 1 ,  1 > ::space_dimension> &);

 template
 void collect_periodic_faces< hp::DoFHandler< 1 ,  1 > > (const  hp::DoFHandler< 1 ,  1 >  &,
 const types::boundary_id,
 const int,
 std::vector<PeriodicFacePair< hp::DoFHandler< 1 ,  1 > ::cell_iterator> > &,
 const Tensor<1, hp::DoFHandler< 1 ,  1 > ::space_dimension> &);

 #endif

 }
#endif

#if  1  <=  2 
 namespace GridTools {

 template
 bool orthogonal_equality< hp::DoFHandler< 1 ,  2 > ::active_face_iterator> (std::bitset<3> &,
 const  hp::DoFHandler< 1 ,  2 > ::active_face_iterator&,
 const  hp::DoFHandler< 1 ,  2 > ::active_face_iterator&,
 const int,
 const Tensor<1, 2 > &);

 template
 bool orthogonal_equality< hp::DoFHandler< 1 ,  2 > ::face_iterator> (std::bitset<3> &,
 const  hp::DoFHandler< 1 ,  2 > ::face_iterator&,
 const  hp::DoFHandler< 1 ,  2 > ::face_iterator&,
 const int,
 const Tensor<1, 2 > &);

 template
 bool orthogonal_equality< hp::DoFHandler< 1 ,  2 > ::active_face_iterator> (const  hp::DoFHandler< 1 ,  2 > ::active_face_iterator&,
 const  hp::DoFHandler< 1 ,  2 > ::active_face_iterator&,
 const int,
 const Tensor<1, 2 > &);

 template
 bool orthogonal_equality< hp::DoFHandler< 1 ,  2 > ::face_iterator> (const  hp::DoFHandler< 1 ,  2 > ::face_iterator&,
 const  hp::DoFHandler< 1 ,  2 > ::face_iterator&,
 const int,
 const Tensor<1, 2 > &);

 #if  1  >= 2

 template
 void collect_periodic_faces< hp::DoFHandler< 1 ,  2 > > (const  hp::DoFHandler< 1 ,  2 >  &,
 const types::boundary_id,
 const types::boundary_id,
 const int,
 std::vector<PeriodicFacePair< hp::DoFHandler< 1 ,  2 > ::cell_iterator> > &,
 const Tensor<1, hp::DoFHandler< 1 ,  2 > ::space_dimension> &);

 template
 void collect_periodic_faces< hp::DoFHandler< 1 ,  2 > > (const  hp::DoFHandler< 1 ,  2 >  &,
 const types::boundary_id,
 const int,
 std::vector<PeriodicFacePair< hp::DoFHandler< 1 ,  2 > ::cell_iterator> > &,
 const Tensor<1, hp::DoFHandler< 1 ,  2 > ::space_dimension> &);

 #endif

 }
#endif

#if  1  <=  3 
 namespace GridTools {

 template
 bool orthogonal_equality< hp::DoFHandler< 1 ,  3 > ::active_face_iterator> (std::bitset<3> &,
 const  hp::DoFHandler< 1 ,  3 > ::active_face_iterator&,
 const  hp::DoFHandler< 1 ,  3 > ::active_face_iterator&,
 const int,
 const Tensor<1, 3 > &);

 template
 bool orthogonal_equality< hp::DoFHandler< 1 ,  3 > ::face_iterator> (std::bitset<3> &,
 const  hp::DoFHandler< 1 ,  3 > ::face_iterator&,
 const  hp::DoFHandler< 1 ,  3 > ::face_iterator&,
 const int,
 const Tensor<1, 3 > &);

 template
 bool orthogonal_equality< hp::DoFHandler< 1 ,  3 > ::active_face_iterator> (const  hp::DoFHandler< 1 ,  3 > ::active_face_iterator&,
 const  hp::DoFHandler< 1 ,  3 > ::active_face_iterator&,
 const int,
 const Tensor<1, 3 > &);

 template
 bool orthogonal_equality< hp::DoFHandler< 1 ,  3 > ::face_iterator> (const  hp::DoFHandler< 1 ,  3 > ::face_iterator&,
 const  hp::DoFHandler< 1 ,  3 > ::face_iterator&,
 const int,
 const Tensor<1, 3 > &);

 #if  1  >= 2

 template
 void collect_periodic_faces< hp::DoFHandler< 1 ,  3 > > (const  hp::DoFHandler< 1 ,  3 >  &,
 const types::boundary_id,
 const types::boundary_id,
 const int,
 std::vector<PeriodicFacePair< hp::DoFHandler< 1 ,  3 > ::cell_iterator> > &,
 const Tensor<1, hp::DoFHandler< 1 ,  3 > ::space_dimension> &);

 template
 void collect_periodic_faces< hp::DoFHandler< 1 ,  3 > > (const  hp::DoFHandler< 1 ,  3 >  &,
 const types::boundary_id,
 const int,
 std::vector<PeriodicFacePair< hp::DoFHandler< 1 ,  3 > ::cell_iterator> > &,
 const Tensor<1, hp::DoFHandler< 1 ,  3 > ::space_dimension> &);

 #endif

 }
#endif

#if  2  <=  1 
 namespace GridTools {

 template
 bool orthogonal_equality< hp::DoFHandler< 2 ,  1 > ::active_face_iterator> (std::bitset<3> &,
 const  hp::DoFHandler< 2 ,  1 > ::active_face_iterator&,
 const  hp::DoFHandler< 2 ,  1 > ::active_face_iterator&,
 const int,
 const Tensor<1, 1 > &);

 template
 bool orthogonal_equality< hp::DoFHandler< 2 ,  1 > ::face_iterator> (std::bitset<3> &,
 const  hp::DoFHandler< 2 ,  1 > ::face_iterator&,
 const  hp::DoFHandler< 2 ,  1 > ::face_iterator&,
 const int,
 const Tensor<1, 1 > &);

 template
 bool orthogonal_equality< hp::DoFHandler< 2 ,  1 > ::active_face_iterator> (const  hp::DoFHandler< 2 ,  1 > ::active_face_iterator&,
 const  hp::DoFHandler< 2 ,  1 > ::active_face_iterator&,
 const int,
 const Tensor<1, 1 > &);

 template
 bool orthogonal_equality< hp::DoFHandler< 2 ,  1 > ::face_iterator> (const  hp::DoFHandler< 2 ,  1 > ::face_iterator&,
 const  hp::DoFHandler< 2 ,  1 > ::face_iterator&,
 const int,
 const Tensor<1, 1 > &);

 #if  2  >= 2

 template
 void collect_periodic_faces< hp::DoFHandler< 2 ,  1 > > (const  hp::DoFHandler< 2 ,  1 >  &,
 const types::boundary_id,
 const types::boundary_id,
 const int,
 std::vector<PeriodicFacePair< hp::DoFHandler< 2 ,  1 > ::cell_iterator> > &,
 const Tensor<1, hp::DoFHandler< 2 ,  1 > ::space_dimension> &);

 template
 void collect_periodic_faces< hp::DoFHandler< 2 ,  1 > > (const  hp::DoFHandler< 2 ,  1 >  &,
 const types::boundary_id,
 const int,
 std::vector<PeriodicFacePair< hp::DoFHandler< 2 ,  1 > ::cell_iterator> > &,
 const Tensor<1, hp::DoFHandler< 2 ,  1 > ::space_dimension> &);

 #endif

 }
#endif

#if  2  <=  2 
 namespace GridTools {

 template
 bool orthogonal_equality< hp::DoFHandler< 2 ,  2 > ::active_face_iterator> (std::bitset<3> &,
 const  hp::DoFHandler< 2 ,  2 > ::active_face_iterator&,
 const  hp::DoFHandler< 2 ,  2 > ::active_face_iterator&,
 const int,
 const Tensor<1, 2 > &);

 template
 bool orthogonal_equality< hp::DoFHandler< 2 ,  2 > ::face_iterator> (std::bitset<3> &,
 const  hp::DoFHandler< 2 ,  2 > ::face_iterator&,
 const  hp::DoFHandler< 2 ,  2 > ::face_iterator&,
 const int,
 const Tensor<1, 2 > &);

 template
 bool orthogonal_equality< hp::DoFHandler< 2 ,  2 > ::active_face_iterator> (const  hp::DoFHandler< 2 ,  2 > ::active_face_iterator&,
 const  hp::DoFHandler< 2 ,  2 > ::active_face_iterator&,
 const int,
 const Tensor<1, 2 > &);

 template
 bool orthogonal_equality< hp::DoFHandler< 2 ,  2 > ::face_iterator> (const  hp::DoFHandler< 2 ,  2 > ::face_iterator&,
 const  hp::DoFHandler< 2 ,  2 > ::face_iterator&,
 const int,
 const Tensor<1, 2 > &);

 #if  2  >= 2

 template
 void collect_periodic_faces< hp::DoFHandler< 2 ,  2 > > (const  hp::DoFHandler< 2 ,  2 >  &,
 const types::boundary_id,
 const types::boundary_id,
 const int,
 std::vector<PeriodicFacePair< hp::DoFHandler< 2 ,  2 > ::cell_iterator> > &,
 const Tensor<1, hp::DoFHandler< 2 ,  2 > ::space_dimension> &);

 template
 void collect_periodic_faces< hp::DoFHandler< 2 ,  2 > > (const  hp::DoFHandler< 2 ,  2 >  &,
 const types::boundary_id,
 const int,
 std::vector<PeriodicFacePair< hp::DoFHandler< 2 ,  2 > ::cell_iterator> > &,
 const Tensor<1, hp::DoFHandler< 2 ,  2 > ::space_dimension> &);

 #endif

 }
#endif

#if  2  <=  3 
 namespace GridTools {

 template
 bool orthogonal_equality< hp::DoFHandler< 2 ,  3 > ::active_face_iterator> (std::bitset<3> &,
 const  hp::DoFHandler< 2 ,  3 > ::active_face_iterator&,
 const  hp::DoFHandler< 2 ,  3 > ::active_face_iterator&,
 const int,
 const Tensor<1, 3 > &);

 template
 bool orthogonal_equality< hp::DoFHandler< 2 ,  3 > ::face_iterator> (std::bitset<3> &,
 const  hp::DoFHandler< 2 ,  3 > ::face_iterator&,
 const  hp::DoFHandler< 2 ,  3 > ::face_iterator&,
 const int,
 const Tensor<1, 3 > &);

 template
 bool orthogonal_equality< hp::DoFHandler< 2 ,  3 > ::active_face_iterator> (const  hp::DoFHandler< 2 ,  3 > ::active_face_iterator&,
 const  hp::DoFHandler< 2 ,  3 > ::active_face_iterator&,
 const int,
 const Tensor<1, 3 > &);

 template
 bool orthogonal_equality< hp::DoFHandler< 2 ,  3 > ::face_iterator> (const  hp::DoFHandler< 2 ,  3 > ::face_iterator&,
 const  hp::DoFHandler< 2 ,  3 > ::face_iterator&,
 const int,
 const Tensor<1, 3 > &);

 #if  2  >= 2

 template
 void collect_periodic_faces< hp::DoFHandler< 2 ,  3 > > (const  hp::DoFHandler< 2 ,  3 >  &,
 const types::boundary_id,
 const types::boundary_id,
 const int,
 std::vector<PeriodicFacePair< hp::DoFHandler< 2 ,  3 > ::cell_iterator> > &,
 const Tensor<1, hp::DoFHandler< 2 ,  3 > ::space_dimension> &);

 template
 void collect_periodic_faces< hp::DoFHandler< 2 ,  3 > > (const  hp::DoFHandler< 2 ,  3 >  &,
 const types::boundary_id,
 const int,
 std::vector<PeriodicFacePair< hp::DoFHandler< 2 ,  3 > ::cell_iterator> > &,
 const Tensor<1, hp::DoFHandler< 2 ,  3 > ::space_dimension> &);

 #endif

 }
#endif

#if  3  <=  1 
 namespace GridTools {

 template
 bool orthogonal_equality< hp::DoFHandler< 3 ,  1 > ::active_face_iterator> (std::bitset<3> &,
 const  hp::DoFHandler< 3 ,  1 > ::active_face_iterator&,
 const  hp::DoFHandler< 3 ,  1 > ::active_face_iterator&,
 const int,
 const Tensor<1, 1 > &);

 template
 bool orthogonal_equality< hp::DoFHandler< 3 ,  1 > ::face_iterator> (std::bitset<3> &,
 const  hp::DoFHandler< 3 ,  1 > ::face_iterator&,
 const  hp::DoFHandler< 3 ,  1 > ::face_iterator&,
 const int,
 const Tensor<1, 1 > &);

 template
 bool orthogonal_equality< hp::DoFHandler< 3 ,  1 > ::active_face_iterator> (const  hp::DoFHandler< 3 ,  1 > ::active_face_iterator&,
 const  hp::DoFHandler< 3 ,  1 > ::active_face_iterator&,
 const int,
 const Tensor<1, 1 > &);

 template
 bool orthogonal_equality< hp::DoFHandler< 3 ,  1 > ::face_iterator> (const  hp::DoFHandler< 3 ,  1 > ::face_iterator&,
 const  hp::DoFHandler< 3 ,  1 > ::face_iterator&,
 const int,
 const Tensor<1, 1 > &);

 #if  3  >= 2

 template
 void collect_periodic_faces< hp::DoFHandler< 3 ,  1 > > (const  hp::DoFHandler< 3 ,  1 >  &,
 const types::boundary_id,
 const types::boundary_id,
 const int,
 std::vector<PeriodicFacePair< hp::DoFHandler< 3 ,  1 > ::cell_iterator> > &,
 const Tensor<1, hp::DoFHandler< 3 ,  1 > ::space_dimension> &);

 template
 void collect_periodic_faces< hp::DoFHandler< 3 ,  1 > > (const  hp::DoFHandler< 3 ,  1 >  &,
 const types::boundary_id,
 const int,
 std::vector<PeriodicFacePair< hp::DoFHandler< 3 ,  1 > ::cell_iterator> > &,
 const Tensor<1, hp::DoFHandler< 3 ,  1 > ::space_dimension> &);

 #endif

 }
#endif

#if  3  <=  2 
 namespace GridTools {

 template
 bool orthogonal_equality< hp::DoFHandler< 3 ,  2 > ::active_face_iterator> (std::bitset<3> &,
 const  hp::DoFHandler< 3 ,  2 > ::active_face_iterator&,
 const  hp::DoFHandler< 3 ,  2 > ::active_face_iterator&,
 const int,
 const Tensor<1, 2 > &);

 template
 bool orthogonal_equality< hp::DoFHandler< 3 ,  2 > ::face_iterator> (std::bitset<3> &,
 const  hp::DoFHandler< 3 ,  2 > ::face_iterator&,
 const  hp::DoFHandler< 3 ,  2 > ::face_iterator&,
 const int,
 const Tensor<1, 2 > &);

 template
 bool orthogonal_equality< hp::DoFHandler< 3 ,  2 > ::active_face_iterator> (const  hp::DoFHandler< 3 ,  2 > ::active_face_iterator&,
 const  hp::DoFHandler< 3 ,  2 > ::active_face_iterator&,
 const int,
 const Tensor<1, 2 > &);

 template
 bool orthogonal_equality< hp::DoFHandler< 3 ,  2 > ::face_iterator> (const  hp::DoFHandler< 3 ,  2 > ::face_iterator&,
 const  hp::DoFHandler< 3 ,  2 > ::face_iterator&,
 const int,
 const Tensor<1, 2 > &);

 #if  3  >= 2

 template
 void collect_periodic_faces< hp::DoFHandler< 3 ,  2 > > (const  hp::DoFHandler< 3 ,  2 >  &,
 const types::boundary_id,
 const types::boundary_id,
 const int,
 std::vector<PeriodicFacePair< hp::DoFHandler< 3 ,  2 > ::cell_iterator> > &,
 const Tensor<1, hp::DoFHandler< 3 ,  2 > ::space_dimension> &);

 template
 void collect_periodic_faces< hp::DoFHandler< 3 ,  2 > > (const  hp::DoFHandler< 3 ,  2 >  &,
 const types::boundary_id,
 const int,
 std::vector<PeriodicFacePair< hp::DoFHandler< 3 ,  2 > ::cell_iterator> > &,
 const Tensor<1, hp::DoFHandler< 3 ,  2 > ::space_dimension> &);

 #endif

 }
#endif

#if  3  <=  3 
 namespace GridTools {

 template
 bool orthogonal_equality< hp::DoFHandler< 3 ,  3 > ::active_face_iterator> (std::bitset<3> &,
 const  hp::DoFHandler< 3 ,  3 > ::active_face_iterator&,
 const  hp::DoFHandler< 3 ,  3 > ::active_face_iterator&,
 const int,
 const Tensor<1, 3 > &);

 template
 bool orthogonal_equality< hp::DoFHandler< 3 ,  3 > ::face_iterator> (std::bitset<3> &,
 const  hp::DoFHandler< 3 ,  3 > ::face_iterator&,
 const  hp::DoFHandler< 3 ,  3 > ::face_iterator&,
 const int,
 const Tensor<1, 3 > &);

 template
 bool orthogonal_equality< hp::DoFHandler< 3 ,  3 > ::active_face_iterator> (const  hp::DoFHandler< 3 ,  3 > ::active_face_iterator&,
 const  hp::DoFHandler< 3 ,  3 > ::active_face_iterator&,
 const int,
 const Tensor<1, 3 > &);

 template
 bool orthogonal_equality< hp::DoFHandler< 3 ,  3 > ::face_iterator> (const  hp::DoFHandler< 3 ,  3 > ::face_iterator&,
 const  hp::DoFHandler< 3 ,  3 > ::face_iterator&,
 const int,
 const Tensor<1, 3 > &);

 #if  3  >= 2

 template
 void collect_periodic_faces< hp::DoFHandler< 3 ,  3 > > (const  hp::DoFHandler< 3 ,  3 >  &,
 const types::boundary_id,
 const types::boundary_id,
 const int,
 std::vector<PeriodicFacePair< hp::DoFHandler< 3 ,  3 > ::cell_iterator> > &,
 const Tensor<1, hp::DoFHandler< 3 ,  3 > ::space_dimension> &);

 template
 void collect_periodic_faces< hp::DoFHandler< 3 ,  3 > > (const  hp::DoFHandler< 3 ,  3 >  &,
 const types::boundary_id,
 const int,
 std::vector<PeriodicFacePair< hp::DoFHandler< 3 ,  3 > ::cell_iterator> > &,
 const Tensor<1, hp::DoFHandler< 3 ,  3 > ::space_dimension> &);

 #endif

 }
#endif

#if  1  <=  1 
 #if  1  >= 2

 namespace GridTools {

 template
 void
 collect_periodic_faces<parallel::distributed::Triangulation< 1 ,  1 > >
 (const parallel::distributed::Triangulation< 1 ,  1 > &,
 const types::boundary_id,
 const types::boundary_id,
 const int,
 std::vector<PeriodicFacePair<parallel::distributed::Triangulation< 1 ,  1 >::cell_iterator> > &,
 const Tensor<1,parallel::distributed::Triangulation< 1 ,  1 >::space_dimension> &);

 template
 void
 collect_periodic_faces<parallel::distributed::Triangulation< 1 ,  1 > >
 (const parallel::distributed::Triangulation< 1 ,  1 > &,
 const types::boundary_id,
 const int,
 std::vector<PeriodicFacePair<parallel::distributed::Triangulation< 1 ,  1 >::cell_iterator> > &,
 const Tensor<1,parallel::distributed::Triangulation< 1 ,  1 >::space_dimension> &);

 }
 #endif
#endif

#if  1  <=  2 
 #if  1  >= 2

 namespace GridTools {

 template
 void
 collect_periodic_faces<parallel::distributed::Triangulation< 1 ,  2 > >
 (const parallel::distributed::Triangulation< 1 ,  2 > &,
 const types::boundary_id,
 const types::boundary_id,
 const int,
 std::vector<PeriodicFacePair<parallel::distributed::Triangulation< 1 ,  2 >::cell_iterator> > &,
 const Tensor<1,parallel::distributed::Triangulation< 1 ,  2 >::space_dimension> &);

 template
 void
 collect_periodic_faces<parallel::distributed::Triangulation< 1 ,  2 > >
 (const parallel::distributed::Triangulation< 1 ,  2 > &,
 const types::boundary_id,
 const int,
 std::vector<PeriodicFacePair<parallel::distributed::Triangulation< 1 ,  2 >::cell_iterator> > &,
 const Tensor<1,parallel::distributed::Triangulation< 1 ,  2 >::space_dimension> &);

 }
 #endif
#endif

#if  1  <=  3 
 #if  1  >= 2

 namespace GridTools {

 template
 void
 collect_periodic_faces<parallel::distributed::Triangulation< 1 ,  3 > >
 (const parallel::distributed::Triangulation< 1 ,  3 > &,
 const types::boundary_id,
 const types::boundary_id,
 const int,
 std::vector<PeriodicFacePair<parallel::distributed::Triangulation< 1 ,  3 >::cell_iterator> > &,
 const Tensor<1,parallel::distributed::Triangulation< 1 ,  3 >::space_dimension> &);

 template
 void
 collect_periodic_faces<parallel::distributed::Triangulation< 1 ,  3 > >
 (const parallel::distributed::Triangulation< 1 ,  3 > &,
 const types::boundary_id,
 const int,
 std::vector<PeriodicFacePair<parallel::distributed::Triangulation< 1 ,  3 >::cell_iterator> > &,
 const Tensor<1,parallel::distributed::Triangulation< 1 ,  3 >::space_dimension> &);

 }
 #endif
#endif

#if  2  <=  1 
 #if  2  >= 2

 namespace GridTools {

 template
 void
 collect_periodic_faces<parallel::distributed::Triangulation< 2 ,  1 > >
 (const parallel::distributed::Triangulation< 2 ,  1 > &,
 const types::boundary_id,
 const types::boundary_id,
 const int,
 std::vector<PeriodicFacePair<parallel::distributed::Triangulation< 2 ,  1 >::cell_iterator> > &,
 const Tensor<1,parallel::distributed::Triangulation< 2 ,  1 >::space_dimension> &);

 template
 void
 collect_periodic_faces<parallel::distributed::Triangulation< 2 ,  1 > >
 (const parallel::distributed::Triangulation< 2 ,  1 > &,
 const types::boundary_id,
 const int,
 std::vector<PeriodicFacePair<parallel::distributed::Triangulation< 2 ,  1 >::cell_iterator> > &,
 const Tensor<1,parallel::distributed::Triangulation< 2 ,  1 >::space_dimension> &);

 }
 #endif
#endif

#if  2  <=  2 
 #if  2  >= 2

 namespace GridTools {

 template
 void
 collect_periodic_faces<parallel::distributed::Triangulation< 2 ,  2 > >
 (const parallel::distributed::Triangulation< 2 ,  2 > &,
 const types::boundary_id,
 const types::boundary_id,
 const int,
 std::vector<PeriodicFacePair<parallel::distributed::Triangulation< 2 ,  2 >::cell_iterator> > &,
 const Tensor<1,parallel::distributed::Triangulation< 2 ,  2 >::space_dimension> &);

 template
 void
 collect_periodic_faces<parallel::distributed::Triangulation< 2 ,  2 > >
 (const parallel::distributed::Triangulation< 2 ,  2 > &,
 const types::boundary_id,
 const int,
 std::vector<PeriodicFacePair<parallel::distributed::Triangulation< 2 ,  2 >::cell_iterator> > &,
 const Tensor<1,parallel::distributed::Triangulation< 2 ,  2 >::space_dimension> &);

 }
 #endif
#endif

#if  2  <=  3 
 #if  2  >= 2

 namespace GridTools {

 template
 void
 collect_periodic_faces<parallel::distributed::Triangulation< 2 ,  3 > >
 (const parallel::distributed::Triangulation< 2 ,  3 > &,
 const types::boundary_id,
 const types::boundary_id,
 const int,
 std::vector<PeriodicFacePair<parallel::distributed::Triangulation< 2 ,  3 >::cell_iterator> > &,
 const Tensor<1,parallel::distributed::Triangulation< 2 ,  3 >::space_dimension> &);

 template
 void
 collect_periodic_faces<parallel::distributed::Triangulation< 2 ,  3 > >
 (const parallel::distributed::Triangulation< 2 ,  3 > &,
 const types::boundary_id,
 const int,
 std::vector<PeriodicFacePair<parallel::distributed::Triangulation< 2 ,  3 >::cell_iterator> > &,
 const Tensor<1,parallel::distributed::Triangulation< 2 ,  3 >::space_dimension> &);

 }
 #endif
#endif

#if  3  <=  1 
 #if  3  >= 2

 namespace GridTools {

 template
 void
 collect_periodic_faces<parallel::distributed::Triangulation< 3 ,  1 > >
 (const parallel::distributed::Triangulation< 3 ,  1 > &,
 const types::boundary_id,
 const types::boundary_id,
 const int,
 std::vector<PeriodicFacePair<parallel::distributed::Triangulation< 3 ,  1 >::cell_iterator> > &,
 const Tensor<1,parallel::distributed::Triangulation< 3 ,  1 >::space_dimension> &);

 template
 void
 collect_periodic_faces<parallel::distributed::Triangulation< 3 ,  1 > >
 (const parallel::distributed::Triangulation< 3 ,  1 > &,
 const types::boundary_id,
 const int,
 std::vector<PeriodicFacePair<parallel::distributed::Triangulation< 3 ,  1 >::cell_iterator> > &,
 const Tensor<1,parallel::distributed::Triangulation< 3 ,  1 >::space_dimension> &);

 }
 #endif
#endif

#if  3  <=  2 
 #if  3  >= 2

 namespace GridTools {

 template
 void
 collect_periodic_faces<parallel::distributed::Triangulation< 3 ,  2 > >
 (const parallel::distributed::Triangulation< 3 ,  2 > &,
 const types::boundary_id,
 const types::boundary_id,
 const int,
 std::vector<PeriodicFacePair<parallel::distributed::Triangulation< 3 ,  2 >::cell_iterator> > &,
 const Tensor<1,parallel::distributed::Triangulation< 3 ,  2 >::space_dimension> &);

 template
 void
 collect_periodic_faces<parallel::distributed::Triangulation< 3 ,  2 > >
 (const parallel::distributed::Triangulation< 3 ,  2 > &,
 const types::boundary_id,
 const int,
 std::vector<PeriodicFacePair<parallel::distributed::Triangulation< 3 ,  2 >::cell_iterator> > &,
 const Tensor<1,parallel::distributed::Triangulation< 3 ,  2 >::space_dimension> &);

 }
 #endif
#endif

#if  3  <=  3 
 #if  3  >= 2

 namespace GridTools {

 template
 void
 collect_periodic_faces<parallel::distributed::Triangulation< 3 ,  3 > >
 (const parallel::distributed::Triangulation< 3 ,  3 > &,
 const types::boundary_id,
 const types::boundary_id,
 const int,
 std::vector<PeriodicFacePair<parallel::distributed::Triangulation< 3 ,  3 >::cell_iterator> > &,
 const Tensor<1,parallel::distributed::Triangulation< 3 ,  3 >::space_dimension> &);

 template
 void
 collect_periodic_faces<parallel::distributed::Triangulation< 3 ,  3 > >
 (const parallel::distributed::Triangulation< 3 ,  3 > &,
 const types::boundary_id,
 const int,
 std::vector<PeriodicFacePair<parallel::distributed::Triangulation< 3 ,  3 >::cell_iterator> > &,
 const Tensor<1,parallel::distributed::Triangulation< 3 ,  3 >::space_dimension> &);

 }
 #endif
#endif

